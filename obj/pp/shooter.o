# 1 "shooter.cpp"
# 1 "<built-in>"
# 1 "<command line>"
# 1 "shooter.cpp"




# 1 "player.h" 1



# 1 "H:/CPP/lua51/include/lua.hpp" 1




extern "C" {
# 1 "H:/CPP/lua51/include/lua.h" 1
# 12 "H:/CPP/lua51/include/lua.h"
# 1 "H:/CPP/wxdevcpp6.10/lib/gcc/mingw32/3.4.2/include/stdarg.h" 1
# 44 "H:/CPP/wxdevcpp6.10/lib/gcc/mingw32/3.4.2/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
# 106 "H:/CPP/wxdevcpp6.10/lib/gcc/mingw32/3.4.2/include/stdarg.h"
typedef __gnuc_va_list va_list;
# 13 "H:/CPP/lua51/include/lua.h" 2
# 1 "H:/CPP/wxdevcpp6.10/lib/gcc/mingw32/3.4.2/include/stddef.h" 1
# 151 "H:/CPP/wxdevcpp6.10/lib/gcc/mingw32/3.4.2/include/stddef.h"
typedef int ptrdiff_t;
# 213 "H:/CPP/wxdevcpp6.10/lib/gcc/mingw32/3.4.2/include/stddef.h"
typedef unsigned int size_t;
# 14 "H:/CPP/lua51/include/lua.h" 2


# 1 "H:/CPP/lua51/include/luaconf.h" 1
# 11 "H:/CPP/lua51/include/luaconf.h"
# 1 "H:/CPP/wxdevcpp6.10/lib/gcc/mingw32/3.4.2/include/limits.h" 1
# 11 "H:/CPP/wxdevcpp6.10/lib/gcc/mingw32/3.4.2/include/limits.h"
# 1 "H:/CPP/wxdevcpp6.10/lib/gcc/mingw32/3.4.2/include/syslimits.h" 1






# 1 "H:/CPP/wxdevcpp6.10/lib/gcc/mingw32/3.4.2/include/limits.h" 1
# 122 "H:/CPP/wxdevcpp6.10/lib/gcc/mingw32/3.4.2/include/limits.h"
# 1 "H:/CPP/wxdevcpp6.10/include/limits.h" 1
# 21 "H:/CPP/wxdevcpp6.10/include/limits.h"
# 1 "H:/CPP/wxdevcpp6.10/include/_mingw.h" 1
# 22 "H:/CPP/wxdevcpp6.10/include/limits.h" 2
# 123 "H:/CPP/wxdevcpp6.10/lib/gcc/mingw32/3.4.2/include/limits.h" 2
# 8 "H:/CPP/wxdevcpp6.10/lib/gcc/mingw32/3.4.2/include/syslimits.h" 2
# 12 "H:/CPP/wxdevcpp6.10/lib/gcc/mingw32/3.4.2/include/limits.h" 2
# 12 "H:/CPP/lua51/include/luaconf.h" 2
# 1 "H:/CPP/wxdevcpp6.10/lib/gcc/mingw32/3.4.2/include/stddef.h" 1
# 13 "H:/CPP/lua51/include/luaconf.h" 2
# 569 "H:/CPP/lua51/include/luaconf.h"
union luai_Cast { double l_d; long l_l; };
# 17 "H:/CPP/lua51/include/lua.h" 2
# 50 "H:/CPP/lua51/include/lua.h"
typedef struct lua_State lua_State;

typedef int (*lua_CFunction) (lua_State *L);





typedef const char * (*lua_Reader) (lua_State *L, void *ud, size_t *sz);

typedef int (*lua_Writer) (lua_State *L, const void* p, size_t sz, void* ud);





typedef void * (*lua_Alloc) (void *ud, void *ptr, size_t osize, size_t nsize);
# 99 "H:/CPP/lua51/include/lua.h"
typedef double lua_Number;



typedef ptrdiff_t lua_Integer;






extern lua_State *(lua_newstate) (lua_Alloc f, void *ud);
extern void (lua_close) (lua_State *L);
extern lua_State *(lua_newthread) (lua_State *L);

extern lua_CFunction (lua_atpanic) (lua_State *L, lua_CFunction panicf);





extern int (lua_gettop) (lua_State *L);
extern void (lua_settop) (lua_State *L, int idx);
extern void (lua_pushvalue) (lua_State *L, int idx);
extern void (lua_remove) (lua_State *L, int idx);
extern void (lua_insert) (lua_State *L, int idx);
extern void (lua_replace) (lua_State *L, int idx);
extern int (lua_checkstack) (lua_State *L, int sz);

extern void (lua_xmove) (lua_State *from, lua_State *to, int n);






extern int (lua_isnumber) (lua_State *L, int idx);
extern int (lua_isstring) (lua_State *L, int idx);
extern int (lua_iscfunction) (lua_State *L, int idx);
extern int (lua_isuserdata) (lua_State *L, int idx);
extern int (lua_type) (lua_State *L, int idx);
extern const char *(lua_typename) (lua_State *L, int tp);

extern int (lua_equal) (lua_State *L, int idx1, int idx2);
extern int (lua_rawequal) (lua_State *L, int idx1, int idx2);
extern int (lua_lessthan) (lua_State *L, int idx1, int idx2);

extern lua_Number (lua_tonumber) (lua_State *L, int idx);
extern lua_Integer (lua_tointeger) (lua_State *L, int idx);
extern int (lua_toboolean) (lua_State *L, int idx);
extern const char *(lua_tolstring) (lua_State *L, int idx, size_t *len);
extern size_t (lua_objlen) (lua_State *L, int idx);
extern lua_CFunction (lua_tocfunction) (lua_State *L, int idx);
extern void *(lua_touserdata) (lua_State *L, int idx);
extern lua_State *(lua_tothread) (lua_State *L, int idx);
extern const void *(lua_topointer) (lua_State *L, int idx);





extern void (lua_pushnil) (lua_State *L);
extern void (lua_pushnumber) (lua_State *L, lua_Number n);
extern void (lua_pushinteger) (lua_State *L, lua_Integer n);
extern void (lua_pushlstring) (lua_State *L, const char *s, size_t l);
extern void (lua_pushstring) (lua_State *L, const char *s);
extern const char *(lua_pushvfstring) (lua_State *L, const char *fmt,
                                                      va_list argp);
extern const char *(lua_pushfstring) (lua_State *L, const char *fmt, ...);
extern void (lua_pushcclosure) (lua_State *L, lua_CFunction fn, int n);
extern void (lua_pushboolean) (lua_State *L, int b);
extern void (lua_pushlightuserdata) (lua_State *L, void *p);
extern int (lua_pushthread) (lua_State *L);





extern void (lua_gettable) (lua_State *L, int idx);
extern void (lua_getfield) (lua_State *L, int idx, const char *k);
extern void (lua_rawget) (lua_State *L, int idx);
extern void (lua_rawgeti) (lua_State *L, int idx, int n);
extern void (lua_createtable) (lua_State *L, int narr, int nrec);
extern void *(lua_newuserdata) (lua_State *L, size_t sz);
extern int (lua_getmetatable) (lua_State *L, int objindex);
extern void (lua_getfenv) (lua_State *L, int idx);





extern void (lua_settable) (lua_State *L, int idx);
extern void (lua_setfield) (lua_State *L, int idx, const char *k);
extern void (lua_rawset) (lua_State *L, int idx);
extern void (lua_rawseti) (lua_State *L, int idx, int n);
extern int (lua_setmetatable) (lua_State *L, int objindex);
extern int (lua_setfenv) (lua_State *L, int idx);





extern void (lua_call) (lua_State *L, int nargs, int nresults);
extern int (lua_pcall) (lua_State *L, int nargs, int nresults, int errfunc);
extern int (lua_cpcall) (lua_State *L, lua_CFunction func, void *ud);
extern int (lua_load) (lua_State *L, lua_Reader reader, void *dt,
                                        const char *chunkname);

extern int (lua_dump) (lua_State *L, lua_Writer writer, void *data);





extern int (lua_yield) (lua_State *L, int nresults);
extern int (lua_resume) (lua_State *L, int narg);
extern int (lua_status) (lua_State *L);
# 230 "H:/CPP/lua51/include/lua.h"
extern int (lua_gc) (lua_State *L, int what, int data);






extern int (lua_error) (lua_State *L);

extern int (lua_next) (lua_State *L, int idx);

extern void (lua_concat) (lua_State *L, int n);

extern lua_Alloc (lua_getallocf) (lua_State *L, void **ud);
extern void lua_setallocf (lua_State *L, lua_Alloc f, void *ud);
# 323 "H:/CPP/lua51/include/lua.h"
typedef struct lua_Debug lua_Debug;



typedef void (*lua_Hook) (lua_State *L, lua_Debug *ar);


extern int lua_getstack (lua_State *L, int level, lua_Debug *ar);
extern int lua_getinfo (lua_State *L, const char *what, lua_Debug *ar);
extern const char *lua_getlocal (lua_State *L, const lua_Debug *ar, int n);
extern const char *lua_setlocal (lua_State *L, const lua_Debug *ar, int n);
extern const char *lua_getupvalue (lua_State *L, int funcindex, int n);
extern const char *lua_setupvalue (lua_State *L, int funcindex, int n);

extern int lua_sethook (lua_State *L, lua_Hook func, int mask, int count);
extern lua_Hook lua_gethook (lua_State *L);
extern int lua_gethookmask (lua_State *L);
extern int lua_gethookcount (lua_State *L);


struct lua_Debug {
  int event;
  const char *name;
  const char *namewhat;
  const char *what;
  const char *source;
  int currentline;
  int nups;
  int linedefined;
  int lastlinedefined;
  char short_src[60];

  int i_ci;
};
# 7 "H:/CPP/lua51/include/lua.hpp" 2
# 1 "H:/CPP/lua51/include/lualib.h" 1
# 19 "H:/CPP/lua51/include/lualib.h"
extern int (luaopen_base) (lua_State *L);


extern int (luaopen_table) (lua_State *L);


extern int (luaopen_io) (lua_State *L);


extern int (luaopen_os) (lua_State *L);


extern int (luaopen_string) (lua_State *L);


extern int (luaopen_math) (lua_State *L);


extern int (luaopen_debug) (lua_State *L);


extern int (luaopen_package) (lua_State *L);



extern void (luaL_openlibs) (lua_State *L);
# 8 "H:/CPP/lua51/include/lua.hpp" 2
# 1 "H:/CPP/lua51/include/lauxlib.h" 1
# 12 "H:/CPP/lua51/include/lauxlib.h"
# 1 "H:/CPP/wxdevcpp6.10/lib/gcc/mingw32/3.4.2/include/stddef.h" 1
# 13 "H:/CPP/lua51/include/lauxlib.h" 2
# 1 "H:/CPP/wxdevcpp6.10/include/stdio.h" 1
# 26 "H:/CPP/wxdevcpp6.10/include/stdio.h"
# 1 "H:/CPP/wxdevcpp6.10/lib/gcc/mingw32/3.4.2/include/stddef.h" 1
# 354 "H:/CPP/wxdevcpp6.10/lib/gcc/mingw32/3.4.2/include/stddef.h"
typedef short unsigned int wint_t;
# 27 "H:/CPP/wxdevcpp6.10/include/stdio.h" 2
# 138 "H:/CPP/wxdevcpp6.10/include/stdio.h"
typedef struct _iobuf
{
 char* _ptr;
 int _cnt;
 char* _base;
 int _flag;
 int _file;
 int _charbuf;
 int _bufsiz;
 char* _tmpfname;
} FILE;
# 163 "H:/CPP/wxdevcpp6.10/include/stdio.h"
extern __attribute__ ((dllimport)) FILE _iob[];
# 172 "H:/CPP/wxdevcpp6.10/include/stdio.h"
extern "C" {





 FILE* __attribute__((__cdecl__)) fopen (const char*, const char*);
 FILE* __attribute__((__cdecl__)) freopen (const char*, const char*, FILE*);
 int __attribute__((__cdecl__)) fflush (FILE*);
 int __attribute__((__cdecl__)) fclose (FILE*);

 int __attribute__((__cdecl__)) remove (const char*);
 int __attribute__((__cdecl__)) rename (const char*, const char*);
 FILE* __attribute__((__cdecl__)) tmpfile (void);
 char* __attribute__((__cdecl__)) tmpnam (char*);


 char* __attribute__((__cdecl__)) _tempnam (const char*, const char*);
 int __attribute__((__cdecl__)) _rmtmp(void);


 char* __attribute__((__cdecl__)) tempnam (const char*, const char*);
 int __attribute__((__cdecl__)) rmtmp(void);



 int __attribute__((__cdecl__)) setvbuf (FILE*, char*, int, size_t);

 void __attribute__((__cdecl__)) setbuf (FILE*, char*);





 int __attribute__((__cdecl__)) fprintf (FILE*, const char*, ...);
 int __attribute__((__cdecl__)) printf (const char*, ...);
 int __attribute__((__cdecl__)) sprintf (char*, const char*, ...);
 int __attribute__((__cdecl__)) _snprintf (char*, size_t, const char*, ...);
 int __attribute__((__cdecl__)) vfprintf (FILE*, const char*, __gnuc_va_list);
 int __attribute__((__cdecl__)) vprintf (const char*, __gnuc_va_list);
 int __attribute__((__cdecl__)) vsprintf (char*, const char*, __gnuc_va_list);
 int __attribute__((__cdecl__)) _vsnprintf (char*, size_t, const char*, __gnuc_va_list);


int __attribute__((__cdecl__)) snprintf(char* s, size_t n, const char* format, ...);
inline int __attribute__((__cdecl__))
vsnprintf (char* s, size_t n, const char* format, __gnuc_va_list arg)
  { return _vsnprintf ( s, n, format, arg); }
int __attribute__((__cdecl__)) vscanf (const char * __restrict__, __gnuc_va_list);
int __attribute__((__cdecl__)) vfscanf (FILE * __restrict__, const char * __restrict__,
       __gnuc_va_list);
int __attribute__((__cdecl__)) vsscanf (const char * __restrict__,
       const char * __restrict__, __gnuc_va_list);






 int __attribute__((__cdecl__)) fscanf (FILE*, const char*, ...);
 int __attribute__((__cdecl__)) scanf (const char*, ...);
 int __attribute__((__cdecl__)) sscanf (const char*, const char*, ...);




 int __attribute__((__cdecl__)) fgetc (FILE*);
 char* __attribute__((__cdecl__)) fgets (char*, int, FILE*);
 int __attribute__((__cdecl__)) fputc (int, FILE*);
 int __attribute__((__cdecl__)) fputs (const char*, FILE*);
 char* __attribute__((__cdecl__)) gets (char*);
 int __attribute__((__cdecl__)) puts (const char*);
 int __attribute__((__cdecl__)) ungetc (int, FILE*);







 int __attribute__((__cdecl__)) _filbuf (FILE*);
 int __attribute__((__cdecl__)) _flsbuf (int, FILE*);



inline int __attribute__((__cdecl__)) getc (FILE* __F)
{
  return (--__F->_cnt >= 0)
    ? (int) (unsigned char) *__F->_ptr++
    : _filbuf (__F);
}

inline int __attribute__((__cdecl__)) putc (int __c, FILE* __F)
{
  return (--__F->_cnt >= 0)
    ? (int) (unsigned char) (*__F->_ptr++ = (char)__c)
    : _flsbuf (__c, __F);
}

inline int __attribute__((__cdecl__)) getchar (void)
{
  return (--(&_iob[0])->_cnt >= 0)
    ? (int) (unsigned char) *(&_iob[0])->_ptr++
    : _filbuf ((&_iob[0]));
}

inline int __attribute__((__cdecl__)) putchar(int __c)
{
  return (--(&_iob[1])->_cnt >= 0)
    ? (int) (unsigned char) (*(&_iob[1])->_ptr++ = (char)__c)
    : _flsbuf (__c, (&_iob[1]));}
# 297 "H:/CPP/wxdevcpp6.10/include/stdio.h"
 size_t __attribute__((__cdecl__)) fread (void*, size_t, size_t, FILE*);
 size_t __attribute__((__cdecl__)) fwrite (const void*, size_t, size_t, FILE*);





 int __attribute__((__cdecl__)) fseek (FILE*, long, int);
 long __attribute__((__cdecl__)) ftell (FILE*);
 void __attribute__((__cdecl__)) rewind (FILE*);
# 330 "H:/CPP/wxdevcpp6.10/include/stdio.h"
typedef long long fpos_t;




 int __attribute__((__cdecl__)) fgetpos (FILE*, fpos_t*);
 int __attribute__((__cdecl__)) fsetpos (FILE*, const fpos_t*);





 int __attribute__((__cdecl__)) feof (FILE*);
 int __attribute__((__cdecl__)) ferror (FILE*);


inline int __attribute__((__cdecl__)) feof (FILE* __F)
  { return __F->_flag & 0x0010; }
inline int __attribute__((__cdecl__)) ferror (FILE* __F)
  { return __F->_flag & 0x0020; }





 void __attribute__((__cdecl__)) clearerr (FILE*);
 void __attribute__((__cdecl__)) perror (const char*);






 FILE* __attribute__((__cdecl__)) _popen (const char*, const char*);
 int __attribute__((__cdecl__)) _pclose (FILE*);


 FILE* __attribute__((__cdecl__)) popen (const char*, const char*);
 int __attribute__((__cdecl__)) pclose (FILE*);





 int __attribute__((__cdecl__)) _flushall (void);
 int __attribute__((__cdecl__)) _fgetchar (void);
 int __attribute__((__cdecl__)) _fputchar (int);
 FILE* __attribute__((__cdecl__)) _fdopen (int, const char*);
 int __attribute__((__cdecl__)) _fileno (FILE*);
 int __attribute__((__cdecl__)) _fcloseall(void);
 FILE* __attribute__((__cdecl__)) _fsopen(const char*, const char*, int);

 int __attribute__((__cdecl__)) _getmaxstdio(void);
 int __attribute__((__cdecl__)) _setmaxstdio(int);



 int __attribute__((__cdecl__)) fgetchar (void);
 int __attribute__((__cdecl__)) fputchar (int);
 FILE* __attribute__((__cdecl__)) fdopen (int, const char*);
 int __attribute__((__cdecl__)) fileno (FILE*);
# 399 "H:/CPP/wxdevcpp6.10/include/stdio.h"
# 1 "H:/CPP/wxdevcpp6.10/include/sys/types.h" 1
# 21 "H:/CPP/wxdevcpp6.10/include/sys/types.h"
# 1 "H:/CPP/wxdevcpp6.10/lib/gcc/mingw32/3.4.2/include/stddef.h" 1
# 22 "H:/CPP/wxdevcpp6.10/include/sys/types.h" 2





typedef long time_t;




typedef long long __time64_t;





typedef long _off_t;


typedef _off_t off_t;







typedef unsigned int _dev_t;





typedef _dev_t dev_t;






typedef short _ino_t;


typedef _ino_t ino_t;






typedef int _pid_t;


typedef _pid_t pid_t;






typedef unsigned short _mode_t;


typedef _mode_t mode_t;






typedef int _sigset_t;


typedef _sigset_t sigset_t;





typedef long _ssize_t;


typedef _ssize_t ssize_t;





typedef long long fpos64_t;




typedef long long off64_t;
# 400 "H:/CPP/wxdevcpp6.10/include/stdio.h" 2
inline FILE* __attribute__((__cdecl__)) fopen64 (const char* filename, const char* mode)
{
  return fopen (filename, mode);
}

int __attribute__((__cdecl__)) fseeko64 (FILE*, off64_t, int);






inline off64_t __attribute__((__cdecl__)) ftello64 (FILE * stream)
{
  fpos_t pos;
  if (fgetpos(stream, &pos))
    return -1LL;
  else
   return ((off64_t) pos);
}
# 428 "H:/CPP/wxdevcpp6.10/include/stdio.h"
 int __attribute__((__cdecl__)) fwprintf (FILE*, const wchar_t*, ...);
 int __attribute__((__cdecl__)) wprintf (const wchar_t*, ...);
 int __attribute__((__cdecl__)) swprintf (wchar_t*, const wchar_t*, ...);
 int __attribute__((__cdecl__)) _snwprintf (wchar_t*, size_t, const wchar_t*, ...);
 int __attribute__((__cdecl__)) vfwprintf (FILE*, const wchar_t*, __gnuc_va_list);
 int __attribute__((__cdecl__)) vwprintf (const wchar_t*, __gnuc_va_list);
 int __attribute__((__cdecl__)) vswprintf (wchar_t*, const wchar_t*, __gnuc_va_list);
 int __attribute__((__cdecl__)) _vsnwprintf (wchar_t*, size_t, const wchar_t*, __gnuc_va_list);
 int __attribute__((__cdecl__)) fwscanf (FILE*, const wchar_t*, ...);
 int __attribute__((__cdecl__)) wscanf (const wchar_t*, ...);
 int __attribute__((__cdecl__)) swscanf (const wchar_t*, const wchar_t*, ...);
 wint_t __attribute__((__cdecl__)) fgetwc (FILE*);
 wint_t __attribute__((__cdecl__)) fputwc (wchar_t, FILE*);
 wint_t __attribute__((__cdecl__)) ungetwc (wchar_t, FILE*);


 wchar_t* __attribute__((__cdecl__)) fgetws (wchar_t*, int, FILE*);
 int __attribute__((__cdecl__)) fputws (const wchar_t*, FILE*);
 wint_t __attribute__((__cdecl__)) getwc (FILE*);
 wint_t __attribute__((__cdecl__)) getwchar (void);
 wchar_t* __attribute__((__cdecl__)) _getws (wchar_t*);
 wint_t __attribute__((__cdecl__)) putwc (wint_t, FILE*);
 int __attribute__((__cdecl__)) _putws (const wchar_t*);
 wint_t __attribute__((__cdecl__)) putwchar (wint_t);
 FILE* __attribute__((__cdecl__)) _wfdopen(int, wchar_t *);
 FILE* __attribute__((__cdecl__)) _wfopen (const wchar_t*, const wchar_t*);
 FILE* __attribute__((__cdecl__)) _wfreopen (const wchar_t*, const wchar_t*, FILE*);
 FILE* __attribute__((__cdecl__)) _wfsopen (const wchar_t*, const wchar_t*, int);
 wchar_t* __attribute__((__cdecl__)) _wtmpnam (wchar_t*);
 wchar_t* __attribute__((__cdecl__)) _wtempnam (const wchar_t*, const wchar_t*);
 int __attribute__((__cdecl__)) _wrename (const wchar_t*, const wchar_t*);
 int __attribute__((__cdecl__)) _wremove (const wchar_t*);
 void __attribute__((__cdecl__)) _wperror (const wchar_t*);
 FILE* __attribute__((__cdecl__)) _wpopen (const wchar_t*, const wchar_t*);



int __attribute__((__cdecl__)) snwprintf (wchar_t* s, size_t n, const wchar_t* format, ...);
inline int __attribute__((__cdecl__))
vsnwprintf (wchar_t* s, size_t n, const wchar_t* format, __gnuc_va_list arg)
  { return _vsnwprintf ( s, n, format, arg);}
int __attribute__((__cdecl__)) vwscanf (const wchar_t * __restrict__, __gnuc_va_list);
int __attribute__((__cdecl__)) vfwscanf (FILE * __restrict__,
         const wchar_t * __restrict__, __gnuc_va_list);
int __attribute__((__cdecl__)) vswscanf (const wchar_t * __restrict__,
         const wchar_t * __restrict__, __gnuc_va_list);
# 482 "H:/CPP/wxdevcpp6.10/include/stdio.h"
 FILE* __attribute__((__cdecl__)) wpopen (const wchar_t*, const wchar_t*);






 wint_t __attribute__((__cdecl__)) _fgetwchar (void);
 wint_t __attribute__((__cdecl__)) _fputwchar (wint_t);
 int __attribute__((__cdecl__)) _getw (FILE*);
 int __attribute__((__cdecl__)) _putw (int, FILE*);


 wint_t __attribute__((__cdecl__)) fgetwchar (void);
 wint_t __attribute__((__cdecl__)) fputwchar (wint_t);
 int __attribute__((__cdecl__)) getw (FILE*);
 int __attribute__((__cdecl__)) putw (int, FILE*);





}
# 14 "H:/CPP/lua51/include/lauxlib.h" 2
# 35 "H:/CPP/lua51/include/lauxlib.h"
typedef struct luaL_Reg {
  const char *name;
  lua_CFunction func;
} luaL_Reg;



extern void (luaL_openlib) (lua_State *L, const char *libname,
                                const luaL_Reg *l, int nup);
extern void (luaL_register) (lua_State *L, const char *libname,
                                const luaL_Reg *l);
extern int (luaL_getmetafield) (lua_State *L, int obj, const char *e);
extern int (luaL_callmeta) (lua_State *L, int obj, const char *e);
extern int (luaL_typerror) (lua_State *L, int narg, const char *tname);
extern int (luaL_argerror) (lua_State *L, int numarg, const char *extramsg);
extern const char *(luaL_checklstring) (lua_State *L, int numArg,
                                                          size_t *l);
extern const char *(luaL_optlstring) (lua_State *L, int numArg,
                                          const char *def, size_t *l);
extern lua_Number (luaL_checknumber) (lua_State *L, int numArg);
extern lua_Number (luaL_optnumber) (lua_State *L, int nArg, lua_Number def);

extern lua_Integer (luaL_checkinteger) (lua_State *L, int numArg);
extern lua_Integer (luaL_optinteger) (lua_State *L, int nArg,
                                          lua_Integer def);

extern void (luaL_checkstack) (lua_State *L, int sz, const char *msg);
extern void (luaL_checktype) (lua_State *L, int narg, int t);
extern void (luaL_checkany) (lua_State *L, int narg);

extern int (luaL_newmetatable) (lua_State *L, const char *tname);
extern void *(luaL_checkudata) (lua_State *L, int ud, const char *tname);

extern void (luaL_where) (lua_State *L, int lvl);
extern int (luaL_error) (lua_State *L, const char *fmt, ...);

extern int (luaL_checkoption) (lua_State *L, int narg, const char *def,
                                   const char *const lst[]);

extern int (luaL_ref) (lua_State *L, int t);
extern void (luaL_unref) (lua_State *L, int t, int ref);

extern int (luaL_loadfile) (lua_State *L, const char *filename);
extern int (luaL_loadbuffer) (lua_State *L, const char *buff, size_t sz,
                                  const char *name);
extern int (luaL_loadstring) (lua_State *L, const char *s);

extern lua_State *(luaL_newstate) (void);


extern const char *(luaL_gsub) (lua_State *L, const char *s, const char *p,
                                                  const char *r);

extern const char *(luaL_findtable) (lua_State *L, int idx,
                                         const char *fname, int szhint);
# 129 "H:/CPP/lua51/include/lauxlib.h"
typedef struct luaL_Buffer {
  char *p;
  int lvl;
  lua_State *L;
  char buffer[512];
} luaL_Buffer;
# 145 "H:/CPP/lua51/include/lauxlib.h"
extern void (luaL_buffinit) (lua_State *L, luaL_Buffer *B);
extern char *(luaL_prepbuffer) (luaL_Buffer *B);
extern void (luaL_addlstring) (luaL_Buffer *B, const char *s, size_t l);
extern void (luaL_addstring) (luaL_Buffer *B, const char *s);
extern void (luaL_addvalue) (luaL_Buffer *B);
extern void (luaL_pushresult) (luaL_Buffer *B);
# 9 "H:/CPP/lua51/include/lua.hpp" 2
}
# 5 "player.h" 2
class Player
{
      private:
      double x, y;
      int lives;
      int score;
      int bombs;
      int power;
      int sprite1;
      int sprite2;
      int spriteinvincible;
      int bgsprite;
      bool invincible;
      double radius;
      double speed;
      double recoila;
      double recoilb;
      double rotation;
      double rotationspeed;
      double rotationmax;


      public:
      Player(char* charfile);
      ~Player();
      int invincibletime;

      double xvel;
      double yvel;


      double getX();
      void setX(double newx);

      double getY();
      void setY(double newy);

      int getLives();
      void setLives(int newlives);

      int getScore();
      void setScore(int newscore);

      int getBombs();
      void setBombs(int newbombs);

      int getPower();
      void setPower(int newpower);




      bool getInvincible();
      void setInvincible(bool newinvincible);

      double getRadius();
      void setRadius(double newradius);

      double getSpeed();
      void setSpeed(double newspeed);

      double getRecoilA();
      void setRecoilA(double newrecoila);

      double getRecoilB();
      void setRecoilB(double newrecoilb);

      double getRotation();
      void setRotation(double newroation);

      double getRotationSpeed();
      void setRotationSpeed(double newrotationspeed);

      double getRotationMax();
      void setRotationMax(double newrotationmax);

      int getSprite1();
      int getSprite2();
      int getSpriteInvincible();
      int getBGSprite();

      static int l_setSprite1( lua_State* luaVM);
      static int l_setSprite2( lua_State* luaVM);
      static int l_setSpriteInvincible( lua_State* luaVM);
      static int l_setBGSprite( lua_State* luaVM);

};
# 6 "shooter.cpp" 2
# 1 "bullet.h" 1



class Bullet
{
    private:
        double x, y;
        double xaccel, yaccel;
        double xvel, yvel;
        double radius;
        int sprite;
        bool arclengthrotation;
        double rcenterx, rcentery;
        double rvel;
        double raccel;
        double radialaccel;
        double radialvel;
        double damage;

    public:
        Bullet(double sx, double sy, double sxaccel, double syaccel,
               double sxvel, double syvel, double sradius, double sdamage, int ssprite);

        Bullet(double sx, double sy, double sxaccel, double syaccel,
               double sxvel, double syvel, bool sarclengthrotation,
               double srcenterx, double srcentery, double rvel, double sraccel,
               double sradialaccel, double sradialvel,
               double sradius,double damage, int ssprite);
        ~Bullet();

        double oldx, oldy;
        double effvelx, effvely;

        double getX();
        void setX(double newx);

        double getY();
        void setY(double newy);

        double getXVel();
        void setXVel(double newxvel);

        double getYVel();
        void setYVel(double newyvel);

        double getXAccel();
        void setXAccel(double newxaccel);

        double getYAccel();
        void setYAccel(double newyaccel);

        double getRotationCenterX();
        void setRotationCenterX(double newrcenterx);

        double getRotationCenterY();
        void setRotationCenterY(double newrcentery);

        bool getArcLengthRotation();
        void setArcLengthRotation(bool newarclengthrotation);

        double getRotationalVelocity();
        void setRotationalVelocity(double newrvel);

        double getRotationalAcceleration();
        void setRotationalAcceleration(double newraccel);

        double getRadialAcceleration();
        void setRadialAcceleration(double newradaccel);

        double getRadialVelocity();
        void setRadialVelocity(double newradvel);

        double getRadius();
        void setRadius(double newradius);

        int getSprite();
        void setSprite(int newsprite);

        double getDamage();
        void setDamage(double newdamage);


        void update();
};
# 7 "shooter.cpp" 2
# 1 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/backward/iostream.h" 1
# 31 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/backward/iostream.h"
# 1 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/backward/backward_warning.h" 1
# 32 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/backward/iostream.h" 2
# 1 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/iostream" 1
# 42 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/iostream"
       
# 43 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/iostream" 3

# 1 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/mingw32/bits/c++config.h" 1 3
# 35 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/mingw32/bits/c++config.h" 3
# 1 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/mingw32/bits/os_defines.h" 1 3
# 36 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/mingw32/bits/c++config.h" 2 3
# 57 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/mingw32/bits/c++config.h" 3
namespace __gnu_debug_def { }

namespace __gnu_debug
{
  using namespace __gnu_debug_def;
}
# 45 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/iostream" 2 3
# 1 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/ostream" 1 3
# 43 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/ostream" 3
       
# 44 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/ostream" 3

# 1 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/ios" 1 3
# 42 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/ios" 3
       
# 43 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/ios" 3

# 1 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/iosfwd" 1 3
# 43 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/iosfwd" 3
       
# 44 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/iosfwd" 3


# 1 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/mingw32/bits/c++locale.h" 1 3
# 39 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/mingw32/bits/c++locale.h" 3
       
# 40 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/mingw32/bits/c++locale.h" 3

# 1 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/clocale" 1 3
# 47 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/clocale" 3
       
# 48 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/clocale" 3

# 1 "H:/CPP/wxdevcpp6.10/include/locale.h" 1 3
# 40 "H:/CPP/wxdevcpp6.10/include/locale.h" 3
# 1 "H:/CPP/wxdevcpp6.10/lib/gcc/mingw32/3.4.2/include/stddef.h" 1 3
# 41 "H:/CPP/wxdevcpp6.10/include/locale.h" 2 3




struct lconv
{
 char* decimal_point;
 char* thousands_sep;
 char* grouping;
 char* int_curr_symbol;
 char* currency_symbol;
 char* mon_decimal_point;
 char* mon_thousands_sep;
 char* mon_grouping;
 char* positive_sign;
 char* negative_sign;
 char int_frac_digits;
 char frac_digits;
 char p_cs_precedes;
 char p_sep_by_space;
 char n_cs_precedes;
 char n_sep_by_space;
 char p_sign_posn;
 char n_sign_posn;
};


extern "C" {


 char* __attribute__((__cdecl__)) setlocale (int, const char*);
 struct lconv* __attribute__((__cdecl__)) localeconv (void);



# 1 "H:/CPP/wxdevcpp6.10/lib/gcc/mingw32/3.4.2/include/stddef.h" 1 3
# 77 "H:/CPP/wxdevcpp6.10/include/locale.h" 2 3
  wchar_t* __attribute__((__cdecl__)) _wsetlocale(int, const wchar_t*);




}
# 50 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/clocale" 2 3





namespace std
{
  using ::lconv;
  using ::setlocale;
  using ::localeconv;
}
# 42 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/mingw32/bits/c++locale.h" 2 3
# 1 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/cstring" 1 3
# 47 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/cstring" 3
       
# 48 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/cstring" 3

# 1 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/cstddef" 1 3
# 46 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/cstddef" 3
       
# 47 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/cstddef" 3

# 1 "H:/CPP/wxdevcpp6.10/lib/gcc/mingw32/3.4.2/include/stddef.h" 1 3
# 49 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/cstddef" 2 3

namespace std
{
  using ::ptrdiff_t;
  using ::size_t;
}
# 50 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/cstring" 2 3

# 1 "H:/CPP/wxdevcpp6.10/include/string.h" 1 3
# 24 "H:/CPP/wxdevcpp6.10/include/string.h" 3
# 1 "H:/CPP/wxdevcpp6.10/lib/gcc/mingw32/3.4.2/include/stddef.h" 1 3
# 25 "H:/CPP/wxdevcpp6.10/include/string.h" 2 3





extern "C" {





 void* __attribute__((__cdecl__)) memchr (const void*, int, size_t) __attribute__ ((__pure__));
 int __attribute__((__cdecl__)) memcmp (const void*, const void*, size_t) __attribute__ ((__pure__));
 void* __attribute__((__cdecl__)) memcpy (void*, const void*, size_t);
 void* __attribute__((__cdecl__)) memmove (void*, const void*, size_t);
 void* __attribute__((__cdecl__)) memset (void*, int, size_t);
 char* __attribute__((__cdecl__)) strcat (char*, const char*);
 char* __attribute__((__cdecl__)) strchr (const char*, int) __attribute__ ((__pure__));
 int __attribute__((__cdecl__)) strcmp (const char*, const char*) __attribute__ ((__pure__));
 int __attribute__((__cdecl__)) strcoll (const char*, const char*);
 char* __attribute__((__cdecl__)) strcpy (char*, const char*);
 size_t __attribute__((__cdecl__)) strcspn (const char*, const char*) __attribute__ ((__pure__));
 char* __attribute__((__cdecl__)) strerror (int);

 size_t __attribute__((__cdecl__)) strlen (const char*) __attribute__ ((__pure__));
 char* __attribute__((__cdecl__)) strncat (char*, const char*, size_t);
 int __attribute__((__cdecl__)) strncmp (const char*, const char*, size_t) __attribute__ ((__pure__));
 char* __attribute__((__cdecl__)) strncpy (char*, const char*, size_t);
 char* __attribute__((__cdecl__)) strpbrk (const char*, const char*) __attribute__ ((__pure__));
 char* __attribute__((__cdecl__)) strrchr (const char*, int) __attribute__ ((__pure__));
 size_t __attribute__((__cdecl__)) strspn (const char*, const char*) __attribute__ ((__pure__));
 char* __attribute__((__cdecl__)) strstr (const char*, const char*) __attribute__ ((__pure__));
 char* __attribute__((__cdecl__)) strtok (char*, const char*);
 size_t __attribute__((__cdecl__)) strxfrm (char*, const char*, size_t);





 char* __attribute__((__cdecl__)) _strerror (const char *);
 void* __attribute__((__cdecl__)) _memccpy (void*, const void*, int, size_t);
 int __attribute__((__cdecl__)) _memicmp (const void*, const void*, size_t);
 char* __attribute__((__cdecl__)) _strdup (const char*) __attribute__ ((__malloc__));
 int __attribute__((__cdecl__)) _strcmpi (const char*, const char*);
 int __attribute__((__cdecl__)) _stricmp (const char*, const char*);
 int __attribute__((__cdecl__)) _stricoll (const char*, const char*);
 char* __attribute__((__cdecl__)) _strlwr (char*);
 int __attribute__((__cdecl__)) _strnicmp (const char*, const char*, size_t);
 char* __attribute__((__cdecl__)) _strnset (char*, int, size_t);
 char* __attribute__((__cdecl__)) _strrev (char*);
 char* __attribute__((__cdecl__)) _strset (char*, int);
 char* __attribute__((__cdecl__)) _strupr (char*);
 void __attribute__((__cdecl__)) _swab (const char*, char*, size_t);


 int __attribute__((__cdecl__)) _strncoll(const char*, const char*, size_t);
 int __attribute__((__cdecl__)) _strnicoll(const char*, const char*, size_t);
# 90 "H:/CPP/wxdevcpp6.10/include/string.h" 3
 void* __attribute__((__cdecl__)) memccpy (void*, const void*, int, size_t);
 int __attribute__((__cdecl__)) memicmp (const void*, const void*, size_t);
 char* __attribute__((__cdecl__)) strdup (const char*) __attribute__ ((__malloc__));
 int __attribute__((__cdecl__)) strcmpi (const char*, const char*);
 int __attribute__((__cdecl__)) stricmp (const char*, const char*);
inline int __attribute__((__cdecl__))
strcasecmp (const char * __sz1, const char * __sz2)
  {return _stricmp (__sz1, __sz2);}
 int __attribute__((__cdecl__)) stricoll (const char*, const char*);
 char* __attribute__((__cdecl__)) strlwr (char*);
 int __attribute__((__cdecl__)) strnicmp (const char*, const char*, size_t);
inline int __attribute__((__cdecl__))
strncasecmp (const char * __sz1, const char * __sz2, size_t __sizeMaxCompare)
  {return _strnicmp (__sz1, __sz2, __sizeMaxCompare);}
 char* __attribute__((__cdecl__)) strnset (char*, int, size_t);
 char* __attribute__((__cdecl__)) strrev (char*);
 char* __attribute__((__cdecl__)) strset (char*, int);
 char* __attribute__((__cdecl__)) strupr (char*);

 void __attribute__((__cdecl__)) swab (const char*, char*, size_t);
# 120 "H:/CPP/wxdevcpp6.10/include/string.h" 3
 wchar_t* __attribute__((__cdecl__)) wcscat (wchar_t*, const wchar_t*);
 wchar_t* __attribute__((__cdecl__)) wcschr (const wchar_t*, wchar_t);
 int __attribute__((__cdecl__)) wcscmp (const wchar_t*, const wchar_t*);
 int __attribute__((__cdecl__)) wcscoll (const wchar_t*, const wchar_t*);
 wchar_t* __attribute__((__cdecl__)) wcscpy (wchar_t*, const wchar_t*);
 size_t __attribute__((__cdecl__)) wcscspn (const wchar_t*, const wchar_t*);

 size_t __attribute__((__cdecl__)) wcslen (const wchar_t*);
 wchar_t* __attribute__((__cdecl__)) wcsncat (wchar_t*, const wchar_t*, size_t);
 int __attribute__((__cdecl__)) wcsncmp(const wchar_t*, const wchar_t*, size_t);
 wchar_t* __attribute__((__cdecl__)) wcsncpy(wchar_t*, const wchar_t*, size_t);
 wchar_t* __attribute__((__cdecl__)) wcspbrk(const wchar_t*, const wchar_t*);
 wchar_t* __attribute__((__cdecl__)) wcsrchr(const wchar_t*, wchar_t);
 size_t __attribute__((__cdecl__)) wcsspn(const wchar_t*, const wchar_t*);
 wchar_t* __attribute__((__cdecl__)) wcsstr(const wchar_t*, const wchar_t*);
 wchar_t* __attribute__((__cdecl__)) wcstok(wchar_t*, const wchar_t*);
 size_t __attribute__((__cdecl__)) wcsxfrm(wchar_t*, const wchar_t*, size_t);
# 146 "H:/CPP/wxdevcpp6.10/include/string.h" 3
 wchar_t* __attribute__((__cdecl__)) _wcsdup (const wchar_t*);
 int __attribute__((__cdecl__)) _wcsicmp (const wchar_t*, const wchar_t*);
 int __attribute__((__cdecl__)) _wcsicoll (const wchar_t*, const wchar_t*);
 wchar_t* __attribute__((__cdecl__)) _wcslwr (wchar_t*);
 int __attribute__((__cdecl__)) _wcsnicmp (const wchar_t*, const wchar_t*, size_t);
 wchar_t* __attribute__((__cdecl__)) _wcsnset (wchar_t*, wchar_t, size_t);
 wchar_t* __attribute__((__cdecl__)) _wcsrev (wchar_t*);
 wchar_t* __attribute__((__cdecl__)) _wcsset (wchar_t*, wchar_t);
 wchar_t* __attribute__((__cdecl__)) _wcsupr (wchar_t*);


 int __attribute__((__cdecl__)) _wcsncoll(const wchar_t*, const wchar_t*, size_t);
 int __attribute__((__cdecl__)) _wcsnicoll(const wchar_t*, const wchar_t*, size_t);
# 167 "H:/CPP/wxdevcpp6.10/include/string.h" 3
int __attribute__((__cdecl__)) wcscmpi (const wchar_t * __ws1, const wchar_t * __ws2);
inline int __attribute__((__cdecl__))
wcscmpi (const wchar_t * __ws1, const wchar_t * __ws2)
  {return _wcsicmp (__ws1, __ws2);}
 wchar_t* __attribute__((__cdecl__)) wcsdup (const wchar_t*);
 int __attribute__((__cdecl__)) wcsicmp (const wchar_t*, const wchar_t*);
 int __attribute__((__cdecl__)) wcsicoll (const wchar_t*, const wchar_t*);
 wchar_t* __attribute__((__cdecl__)) wcslwr (wchar_t*);
 int __attribute__((__cdecl__)) wcsnicmp (const wchar_t*, const wchar_t*, size_t);
 wchar_t* __attribute__((__cdecl__)) wcsnset (wchar_t*, wchar_t, size_t);
 wchar_t* __attribute__((__cdecl__)) wcsrev (wchar_t*);
 wchar_t* __attribute__((__cdecl__)) wcsset (wchar_t*, wchar_t);
 wchar_t* __attribute__((__cdecl__)) wcsupr (wchar_t*);
# 188 "H:/CPP/wxdevcpp6.10/include/string.h" 3
}
# 52 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/cstring" 2 3
# 77 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/cstring" 3
namespace std
{
  using ::memcpy;
  using ::memmove;
  using ::strcpy;
  using ::strncpy;
  using ::strcat;
  using ::strncat;
  using ::memcmp;
  using ::strcmp;
  using ::strcoll;
  using ::strncmp;
  using ::strxfrm;
  using ::strcspn;
  using ::strspn;
  using ::strtok;
  using ::memset;
  using ::strerror;
  using ::strlen;

  using ::memchr;

  inline void*
  memchr(void* __p, int __c, size_t __n)
  { return memchr(const_cast<const void*>(__p), __c, __n); }

  using ::strchr;

  inline char*
  strchr(char* __s1, int __n)
  { return __builtin_strchr(const_cast<const char*>(__s1), __n); }

  using ::strpbrk;

  inline char*
  strpbrk(char* __s1, const char* __s2)
  { return __builtin_strpbrk(const_cast<const char*>(__s1), __s2); }

  using ::strrchr;

  inline char*
  strrchr(char* __s1, int __n)
  { return __builtin_strrchr(const_cast<const char*>(__s1), __n); }

  using ::strstr;

  inline char*
  strstr(char* __s1, const char* __s2)
  { return __builtin_strstr(const_cast<const char*>(__s1), __s2); }
}
# 43 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/mingw32/bits/c++locale.h" 2 3
# 1 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/cstdio" 1 3
# 47 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/cstdio" 3
       
# 48 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/cstdio" 3
# 97 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/cstdio" 3
namespace std
{
  using ::FILE;
  using ::fpos_t;

  using ::clearerr;
  using ::fclose;
  using ::feof;
  using ::ferror;
  using ::fflush;
  using ::fgetc;
  using ::fgetpos;
  using ::fgets;
  using ::fopen;
  using ::fprintf;
  using ::fputc;
  using ::fputs;
  using ::fread;
  using ::freopen;
  using ::fscanf;
  using ::fseek;
  using ::fsetpos;
  using ::ftell;
  using ::fwrite;
  using ::getc;
  using ::getchar;
  using ::gets;
  using ::perror;
  using ::printf;
  using ::putc;
  using ::putchar;
  using ::puts;
  using ::remove;
  using ::rename;
  using ::rewind;
  using ::scanf;
  using ::setbuf;
  using ::setvbuf;
  using ::sprintf;
  using ::sscanf;
  using ::tmpfile;
  using ::tmpnam;
  using ::ungetc;
  using ::vfprintf;
  using ::vprintf;
  using ::vsprintf;
}
# 153 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/cstdio" 3
namespace __gnu_cxx
{
# 167 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/cstdio" 3
  using ::snprintf;
  using ::vfscanf;
  using ::vscanf;
  using ::vsnprintf;
  using ::vsscanf;

}

namespace std
{
  using __gnu_cxx::snprintf;
  using __gnu_cxx::vfscanf;
  using __gnu_cxx::vscanf;
  using __gnu_cxx::vsnprintf;
  using __gnu_cxx::vsscanf;
}
# 44 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/mingw32/bits/c++locale.h" 2 3



namespace std
{
  typedef int* __c_locale;





  template<typename _Tv>
    int
    __convert_from_v(char* __out,
       const int __size __attribute__((__unused__)),
       const char* __fmt,
       _Tv __v, const __c_locale&, int __prec)
    {
      char* __old = std::setlocale(0, __null);
      char* __sav = new char[std::strlen(__old) + 1];
      std::strcpy(__sav, __old);
      std::setlocale(0, "C");


      const int __ret = std::snprintf(__out, __size, __fmt, __prec, __v);



      std::setlocale(0, __sav);
      delete [] __sav;
      return __ret;
    }
}
# 47 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/iosfwd" 2 3
# 1 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/mingw32/bits/c++io.h" 1 3
# 37 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/mingw32/bits/c++io.h" 3
# 1 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/mingw32/bits/gthr.h" 1 3
# 96 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/mingw32/bits/gthr.h" 3
# 1 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/mingw32/bits/gthr-default.h" 1 3
# 66 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/mingw32/bits/gthr-default.h" 3
# 1 "H:/CPP/wxdevcpp6.10/include/errno.h" 1 3
# 80 "H:/CPP/wxdevcpp6.10/include/errno.h" 3
extern "C" {
# 91 "H:/CPP/wxdevcpp6.10/include/errno.h" 3
 int* __attribute__((__cdecl__)) _errno(void);




}
# 67 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/mingw32/bits/gthr-default.h" 2 3
# 331 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/mingw32/bits/gthr-default.h" 3
extern "C" {


typedef unsigned long __gthread_key_t;

typedef struct {
  int done;
  long started;
} __gthread_once_t;

typedef struct {
  long counter;
  void *sema;
} __gthread_mutex_t;
# 356 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/mingw32/bits/gthr-default.h" 3
extern int _CRT_MT;
extern int __mingwthr_key_dtor (unsigned long, void (*) (void *));
# 383 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/mingw32/bits/gthr-default.h" 3
static inline int
__gthread_active_p (void)
{

  return _CRT_MT;



}







extern int __gthr_win32_once (__gthread_once_t *, void (*) (void));
extern int __gthr_win32_key_create (__gthread_key_t *, void (*) (void*));
extern int __gthr_win32_key_delete (__gthread_key_t);
extern void * __gthr_win32_getspecific (__gthread_key_t);
extern int __gthr_win32_setspecific (__gthread_key_t, const void *);
extern void __gthr_win32_mutex_init_function (__gthread_mutex_t *);
extern int __gthr_win32_mutex_lock (__gthread_mutex_t *);
extern int __gthr_win32_mutex_trylock (__gthread_mutex_t *);
extern int __gthr_win32_mutex_unlock (__gthread_mutex_t *);

static inline int
__gthread_once (__gthread_once_t *once, void (*func) (void))
{
  if (__gthread_active_p ())
    return __gthr_win32_once (once, func);
  else
    return -1;
}

static inline int
__gthread_key_create (__gthread_key_t *key, void (*dtor) (void *))
{
  return __gthr_win32_key_create (key, dtor);
}

static inline int
__gthread_key_delete (__gthread_key_t key)
{
  return __gthr_win32_key_delete (key);
}

static inline void *
__gthread_getspecific (__gthread_key_t key)
{
  return __gthr_win32_getspecific (key);
}

static inline int
__gthread_setspecific (__gthread_key_t key, const void *ptr)
{
  return __gthr_win32_setspecific (key, ptr);
}

static inline void
__gthread_mutex_init_function (__gthread_mutex_t *mutex)
{
  __gthr_win32_mutex_init_function (mutex);
}

static inline int
__gthread_mutex_lock (__gthread_mutex_t *mutex)
{
  if (__gthread_active_p ())
    return __gthr_win32_mutex_lock (mutex);
  else
    return 0;
}

static inline int
__gthread_mutex_trylock (__gthread_mutex_t *mutex)
{
  if (__gthread_active_p ())
    return __gthr_win32_mutex_trylock (mutex);
  else
    return 0;
}

static inline int
__gthread_mutex_unlock (__gthread_mutex_t *mutex)
{
  if (__gthread_active_p ())
    return __gthr_win32_mutex_unlock (mutex);
  else
    return 0;
}
# 616 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/mingw32/bits/gthr-default.h" 3
}
# 97 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/mingw32/bits/gthr.h" 2 3
# 38 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/mingw32/bits/c++io.h" 2 3

namespace std
{
  typedef __gthread_mutex_t __c_lock;


  typedef FILE __c_file;


  struct __ios_flags
  {
    typedef short __int_type;

    static const __int_type _S_boolalpha = 0x0001;
    static const __int_type _S_dec = 0x0002;
    static const __int_type _S_fixed = 0x0004;
    static const __int_type _S_hex = 0x0008;
    static const __int_type _S_internal = 0x0010;
    static const __int_type _S_left = 0x0020;
    static const __int_type _S_oct = 0x0040;
    static const __int_type _S_right = 0x0080;
    static const __int_type _S_scientific = 0x0100;
    static const __int_type _S_showbase = 0x0200;
    static const __int_type _S_showpoint = 0x0400;
    static const __int_type _S_showpos = 0x0800;
    static const __int_type _S_skipws = 0x1000;
    static const __int_type _S_unitbuf = 0x2000;
    static const __int_type _S_uppercase = 0x4000;
    static const __int_type _S_adjustfield = 0x0020 | 0x0080 | 0x0010;
    static const __int_type _S_basefield = 0x0002 | 0x0040 | 0x0008;
    static const __int_type _S_floatfield = 0x0100 | 0x0004;


    static const __int_type _S_badbit = 0x01;
    static const __int_type _S_eofbit = 0x02;
    static const __int_type _S_failbit = 0x04;


    static const __int_type _S_app = 0x01;
    static const __int_type _S_ate = 0x02;
    static const __int_type _S_bin = 0x04;
    static const __int_type _S_in = 0x08;
    static const __int_type _S_out = 0x10;
    static const __int_type _S_trunc = 0x20;
  };
}
# 48 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/iosfwd" 2 3
# 1 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/cctype" 1 3
# 46 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/cctype" 3
       
# 47 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/cctype" 3


# 1 "H:/CPP/wxdevcpp6.10/include/ctype.h" 1 3
# 20 "H:/CPP/wxdevcpp6.10/include/ctype.h" 3
# 1 "H:/CPP/wxdevcpp6.10/lib/gcc/mingw32/3.4.2/include/stddef.h" 1 3
# 21 "H:/CPP/wxdevcpp6.10/include/ctype.h" 2 3
# 43 "H:/CPP/wxdevcpp6.10/include/ctype.h" 3
extern "C" {


 int __attribute__((__cdecl__)) isalnum(int);
 int __attribute__((__cdecl__)) isalpha(int);
 int __attribute__((__cdecl__)) iscntrl(int);
 int __attribute__((__cdecl__)) isdigit(int);
 int __attribute__((__cdecl__)) isgraph(int);
 int __attribute__((__cdecl__)) islower(int);
 int __attribute__((__cdecl__)) isprint(int);
 int __attribute__((__cdecl__)) ispunct(int);
 int __attribute__((__cdecl__)) isspace(int);
 int __attribute__((__cdecl__)) isupper(int);
 int __attribute__((__cdecl__)) isxdigit(int);


 int __attribute__((__cdecl__)) _isctype (int, int);



 int __attribute__((__cdecl__)) tolower(int);
 int __attribute__((__cdecl__)) toupper(int);
# 76 "H:/CPP/wxdevcpp6.10/include/ctype.h" 3
 int __attribute__((__cdecl__)) _tolower(int);
 int __attribute__((__cdecl__)) _toupper(int);







   extern __attribute__ ((dllimport)) int __mb_cur_max;
# 104 "H:/CPP/wxdevcpp6.10/include/ctype.h" 3
extern __attribute__ ((dllimport)) unsigned short _ctype[];

  extern __attribute__ ((dllimport)) unsigned short* _pctype;
# 143 "H:/CPP/wxdevcpp6.10/include/ctype.h" 3
inline int __attribute__((__cdecl__)) isalnum(int c) {return (__mb_cur_max == 1 ? (_pctype[c] & (0x0103|0x0004)) : _isctype(c, (0x0103|0x0004)));}
inline int __attribute__((__cdecl__)) isalpha(int c) {return (__mb_cur_max == 1 ? (_pctype[c] & 0x0103) : _isctype(c, 0x0103));}
inline int __attribute__((__cdecl__)) iscntrl(int c) {return (__mb_cur_max == 1 ? (_pctype[c] & 0x0020) : _isctype(c, 0x0020));}
inline int __attribute__((__cdecl__)) isdigit(int c) {return (__mb_cur_max == 1 ? (_pctype[c] & 0x0004) : _isctype(c, 0x0004));}
inline int __attribute__((__cdecl__)) isgraph(int c) {return (__mb_cur_max == 1 ? (_pctype[c] & (0x0010|0x0103|0x0004)) : _isctype(c, (0x0010|0x0103|0x0004)));}
inline int __attribute__((__cdecl__)) islower(int c) {return (__mb_cur_max == 1 ? (_pctype[c] & 0x0002) : _isctype(c, 0x0002));}
inline int __attribute__((__cdecl__)) isprint(int c) {return (__mb_cur_max == 1 ? (_pctype[c] & (0x0040|0x0010|0x0103|0x0004)) : _isctype(c, (0x0040|0x0010|0x0103|0x0004)));}
inline int __attribute__((__cdecl__)) ispunct(int c) {return (__mb_cur_max == 1 ? (_pctype[c] & 0x0010) : _isctype(c, 0x0010));}
inline int __attribute__((__cdecl__)) isspace(int c) {return (__mb_cur_max == 1 ? (_pctype[c] & 0x0008) : _isctype(c, 0x0008));}
inline int __attribute__((__cdecl__)) isupper(int c) {return (__mb_cur_max == 1 ? (_pctype[c] & 0x0001) : _isctype(c, 0x0001));}
inline int __attribute__((__cdecl__)) isxdigit(int c) {return (__mb_cur_max == 1 ? (_pctype[c] & 0x0080) : _isctype(c, 0x0080));}


inline int __attribute__((__cdecl__)) _tolower(int c) {return ( c -'A'+'a');}
inline int __attribute__((__cdecl__)) _toupper(int c) {return ( c -'a'+'A');}
# 171 "H:/CPP/wxdevcpp6.10/include/ctype.h" 3
typedef wchar_t wctype_t;



 int __attribute__((__cdecl__)) iswalnum(wint_t);
 int __attribute__((__cdecl__)) iswalpha(wint_t);
 int __attribute__((__cdecl__)) iswascii(wint_t);
 int __attribute__((__cdecl__)) iswcntrl(wint_t);
 int __attribute__((__cdecl__)) iswctype(wint_t, wctype_t);
 int __attribute__((__cdecl__)) is_wctype(wint_t, wctype_t);
 int __attribute__((__cdecl__)) iswdigit(wint_t);
 int __attribute__((__cdecl__)) iswgraph(wint_t);
 int __attribute__((__cdecl__)) iswlower(wint_t);
 int __attribute__((__cdecl__)) iswprint(wint_t);
 int __attribute__((__cdecl__)) iswpunct(wint_t);
 int __attribute__((__cdecl__)) iswspace(wint_t);
 int __attribute__((__cdecl__)) iswupper(wint_t);
 int __attribute__((__cdecl__)) iswxdigit(wint_t);




 wint_t __attribute__((__cdecl__)) towlower (wint_t);
 wint_t __attribute__((__cdecl__)) towupper (wint_t);

 int __attribute__((__cdecl__)) isleadbyte (int);





inline int __attribute__((__cdecl__)) iswalnum(wint_t wc) {return (iswctype(wc,0x0103|0x0004));}
inline int __attribute__((__cdecl__)) iswalpha(wint_t wc) {return (iswctype(wc,0x0103));}
inline int __attribute__((__cdecl__)) iswascii(wint_t wc) {return ((wc & ~0x7F) ==0);}
inline int __attribute__((__cdecl__)) iswcntrl(wint_t wc) {return (iswctype(wc,0x0020));}
inline int __attribute__((__cdecl__)) iswdigit(wint_t wc) {return (iswctype(wc,0x0004));}
inline int __attribute__((__cdecl__)) iswgraph(wint_t wc) {return (iswctype(wc,0x0010|0x0103|0x0004));}
inline int __attribute__((__cdecl__)) iswlower(wint_t wc) {return (iswctype(wc,0x0002));}
inline int __attribute__((__cdecl__)) iswprint(wint_t wc) {return (iswctype(wc,0x0040|0x0010|0x0103|0x0004));}
inline int __attribute__((__cdecl__)) iswpunct(wint_t wc) {return (iswctype(wc,0x0010));}
inline int __attribute__((__cdecl__)) iswspace(wint_t wc) {return (iswctype(wc,0x0008));}
inline int __attribute__((__cdecl__)) iswupper(wint_t wc) {return (iswctype(wc,0x0001));}
inline int __attribute__((__cdecl__)) iswxdigit(wint_t wc) {return (iswctype(wc,0x0080));}
inline int __attribute__((__cdecl__)) isleadbyte(int c) {return (_pctype[(unsigned char)(c)] & 0x8000);}



int __attribute__((__cdecl__)) __isascii (int);
int __attribute__((__cdecl__)) __toascii (int);
int __attribute__((__cdecl__)) __iscsymf (int);
int __attribute__((__cdecl__)) __iscsym (int);


inline int __attribute__((__cdecl__)) __isascii(int c) {return ((c & ~0x7F) == 0);}
inline int __attribute__((__cdecl__)) __toascii(int c) {return (c & 0x7F);}
inline int __attribute__((__cdecl__)) __iscsymf(int c) {return (isalpha(c) || (c == '_'));}
inline int __attribute__((__cdecl__)) __iscsym(int c) {return (isalnum(c) || (c == '_'));}




int __attribute__((__cdecl__)) isascii (int);
int __attribute__((__cdecl__)) toascii (int);
int __attribute__((__cdecl__)) iscsymf (int);
int __attribute__((__cdecl__)) iscsym (int);





}
# 50 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/cctype" 2 3
# 66 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/cctype" 3
namespace std
{
  using ::isalnum;
  using ::isalpha;
  using ::iscntrl;
  using ::isdigit;
  using ::isgraph;
  using ::islower;
  using ::isprint;
  using ::ispunct;
  using ::isspace;
  using ::isupper;
  using ::isxdigit;
  using ::tolower;
  using ::toupper;
}
# 49 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/iosfwd" 2 3
# 1 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stringfwd.h" 1 3
# 42 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stringfwd.h" 3
       
# 43 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stringfwd.h" 3



namespace std
{
  template<typename _Alloc>
    class allocator;

  template<class _CharT>
    struct char_traits;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
           typename _Alloc = allocator<_CharT> >
    class basic_string;

  template<> struct char_traits<char>;

  typedef basic_string<char> string;


  template<> struct char_traits<wchar_t>;

  typedef basic_string<wchar_t> wstring;

}
# 50 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/iosfwd" 2 3
# 1 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/postypes.h" 1 3
# 44 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/postypes.h" 3
       
# 45 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/postypes.h" 3

# 1 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/cwchar" 1 3
# 47 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/cwchar" 3
       
# 48 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/cwchar" 3



# 1 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/ctime" 1 3
# 47 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/ctime" 3
       
# 48 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/ctime" 3



# 1 "H:/CPP/wxdevcpp6.10/include/time.h" 1 3
# 21 "H:/CPP/wxdevcpp6.10/include/time.h" 3
# 1 "H:/CPP/wxdevcpp6.10/lib/gcc/mingw32/3.4.2/include/stddef.h" 1 3
# 22 "H:/CPP/wxdevcpp6.10/include/time.h" 2 3
# 55 "H:/CPP/wxdevcpp6.10/include/time.h" 3
typedef long clock_t;
# 64 "H:/CPP/wxdevcpp6.10/include/time.h" 3
struct tm
{
 int tm_sec;
 int tm_min;
 int tm_hour;
 int tm_mday;
 int tm_mon;
 int tm_year;
 int tm_wday;
 int tm_yday;
 int tm_isdst;

};




extern "C" {


 clock_t __attribute__((__cdecl__)) clock (void);
 time_t __attribute__((__cdecl__)) time (time_t*);
 double __attribute__((__cdecl__)) difftime (time_t, time_t);
 time_t __attribute__((__cdecl__)) mktime (struct tm*);
# 99 "H:/CPP/wxdevcpp6.10/include/time.h" 3
 char* __attribute__((__cdecl__)) asctime (const struct tm*);
 char* __attribute__((__cdecl__)) ctime (const time_t*);
 struct tm* __attribute__((__cdecl__)) gmtime (const time_t*);
 struct tm* __attribute__((__cdecl__)) localtime (const time_t*);

 size_t __attribute__((__cdecl__)) strftime (char*, size_t, const char*, const struct tm*);



extern void __attribute__((__cdecl__)) _tzset (void);


extern void __attribute__((__cdecl__)) tzset (void);


 char* __attribute__((__cdecl__)) _strdate(char*);
 char* __attribute__((__cdecl__)) _strtime(char*);
# 135 "H:/CPP/wxdevcpp6.10/include/time.h" 3
extern int* __attribute__((__cdecl__)) __p__daylight (void);
extern long* __attribute__((__cdecl__)) __p__timezone (void);
extern char** __attribute__((__cdecl__)) __p__tzname (void);

extern __attribute__ ((dllimport)) int _daylight;
extern __attribute__ ((dllimport)) long _timezone;
extern __attribute__ ((dllimport)) char *_tzname[2];
# 173 "H:/CPP/wxdevcpp6.10/include/time.h" 3
extern __attribute__ ((dllimport)) int daylight;
extern __attribute__ ((dllimport)) long timezone;
extern __attribute__ ((dllimport)) char *tzname[2];
# 197 "H:/CPP/wxdevcpp6.10/include/time.h" 3
 wchar_t* __attribute__((__cdecl__)) _wasctime(const struct tm*);
 wchar_t* __attribute__((__cdecl__)) _wctime(const time_t*);
 wchar_t* __attribute__((__cdecl__)) _wstrdate(wchar_t*);
 wchar_t* __attribute__((__cdecl__)) _wstrtime(wchar_t*);





 size_t __attribute__((__cdecl__)) wcsftime (wchar_t*, size_t, const wchar_t*, const struct tm*);




}
# 52 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/ctime" 2 3
# 64 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/ctime" 3
namespace std
{
  using ::clock_t;
  using ::time_t;
  using ::tm;

  using ::clock;
  using ::difftime;
  using ::mktime;
  using ::time;
  using ::asctime;
  using ::ctime;
  using ::gmtime;
  using ::localtime;
  using ::strftime;
}
# 52 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/cwchar" 2 3


# 1 "H:/CPP/wxdevcpp6.10/include/wchar.h" 1 3
# 26 "H:/CPP/wxdevcpp6.10/include/wchar.h" 3
# 1 "H:/CPP/wxdevcpp6.10/lib/gcc/mingw32/3.4.2/include/stddef.h" 1 3
# 27 "H:/CPP/wxdevcpp6.10/include/wchar.h" 2 3
# 45 "H:/CPP/wxdevcpp6.10/include/wchar.h" 3
# 1 "H:/CPP/wxdevcpp6.10/include/wctype.h" 1 3
# 32 "H:/CPP/wxdevcpp6.10/include/wctype.h" 3
# 1 "H:/CPP/wxdevcpp6.10/lib/gcc/mingw32/3.4.2/include/stddef.h" 1 3
# 33 "H:/CPP/wxdevcpp6.10/include/wctype.h" 2 3
# 54 "H:/CPP/wxdevcpp6.10/include/wctype.h" 3
extern "C" {
# 67 "H:/CPP/wxdevcpp6.10/include/wctype.h" 3
 int __attribute__((__cdecl__)) iswalnum(wint_t);
 int __attribute__((__cdecl__)) iswalpha(wint_t);
 int __attribute__((__cdecl__)) iswascii(wint_t);
 int __attribute__((__cdecl__)) iswcntrl(wint_t);
 int __attribute__((__cdecl__)) iswctype(wint_t, wctype_t);
 int __attribute__((__cdecl__)) is_wctype(wint_t, wctype_t);
 int __attribute__((__cdecl__)) iswdigit(wint_t);
 int __attribute__((__cdecl__)) iswgraph(wint_t);
 int __attribute__((__cdecl__)) iswlower(wint_t);
 int __attribute__((__cdecl__)) iswprint(wint_t);
 int __attribute__((__cdecl__)) iswpunct(wint_t);
 int __attribute__((__cdecl__)) iswspace(wint_t);
 int __attribute__((__cdecl__)) iswupper(wint_t);
 int __attribute__((__cdecl__)) iswxdigit(wint_t);




 wint_t __attribute__((__cdecl__)) towlower (wint_t);
 wint_t __attribute__((__cdecl__)) towupper (wint_t);

 int __attribute__((__cdecl__)) isleadbyte (int);




extern __attribute__ ((dllimport)) unsigned short _ctype[];

  extern __attribute__ ((dllimport)) unsigned short* _pctype;
# 133 "H:/CPP/wxdevcpp6.10/include/wctype.h" 3
typedef wchar_t wctrans_t;
# 142 "H:/CPP/wxdevcpp6.10/include/wctype.h" 3
wint_t __attribute__((__cdecl__)) towctrans(wint_t, wctrans_t);
wctrans_t __attribute__((__cdecl__)) wctrans(const char*);
wctype_t __attribute__((__cdecl__)) wctype(const char*);


}
# 46 "H:/CPP/wxdevcpp6.10/include/wchar.h" 2 3
# 63 "H:/CPP/wxdevcpp6.10/include/wchar.h" 3
extern "C" {
# 157 "H:/CPP/wxdevcpp6.10/include/wchar.h" 3
 long __attribute__((__cdecl__)) wcstol (const wchar_t*, wchar_t**, int);
 unsigned long __attribute__((__cdecl__)) wcstoul (const wchar_t*, wchar_t**, int);
 double __attribute__((__cdecl__)) wcstod (const wchar_t*, wchar_t**);

inline float __attribute__((__cdecl__)) wcstof( const wchar_t *nptr, wchar_t **endptr)
{ return (wcstod(nptr, endptr)); }
long double __attribute__((__cdecl__)) wcstold (const wchar_t * __restrict__, wchar_t ** __restrict__);
# 263 "H:/CPP/wxdevcpp6.10/include/wchar.h" 3
typedef wchar_t _Wint_t;


typedef int mbstate_t;

wint_t __attribute__((__cdecl__)) btowc(int);
size_t __attribute__((__cdecl__)) mbrlen(const char * __restrict__, size_t,
        mbstate_t * __restrict__);
size_t __attribute__((__cdecl__)) mbrtowc(wchar_t * __restrict__, const char * __restrict__,
         size_t, mbstate_t * __restrict__);
size_t __attribute__((__cdecl__)) mbsrtowcs(wchar_t * __restrict__, const char ** __restrict__,
    size_t, mbstate_t * __restrict__);
size_t __attribute__((__cdecl__)) wcrtomb(char * __restrict__, wchar_t,
         mbstate_t * __restrict__);
size_t __attribute__((__cdecl__)) wcsrtombs(char * __restrict__, const wchar_t ** __restrict__,
    size_t, mbstate_t * __restrict__);
int __attribute__((__cdecl__)) wctob(wint_t);


inline int __attribute__((__cdecl__)) fwide(FILE* ,
          int )
  {return -1;}
inline int __attribute__((__cdecl__)) mbsinit(const mbstate_t* )
  {return 1;}
wchar_t* __attribute__((__cdecl__)) wmemset(wchar_t *, wchar_t, size_t);
wchar_t* __attribute__((__cdecl__)) wmemchr(const wchar_t*, wchar_t, size_t);
int wmemcmp(const wchar_t*, const wchar_t *, size_t);
wchar_t* __attribute__((__cdecl__)) wmemcpy(wchar_t* __restrict__,
           const wchar_t* __restrict__,
    size_t);
wchar_t* __attribute__((__cdecl__)) wmemmove(wchar_t* s1, const wchar_t *, size_t);
long long __attribute__((__cdecl__)) wcstoll(const wchar_t * __restrict__,
     wchar_t** __restrict__, int);
unsigned long long __attribute__((__cdecl__)) wcstoull(const wchar_t * __restrict__,
       wchar_t ** __restrict__, int);






typedef unsigned long _fsize_t;




struct _wfinddata_t {
 unsigned attrib;
 time_t time_create;
 time_t time_access;
 time_t time_write;
 _fsize_t size;
 wchar_t name[260];
};
struct _wfinddatai64_t {
 unsigned attrib;
 time_t time_create;
 time_t time_access;
 time_t time_write;
 long long size;
 wchar_t name[260];
};
struct __wfinddata64_t {
        unsigned attrib;
        __time64_t time_create;
        __time64_t time_access;
        __time64_t time_write;
        _fsize_t size;
        wchar_t name[260];
};
# 341 "H:/CPP/wxdevcpp6.10/include/wchar.h" 3
# 1 "H:/CPP/wxdevcpp6.10/include/stdint.h" 1 3
# 24 "H:/CPP/wxdevcpp6.10/include/stdint.h" 3
# 1 "H:/CPP/wxdevcpp6.10/lib/gcc/mingw32/3.4.2/include/stddef.h" 1 3
# 25 "H:/CPP/wxdevcpp6.10/include/stdint.h" 2 3


typedef signed char int8_t;
typedef unsigned char uint8_t;
typedef short int16_t;
typedef unsigned short uint16_t;
typedef int int32_t;
typedef unsigned uint32_t;
typedef long long int64_t;
typedef unsigned long long uint64_t;


typedef signed char int_least8_t;
typedef unsigned char uint_least8_t;
typedef short int_least16_t;
typedef unsigned short uint_least16_t;
typedef int int_least32_t;
typedef unsigned uint_least32_t;
typedef long long int_least64_t;
typedef unsigned long long uint_least64_t;





typedef char int_fast8_t;
typedef unsigned char uint_fast8_t;
typedef short int_fast16_t;
typedef unsigned short uint_fast16_t;
typedef int int_fast32_t;
typedef unsigned int uint_fast32_t;
typedef long long int_fast64_t;
typedef unsigned long long uint_fast64_t;


typedef int intptr_t;
typedef unsigned uintptr_t;


typedef long long intmax_t;
typedef unsigned long long uintmax_t;
# 342 "H:/CPP/wxdevcpp6.10/include/wchar.h" 2 3
 int __attribute__((__cdecl__)) _waccess (const wchar_t*, int);
 int __attribute__((__cdecl__)) _wchmod (const wchar_t*, int);
 int __attribute__((__cdecl__)) _wcreat (const wchar_t*, int);
 long __attribute__((__cdecl__)) _wfindfirst (const wchar_t*, struct _wfinddata_t *);
 int __attribute__((__cdecl__)) _wfindnext (long, struct _wfinddata_t *);
 int __attribute__((__cdecl__)) _wunlink (const wchar_t*);
 int __attribute__((__cdecl__)) _wopen (const wchar_t*, int, ...);
 int __attribute__((__cdecl__)) _wsopen (const wchar_t*, int, int, ...);
 wchar_t* __attribute__((__cdecl__)) _wmktemp (wchar_t*);
 long __attribute__((__cdecl__)) _wfindfirsti64 (const wchar_t*, struct _wfinddatai64_t*);
 int __attribute__((__cdecl__)) _wfindnexti64 (long, struct _wfinddatai64_t*);
# 364 "H:/CPP/wxdevcpp6.10/include/wchar.h" 3
 int __attribute__((__cdecl__)) _wchdir (const wchar_t*);
 wchar_t* __attribute__((__cdecl__)) _wgetcwd (wchar_t*, int);
 wchar_t* __attribute__((__cdecl__)) _wgetdcwd (int, wchar_t*, int);
 int __attribute__((__cdecl__)) _wmkdir (const wchar_t*);
 int __attribute__((__cdecl__)) _wrmdir (const wchar_t*);
# 381 "H:/CPP/wxdevcpp6.10/include/wchar.h" 3
struct _stat
{
 _dev_t st_dev;
 _ino_t st_ino;
 _mode_t st_mode;
 short st_nlink;
 short st_uid;
 short st_gid;
 _dev_t st_rdev;
 _off_t st_size;
 time_t st_atime;

 time_t st_mtime;
 time_t st_ctime;
};



struct stat
{
 _dev_t st_dev;
 _ino_t st_ino;
 _mode_t st_mode;
 short st_nlink;
 short st_uid;
 short st_gid;
 _dev_t st_rdev;
 _off_t st_size;
 time_t st_atime;

 time_t st_mtime;
 time_t st_ctime;
};



struct _stati64 {
    _dev_t st_dev;
    _ino_t st_ino;
    unsigned short st_mode;
    short st_nlink;
    short st_uid;
    short st_gid;
    _dev_t st_rdev;
    long long st_size;
    time_t st_atime;
    time_t st_mtime;
    time_t st_ctime;
    };

struct __stat64
{
    _dev_t st_dev;
    _ino_t st_ino;
    _mode_t st_mode;
    short st_nlink;
    short st_uid;
    short st_gid;
    _dev_t st_rdev;
    long long st_size;
    __time64_t st_atime;
    __time64_t st_mtime;
    __time64_t st_ctime;
};







 int __attribute__((__cdecl__)) _wstat (const wchar_t*, struct _stat*);
 int __attribute__((__cdecl__)) _wstati64 (const wchar_t*, struct _stati64*);
# 469 "H:/CPP/wxdevcpp6.10/include/wchar.h" 3
}
# 55 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/cwchar" 2 3
# 69 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/cwchar" 3
namespace std
{
  using ::mbstate_t;
}
# 141 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/cwchar" 3
namespace std
{
  using ::wint_t;

  using ::btowc;
  using ::fgetwc;
  using ::fgetws;
  using ::fputwc;
  using ::fputws;
  using ::fwide;
  using ::fwprintf;
  using ::fwscanf;
  using ::getwc;
  using ::getwchar;
  using ::mbrlen;
  using ::mbrtowc;
  using ::mbsinit;
  using ::mbsrtowcs;
  using ::putwc;
  using ::putwchar;
  using ::swprintf;
  using ::swscanf;
  using ::ungetwc;
  using ::vfwprintf;

  using ::vfwscanf;

  using ::vswprintf;

  using ::vswscanf;

  using ::vwprintf;

  using ::vwscanf;

  using ::wcrtomb;
  using ::wcscat;
  using ::wcscmp;
  using ::wcscoll;
  using ::wcscpy;
  using ::wcscspn;
  using ::wcsftime;
  using ::wcslen;
  using ::wcsncat;
  using ::wcsncmp;
  using ::wcsncpy;
  using ::wcsrtombs;
  using ::wcsspn;
  using ::wcstod;

  using ::wcstof;

  using ::wcstok;
  using ::wcstol;
  using ::wcstoul;
  using ::wcsxfrm;
  using ::wctob;
  using ::wmemcmp;
  using ::wmemcpy;
  using ::wmemmove;
  using ::wmemset;
  using ::wprintf;
  using ::wscanf;

  using ::wcschr;

  inline wchar_t*
  wcschr(wchar_t* __p, wchar_t __c)
  { return wcschr(const_cast<const wchar_t*>(__p), __c); }

  using ::wcspbrk;

  inline wchar_t*
  wcspbrk(wchar_t* __s1, wchar_t* __s2)
  { return wcspbrk(const_cast<const wchar_t*>(__s1), __s2); }

  using ::wcsrchr;

  inline wchar_t*
  wcsrchr(wchar_t* __p, wchar_t __c)
  { return wcsrchr(const_cast<const wchar_t*>(__p), __c); }

  using ::wcsstr;

  inline wchar_t*
  wcsstr(wchar_t* __s1, const wchar_t* __s2)
  { return wcsstr(const_cast<const wchar_t*>(__s1), __s2); }

  using ::wmemchr;

  inline wchar_t*
  wmemchr(wchar_t* __p, wchar_t __c, size_t __n)
  { return wmemchr(const_cast<const wchar_t*>(__p), __c, __n); }
}







namespace __gnu_cxx
{





  using ::wcstold;
# 258 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/cwchar" 3
  using ::wcstoll;
  using ::wcstoull;

}

namespace std
{
  using __gnu_cxx::wcstold;
  using __gnu_cxx::wcstoll;
  using __gnu_cxx::wcstoull;
}
# 47 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/postypes.h" 2 3





namespace std
{
# 72 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/postypes.h" 3
  typedef int64_t streamoff;





  typedef ptrdiff_t streamsize;

  template<typename _StateT>
    class fpos;
# 94 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/postypes.h" 3
  template<typename _StateT>
    class fpos
    {
    private:
      streamoff _M_off;
      _StateT _M_state;

    public:




      fpos()
      : _M_off(0), _M_state() { }
# 116 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/postypes.h" 3
      fpos(streamoff __off)
      : _M_off(__off), _M_state() { }


      operator streamoff() const { return _M_off; }


      void
      state(_StateT __st)
      { _M_state = __st; }


      _StateT
      state() const
      { return _M_state; }






      bool
      operator==(const fpos& __other) const
      { return _M_off == __other._M_off; }


      bool
      operator!=(const fpos& __other) const
      { return _M_off != __other._M_off; }





      fpos&
      operator+=(streamoff __off)
      {
 _M_off += __off;
 return *this;
      }





      fpos&
      operator-=(streamoff __off)
      {
 _M_off -= __off;
 return *this;
      }







      fpos
      operator+(streamoff __off) const
      {
 fpos __pos(*this);
 __pos += __off;
 return __pos;
      }







      fpos
      operator-(streamoff __off) const
      {
 fpos __pos(*this);
 __pos -= __off;
 return __pos;
      }






      streamoff
      operator-(const fpos& __other) const
      { return _M_off - __other._M_off; }
    };





  typedef fpos<mbstate_t> streampos;

  typedef fpos<mbstate_t> wstreampos;
}
# 51 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/iosfwd" 2 3
# 1 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/functexcept.h" 1 3
# 34 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/functexcept.h" 3
# 1 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/exception_defines.h" 1 3
# 35 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/functexcept.h" 2 3

namespace std
{

  void
  __throw_bad_exception(void);


  void
  __throw_bad_alloc(void);


  void
  __throw_bad_cast(void);

  void
  __throw_bad_typeid(void);


  void
  __throw_logic_error(const char* __s);

  void
  __throw_domain_error(const char* __s);

  void
  __throw_invalid_argument(const char* __s);

  void
  __throw_length_error(const char* __s);

  void
  __throw_out_of_range(const char* __s);

  void
  __throw_runtime_error(const char* __s);

  void
  __throw_range_error(const char* __s);

  void
  __throw_overflow_error(const char* __s);

  void
  __throw_underflow_error(const char* __s);


  void
  __throw_ios_failure(const char* __s);
}
# 52 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/iosfwd" 2 3

namespace std
{
  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ios;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_streambuf;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_istream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ostream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_iostream;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
     typename _Alloc = allocator<_CharT> >
    class basic_stringbuf;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
    typename _Alloc = allocator<_CharT> >
    class basic_istringstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
    typename _Alloc = allocator<_CharT> >
    class basic_ostringstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
    typename _Alloc = allocator<_CharT> >
    class basic_stringstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_filebuf;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ifstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ofstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_fstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class istreambuf_iterator;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class ostreambuf_iterator;



  class ios_base;
# 136 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/iosfwd" 3
  typedef basic_ios<char> ios;
  typedef basic_streambuf<char> streambuf;
  typedef basic_istream<char> istream;
  typedef basic_ostream<char> ostream;
  typedef basic_iostream<char> iostream;
  typedef basic_stringbuf<char> stringbuf;
  typedef basic_istringstream<char> istringstream;
  typedef basic_ostringstream<char> ostringstream;
  typedef basic_stringstream<char> stringstream;
  typedef basic_filebuf<char> filebuf;
  typedef basic_ifstream<char> ifstream;
  typedef basic_ofstream<char> ofstream;
  typedef basic_fstream<char> fstream;
# 166 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/iosfwd" 3
}
# 45 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/ios" 2 3
# 1 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/exception" 1 3
# 40 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/exception" 3
extern "C++" {

namespace std
{
# 52 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/exception" 3
  class exception
  {
  public:
    exception() throw() { }
    virtual ~exception() throw();


    virtual const char* what() const throw();
  };



  class bad_exception : public exception
  {
  public:
    bad_exception() throw() { }


    virtual ~bad_exception() throw();
  };


  typedef void (*terminate_handler) ();

  typedef void (*unexpected_handler) ();


  terminate_handler set_terminate(terminate_handler) throw();


  void terminate() __attribute__ ((__noreturn__));


  unexpected_handler set_unexpected(unexpected_handler) throw();


  void unexpected() __attribute__ ((__noreturn__));
# 100 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/exception" 3
  bool uncaught_exception() throw();
}

namespace __gnu_cxx
{
# 115 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/exception" 3
  void __verbose_terminate_handler ();
}

}
# 46 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/ios" 2 3
# 1 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/char_traits.h" 1 3
# 43 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/char_traits.h" 3
       
# 44 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/char_traits.h" 3


# 1 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_algobase.h" 1 3
# 66 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_algobase.h" 3
# 1 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/climits" 1 3
# 47 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/climits" 3
       
# 48 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/climits" 3

# 1 "H:/CPP/wxdevcpp6.10/lib/gcc/mingw32/3.4.2/include/limits.h" 1 3
# 50 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/climits" 2 3
# 67 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_algobase.h" 2 3
# 1 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/cstdlib" 1 3
# 47 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/cstdlib" 3
       
# 48 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/cstdlib" 3




# 1 "H:/CPP/wxdevcpp6.10/include/stdlib.h" 1 3
# 22 "H:/CPP/wxdevcpp6.10/include/stdlib.h" 3
# 1 "H:/CPP/wxdevcpp6.10/lib/gcc/mingw32/3.4.2/include/stddef.h" 1 3
# 23 "H:/CPP/wxdevcpp6.10/include/stdlib.h" 2 3
# 61 "H:/CPP/wxdevcpp6.10/include/stdlib.h" 3
extern "C" {
# 72 "H:/CPP/wxdevcpp6.10/include/stdlib.h" 3
extern int _argc;
extern char** _argv;




extern int* __attribute__((__cdecl__)) __p___argc(void);
extern char*** __attribute__((__cdecl__)) __p___argv(void);
extern wchar_t*** __attribute__((__cdecl__)) __p___wargv(void);
# 138 "H:/CPP/wxdevcpp6.10/include/stdlib.h" 3
 int* __attribute__((__cdecl__)) _errno(void);


 int* __attribute__((__cdecl__)) __doserrno(void);
# 150 "H:/CPP/wxdevcpp6.10/include/stdlib.h" 3
  extern char *** __attribute__((__cdecl__)) __p__environ(void);
  extern wchar_t *** __attribute__((__cdecl__)) __p__wenviron(void);
# 173 "H:/CPP/wxdevcpp6.10/include/stdlib.h" 3
  extern __attribute__ ((dllimport)) int _sys_nerr;
# 197 "H:/CPP/wxdevcpp6.10/include/stdlib.h" 3
extern __attribute__ ((dllimport)) char* _sys_errlist[];
# 210 "H:/CPP/wxdevcpp6.10/include/stdlib.h" 3
extern unsigned __attribute__((__cdecl__)) int* __p__osver(void);
extern unsigned __attribute__((__cdecl__)) int* __p__winver(void);
extern unsigned __attribute__((__cdecl__)) int* __p__winmajor(void);
extern unsigned __attribute__((__cdecl__)) int* __p__winminor(void);







extern __attribute__ ((dllimport)) unsigned int _osver;
extern __attribute__ ((dllimport)) unsigned int _winver;
extern __attribute__ ((dllimport)) unsigned int _winmajor;
extern __attribute__ ((dllimport)) unsigned int _winminor;
# 261 "H:/CPP/wxdevcpp6.10/include/stdlib.h" 3
 char** __attribute__((__cdecl__)) __p__pgmptr(void);

 wchar_t** __attribute__((__cdecl__)) __p__wpgmptr(void);
# 294 "H:/CPP/wxdevcpp6.10/include/stdlib.h" 3
extern __attribute__ ((dllimport)) int _fmode;
# 304 "H:/CPP/wxdevcpp6.10/include/stdlib.h" 3
 double __attribute__((__cdecl__)) atof (const char*);
 int __attribute__((__cdecl__)) atoi (const char*);
 long __attribute__((__cdecl__)) atol (const char*);

 int __attribute__((__cdecl__)) _wtoi (const wchar_t *);
 long __attribute__((__cdecl__)) _wtol (const wchar_t *);

 double __attribute__((__cdecl__)) strtod (const char*, char**);

float __attribute__((__cdecl__)) strtof (const char *, char **);
inline float __attribute__((__cdecl__)) strtof (const char *__nptr, char **__endptr)
  { return (strtod (__nptr, __endptr));}
long double __attribute__((__cdecl__)) strtold (const char * __restrict__, char ** __restrict__);


 long __attribute__((__cdecl__)) strtol (const char*, char**, int);
 unsigned long __attribute__((__cdecl__)) strtoul (const char*, char**, int);
# 337 "H:/CPP/wxdevcpp6.10/include/stdlib.h" 3
 size_t __attribute__((__cdecl__)) wcstombs (char*, const wchar_t*, size_t);
 int __attribute__((__cdecl__)) wctomb (char*, wchar_t);

 int __attribute__((__cdecl__)) mblen (const char*, size_t);
 size_t __attribute__((__cdecl__)) mbstowcs (wchar_t*, const char*, size_t);
 int __attribute__((__cdecl__)) mbtowc (wchar_t*, const char*, size_t);

 int __attribute__((__cdecl__)) rand (void);
 void __attribute__((__cdecl__)) srand (unsigned int);

 void* __attribute__((__cdecl__)) calloc (size_t, size_t) __attribute__ ((__malloc__));
 void* __attribute__((__cdecl__)) malloc (size_t) __attribute__ ((__malloc__));
 void* __attribute__((__cdecl__)) realloc (void*, size_t);
 void __attribute__((__cdecl__)) free (void*);

 void __attribute__((__cdecl__)) abort (void) __attribute__ ((__noreturn__));
 void __attribute__((__cdecl__)) exit (int) __attribute__ ((__noreturn__));


int __attribute__((__cdecl__)) atexit (void (*)(void));

 int __attribute__((__cdecl__)) system (const char*);
 char* __attribute__((__cdecl__)) getenv (const char*);


 void* __attribute__((__cdecl__)) bsearch (const void*, const void*, size_t, size_t,
     int (*)(const void*, const void*));
 void __attribute__((__cdecl__)) qsort (void*, size_t, size_t,
     int (*)(const void*, const void*));

 int __attribute__((__cdecl__)) abs (int) __attribute__ ((__const__));
 long __attribute__((__cdecl__)) labs (long) __attribute__ ((__const__));
# 378 "H:/CPP/wxdevcpp6.10/include/stdlib.h" 3
typedef struct { int quot, rem; } div_t;
typedef struct { long quot, rem; } ldiv_t;

 div_t __attribute__((__cdecl__)) div (int, int) __attribute__ ((__const__));
 ldiv_t __attribute__((__cdecl__)) ldiv (long, long) __attribute__ ((__const__));







 void __attribute__((__cdecl__)) _beep (unsigned int, unsigned int);
 void __attribute__((__cdecl__)) _seterrormode (int);
 void __attribute__((__cdecl__)) _sleep (unsigned long);

 void __attribute__((__cdecl__)) _exit (int) __attribute__ ((__noreturn__));



typedef int (* _onexit_t)(void);
_onexit_t __attribute__((__cdecl__)) _onexit( _onexit_t );

 int __attribute__((__cdecl__)) _putenv (const char*);
 void __attribute__((__cdecl__)) _searchenv (const char*, const char*, char*);


 char* __attribute__((__cdecl__)) _ecvt (double, int, int*, int*);
 char* __attribute__((__cdecl__)) _fcvt (double, int, int*, int*);
 char* __attribute__((__cdecl__)) _gcvt (double, int, char*);

 void __attribute__((__cdecl__)) _makepath (char*, const char*, const char*, const char*, const char*);
 void __attribute__((__cdecl__)) _splitpath (const char*, char*, char*, char*, char*);
 char* __attribute__((__cdecl__)) _fullpath (char*, const char*, size_t);

 char* __attribute__((__cdecl__)) _itoa (int, char*, int);
 char* __attribute__((__cdecl__)) _ltoa (long, char*, int);
 char* __attribute__((__cdecl__)) _ultoa(unsigned long, char*, int);
 wchar_t* __attribute__((__cdecl__)) _itow (int, wchar_t*, int);
 wchar_t* __attribute__((__cdecl__)) _ltow (long, wchar_t*, int);
 wchar_t* __attribute__((__cdecl__)) _ultow (unsigned long, wchar_t*, int);


 long long __attribute__((__cdecl__)) _atoi64(const char *);
 char* __attribute__((__cdecl__)) _i64toa(long long, char *, int);
 char* __attribute__((__cdecl__)) _ui64toa(unsigned long long, char *, int);
 long long __attribute__((__cdecl__)) _wtoi64(const wchar_t *);
 wchar_t* __attribute__((__cdecl__)) _i64tow(long long, wchar_t *, int);
 wchar_t* __attribute__((__cdecl__)) _ui64tow(unsigned long long, wchar_t *, int);

 wchar_t* __attribute__((__cdecl__)) _wgetenv(const wchar_t*);
 int __attribute__((__cdecl__)) _wputenv(const wchar_t*);
 void __attribute__((__cdecl__)) _wsearchenv(const wchar_t*, const wchar_t*, wchar_t*);
 void __attribute__((__cdecl__)) _wmakepath(wchar_t*, const wchar_t*, const wchar_t*, const wchar_t*, const wchar_t*);
 void __attribute__((__cdecl__)) _wsplitpath (const wchar_t*, wchar_t*, wchar_t*, wchar_t*, wchar_t*);
 wchar_t* __attribute__((__cdecl__)) _wfullpath (wchar_t*, const wchar_t*, size_t);

 unsigned int __attribute__((__cdecl__)) _rotl(unsigned int, int) __attribute__ ((__const__));
 unsigned int __attribute__((__cdecl__)) _rotr(unsigned int, int) __attribute__ ((__const__));
 unsigned long __attribute__((__cdecl__)) _lrotl(unsigned long, int) __attribute__ ((__const__));
 unsigned long __attribute__((__cdecl__)) _lrotr(unsigned long, int) __attribute__ ((__const__));

 int __attribute__((__cdecl__)) _set_error_mode (int);
# 450 "H:/CPP/wxdevcpp6.10/include/stdlib.h" 3
 int __attribute__((__cdecl__)) putenv (const char*);
 void __attribute__((__cdecl__)) searchenv (const char*, const char*, char*);

 char* __attribute__((__cdecl__)) itoa (int, char*, int);
 char* __attribute__((__cdecl__)) ltoa (long, char*, int);


 char* __attribute__((__cdecl__)) ecvt (double, int, int*, int*);
 char* __attribute__((__cdecl__)) fcvt (double, int, int*, int*);
 char* __attribute__((__cdecl__)) gcvt (double, int, char*);
# 470 "H:/CPP/wxdevcpp6.10/include/stdlib.h" 3
void __attribute__((__cdecl__)) _Exit(int) __attribute__ ((__noreturn__));

inline void __attribute__((__cdecl__)) _Exit(int __status)
 { _exit (__status); }


typedef struct { long long quot, rem; } lldiv_t;

lldiv_t __attribute__((__cdecl__)) lldiv (long long, long long) __attribute__ ((__const__));

long long __attribute__((__cdecl__)) llabs(long long);
inline long long __attribute__((__cdecl__)) llabs(long long _j)
  {return (_j >= 0 ? _j : -_j);}

long long __attribute__((__cdecl__)) strtoll (const char* __restrict__, char** __restrict, int);
unsigned long long __attribute__((__cdecl__)) strtoull (const char* __restrict__, char** __restrict__, int);


long long __attribute__((__cdecl__)) atoll (const char *);


long long __attribute__((__cdecl__)) wtoll (const wchar_t *);
char* __attribute__((__cdecl__)) lltoa (long long, char *, int);
char* __attribute__((__cdecl__)) ulltoa (unsigned long long , char *, int);
wchar_t* __attribute__((__cdecl__)) lltow (long long, wchar_t *, int);
wchar_t* __attribute__((__cdecl__)) ulltow (unsigned long long, wchar_t *, int);


inline long long __attribute__((__cdecl__)) atoll (const char * _c)
 { return _atoi64 (_c); }
inline char* __attribute__((__cdecl__)) lltoa (long long _n, char * _c, int _i)
 { return _i64toa (_n, _c, _i); }
inline char* __attribute__((__cdecl__)) ulltoa (unsigned long long _n, char * _c, int _i)
 { return _ui64toa (_n, _c, _i); }
inline long long __attribute__((__cdecl__)) wtoll (const wchar_t * _w)
  { return _wtoi64 (_w); }
inline wchar_t* __attribute__((__cdecl__)) lltow (long long _n, wchar_t * _w, int _i)
 { return _i64tow (_n, _w, _i); }
inline wchar_t* __attribute__((__cdecl__)) ulltow (unsigned long long _n, wchar_t * _w, int _i)
 { return _ui64tow (_n, _w, _i); }
# 518 "H:/CPP/wxdevcpp6.10/include/stdlib.h" 3
}
# 53 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/cstdlib" 2 3
# 84 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/cstdlib" 3
namespace std
{
  using ::div_t;
  using ::ldiv_t;

  using ::abort;
  using ::abs;
  using ::atexit;
  using ::atof;
  using ::atoi;
  using ::atol;
  using ::bsearch;
  using ::calloc;
  using ::div;
  using ::exit;
  using ::free;
  using ::getenv;
  using ::labs;
  using ::ldiv;
  using ::malloc;

  using ::mblen;
  using ::mbstowcs;
  using ::mbtowc;

  using ::qsort;
  using ::rand;
  using ::realloc;
  using ::srand;
  using ::strtod;
  using ::strtol;
  using ::strtoul;
  using ::system;





  inline long
  abs(long __i) { return labs(__i); }

  inline ldiv_t
  div(long __i, long __j) { return ldiv(__i, __j); }
}
# 140 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/cstdlib" 3
namespace __gnu_cxx
{

  using ::lldiv_t;





  using ::_Exit;


  inline long long
  abs(long long __x) { return __x >= 0 ? __x : -__x; }

  inline long long
  llabs(long long __x) { return __x >= 0 ? __x : -__x; }


  inline lldiv_t
  div(long long __n, long long __d)
  { lldiv_t __q; __q.quot = __n / __d; __q.rem = __n % __d; return __q; }

  inline lldiv_t
  lldiv(long long __n, long long __d)
  { lldiv_t __q; __q.quot = __n / __d; __q.rem = __n % __d; return __q; }
# 176 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/cstdlib" 3
  using ::atoll;
  using ::strtoll;
  using ::strtoull;

  using ::strtof;
  using ::strtold;
}

namespace std
{

  using __gnu_cxx::lldiv_t;

  using __gnu_cxx::_Exit;
  using __gnu_cxx::abs;
  using __gnu_cxx::llabs;

  using __gnu_cxx::div;
  using __gnu_cxx::lldiv;

  using __gnu_cxx::atoll;
  using __gnu_cxx::strtof;
  using __gnu_cxx::strtoll;
  using __gnu_cxx::strtoull;
  using __gnu_cxx::strtold;
}
# 68 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_algobase.h" 2 3

# 1 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/new" 1 3
# 44 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/new" 3
extern "C++" {

namespace std
{





  class bad_alloc : public exception
  {
  public:
    bad_alloc() throw() { }


    virtual ~bad_alloc() throw();
  };

  struct nothrow_t { };
  extern const nothrow_t nothrow;


  typedef void (*new_handler)();

  new_handler set_new_handler(new_handler) throw();
}
# 82 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/new" 3
void* operator new(std::size_t) throw (std::bad_alloc);
void* operator new[](std::size_t) throw (std::bad_alloc);
void operator delete(void*) throw();
void operator delete[](void*) throw();
void* operator new(std::size_t, const std::nothrow_t&) throw();
void* operator new[](std::size_t, const std::nothrow_t&) throw();
void operator delete(void*, const std::nothrow_t&) throw();
void operator delete[](void*, const std::nothrow_t&) throw();


inline void* operator new(std::size_t, void* __p) throw() { return __p; }
inline void* operator new[](std::size_t, void* __p) throw() { return __p; }


inline void operator delete (void*, void*) throw() { }
inline void operator delete[](void*, void*) throw() { }

}
# 70 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_algobase.h" 2 3

# 1 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_pair.h" 1 3
# 64 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_pair.h" 3
namespace std
{

  template<class _T1, class _T2>
    struct pair
    {
      typedef _T1 first_type;
      typedef _T2 second_type;

      _T1 first;
      _T2 second;





      pair()
      : first(), second() { }


      pair(const _T1& __a, const _T2& __b)
      : first(__a), second(__b) { }


      template<class _U1, class _U2>
        pair(const pair<_U1, _U2>& __p)
 : first(__p.first), second(__p.second) { }
    };


  template<class _T1, class _T2>
    inline bool
    operator==(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __x.first == __y.first && __x.second == __y.second; }


  template<class _T1, class _T2>
    inline bool
    operator<(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __x.first < __y.first
      || (!(__y.first < __x.first) && __x.second < __y.second); }


  template<class _T1, class _T2>
    inline bool
    operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return !(__x == __y); }


  template<class _T1, class _T2>
    inline bool
    operator>(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __y < __x; }


  template<class _T1, class _T2>
    inline bool
    operator<=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return !(__y < __x); }


  template<class _T1, class _T2>
    inline bool
    operator>=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return !(__x < __y); }
# 142 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_pair.h" 3
  template<class _T1, class _T2>
    inline pair<_T1, _T2>
    make_pair(_T1 __x, _T2 __y) { return pair<_T1, _T2>(__x, __y); }
}
# 72 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_algobase.h" 2 3
# 1 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/type_traits.h" 1 3
# 52 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/type_traits.h" 3
       
# 53 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/type_traits.h" 3
# 90 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/type_traits.h" 3
struct __true_type {};
struct __false_type {};

template <class _Tp>
  struct __type_traits
  {
    typedef __true_type this_dummy_member_must_be_first;
# 114 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/type_traits.h" 3
    typedef __false_type has_trivial_default_constructor;
    typedef __false_type has_trivial_copy_constructor;
    typedef __false_type has_trivial_assignment_operator;
    typedef __false_type has_trivial_destructor;
    typedef __false_type is_POD_type;
  };




template<>
  struct __type_traits<bool>
  {
    typedef __true_type has_trivial_default_constructor;
    typedef __true_type has_trivial_copy_constructor;
    typedef __true_type has_trivial_assignment_operator;
    typedef __true_type has_trivial_destructor;
    typedef __true_type is_POD_type;
  };

template<>
  struct __type_traits<char>
  {
    typedef __true_type has_trivial_default_constructor;
    typedef __true_type has_trivial_copy_constructor;
    typedef __true_type has_trivial_assignment_operator;
    typedef __true_type has_trivial_destructor;
    typedef __true_type is_POD_type;
  };

template<>
  struct __type_traits<signed char>
  {
    typedef __true_type has_trivial_default_constructor;
    typedef __true_type has_trivial_copy_constructor;
    typedef __true_type has_trivial_assignment_operator;
    typedef __true_type has_trivial_destructor;
    typedef __true_type is_POD_type;
  };

template<>
  struct __type_traits<unsigned char>
  {
    typedef __true_type has_trivial_default_constructor;
    typedef __true_type has_trivial_copy_constructor;
    typedef __true_type has_trivial_assignment_operator;
    typedef __true_type has_trivial_destructor;
    typedef __true_type is_POD_type;
  };

template<>
  struct __type_traits<wchar_t>
  {
    typedef __true_type has_trivial_default_constructor;
    typedef __true_type has_trivial_copy_constructor;
    typedef __true_type has_trivial_assignment_operator;
    typedef __true_type has_trivial_destructor;
    typedef __true_type is_POD_type;
  };

template<>
  struct __type_traits<short>
  {
    typedef __true_type has_trivial_default_constructor;
    typedef __true_type has_trivial_copy_constructor;
    typedef __true_type has_trivial_assignment_operator;
    typedef __true_type has_trivial_destructor;
    typedef __true_type is_POD_type;
  };

template<>
  struct __type_traits<unsigned short>
  {
    typedef __true_type has_trivial_default_constructor;
    typedef __true_type has_trivial_copy_constructor;
    typedef __true_type has_trivial_assignment_operator;
    typedef __true_type has_trivial_destructor;
    typedef __true_type is_POD_type;
  };

template<>
  struct __type_traits<int>
  {
    typedef __true_type has_trivial_default_constructor;
    typedef __true_type has_trivial_copy_constructor;
    typedef __true_type has_trivial_assignment_operator;
    typedef __true_type has_trivial_destructor;
    typedef __true_type is_POD_type;
  };

template<>
  struct __type_traits<unsigned int>
  {
    typedef __true_type has_trivial_default_constructor;
    typedef __true_type has_trivial_copy_constructor;
    typedef __true_type has_trivial_assignment_operator;
    typedef __true_type has_trivial_destructor;
    typedef __true_type is_POD_type;
  };

template<>
  struct __type_traits<long>
  {
    typedef __true_type has_trivial_default_constructor;
    typedef __true_type has_trivial_copy_constructor;
    typedef __true_type has_trivial_assignment_operator;
    typedef __true_type has_trivial_destructor;
    typedef __true_type is_POD_type;
  };

template<>
  struct __type_traits<unsigned long>
  {
    typedef __true_type has_trivial_default_constructor;
    typedef __true_type has_trivial_copy_constructor;
    typedef __true_type has_trivial_assignment_operator;
    typedef __true_type has_trivial_destructor;
    typedef __true_type is_POD_type;
  };

template<>
  struct __type_traits<long long>
  {
    typedef __true_type has_trivial_default_constructor;
    typedef __true_type has_trivial_copy_constructor;
    typedef __true_type has_trivial_assignment_operator;
    typedef __true_type has_trivial_destructor;
    typedef __true_type is_POD_type;
  };

template<>
  struct __type_traits<unsigned long long>
  {
    typedef __true_type has_trivial_default_constructor;
    typedef __true_type has_trivial_copy_constructor;
    typedef __true_type has_trivial_assignment_operator;
    typedef __true_type has_trivial_destructor;
    typedef __true_type is_POD_type;
  };

template<>
  struct __type_traits<float>
  {
    typedef __true_type has_trivial_default_constructor;
    typedef __true_type has_trivial_copy_constructor;
    typedef __true_type has_trivial_assignment_operator;
    typedef __true_type has_trivial_destructor;
    typedef __true_type is_POD_type;
  };

template<>
  struct __type_traits<double>
  {
    typedef __true_type has_trivial_default_constructor;
    typedef __true_type has_trivial_copy_constructor;
    typedef __true_type has_trivial_assignment_operator;
    typedef __true_type has_trivial_destructor;
    typedef __true_type is_POD_type;
  };

template<>
  struct __type_traits<long double>
  {
    typedef __true_type has_trivial_default_constructor;
    typedef __true_type has_trivial_copy_constructor;
    typedef __true_type has_trivial_assignment_operator;
    typedef __true_type has_trivial_destructor;
    typedef __true_type is_POD_type;
  };

template <class _Tp>
  struct __type_traits<_Tp*>
  {
    typedef __true_type has_trivial_default_constructor;
    typedef __true_type has_trivial_copy_constructor;
    typedef __true_type has_trivial_assignment_operator;
    typedef __true_type has_trivial_destructor;
    typedef __true_type is_POD_type;
  };




template <class _Tp>
  struct _Is_integer
  {
    typedef __false_type _Integral;
  };

template<>
  struct _Is_integer<bool>
  {
    typedef __true_type _Integral;
  };

template<>
  struct _Is_integer<char>
  {
    typedef __true_type _Integral;
  };

template<>
  struct _Is_integer<signed char>
  {
    typedef __true_type _Integral;
  };

template<>
  struct _Is_integer<unsigned char>
  {
    typedef __true_type _Integral;
  };

template<>
  struct _Is_integer<wchar_t>
  {
    typedef __true_type _Integral;
  };

template<>
  struct _Is_integer<short>
  {
    typedef __true_type _Integral;
  };

template<>
  struct _Is_integer<unsigned short>
  {
    typedef __true_type _Integral;
  };

template<>
  struct _Is_integer<int>
  {
    typedef __true_type _Integral;
  };

template<>
  struct _Is_integer<unsigned int>
  {
    typedef __true_type _Integral;
  };

template<>
  struct _Is_integer<long>
  {
    typedef __true_type _Integral;
  };

template<>
  struct _Is_integer<unsigned long>
  {
    typedef __true_type _Integral;
  };

template<>
  struct _Is_integer<long long>
  {
    typedef __true_type _Integral;
  };

template<>
  struct _Is_integer<unsigned long long>
  {
    typedef __true_type _Integral;
  };

template<typename _Tp>
  struct _Is_normal_iterator
  {
    typedef __false_type _Normal;
  };


namespace __gnu_cxx
{
  template<typename _Iterator, typename _Container>
    class __normal_iterator;
}

template<typename _Iterator, typename _Container>
  struct _Is_normal_iterator< __gnu_cxx::__normal_iterator<_Iterator,
          _Container> >
  {
    typedef __true_type _Normal;
  };
# 73 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_algobase.h" 2 3
# 1 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_iterator_base_types.h" 1 3
# 67 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_iterator_base_types.h" 3
       
# 68 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_iterator_base_types.h" 3

namespace std
{
# 80 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_iterator_base_types.h" 3
  struct input_iterator_tag {};

  struct output_iterator_tag {};

  struct forward_iterator_tag : public input_iterator_tag {};


  struct bidirectional_iterator_tag : public forward_iterator_tag {};


  struct random_access_iterator_tag : public bidirectional_iterator_tag {};
# 104 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_iterator_base_types.h" 3
  template<typename _Category, typename _Tp, typename _Distance = ptrdiff_t,
           typename _Pointer = _Tp*, typename _Reference = _Tp&>
    struct iterator
    {

      typedef _Category iterator_category;

      typedef _Tp value_type;

      typedef _Distance difference_type;

      typedef _Pointer pointer;

      typedef _Reference reference;
    };







  template<typename _Iterator>
    struct iterator_traits
    {
      typedef typename _Iterator::iterator_category iterator_category;
      typedef typename _Iterator::value_type value_type;
      typedef typename _Iterator::difference_type difference_type;
      typedef typename _Iterator::pointer pointer;
      typedef typename _Iterator::reference reference;
    };

  template<typename _Tp>
    struct iterator_traits<_Tp*>
    {
      typedef random_access_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef ptrdiff_t difference_type;
      typedef _Tp* pointer;
      typedef _Tp& reference;
    };

  template<typename _Tp>
    struct iterator_traits<const _Tp*>
    {
      typedef random_access_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef ptrdiff_t difference_type;
      typedef const _Tp* pointer;
      typedef const _Tp& reference;
    };







  template<typename _Iter>
    inline typename iterator_traits<_Iter>::iterator_category
    __iterator_category(const _Iter&)
    { return typename iterator_traits<_Iter>::iterator_category(); }

}
# 74 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_algobase.h" 2 3
# 1 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_iterator_base_funcs.h" 1 3
# 67 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_iterator_base_funcs.h" 3
       
# 68 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_iterator_base_funcs.h" 3
# 1 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/concept_check.h" 1 3
# 38 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/concept_check.h" 3
       
# 39 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/concept_check.h" 3
# 69 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_iterator_base_funcs.h" 2 3

namespace std
{
  template<typename _InputIterator>
    inline typename iterator_traits<_InputIterator>::difference_type
    __distance(_InputIterator __first, _InputIterator __last,
               input_iterator_tag)
    {

     

      typename iterator_traits<_InputIterator>::difference_type __n = 0;
      while (__first != __last)
 {
   ++__first;
   ++__n;
 }
      return __n;
    }

  template<typename _RandomAccessIterator>
    inline typename iterator_traits<_RandomAccessIterator>::difference_type
    __distance(_RandomAccessIterator __first, _RandomAccessIterator __last,
               random_access_iterator_tag)
    {

     

      return __last - __first;
    }
# 112 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_iterator_base_funcs.h" 3
  template<typename _InputIterator>
    inline typename iterator_traits<_InputIterator>::difference_type
    distance(_InputIterator __first, _InputIterator __last)
    {

      return std::__distance(__first, __last,
        std::__iterator_category(__first));
    }

  template<typename _InputIterator, typename _Distance>
    inline void
    __advance(_InputIterator& __i, _Distance __n, input_iterator_tag)
    {

     
      while (__n--)
 ++__i;
    }

  template<typename _BidirectionalIterator, typename _Distance>
    inline void
    __advance(_BidirectionalIterator& __i, _Distance __n,
              bidirectional_iterator_tag)
    {

     

      if (__n > 0)
        while (__n--)
   ++__i;
      else
        while (__n++)
   --__i;
    }

  template<typename _RandomAccessIterator, typename _Distance>
    inline void
    __advance(_RandomAccessIterator& __i, _Distance __n,
              random_access_iterator_tag)
    {

     

      __i += __n;
    }
# 170 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_iterator_base_funcs.h" 3
  template<typename _InputIterator, typename _Distance>
    inline void
    advance(_InputIterator& __i, _Distance __n)
    {

      std::__advance(__i, __n, std::__iterator_category(__i));
    }
}
# 75 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_algobase.h" 2 3
# 1 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_iterator.h" 1 3
# 68 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_iterator.h" 3
namespace std
{
# 89 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_iterator.h" 3
  template<typename _Iterator>
    class reverse_iterator
    : public iterator<typename iterator_traits<_Iterator>::iterator_category,
        typename iterator_traits<_Iterator>::value_type,
        typename iterator_traits<_Iterator>::difference_type,
        typename iterator_traits<_Iterator>::pointer,
                      typename iterator_traits<_Iterator>::reference>
    {
    protected:
      _Iterator current;

    public:
      typedef _Iterator iterator_type;
      typedef typename iterator_traits<_Iterator>::difference_type
              difference_type;
      typedef typename iterator_traits<_Iterator>::reference reference;
      typedef typename iterator_traits<_Iterator>::pointer pointer;

    public:






      reverse_iterator() : current() { }




      explicit
      reverse_iterator(iterator_type __x) : current(__x) { }




      reverse_iterator(const reverse_iterator& __x)
      : current(__x.current) { }





      template<typename _Iter>
        reverse_iterator(const reverse_iterator<_Iter>& __x)
 : current(__x.base()) { }




      iterator_type
      base() const
      { return current; }






      reference
      operator*() const
      {
 _Iterator __tmp = current;
 return *--__tmp;
      }






      pointer
      operator->() const
      { return &(operator*()); }






      reverse_iterator&
      operator++()
      {
 --current;
 return *this;
      }






      reverse_iterator
      operator++(int)
      {
 reverse_iterator __tmp = *this;
 --current;
 return __tmp;
      }






      reverse_iterator&
      operator--()
      {
 ++current;
 return *this;
      }






      reverse_iterator operator--(int)
      {
 reverse_iterator __tmp = *this;
 ++current;
 return __tmp;
      }






      reverse_iterator
      operator+(difference_type __n) const
      { return reverse_iterator(current - __n); }






      reverse_iterator&
      operator+=(difference_type __n)
      {
 current -= __n;
 return *this;
      }






      reverse_iterator
      operator-(difference_type __n) const
      { return reverse_iterator(current + __n); }






      reverse_iterator&
      operator-=(difference_type __n)
      {
 current += __n;
 return *this;
      }






      reference
      operator[](difference_type __n) const
      { return *(*this + __n); }
    };
# 275 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_iterator.h" 3
  template<typename _Iterator>
    inline bool
    operator==(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return __x.base() == __y.base(); }

  template<typename _Iterator>
    inline bool
    operator<(const reverse_iterator<_Iterator>& __x,
       const reverse_iterator<_Iterator>& __y)
    { return __y.base() < __x.base(); }

  template<typename _Iterator>
    inline bool
    operator!=(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return !(__x == __y); }

  template<typename _Iterator>
    inline bool
    operator>(const reverse_iterator<_Iterator>& __x,
       const reverse_iterator<_Iterator>& __y)
    { return __y < __x; }

  template<typename _Iterator>
    inline bool
    operator<=(const reverse_iterator<_Iterator>& __x,
  const reverse_iterator<_Iterator>& __y)
    { return !(__y < __x); }

  template<typename _Iterator>
    inline bool
    operator>=(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return !(__x < __y); }

  template<typename _Iterator>
    inline typename reverse_iterator<_Iterator>::difference_type
    operator-(const reverse_iterator<_Iterator>& __x,
       const reverse_iterator<_Iterator>& __y)
    { return __y.base() - __x.base(); }

  template<typename _Iterator>
    inline reverse_iterator<_Iterator>
    operator+(typename reverse_iterator<_Iterator>::difference_type __n,
       const reverse_iterator<_Iterator>& __x)
    { return reverse_iterator<_Iterator>(__x.base() - __n); }
# 335 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_iterator.h" 3
  template<typename _Container>
    class back_insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;

    public:

      typedef _Container container_type;


      explicit
      back_insert_iterator(_Container& __x) : container(&__x) { }
# 361 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_iterator.h" 3
      back_insert_iterator&
      operator=(typename _Container::const_reference __value)
      {
 container->push_back(__value);
 return *this;
      }


      back_insert_iterator&
      operator*()
      { return *this; }


      back_insert_iterator&
      operator++()
      { return *this; }


      back_insert_iterator
      operator++(int)
      { return *this; }
    };
# 395 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_iterator.h" 3
  template<typename _Container>
    inline back_insert_iterator<_Container>
    back_inserter(_Container& __x)
    { return back_insert_iterator<_Container>(__x); }
# 410 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_iterator.h" 3
  template<typename _Container>
    class front_insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;

    public:

      typedef _Container container_type;


      explicit front_insert_iterator(_Container& __x) : container(&__x) { }
# 435 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_iterator.h" 3
      front_insert_iterator&
      operator=(typename _Container::const_reference __value)
      {
 container->push_front(__value);
 return *this;
      }


      front_insert_iterator&
      operator*()
      { return *this; }


      front_insert_iterator&
      operator++()
      { return *this; }


      front_insert_iterator
      operator++(int)
      { return *this; }
    };
# 469 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_iterator.h" 3
  template<typename _Container>
    inline front_insert_iterator<_Container>
    front_inserter(_Container& __x)
    { return front_insert_iterator<_Container>(__x); }
# 488 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_iterator.h" 3
  template<typename _Container>
    class insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;
      typename _Container::iterator iter;

    public:

      typedef _Container container_type;





      insert_iterator(_Container& __x, typename _Container::iterator __i)
      : container(&__x), iter(__i) {}
# 530 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_iterator.h" 3
      insert_iterator&
      operator=(const typename _Container::const_reference __value)
      {
 iter = container->insert(iter, __value);
 ++iter;
 return *this;
      }


      insert_iterator&
      operator*()
      { return *this; }


      insert_iterator&
      operator++()
      { return *this; }


      insert_iterator&
      operator++(int)
      { return *this; }
    };
# 565 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_iterator.h" 3
  template<typename _Container, typename _Iterator>
    inline insert_iterator<_Container>
    inserter(_Container& __x, _Iterator __i)
    {
      return insert_iterator<_Container>(__x,
      typename _Container::iterator(__i));
    }
}

namespace __gnu_cxx
{







  using std::iterator_traits;
  using std::iterator;
  template<typename _Iterator, typename _Container>
    class __normal_iterator
    {
    protected:
      _Iterator _M_current;

    public:
      typedef typename iterator_traits<_Iterator>::iterator_category
                                                             iterator_category;
      typedef typename iterator_traits<_Iterator>::value_type value_type;
      typedef typename iterator_traits<_Iterator>::difference_type
                                                             difference_type;
      typedef typename iterator_traits<_Iterator>::reference reference;
      typedef typename iterator_traits<_Iterator>::pointer pointer;

      __normal_iterator() : _M_current(_Iterator()) { }

      explicit
      __normal_iterator(const _Iterator& __i) : _M_current(__i) { }


      template<typename _Iter>
        inline __normal_iterator(const __normal_iterator<_Iter,
     _Container>& __i)
 : _M_current(__i.base()) { }


      reference
      operator*() const
      { return *_M_current; }

      pointer
      operator->() const
      { return _M_current; }

      __normal_iterator&
      operator++()
      {
 ++_M_current;
 return *this;
      }

      __normal_iterator
      operator++(int)
      { return __normal_iterator(_M_current++); }


      __normal_iterator&
      operator--()
      {
 --_M_current;
 return *this;
      }

      __normal_iterator
      operator--(int)
      { return __normal_iterator(_M_current--); }


      reference
      operator[](const difference_type& __n) const
      { return _M_current[__n]; }

      __normal_iterator&
      operator+=(const difference_type& __n)
      { _M_current += __n; return *this; }

      __normal_iterator
      operator+(const difference_type& __n) const
      { return __normal_iterator(_M_current + __n); }

      __normal_iterator&
      operator-=(const difference_type& __n)
      { _M_current -= __n; return *this; }

      __normal_iterator
      operator-(const difference_type& __n) const
      { return __normal_iterator(_M_current - __n); }

      const _Iterator&
      base() const
      { return _M_current; }
    };
# 678 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_iterator.h" 3
  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator==(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() == __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator==(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() == __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator!=(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() != __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator!=(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() != __rhs.base(); }


  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator<(const __normal_iterator<_IteratorL, _Container>& __lhs,
       const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() < __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator<(const __normal_iterator<_Iterator, _Container>& __lhs,
       const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() < __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator>(const __normal_iterator<_IteratorL, _Container>& __lhs,
       const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() > __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator>(const __normal_iterator<_Iterator, _Container>& __lhs,
       const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() > __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator<=(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() <= __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator<=(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() <= __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator>=(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() >= __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator>=(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() >= __rhs.base(); }





  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline typename __normal_iterator<_IteratorL, _Container>::difference_type
    operator-(const __normal_iterator<_IteratorL, _Container>& __lhs,
       const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() - __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline __normal_iterator<_Iterator, _Container>
    operator+(typename __normal_iterator<_Iterator, _Container>::difference_type
       __n, const __normal_iterator<_Iterator, _Container>& __i)
    { return __normal_iterator<_Iterator, _Container>(__i.base() + __n); }
}
# 76 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_algobase.h" 2 3

# 1 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/debug/debug.h" 1 3
# 272 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/debug/debug.h" 3
# 1 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/cassert" 1 3
# 46 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/cassert" 3
       
# 47 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/cassert" 3

# 1 "H:/CPP/wxdevcpp6.10/include/assert.h" 1 3
# 23 "H:/CPP/wxdevcpp6.10/include/assert.h" 3
extern "C" {
# 38 "H:/CPP/wxdevcpp6.10/include/assert.h" 3
 void __attribute__((__cdecl__)) _assert (const char*, const char*, int) __attribute__ ((__noreturn__));
# 48 "H:/CPP/wxdevcpp6.10/include/assert.h" 3
}
# 49 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/cassert" 2 3
# 273 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/debug/debug.h" 2 3

# 1 "H:/CPP/wxdevcpp6.10/lib/gcc/mingw32/3.4.2/include/stddef.h" 1 3
# 275 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/debug/debug.h" 2 3



namespace __gnu_debug
{
  template<typename _Iterator, typename _Sequence>
    class _Safe_iterator;


  inline bool
  __check_singular_aux(const void*) { return false; }



  template<typename _Iterator>
    inline bool
    __check_singular(_Iterator& __x)
    { return __gnu_debug::__check_singular_aux(&__x); }


  template<typename _Tp>
    inline bool
    __check_singular(const _Tp* __ptr)
    { return __ptr == 0; }


  template<typename _Iterator, typename _Sequence>
    inline bool
    __check_singular(const _Safe_iterator<_Iterator, _Sequence>& __x)
    { return __x._M_singular(); }



  template<typename _Iterator>
    inline bool
    __check_dereferenceable(_Iterator&)
    { return true; }


  template<typename _Tp>
    inline bool
    __check_dereferenceable(const _Tp* __ptr)
    { return __ptr; }


  template<typename _Iterator, typename _Sequence>
    inline bool
    __check_dereferenceable(const _Safe_iterator<_Iterator, _Sequence>& __x)
    { return __x._M_dereferenceable(); }




  template<typename _RandomAccessIterator>
    inline bool
    __valid_range_aux2(const _RandomAccessIterator& __first,
         const _RandomAccessIterator& __last,
         std::random_access_iterator_tag)
    { return __last - __first >= 0; }





  template<typename _InputIterator>
    inline bool
    __valid_range_aux2(const _InputIterator&, const _InputIterator&,
         std::input_iterator_tag)
    { return true; }





  template<typename _Integral>
    inline bool
    __valid_range_aux(const _Integral&, const _Integral&, __true_type)
    { return true; }




  template<typename _InputIterator>
    inline bool
    __valid_range_aux(const _InputIterator& __first,
        const _InputIterator& __last, __false_type)
  {
    typedef typename std::iterator_traits<_InputIterator>::iterator_category
      _Category;
    return __gnu_debug::__valid_range_aux2(__first, __last, _Category());
  }






  template<typename _InputIterator>
    inline bool
    __valid_range(const _InputIterator& __first, const _InputIterator& __last)
    {
      typedef typename _Is_integer<_InputIterator>::_Integral _Integral;
      return __gnu_debug::__valid_range_aux(__first, __last, _Integral());
    }


  template<typename _Iterator, typename _Sequence>
    inline bool
    __valid_range(const _Safe_iterator<_Iterator, _Sequence>& __first,
    const _Safe_iterator<_Iterator, _Sequence>& __last)
    { return __first._M_valid_range(__last); }





  template<typename _InputIterator>
    inline _InputIterator
    __check_valid_range(const _InputIterator& __first,
   const _InputIterator& __last)
    {
      ;
      return __first;
    }


  template<typename _CharT, typename _Integer>
    inline const _CharT*
    __check_string(const _CharT* __s, const _Integer& __n)
    {



      return __s;
    }


  template<typename _CharT>
    inline const _CharT*
    __check_string(const _CharT* __s)
    {



      return __s;
    }



  template<typename _InputIterator>
    inline bool
    __check_sorted_aux(const _InputIterator&, const _InputIterator&,
                       std::input_iterator_tag)
    { return true; }



  template<typename _ForwardIterator>
    inline bool
    __check_sorted_aux(_ForwardIterator __first, _ForwardIterator __last,
                       std::forward_iterator_tag)
    {
      if (__first == __last)
        return true;

      _ForwardIterator __next = __first;
      for (++__next; __next != __last; __first = __next, ++__next) {
        if (*__next < *__first)
          return false;
      }

      return true;
    }



  template<typename _InputIterator, typename _Predicate>
    inline bool
    __check_sorted_aux(const _InputIterator&, const _InputIterator&,
                       _Predicate, std::input_iterator_tag)
    { return true; }



  template<typename _ForwardIterator, typename _Predicate>
    inline bool
    __check_sorted_aux(_ForwardIterator __first, _ForwardIterator __last,
                       _Predicate __pred, std::forward_iterator_tag)
    {
      if (__first == __last)
        return true;

      _ForwardIterator __next = __first;
      for (++__next; __next != __last; __first = __next, ++__next) {
        if (__pred(*__next, *__first))
          return false;
      }

      return true;
    }


  template<typename _InputIterator>
    inline bool
    __check_sorted(const _InputIterator& __first, const _InputIterator& __last)
    {
      typedef typename std::iterator_traits<_InputIterator>::iterator_category
        _Category;
      return __gnu_debug::__check_sorted_aux(__first, __last, _Category());
    }

  template<typename _InputIterator, typename _Predicate>
    inline bool
    __check_sorted(const _InputIterator& __first, const _InputIterator& __last,
                   _Predicate __pred)
    {
      typedef typename std::iterator_traits<_InputIterator>::iterator_category
        _Category;
      return __gnu_debug::__check_sorted_aux(__first, __last, __pred,
          _Category());
    }




  template<typename _ForwardIterator, typename _Tp>
    inline bool
    __check_partitioned(_ForwardIterator __first, _ForwardIterator __last,
   const _Tp& __value)
    {
      while (__first != __last && *__first < __value)
 ++__first;
      while (__first != __last && !(*__first < __value))
 ++__first;
      return __first == __last;
    }


  template<typename _ForwardIterator, typename _Tp, typename _Pred>
    inline bool
    __check_partitioned(_ForwardIterator __first, _ForwardIterator __last,
   const _Tp& __value, _Pred __pred)
    {
      while (__first != __last && __pred(*__first, __value))
 ++__first;
      while (__first != __last && !__pred(*__first, __value))
 ++__first;
      return __first == __last;
    }
}
# 78 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_algobase.h" 2 3

namespace std
{
# 90 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_algobase.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    inline void
    iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
    {
      typedef typename iterator_traits<_ForwardIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_ForwardIterator2>::value_type
 _ValueType2;


     

     

     

     


      const _ValueType1 __tmp = *__a;
      *__a = *__b;
      *__b = __tmp;
    }
# 123 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_algobase.h" 3
  template<typename _Tp>
    inline void
    swap(_Tp& __a, _Tp& __b)
    {

     

      const _Tp __tmp = __a;
      __a = __b;
      __b = __tmp;
    }
# 148 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_algobase.h" 3
  template<typename _Tp>
    inline const _Tp&
    min(const _Tp& __a, const _Tp& __b)
    {

     

      if (__b < __a)
 return __b;
      return __a;
    }
# 170 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_algobase.h" 3
  template<typename _Tp>
    inline const _Tp&
    max(const _Tp& __a, const _Tp& __b)
    {

     

      if (__a < __b)
 return __b;
      return __a;
    }
# 192 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_algobase.h" 3
  template<typename _Tp, typename _Compare>
    inline const _Tp&
    min(const _Tp& __a, const _Tp& __b, _Compare __comp)
    {

      if (__comp(__b, __a))
 return __b;
      return __a;
    }
# 212 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_algobase.h" 3
  template<typename _Tp, typename _Compare>
    inline const _Tp&
    max(const _Tp& __a, const _Tp& __b, _Compare __comp)
    {

      if (__comp(__a, __b))
 return __b;
      return __a;
    }







  template<typename _InputIterator, typename _OutputIterator>
    inline _OutputIterator
    __copy(_InputIterator __first, _InputIterator __last,
    _OutputIterator __result, input_iterator_tag)
    {
      for (; __first != __last; ++__result, ++__first)
 *__result = *__first;
      return __result;
    }

  template<typename _RandomAccessIterator, typename _OutputIterator>
    inline _OutputIterator
    __copy(_RandomAccessIterator __first, _RandomAccessIterator __last,
    _OutputIterator __result, random_access_iterator_tag)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
          _Distance;
      for (_Distance __n = __last - __first; __n > 0; --__n)
 {
   *__result = *__first;
   ++__first;
   ++__result;
 }
      return __result;
    }

  template<typename _Tp>
    inline _Tp*
    __copy_trivial(const _Tp* __first, const _Tp* __last, _Tp* __result)
    {
      std::memmove(__result, __first, sizeof(_Tp) * (__last - __first));
      return __result + (__last - __first);
    }

  template<typename _InputIterator, typename _OutputIterator>
    inline _OutputIterator
    __copy_aux2(_InputIterator __first, _InputIterator __last,
  _OutputIterator __result, __false_type)
    { return std::__copy(__first, __last, __result,
    std::__iterator_category(__first)); }

  template<typename _InputIterator, typename _OutputIterator>
    inline _OutputIterator
    __copy_aux2(_InputIterator __first, _InputIterator __last,
  _OutputIterator __result, __true_type)
    { return std::__copy(__first, __last, __result,
    std::__iterator_category(__first)); }

  template<typename _Tp>
    inline _Tp*
    __copy_aux2(_Tp* __first, _Tp* __last, _Tp* __result, __true_type)
    { return std::__copy_trivial(__first, __last, __result); }

  template<typename _Tp>
    inline _Tp*
    __copy_aux2(const _Tp* __first, const _Tp* __last, _Tp* __result,
  __true_type)
    { return std::__copy_trivial(__first, __last, __result); }

  template<typename _InputIterator, typename _OutputIterator>
    inline _OutputIterator
    __copy_ni2(_InputIterator __first, _InputIterator __last,
        _OutputIterator __result, __true_type)
    {
      typedef typename iterator_traits<_InputIterator>::value_type
 _ValueType;
      typedef typename __type_traits<
 _ValueType>::has_trivial_assignment_operator _Trivial;
      return _OutputIterator(std::__copy_aux2(__first, __last, __result.base(),
           _Trivial()));
    }

  template<typename _InputIterator, typename _OutputIterator>
    inline _OutputIterator
    __copy_ni2(_InputIterator __first, _InputIterator __last,
        _OutputIterator __result, __false_type)
    {
      typedef typename iterator_traits<_InputIterator>::value_type _ValueType;
      typedef typename __type_traits<
 _ValueType>::has_trivial_assignment_operator _Trivial;
      return std::__copy_aux2(__first, __last, __result, _Trivial());
    }

  template<typename _InputIterator, typename _OutputIterator>
    inline _OutputIterator
    __copy_ni1(_InputIterator __first, _InputIterator __last,
        _OutputIterator __result, __true_type)
    {
      typedef typename _Is_normal_iterator<_OutputIterator>::_Normal __Normal;
      return std::__copy_ni2(__first.base(), __last.base(),
        __result, __Normal());
    }

  template<typename _InputIterator, typename _OutputIterator>
    inline _OutputIterator
    __copy_ni1(_InputIterator __first, _InputIterator __last,
        _OutputIterator __result, __false_type)
    {
      typedef typename _Is_normal_iterator<_OutputIterator>::_Normal __Normal;
      return std::__copy_ni2(__first, __last, __result, __Normal());
    }
# 346 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_algobase.h" 3
  template<typename _InputIterator, typename _OutputIterator>
    inline _OutputIterator
    copy(_InputIterator __first, _InputIterator __last,
  _OutputIterator __result)
    {

     
     

      ;

       typedef typename _Is_normal_iterator<_InputIterator>::_Normal __Normal;
       return std::__copy_ni1(__first, __last, __result, __Normal());
    }

  template<typename _BidirectionalIterator1, typename _BidirectionalIterator2>
    inline _BidirectionalIterator2
    __copy_backward(_BidirectionalIterator1 __first,
      _BidirectionalIterator1 __last,
      _BidirectionalIterator2 __result,
      bidirectional_iterator_tag)
    {
      while (__first != __last)
        *--__result = *--__last;
      return __result;
    }

  template<typename _RandomAccessIterator, typename _BidirectionalIterator>
    inline _BidirectionalIterator
    __copy_backward(_RandomAccessIterator __first, _RandomAccessIterator __last,
      _BidirectionalIterator __result, random_access_iterator_tag)
    {
      typename iterator_traits<_RandomAccessIterator>::difference_type __n;
      for (__n = __last - __first; __n > 0; --__n)
        *--__result = *--__last;
      return __result;
    }






  template<typename _BidirectionalIterator1, typename _BidirectionalIterator2,
           typename _BoolType>
    struct __copy_backward_dispatch
    {
      static _BidirectionalIterator2
      copy(_BidirectionalIterator1 __first, _BidirectionalIterator1 __last,
    _BidirectionalIterator2 __result)
      { return std::__copy_backward(__first, __last, __result,
        std::__iterator_category(__first)); }
    };

  template<typename _Tp>
    struct __copy_backward_dispatch<_Tp*, _Tp*, __true_type>
    {
      static _Tp*
      copy(const _Tp* __first, const _Tp* __last, _Tp* __result)
      {
 const ptrdiff_t _Num = __last - __first;
 std::memmove(__result - _Num, __first, sizeof(_Tp) * _Num);
 return __result - _Num;
      }
    };

  template<typename _Tp>
    struct __copy_backward_dispatch<const _Tp*, _Tp*, __true_type>
    {
      static _Tp*
      copy(const _Tp* __first, const _Tp* __last, _Tp* __result)
      {
 return std::__copy_backward_dispatch<_Tp*, _Tp*, __true_type>
   ::copy(__first, __last, __result);
      }
    };

  template<typename _BI1, typename _BI2>
    inline _BI2
    __copy_backward_aux(_BI1 __first, _BI1 __last, _BI2 __result)
    {
      typedef typename __type_traits<typename iterator_traits<_BI2>::value_type>
       ::has_trivial_assignment_operator _Trivial;
      return
 std::__copy_backward_dispatch<_BI1, _BI2, _Trivial>::copy(__first,
          __last,
          __result);
    }

  template <typename _BI1, typename _BI2>
    inline _BI2
    __copy_backward_output_normal_iterator(_BI1 __first, _BI1 __last,
        _BI2 __result, __true_type)
    { return _BI2(std::__copy_backward_aux(__first, __last, __result.base())); }

  template <typename _BI1, typename _BI2>
    inline _BI2
    __copy_backward_output_normal_iterator(_BI1 __first, _BI1 __last,
        _BI2 __result, __false_type)
    { return std::__copy_backward_aux(__first, __last, __result); }

  template <typename _BI1, typename _BI2>
    inline _BI2
    __copy_backward_input_normal_iterator(_BI1 __first, _BI1 __last,
       _BI2 __result, __true_type)
    {
      typedef typename _Is_normal_iterator<_BI2>::_Normal __Normal;
      return std::__copy_backward_output_normal_iterator(__first.base(),
        __last.base(),
        __result, __Normal());
    }

  template <typename _BI1, typename _BI2>
    inline _BI2
    __copy_backward_input_normal_iterator(_BI1 __first, _BI1 __last,
       _BI2 __result, __false_type)
    {
      typedef typename _Is_normal_iterator<_BI2>::_Normal __Normal;
      return std::__copy_backward_output_normal_iterator(__first, __last,
        __result, __Normal());
    }
# 485 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_algobase.h" 3
  template <typename _BI1, typename _BI2>
    inline _BI2
    copy_backward(_BI1 __first, _BI1 __last, _BI2 __result)
    {

     
     
     


      ;

      typedef typename _Is_normal_iterator<_BI1>::_Normal __Normal;
      return std::__copy_backward_input_normal_iterator(__first, __last,
       __result, __Normal());
    }
# 514 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_algobase.h" 3
  template<typename _ForwardIterator, typename _Tp>
    void
    fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value)
    {

     

      ;

      for ( ; __first != __last; ++__first)
 *__first = __value;
    }
# 538 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_algobase.h" 3
  template<typename _OutputIterator, typename _Size, typename _Tp>
    _OutputIterator
    fill_n(_OutputIterator __first, _Size __n, const _Tp& __value)
    {

     

      for ( ; __n > 0; --__n, ++__first)
 *__first = __value;
      return __first;
    }


  inline void
  fill(unsigned char* __first, unsigned char* __last, const unsigned char& __c)
  {
    ;
    const unsigned char __tmp = __c;
    std::memset(__first, __tmp, __last - __first);
  }

  inline void
  fill(signed char* __first, signed char* __last, const signed char& __c)
  {
    ;
    const signed char __tmp = __c;
    std::memset(__first, static_cast<unsigned char>(__tmp), __last - __first);
  }

  inline void
  fill(char* __first, char* __last, const char& __c)
  {
    ;
    const char __tmp = __c;
    std::memset(__first, static_cast<unsigned char>(__tmp), __last - __first);
  }

  template<typename _Size>
    inline unsigned char*
    fill_n(unsigned char* __first, _Size __n, const unsigned char& __c)
    {
      std::fill(__first, __first + __n, __c);
      return __first + __n;
    }

  template<typename _Size>
    inline signed char*
    fill_n(char* __first, _Size __n, const signed char& __c)
    {
      std::fill(__first, __first + __n, __c);
      return __first + __n;
    }

  template<typename _Size>
    inline char*
    fill_n(char* __first, _Size __n, const char& __c)
    {
      std::fill(__first, __first + __n, __c);
      return __first + __n;
    }
# 612 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_algobase.h" 3
  template<typename _InputIterator1, typename _InputIterator2>
    pair<_InputIterator1, _InputIterator2>
    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2)
    {

     
     
     

     

      ;

      while (__first1 != __last1 && *__first1 == *__first2)
        {
   ++__first1;
   ++__first2;
        }
      return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
    }
# 648 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_algobase.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _BinaryPredicate>
    pair<_InputIterator1, _InputIterator2>
    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _BinaryPredicate __binary_pred)
    {

     
     
      ;

      while (__first1 != __last1 && __binary_pred(*__first1, *__first2))
        {
   ++__first1;
   ++__first2;
        }
      return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
    }
# 678 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_algobase.h" 3
  template<typename _InputIterator1, typename _InputIterator2>
    inline bool
    equal(_InputIterator1 __first1, _InputIterator1 __last1,
   _InputIterator2 __first2)
    {

     
     
     


      ;

      for ( ; __first1 != __last1; ++__first1, ++__first2)
 if (!(*__first1 == *__first2))
   return false;
      return true;
    }
# 710 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_algobase.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _BinaryPredicate>
    inline bool
    equal(_InputIterator1 __first1, _InputIterator1 __last1,
   _InputIterator2 __first2,
   _BinaryPredicate __binary_pred)
    {

     
     
      ;

      for ( ; __first1 != __last1; ++__first1, ++__first2)
 if (!__binary_pred(*__first1, *__first2))
   return false;
      return true;
    }
# 742 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_algobase.h" 3
  template<typename _InputIterator1, typename _InputIterator2>
    bool
    lexicographical_compare(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _InputIterator2 __last2)
    {

     
     
     

     

      ;
      ;

      for (;__first1 != __last1 && __first2 != __last2; ++__first1, ++__first2)
 {
   if (*__first1 < *__first2)
     return true;
   if (*__first2 < *__first1)
     return false;
 }
      return __first1 == __last1 && __first2 != __last2;
    }
# 779 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_algobase.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _Compare>
    bool
    lexicographical_compare(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _InputIterator2 __last2,
       _Compare __comp)
    {

     
     
      ;
      ;

      for ( ; __first1 != __last1 && __first2 != __last2
     ; ++__first1, ++__first2)
 {
   if (__comp(*__first1, *__first2))
     return true;
   if (__comp(*__first2, *__first1))
     return false;
 }
      return __first1 == __last1 && __first2 != __last2;
    }

  inline bool
  lexicographical_compare(const unsigned char* __first1,
     const unsigned char* __last1,
     const unsigned char* __first2,
     const unsigned char* __last2)
  {
    ;
    ;

    const size_t __len1 = __last1 - __first1;
    const size_t __len2 = __last2 - __first2;
    const int __result = std::memcmp(__first1, __first2,
         std::min(__len1, __len2));
    return __result != 0 ? __result < 0 : __len1 < __len2;
  }

  inline bool
  lexicographical_compare(const char* __first1, const char* __last1,
     const char* __first2, const char* __last2)
  {
    ;
    ;


    return std::lexicographical_compare((const signed char*) __first1,
     (const signed char*) __last1,
     (const signed char*) __first2,
     (const signed char*) __last2);






  }

}
# 47 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/char_traits.h" 2 3


namespace __gnu_cxx
{
# 62 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/char_traits.h" 3
  template <class _CharT>
    struct _Char_types
    {
      typedef unsigned long int_type;
      typedef std::streampos pos_type;
      typedef std::streamoff off_type;
      typedef std::mbstate_t state_type;
    };
# 86 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/char_traits.h" 3
  template<typename _CharT>
    struct char_traits
    {
      typedef _CharT char_type;
      typedef typename _Char_types<_CharT>::int_type int_type;
      typedef typename _Char_types<_CharT>::pos_type pos_type;
      typedef typename _Char_types<_CharT>::off_type off_type;
      typedef typename _Char_types<_CharT>::state_type state_type;

      static void
      assign(char_type& __c1, const char_type& __c2)
      { __c1 = __c2; }

      static bool
      eq(const char_type& __c1, const char_type& __c2)
      { return __c1 == __c2; }

      static bool
      lt(const char_type& __c1, const char_type& __c2)
      { return __c1 < __c2; }

      static int
      compare(const char_type* __s1, const char_type* __s2, std::size_t __n);

      static std::size_t
      length(const char_type* __s);

      static const char_type*
      find(const char_type* __s, std::size_t __n, const char_type& __a);

      static char_type*
      move(char_type* __s1, const char_type* __s2, std::size_t __n);

      static char_type*
      copy(char_type* __s1, const char_type* __s2, std::size_t __n);

      static char_type*
      assign(char_type* __s, std::size_t __n, char_type __a);

      static char_type
      to_char_type(const int_type& __c)
      { return static_cast<char_type>(__c); }

      static int_type
      to_int_type(const char_type& __c)
      { return static_cast<int_type>(__c); }

      static bool
      eq_int_type(const int_type& __c1, const int_type& __c2)
      { return __c1 == __c2; }

      static int_type
      eof()
      { return static_cast<int_type>((-1)); }

      static int_type
      not_eof(const int_type& __c)
      { return !eq_int_type(__c, eof()) ? __c : to_int_type(char_type()); }
    };

  template<typename _CharT>
    int
    char_traits<_CharT>::
    compare(const char_type* __s1, const char_type* __s2, std::size_t __n)
    {
      for (size_t __i = 0; __i < __n; ++__i)
 if (lt(__s1[__i], __s2[__i]))
   return -1;
 else if (lt(__s2[__i], __s1[__i]))
   return 1;
      return 0;
    }

  template<typename _CharT>
    std::size_t
    char_traits<_CharT>::
    length(const char_type* __p)
    {
      std::size_t __i = 0;
      while (!eq(__p[__i], char_type()))
        ++__i;
      return __i;
    }

  template<typename _CharT>
    const typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    find(const char_type* __s, std::size_t __n, const char_type& __a)
    {
      for (std::size_t __i = 0; __i < __n; ++__i)
        if (eq(__s[__i], __a))
          return __s + __i;
      return 0;
    }

  template<typename _CharT>
    typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    move(char_type* __s1, const char_type* __s2, std::size_t __n)
    {
      return static_cast<_CharT*>(std::memmove(__s1, __s2,
            __n * sizeof(char_type)));
    }

  template<typename _CharT>
    typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    copy(char_type* __s1, const char_type* __s2, std::size_t __n)
    {
      std::copy(__s2, __s2 + __n, __s1);
      return __s1;
    }

  template<typename _CharT>
    typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    assign(char_type* __s, std::size_t __n, char_type __a)
    {
      std::fill_n(__s, __n, __a);
      return __s;
    }
}

namespace std
{
# 224 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/char_traits.h" 3
  template<class _CharT>
    struct char_traits
    : public __gnu_cxx::char_traits<_CharT>
    { };



  template<>
    struct char_traits<char>
    {
      typedef char char_type;
      typedef int int_type;
      typedef streampos pos_type;
      typedef streamoff off_type;
      typedef mbstate_t state_type;

      static void
      assign(char_type& __c1, const char_type& __c2)
      { __c1 = __c2; }

      static bool
      eq(const char_type& __c1, const char_type& __c2)
      { return __c1 == __c2; }

      static bool
      lt(const char_type& __c1, const char_type& __c2)
      { return __c1 < __c2; }

      static int
      compare(const char_type* __s1, const char_type* __s2, size_t __n)
      { return memcmp(__s1, __s2, __n); }

      static size_t
      length(const char_type* __s)
      { return strlen(__s); }

      static const char_type*
      find(const char_type* __s, size_t __n, const char_type& __a)
      { return static_cast<const char_type*>(memchr(__s, __a, __n)); }

      static char_type*
      move(char_type* __s1, const char_type* __s2, size_t __n)
      { return static_cast<char_type*>(memmove(__s1, __s2, __n)); }

      static char_type*
      copy(char_type* __s1, const char_type* __s2, size_t __n)
      { return static_cast<char_type*>(memcpy(__s1, __s2, __n)); }

      static char_type*
      assign(char_type* __s, size_t __n, char_type __a)
      { return static_cast<char_type*>(memset(__s, __a, __n)); }

      static char_type
      to_char_type(const int_type& __c)
      { return static_cast<char_type>(__c); }



      static int_type
      to_int_type(const char_type& __c)
      { return static_cast<int_type>(static_cast<unsigned char>(__c)); }

      static bool
      eq_int_type(const int_type& __c1, const int_type& __c2)
      { return __c1 == __c2; }

      static int_type
      eof() { return static_cast<int_type>((-1)); }

      static int_type
      not_eof(const int_type& __c)
      { return (__c == eof()) ? 0 : __c; }
  };




  template<>
    struct char_traits<wchar_t>
    {
      typedef wchar_t char_type;
      typedef wint_t int_type;
      typedef streamoff off_type;





      static void
      assign(char_type& __c1, const char_type& __c2)
      { __c1 = __c2; }

      static bool
      eq(const char_type& __c1, const char_type& __c2)
      { return __c1 == __c2; }

      static bool
      lt(const char_type& __c1, const char_type& __c2)
      { return __c1 < __c2; }

      static int
      compare(const char_type* __s1, const char_type* __s2, size_t __n)
      { return wmemcmp(__s1, __s2, __n); }

      static size_t
      length(const char_type* __s)
      { return wcslen(__s); }

      static const char_type*
      find(const char_type* __s, size_t __n, const char_type& __a)
      { return wmemchr(__s, __a, __n); }

      static char_type*
      move(char_type* __s1, const char_type* __s2, size_t __n)
      { return wmemmove(__s1, __s2, __n); }

      static char_type*
      copy(char_type* __s1, const char_type* __s2, size_t __n)
      { return wmemcpy(__s1, __s2, __n); }

      static char_type*
      assign(char_type* __s, size_t __n, char_type __a)
      { return wmemset(__s, __a, __n); }

      static char_type
      to_char_type(const int_type& __c) { return char_type(__c); }

      static int_type
      to_int_type(const char_type& __c) { return int_type(__c); }

      static bool
      eq_int_type(const int_type& __c1, const int_type& __c2)
      { return __c1 == __c2; }

      static int_type
      eof() { return static_cast<int_type>((wchar_t)(0xFFFF)); }

      static int_type
      not_eof(const int_type& __c)
      { return eq_int_type(__c, eof()) ? 0 : __c; }
  };


  template<typename _CharT, typename _Traits>
    struct _Char_traits_match
    {
      _CharT _M_c;
      _Char_traits_match(_CharT const& __c) : _M_c(__c) { }

      bool
      operator()(_CharT const& __a) { return _Traits::eq(_M_c, __a); }
    };
}
# 47 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/ios" 2 3

# 1 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/localefwd.h" 1 3
# 43 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/localefwd.h" 3
       
# 44 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/localefwd.h" 3




# 1 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/functexcept.h" 1 3
# 36 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/functexcept.h" 3
namespace std
{

  void
  __throw_bad_exception(void);


  void
  __throw_bad_alloc(void);


  void
  __throw_bad_cast(void);

  void
  __throw_bad_typeid(void);


  void
  __throw_logic_error(const char* __s);

  void
  __throw_domain_error(const char* __s);

  void
  __throw_invalid_argument(const char* __s);

  void
  __throw_length_error(const char* __s);

  void
  __throw_out_of_range(const char* __s);

  void
  __throw_runtime_error(const char* __s);

  void
  __throw_range_error(const char* __s);

  void
  __throw_overflow_error(const char* __s);

  void
  __throw_underflow_error(const char* __s);


  void
  __throw_ios_failure(const char* __s);
}
# 49 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/localefwd.h" 2 3

namespace std
{

  class locale;


  template<typename _CharT>
    inline bool
    isspace(_CharT, const locale&);

  template<typename _CharT>
    inline bool
    isprint(_CharT, const locale&);

  template<typename _CharT>
    inline bool
    iscntrl(_CharT, const locale&);

  template<typename _CharT>
    inline bool
    isupper(_CharT, const locale&);

  template<typename _CharT>
    inline bool
    islower(_CharT, const locale&);

  template<typename _CharT>
    inline bool
    isalpha(_CharT, const locale&);

  template<typename _CharT>
    inline bool
    isdigit(_CharT, const locale&);

  template<typename _CharT>
    inline bool
    ispunct(_CharT, const locale&);

  template<typename _CharT>
    inline bool
    isxdigit(_CharT, const locale&);

  template<typename _CharT>
    inline bool
    isalnum(_CharT, const locale&);

  template<typename _CharT>
    inline bool
    isgraph(_CharT, const locale&);

  template<typename _CharT>
    inline _CharT
    toupper(_CharT, const locale&);

  template<typename _CharT>
    inline _CharT
    tolower(_CharT, const locale&);


  class ctype_base;
  template<typename _CharT>
    class ctype;
  template<> class ctype<char>;



  template<typename _CharT>
    class ctype_byname;


  class codecvt_base;
  class __enc_traits;
  template<typename _InternT, typename _ExternT, typename _StateT>
    class codecvt;
  template<> class codecvt<char, char, mbstate_t>;



  template<typename _InternT, typename _ExternT, typename _StateT>
    class codecvt_byname;


  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class num_get;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class num_put;
  template<typename _CharT> class numpunct;
  template<typename _CharT> class numpunct_byname;


  template<typename _CharT>
    class collate;
  template<typename _CharT> class
    collate_byname;


  class time_base;
  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class time_get;
  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class time_get_byname;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class time_put;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class time_put_byname;


  class money_base;
  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class money_get;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class money_put;
  template<typename _CharT, bool _Intl = false>
    class moneypunct;
  template<typename _CharT, bool _Intl = false>
    class moneypunct_byname;


  class messages_base;
  template<typename _CharT>
    class messages;
  template<typename _CharT>
    class messages_byname;

  template<typename _Facet>
    bool
    has_facet(const locale& __loc) throw();

  template<typename _Facet>
    const _Facet&
    use_facet(const locale& __loc);

  template<typename _Facet>
    inline const _Facet&
    __check_facet(const _Facet* __f)
    {
      if (!__f)
 __throw_bad_cast();
      return *__f;
    }
}
# 49 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/ios" 2 3
# 1 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/ios_base.h" 1 3
# 43 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/ios_base.h" 3
       
# 44 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/ios_base.h" 3

# 1 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/atomicity.h" 1 3
# 33 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/atomicity.h" 3
# 1 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/mingw32/bits/atomic_word.h" 1 3
# 33 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/mingw32/bits/atomic_word.h" 3
typedef int _Atomic_word;
# 34 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/atomicity.h" 2 3

namespace __gnu_cxx
{
  _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add(volatile _Atomic_word* __mem, int __val);

  void
  __attribute__ ((__unused__))
  __atomic_add(volatile _Atomic_word* __mem, int __val);
}
# 46 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/ios_base.h" 2 3

# 1 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_classes.h" 1 3
# 43 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_classes.h" 3
       
# 44 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_classes.h" 3



# 1 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/string" 1 3
# 43 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/string" 3
       
# 44 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/string" 3




# 1 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/memory" 1 3
# 52 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/memory" 3
       
# 53 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/memory" 3


# 1 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/allocator.h" 1 3
# 52 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/allocator.h" 3
# 1 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/mingw32/bits/c++allocator.h" 1 3
# 34 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/mingw32/bits/c++allocator.h" 3
# 1 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/ext/new_allocator.h" 1 3
# 35 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/ext/new_allocator.h" 3
namespace __gnu_cxx
{
# 46 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/ext/new_allocator.h" 3
  template<typename _Tp>
    class new_allocator
    {
    public:
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Tp* pointer;
      typedef const _Tp* const_pointer;
      typedef _Tp& reference;
      typedef const _Tp& const_reference;
      typedef _Tp value_type;

      template<typename _Tp1>
        struct rebind
        { typedef new_allocator<_Tp1> other; };

      new_allocator() throw() { }

      new_allocator(const new_allocator&) throw() { }

      template<typename _Tp1>
        new_allocator(const new_allocator<_Tp1>&) throw() { }

      ~new_allocator() throw() { }

      pointer
      address(reference __x) const { return &__x; }

      const_pointer
      address(const_reference __x) const { return &__x; }



      pointer
      allocate(size_type __n, const void* = 0)
      { return static_cast<_Tp*>(::operator new(__n * sizeof(_Tp))); }


      void
      deallocate(pointer __p, size_type)
      { ::operator delete(__p); }

      size_type
      max_size() const throw()
      { return size_t(-1) / sizeof(_Tp); }



      void
      construct(pointer __p, const _Tp& __val)
      { ::new(__p) _Tp(__val); }

      void
      destroy(pointer __p) { __p->~_Tp(); }
    };

  template<typename _Tp>
    inline bool
    operator==(const new_allocator<_Tp>&, const new_allocator<_Tp>&)
    { return true; }

  template<typename _Tp>
    inline bool
    operator!=(const new_allocator<_Tp>&, const new_allocator<_Tp>&)
    { return false; }
}
# 35 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/mingw32/bits/c++allocator.h" 2 3
# 53 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/allocator.h" 2 3

namespace std
{
  template<typename _Tp>
    class allocator;

  template<>
    class allocator<void>
    {
    public:
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef void* pointer;
      typedef const void* const_pointer;
      typedef void value_type;

      template<typename _Tp1>
        struct rebind
        { typedef allocator<_Tp1> other; };
    };






  template<typename _Tp>
    class allocator: public __gnu_cxx::new_allocator<_Tp>
    {
   public:
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Tp* pointer;
      typedef const _Tp* const_pointer;
      typedef _Tp& reference;
      typedef const _Tp& const_reference;
      typedef _Tp value_type;

      template<typename _Tp1>
        struct rebind
        { typedef allocator<_Tp1> other; };

      allocator() throw() { }

      allocator(const allocator& a) throw()
      : __gnu_cxx::new_allocator<_Tp>(a) { }

      template<typename _Tp1>
        allocator(const allocator<_Tp1>&) throw() { }

      ~allocator() throw() { }


    };

  template<typename _T1, typename _T2>
    inline bool
    operator==(const allocator<_T1>&, const allocator<_T2>&)
    { return true; }

  template<typename _T1, typename _T2>
    inline bool
    operator!=(const allocator<_T1>&, const allocator<_T2>&)
    { return false; }





  extern template class allocator<char>;
  extern template class allocator<wchar_t>;




}
# 56 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/memory" 2 3
# 1 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_construct.h" 1 3
# 67 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_construct.h" 3
namespace std
{






  template<typename _T1, typename _T2>
    inline void
    _Construct(_T1* __p, const _T2& __value)
    {


      ::new(static_cast<void*>(__p)) _T1(__value);
    }







  template<typename _T1>
    inline void
    _Construct(_T1* __p)
    {


      ::new(static_cast<void*>(__p)) _T1();
    }






  template<typename _Tp>
    inline void
    _Destroy(_Tp* __pointer)
    { __pointer->~_Tp(); }
# 116 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_construct.h" 3
  template<typename _ForwardIterator>
    inline void
    __destroy_aux(_ForwardIterator __first, _ForwardIterator __last,
    __false_type)
    { for ( ; __first != __last; ++__first) std::_Destroy(&*__first); }
# 131 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_construct.h" 3
  template<typename _ForwardIterator>
    inline void
    __destroy_aux(_ForwardIterator, _ForwardIterator, __true_type)
    { }
# 143 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_construct.h" 3
  template<typename _ForwardIterator>
    inline void
    _Destroy(_ForwardIterator __first, _ForwardIterator __last)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
                       _Value_type;
      typedef typename __type_traits<_Value_type>::has_trivial_destructor
                       _Has_trivial_destructor;

      std::__destroy_aux(__first, __last, _Has_trivial_destructor());
    }
}
# 57 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/memory" 2 3

# 1 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_uninitialized.h" 1 3
# 66 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_uninitialized.h" 3
namespace std
{

  template<typename _InputIterator, typename _ForwardIterator>
    inline _ForwardIterator
    __uninitialized_copy_aux(_InputIterator __first, _InputIterator __last,
        _ForwardIterator __result,
        __true_type)
    { return std::copy(__first, __last, __result); }

  template<typename _InputIterator, typename _ForwardIterator>
    inline _ForwardIterator
    __uninitialized_copy_aux(_InputIterator __first, _InputIterator __last,
        _ForwardIterator __result,
        __false_type)
    {
      _ForwardIterator __cur = __result;
      try
 {
   for ( ; __first != __last; ++__first, ++__cur)
     std::_Construct(&*__cur, *__first);
   return __cur;
 }
      catch(...)
 {
   std::_Destroy(__result, __cur);
   throw;
 }
    }
# 105 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_uninitialized.h" 3
  template<typename _InputIterator, typename _ForwardIterator>
    inline _ForwardIterator
    uninitialized_copy(_InputIterator __first, _InputIterator __last,
         _ForwardIterator __result)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type _ValueType;
      typedef typename __type_traits<_ValueType>::is_POD_type _Is_POD;
      return std::__uninitialized_copy_aux(__first, __last, __result,
        _Is_POD());
    }

  inline char*
  uninitialized_copy(const char* __first, const char* __last, char* __result)
  {
    std::memmove(__result, __first, __last - __first);
    return __result + (__last - __first);
  }

  inline wchar_t*
  uninitialized_copy(const wchar_t* __first, const wchar_t* __last,
       wchar_t* __result)
  {
    std::memmove(__result, __first, sizeof(wchar_t) * (__last - __first));
    return __result + (__last - __first);
  }



  template<typename _ForwardIterator, typename _Tp>
    inline void
    __uninitialized_fill_aux(_ForwardIterator __first,
        _ForwardIterator __last,
        const _Tp& __x, __true_type)
    { std::fill(__first, __last, __x); }

  template<typename _ForwardIterator, typename _Tp>
    void
    __uninitialized_fill_aux(_ForwardIterator __first, _ForwardIterator __last,
        const _Tp& __x, __false_type)
    {
      _ForwardIterator __cur = __first;
      try
 {
   for ( ; __cur != __last; ++__cur)
     std::_Construct(&*__cur, __x);
 }
      catch(...)
 {
   std::_Destroy(__first, __cur);
   throw;
 }
    }
# 167 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_uninitialized.h" 3
  template<typename _ForwardIterator, typename _Tp>
    inline void
    uninitialized_fill(_ForwardIterator __first, _ForwardIterator __last,
         const _Tp& __x)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type _ValueType;
      typedef typename __type_traits<_ValueType>::is_POD_type _Is_POD;
      std::__uninitialized_fill_aux(__first, __last, __x, _Is_POD());
    }



  template<typename _ForwardIterator, typename _Size, typename _Tp>
    inline _ForwardIterator
    __uninitialized_fill_n_aux(_ForwardIterator __first, _Size __n,
          const _Tp& __x, __true_type)
    { return std::fill_n(__first, __n, __x); }

  template<typename _ForwardIterator, typename _Size, typename _Tp>
    _ForwardIterator
    __uninitialized_fill_n_aux(_ForwardIterator __first, _Size __n,
          const _Tp& __x, __false_type)
    {
      _ForwardIterator __cur = __first;
      try
 {
   for ( ; __n > 0; --__n, ++__cur)
     std::_Construct(&*__cur, __x);
   return __cur;
 }
      catch(...)
 {
   std::_Destroy(__first, __cur);
   throw;
 }
    }
# 213 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_uninitialized.h" 3
  template<typename _ForwardIterator, typename _Size, typename _Tp>
    inline _ForwardIterator
    uninitialized_fill_n(_ForwardIterator __first, _Size __n, const _Tp& __x)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type _ValueType;
      typedef typename __type_traits<_ValueType>::is_POD_type _Is_POD;
      return std::__uninitialized_fill_n_aux(__first, __n, __x, _Is_POD());
    }
# 230 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_uninitialized.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _ForwardIterator>
    inline _ForwardIterator
    __uninitialized_copy_copy(_InputIterator1 __first1,
         _InputIterator1 __last1,
         _InputIterator2 __first2,
         _InputIterator2 __last2,
         _ForwardIterator __result)
    {
      _ForwardIterator __mid = std::uninitialized_copy(__first1, __last1,
             __result);
      try
 {
   return std::uninitialized_copy(__first2, __last2, __mid);
 }
      catch(...)
 {
   std::_Destroy(__result, __mid);
   throw;
 }
    }




  template<typename _ForwardIterator, typename _Tp, typename _InputIterator>
    inline _ForwardIterator
    __uninitialized_fill_copy(_ForwardIterator __result, _ForwardIterator __mid,
         const _Tp& __x, _InputIterator __first,
         _InputIterator __last)
    {
      std::uninitialized_fill(__result, __mid, __x);
      try
 {
   return std::uninitialized_copy(__first, __last, __mid);
 }
      catch(...)
 {
   std::_Destroy(__result, __mid);
   throw;
 }
    }




  template<typename _InputIterator, typename _ForwardIterator, typename _Tp>
    inline void
    __uninitialized_copy_fill(_InputIterator __first1, _InputIterator __last1,
         _ForwardIterator __first2,
         _ForwardIterator __last2, const _Tp& __x)
    {
      _ForwardIterator __mid2 = std::uninitialized_copy(__first1, __last1,
       __first2);
      try
 {
   std::uninitialized_fill(__mid2, __last2, __x);
 }
      catch(...)
 {
   std::_Destroy(__first2, __mid2);
   throw;
 }
    }

}
# 59 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/memory" 2 3
# 1 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_raw_storage_iter.h" 1 3
# 64 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_raw_storage_iter.h" 3
namespace std
{




  template <class _ForwardIterator, class _Tp>
    class raw_storage_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _ForwardIterator _M_iter;

    public:
      explicit
      raw_storage_iterator(_ForwardIterator __x)
      : _M_iter(__x) {}

      raw_storage_iterator&
      operator*() { return *this; }

      raw_storage_iterator&
      operator=(const _Tp& __element)
      {
 std::_Construct(&*_M_iter, __element);
 return *this;
      }

      raw_storage_iterator<_ForwardIterator, _Tp>&
      operator++()
      {
 ++_M_iter;
 return *this;
      }

      raw_storage_iterator<_ForwardIterator, _Tp>
      operator++(int)
      {
 raw_storage_iterator<_ForwardIterator, _Tp> __tmp = *this;
 ++_M_iter;
 return __tmp;
      }
    };
}
# 60 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/memory" 2 3


namespace std
{
# 72 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/memory" 3
  template<typename _Tp>
    pair<_Tp*, ptrdiff_t>
    __get_temporary_buffer(ptrdiff_t __len, _Tp*)
    {
      if (__len > ptrdiff_t(2147483647 / sizeof(_Tp)))
 __len = 2147483647 / sizeof(_Tp);

      while (__len > 0)
 {
   _Tp* __tmp = static_cast<_Tp*>(::operator new(__len * sizeof(_Tp),
       nothrow));
   if (__tmp != 0)
     return pair<_Tp*, ptrdiff_t>(__tmp, __len);
   __len /= 2;
 }
      return pair<_Tp*, ptrdiff_t>(static_cast<_Tp*>(0), 0);
    }
# 107 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/memory" 3
  template<typename _Tp>
    inline pair<_Tp*,ptrdiff_t>
    get_temporary_buffer(ptrdiff_t __len)
    { return std::__get_temporary_buffer(__len, static_cast<_Tp*>(0)); }
# 119 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/memory" 3
  template<typename _Tp>
    void
    return_temporary_buffer(_Tp* __p)
    { ::operator delete(__p, nothrow); }
# 131 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/memory" 3
  template<typename _Tp1>
    struct auto_ptr_ref
    {
      _Tp1* _M_ptr;

      explicit
      auto_ptr_ref(_Tp1* __p): _M_ptr(__p) { }
    };
# 172 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/memory" 3
  template<typename _Tp>
    class auto_ptr
    {
    private:
      _Tp* _M_ptr;

    public:

      typedef _Tp element_type;







      explicit
      auto_ptr(element_type* __p = 0) throw() : _M_ptr(__p) { }
# 198 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/memory" 3
      auto_ptr(auto_ptr& __a) throw() : _M_ptr(__a.release()) { }
# 210 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/memory" 3
      template<typename _Tp1>
        auto_ptr(auto_ptr<_Tp1>& __a) throw() : _M_ptr(__a.release()) { }
# 221 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/memory" 3
      auto_ptr&
      operator=(auto_ptr& __a) throw()
      {
 reset(__a.release());
 return *this;
      }
# 238 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/memory" 3
      template<typename _Tp1>
        auto_ptr&
        operator=(auto_ptr<_Tp1>& __a) throw()
        {
   reset(__a.release());
   return *this;
 }
# 258 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/memory" 3
      ~auto_ptr() { delete _M_ptr; }
# 268 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/memory" 3
      element_type&
      operator*() const throw()
      {
 ;
 return *_M_ptr;
      }







      element_type*
      operator->() const throw()
      {
 ;
 return _M_ptr;
      }
# 298 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/memory" 3
      element_type*
      get() const throw() { return _M_ptr; }
# 312 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/memory" 3
      element_type*
      release() throw()
      {
 element_type* __tmp = _M_ptr;
 _M_ptr = 0;
 return __tmp;
      }
# 327 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/memory" 3
      void
      reset(element_type* __p = 0) throw()
      {
 if (__p != _M_ptr)
   {
     delete _M_ptr;
     _M_ptr = __p;
   }
      }
# 348 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/memory" 3
      auto_ptr(auto_ptr_ref<element_type> __ref) throw()
      : _M_ptr(__ref._M_ptr) { }

      auto_ptr&
      operator=(auto_ptr_ref<element_type> __ref) throw()
      {
 if (__ref._M_ptr != this->get())
   {
     delete _M_ptr;
     _M_ptr = __ref._M_ptr;
   }
 return *this;
      }

      template<typename _Tp1>
        operator auto_ptr_ref<_Tp1>() throw()
        { return auto_ptr_ref<_Tp1>(this->release()); }

      template<typename _Tp1>
        operator auto_ptr<_Tp1>() throw()
        { return auto_ptr<_Tp1>(this->release()); }

  };
}
# 49 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/string" 2 3



# 1 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_function.h" 1 3
# 64 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_function.h" 3
namespace std
{
# 101 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_function.h" 3
  template <class _Arg, class _Result>
    struct unary_function
    {
      typedef _Arg argument_type;


      typedef _Result result_type;
    };




  template <class _Arg1, class _Arg2, class _Result>
    struct binary_function
    {
      typedef _Arg1 first_argument_type;


      typedef _Arg2 second_argument_type;
      typedef _Result result_type;
    };
# 133 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_function.h" 3
  template <class _Tp>
    struct plus : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x + __y; }
    };


  template <class _Tp>
    struct minus : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x - __y; }
    };


  template <class _Tp>
    struct multiplies : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x * __y; }
    };


  template <class _Tp>
    struct divides : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x / __y; }
    };


  template <class _Tp>
    struct modulus : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x % __y; }
    };


  template <class _Tp>
    struct negate : public unary_function<_Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x) const
      { return -__x; }
    };
# 195 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_function.h" 3
  template <class _Tp>
    struct equal_to : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x == __y; }
    };


  template <class _Tp>
    struct not_equal_to : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x != __y; }
    };


  template <class _Tp>
    struct greater : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x > __y; }
    };


  template <class _Tp>
    struct less : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x < __y; }
    };


  template <class _Tp>
    struct greater_equal : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x >= __y; }
    };


  template <class _Tp>
    struct less_equal : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x <= __y; }
    };
# 256 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_function.h" 3
  template <class _Tp>
    struct logical_and : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x && __y; }
    };


  template <class _Tp>
    struct logical_or : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x || __y; }
    };


  template <class _Tp>
    struct logical_not : public unary_function<_Tp, bool>
    {
      bool
      operator()(const _Tp& __x) const
      { return !__x; }
    };
# 311 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_function.h" 3
  template <class _Predicate>
    class unary_negate
    : public unary_function<typename _Predicate::argument_type, bool>
    {
    protected:
      _Predicate _M_pred;
    public:
      explicit
      unary_negate(const _Predicate& __x) : _M_pred(__x) {}

      bool
      operator()(const typename _Predicate::argument_type& __x) const
      { return !_M_pred(__x); }
    };


  template <class _Predicate>
    inline unary_negate<_Predicate>
    not1(const _Predicate& __pred)
    { return unary_negate<_Predicate>(__pred); }


  template <class _Predicate>
    class binary_negate
    : public binary_function<typename _Predicate::first_argument_type,
        typename _Predicate::second_argument_type,
        bool>
    {
    protected:
      _Predicate _M_pred;
    public:
      explicit
      binary_negate(const _Predicate& __x)
      : _M_pred(__x) { }

      bool
      operator()(const typename _Predicate::first_argument_type& __x,
   const typename _Predicate::second_argument_type& __y) const
      { return !_M_pred(__x, __y); }
    };


  template <class _Predicate>
    inline binary_negate<_Predicate>
    not2(const _Predicate& __pred)
    { return binary_negate<_Predicate>(__pred); }
# 391 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_function.h" 3
  template <class _Operation>
    class binder1st
    : public unary_function<typename _Operation::second_argument_type,
       typename _Operation::result_type>
    {
    protected:
      _Operation op;
      typename _Operation::first_argument_type value;
    public:
      binder1st(const _Operation& __x,
  const typename _Operation::first_argument_type& __y)
      : op(__x), value(__y) {}

      typename _Operation::result_type
      operator()(const typename _Operation::second_argument_type& __x) const
      { return op(value, __x); }



      typename _Operation::result_type
      operator()(typename _Operation::second_argument_type& __x) const
      { return op(value, __x); }
    };


  template <class _Operation, class _Tp>
    inline binder1st<_Operation>
    bind1st(const _Operation& __fn, const _Tp& __x)
    {
      typedef typename _Operation::first_argument_type _Arg1_type;
      return binder1st<_Operation>(__fn, _Arg1_type(__x));
    }


  template <class _Operation>
    class binder2nd
    : public unary_function<typename _Operation::first_argument_type,
       typename _Operation::result_type>
    {
    protected:
      _Operation op;
      typename _Operation::second_argument_type value;
    public:
      binder2nd(const _Operation& __x,
  const typename _Operation::second_argument_type& __y)
      : op(__x), value(__y) {}

      typename _Operation::result_type
      operator()(const typename _Operation::first_argument_type& __x) const
      { return op(__x, value); }



      typename _Operation::result_type
      operator()(typename _Operation::first_argument_type& __x) const
      { return op(__x, value); }
    };


  template <class _Operation, class _Tp>
    inline binder2nd<_Operation>
    bind2nd(const _Operation& __fn, const _Tp& __x)
    {
      typedef typename _Operation::second_argument_type _Arg2_type;
      return binder2nd<_Operation>(__fn, _Arg2_type(__x));
    }
# 480 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_function.h" 3
  template <class _Arg, class _Result>
    class pointer_to_unary_function : public unary_function<_Arg, _Result>
    {
    protected:
      _Result (*_M_ptr)(_Arg);
    public:
      pointer_to_unary_function() {}

      explicit
      pointer_to_unary_function(_Result (*__x)(_Arg))
      : _M_ptr(__x) {}

      _Result
      operator()(_Arg __x) const
      { return _M_ptr(__x); }
    };


  template <class _Arg, class _Result>
    inline pointer_to_unary_function<_Arg, _Result>
    ptr_fun(_Result (*__x)(_Arg))
    { return pointer_to_unary_function<_Arg, _Result>(__x); }


  template <class _Arg1, class _Arg2, class _Result>
    class pointer_to_binary_function
    : public binary_function<_Arg1, _Arg2, _Result>
    {
    protected:
      _Result (*_M_ptr)(_Arg1, _Arg2);
    public:
      pointer_to_binary_function() {}

      explicit
      pointer_to_binary_function(_Result (*__x)(_Arg1, _Arg2))
      : _M_ptr(__x) {}

      _Result
      operator()(_Arg1 __x, _Arg2 __y) const
      { return _M_ptr(__x, __y); }
    };


  template <class _Arg1, class _Arg2, class _Result>
    inline pointer_to_binary_function<_Arg1, _Arg2, _Result>
    ptr_fun(_Result (*__x)(_Arg1, _Arg2))
    { return pointer_to_binary_function<_Arg1, _Arg2, _Result>(__x); }


  template <class _Tp>
    struct _Identity : public unary_function<_Tp,_Tp>
    {
      _Tp&
      operator()(_Tp& __x) const
      { return __x; }

      const _Tp&
      operator()(const _Tp& __x) const
      { return __x; }
    };

  template <class _Pair>
    struct _Select1st : public unary_function<_Pair,
           typename _Pair::first_type>
    {
      typename _Pair::first_type&
      operator()(_Pair& __x) const
      { return __x.first; }

      const typename _Pair::first_type&
      operator()(const _Pair& __x) const
      { return __x.first; }
    };

  template <class _Pair>
    struct _Select2nd : public unary_function<_Pair,
           typename _Pair::second_type>
    {
      typename _Pair::second_type&
      operator()(_Pair& __x) const
      { return __x.second; }

      const typename _Pair::second_type&
      operator()(const _Pair& __x) const
      { return __x.second; }
    };
# 590 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_function.h" 3
  template <class _Ret, class _Tp>
    class mem_fun_t : public unary_function<_Tp*, _Ret>
    {
    public:
      explicit
      mem_fun_t(_Ret (_Tp::*__pf)())
      : _M_f(__pf) {}

      _Ret
      operator()(_Tp* __p) const
      { return (__p->*_M_f)(); }
    private:
      _Ret (_Tp::*_M_f)();
    };


  template <class _Ret, class _Tp>
    class const_mem_fun_t : public unary_function<const _Tp*, _Ret>
    {
    public:
      explicit
      const_mem_fun_t(_Ret (_Tp::*__pf)() const)
      : _M_f(__pf) {}

      _Ret
      operator()(const _Tp* __p) const
      { return (__p->*_M_f)(); }
    private:
      _Ret (_Tp::*_M_f)() const;
    };


  template <class _Ret, class _Tp>
    class mem_fun_ref_t : public unary_function<_Tp, _Ret>
    {
    public:
      explicit
      mem_fun_ref_t(_Ret (_Tp::*__pf)())
      : _M_f(__pf) {}

      _Ret
      operator()(_Tp& __r) const
      { return (__r.*_M_f)(); }
    private:
      _Ret (_Tp::*_M_f)();
  };


  template <class _Ret, class _Tp>
    class const_mem_fun_ref_t : public unary_function<_Tp, _Ret>
    {
    public:
      explicit
      const_mem_fun_ref_t(_Ret (_Tp::*__pf)() const)
      : _M_f(__pf) {}

      _Ret
      operator()(const _Tp& __r) const
      { return (__r.*_M_f)(); }
    private:
      _Ret (_Tp::*_M_f)() const;
    };


  template <class _Ret, class _Tp, class _Arg>
    class mem_fun1_t : public binary_function<_Tp*, _Arg, _Ret>
    {
    public:
      explicit
      mem_fun1_t(_Ret (_Tp::*__pf)(_Arg))
      : _M_f(__pf) {}

      _Ret
      operator()(_Tp* __p, _Arg __x) const
      { return (__p->*_M_f)(__x); }
    private:
      _Ret (_Tp::*_M_f)(_Arg);
    };


  template <class _Ret, class _Tp, class _Arg>
    class const_mem_fun1_t : public binary_function<const _Tp*, _Arg, _Ret>
    {
    public:
      explicit
      const_mem_fun1_t(_Ret (_Tp::*__pf)(_Arg) const)
      : _M_f(__pf) {}

      _Ret
      operator()(const _Tp* __p, _Arg __x) const
      { return (__p->*_M_f)(__x); }
    private:
      _Ret (_Tp::*_M_f)(_Arg) const;
    };


  template <class _Ret, class _Tp, class _Arg>
    class mem_fun1_ref_t : public binary_function<_Tp, _Arg, _Ret>
    {
    public:
      explicit
      mem_fun1_ref_t(_Ret (_Tp::*__pf)(_Arg))
      : _M_f(__pf) {}

      _Ret
      operator()(_Tp& __r, _Arg __x) const
      { return (__r.*_M_f)(__x); }
    private:
      _Ret (_Tp::*_M_f)(_Arg);
    };


  template <class _Ret, class _Tp, class _Arg>
    class const_mem_fun1_ref_t : public binary_function<_Tp, _Arg, _Ret>
    {
    public:
      explicit
      const_mem_fun1_ref_t(_Ret (_Tp::*__pf)(_Arg) const)
      : _M_f(__pf) {}

      _Ret
      operator()(const _Tp& __r, _Arg __x) const
      { return (__r.*_M_f)(__x); }
    private:
      _Ret (_Tp::*_M_f)(_Arg) const;
    };


  template <class _Tp>
    class mem_fun_t<void, _Tp> : public unary_function<_Tp*, void>
    {
    public:
      explicit
      mem_fun_t(void (_Tp::*__pf)())
      : _M_f(__pf) {}

      void
      operator()(_Tp* __p) const
      { (__p->*_M_f)(); }
    private:
      void (_Tp::*_M_f)();
    };


  template <class _Tp>
    class const_mem_fun_t<void, _Tp> : public unary_function<const _Tp*, void>
    {
    public:
      explicit
      const_mem_fun_t(void (_Tp::*__pf)() const)
      : _M_f(__pf) {}

      void
      operator()(const _Tp* __p) const
      { (__p->*_M_f)(); }
    private:
      void (_Tp::*_M_f)() const;
    };


  template <class _Tp>
    class mem_fun_ref_t<void, _Tp> : public unary_function<_Tp, void>
    {
    public:
      explicit
      mem_fun_ref_t(void (_Tp::*__pf)())
      : _M_f(__pf) {}

      void
      operator()(_Tp& __r) const
      { (__r.*_M_f)(); }
    private:
      void (_Tp::*_M_f)();
    };


  template <class _Tp>
    class const_mem_fun_ref_t<void, _Tp> : public unary_function<_Tp, void>
    {
    public:
      explicit
      const_mem_fun_ref_t(void (_Tp::*__pf)() const)
      : _M_f(__pf) {}

      void
      operator()(const _Tp& __r) const
      { (__r.*_M_f)(); }
    private:
      void (_Tp::*_M_f)() const;
    };


  template <class _Tp, class _Arg>
    class mem_fun1_t<void, _Tp, _Arg> : public binary_function<_Tp*, _Arg, void>
    {
    public:
      explicit
      mem_fun1_t(void (_Tp::*__pf)(_Arg))
      : _M_f(__pf) {}

      void
      operator()(_Tp* __p, _Arg __x) const
      { (__p->*_M_f)(__x); }
    private:
      void (_Tp::*_M_f)(_Arg);
    };


  template <class _Tp, class _Arg>
    class const_mem_fun1_t<void, _Tp, _Arg>
    : public binary_function<const _Tp*, _Arg, void>
    {
    public:
      explicit
      const_mem_fun1_t(void (_Tp::*__pf)(_Arg) const)
      : _M_f(__pf) {}

      void
      operator()(const _Tp* __p, _Arg __x) const
      { (__p->*_M_f)(__x); }
    private:
      void (_Tp::*_M_f)(_Arg) const;
    };


  template <class _Tp, class _Arg>
    class mem_fun1_ref_t<void, _Tp, _Arg>
    : public binary_function<_Tp, _Arg, void>
    {
    public:
      explicit
      mem_fun1_ref_t(void (_Tp::*__pf)(_Arg))
      : _M_f(__pf) {}

      void
      operator()(_Tp& __r, _Arg __x) const
      { (__r.*_M_f)(__x); }
    private:
      void (_Tp::*_M_f)(_Arg);
    };


  template <class _Tp, class _Arg>
    class const_mem_fun1_ref_t<void, _Tp, _Arg>
    : public binary_function<_Tp, _Arg, void>
    {
    public:
      explicit
      const_mem_fun1_ref_t(void (_Tp::*__pf)(_Arg) const)
      : _M_f(__pf) {}

      void
      operator()(const _Tp& __r, _Arg __x) const
      { (__r.*_M_f)(__x); }
    private:
      void (_Tp::*_M_f)(_Arg) const;
    };



  template <class _Ret, class _Tp>
    inline mem_fun_t<_Ret, _Tp>
    mem_fun(_Ret (_Tp::*__f)())
    { return mem_fun_t<_Ret, _Tp>(__f); }

  template <class _Ret, class _Tp>
    inline const_mem_fun_t<_Ret, _Tp>
    mem_fun(_Ret (_Tp::*__f)() const)
    { return const_mem_fun_t<_Ret, _Tp>(__f); }

  template <class _Ret, class _Tp>
    inline mem_fun_ref_t<_Ret, _Tp>
    mem_fun_ref(_Ret (_Tp::*__f)())
    { return mem_fun_ref_t<_Ret, _Tp>(__f); }

  template <class _Ret, class _Tp>
    inline const_mem_fun_ref_t<_Ret, _Tp>
    mem_fun_ref(_Ret (_Tp::*__f)() const)
    { return const_mem_fun_ref_t<_Ret, _Tp>(__f); }

  template <class _Ret, class _Tp, class _Arg>
    inline mem_fun1_t<_Ret, _Tp, _Arg>
    mem_fun(_Ret (_Tp::*__f)(_Arg))
    { return mem_fun1_t<_Ret, _Tp, _Arg>(__f); }

  template <class _Ret, class _Tp, class _Arg>
    inline const_mem_fun1_t<_Ret, _Tp, _Arg>
    mem_fun(_Ret (_Tp::*__f)(_Arg) const)
    { return const_mem_fun1_t<_Ret, _Tp, _Arg>(__f); }

  template <class _Ret, class _Tp, class _Arg>
    inline mem_fun1_ref_t<_Ret, _Tp, _Arg>
    mem_fun_ref(_Ret (_Tp::*__f)(_Arg))
    { return mem_fun1_ref_t<_Ret, _Tp, _Arg>(__f); }

  template <class _Ret, class _Tp, class _Arg>
    inline const_mem_fun1_ref_t<_Ret, _Tp, _Arg>
    mem_fun_ref(_Ret (_Tp::*__f)(_Arg) const)
    { return const_mem_fun1_ref_t<_Ret, _Tp, _Arg>(__f); }



}
# 53 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/string" 2 3
# 1 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/basic_string.h" 1 3
# 43 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/basic_string.h" 3
       
# 44 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/basic_string.h" 3




namespace std
{
# 109 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    class basic_string
    {

    public:
      typedef _Traits traits_type;
      typedef typename _Traits::char_type value_type;
      typedef _Alloc allocator_type;
      typedef typename _Alloc::size_type size_type;
      typedef typename _Alloc::difference_type difference_type;
      typedef typename _Alloc::reference reference;
      typedef typename _Alloc::const_reference const_reference;
      typedef typename _Alloc::pointer pointer;
      typedef typename _Alloc::const_pointer const_pointer;
      typedef __gnu_cxx::__normal_iterator<pointer, basic_string> iterator;
      typedef __gnu_cxx::__normal_iterator<const_pointer, basic_string>
                                                            const_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
      typedef std::reverse_iterator<iterator> reverse_iterator;

    private:
# 144 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/basic_string.h" 3
      struct _Rep_base
      {
 size_type _M_length;
 size_type _M_capacity;
 _Atomic_word _M_refcount;
      };

      struct _Rep : _Rep_base
      {

 typedef typename _Alloc::template rebind<char>::other _Raw_bytes_alloc;
# 169 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/basic_string.h" 3
 static const size_type _S_max_size;
 static const _CharT _S_terminal;



        static size_type _S_empty_rep_storage[];

        static _Rep&
        _S_empty_rep()
        { return *reinterpret_cast<_Rep*>(&_S_empty_rep_storage); }

        bool
 _M_is_leaked() const
        { return this->_M_refcount < 0; }

        bool
 _M_is_shared() const
        { return this->_M_refcount > 0; }

        void
 _M_set_leaked()
        { this->_M_refcount = -1; }

        void
 _M_set_sharable()
        { this->_M_refcount = 0; }

 _CharT*
 _M_refdata() throw()
 { return reinterpret_cast<_CharT*>(this + 1); }

 _CharT*
 _M_grab(const _Alloc& __alloc1, const _Alloc& __alloc2)
 {
   return (!_M_is_leaked() && __alloc1 == __alloc2)
           ? _M_refcopy() : _M_clone(__alloc1);
 }


 static _Rep*
 _S_create(size_type, size_type, const _Alloc&);

 void
 _M_dispose(const _Alloc& __a)
 {
   if (__builtin_expect(this != &_S_empty_rep(), false))
     if (__gnu_cxx::__exchange_and_add(&this->_M_refcount, -1) <= 0)
       _M_destroy(__a);
 }

 void
 _M_destroy(const _Alloc&) throw();

 _CharT*
 _M_refcopy() throw()
 {
   if (__builtin_expect(this != &_S_empty_rep(), false))
            __gnu_cxx::__atomic_add(&this->_M_refcount, 1);
   return _M_refdata();
 }

 _CharT*
 _M_clone(const _Alloc&, size_type __res = 0);
      };


      struct _Alloc_hider : _Alloc
      {
 _Alloc_hider(_CharT* __dat, const _Alloc& __a)
 : _Alloc(__a), _M_p(__dat) { }

 _CharT* _M_p;
      };

    public:





      static const size_type npos = static_cast<size_type>(-1);

    private:

      mutable _Alloc_hider _M_dataplus;

      _CharT*
      _M_data() const
      { return _M_dataplus._M_p; }

      _CharT*
      _M_data(_CharT* __p)
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }



      iterator
      _M_ibegin() const { return iterator(_M_data()); }

      iterator
      _M_iend() const { return iterator(_M_data() + this->size()); }

      void
      _M_leak()
      {
 if (!_M_rep()->_M_is_leaked())
   _M_leak_hard();
      }

      size_type
      _M_check(size_type __pos, const char* __s) const
      {
 if (__pos > this->size())
   __throw_out_of_range((__s));
 return __pos;
      }


      size_type
      _M_limit(size_type __pos, size_type __off) const
      {
 const bool __testoff = __off < this->size() - __pos;
 return __testoff ? __off : this->size() - __pos;
      }



      template<class _Iterator>
        static void
        _S_copy_chars(_CharT* __p, _Iterator __k1, _Iterator __k2)
        {
   for (; __k1 != __k2; ++__k1, ++__p)
     traits_type::assign(*__p, *__k1);
 }

      static void
      _S_copy_chars(_CharT* __p, iterator __k1, iterator __k2)
      { _S_copy_chars(__p, __k1.base(), __k2.base()); }

      static void
      _S_copy_chars(_CharT* __p, const_iterator __k1, const_iterator __k2)
      { _S_copy_chars(__p, __k1.base(), __k2.base()); }

      static void
      _S_copy_chars(_CharT* __p, _CharT* __k1, _CharT* __k2)
      { traits_type::copy(__p, __k1, __k2 - __k1); }

      static void
      _S_copy_chars(_CharT* __p, const _CharT* __k1, const _CharT* __k2)
      { traits_type::copy(__p, __k1, __k2 - __k1); }

      void
      _M_mutate(size_type __pos, size_type __len1, size_type __len2);

      void
      _M_leak_hard();

      static _Rep&
      _S_empty_rep()
      { return _Rep::_S_empty_rep(); }

    public:







      inline
      basic_string();




      explicit
      basic_string(const _Alloc& __a);






      basic_string(const basic_string& __str);






      basic_string(const basic_string& __str, size_type __pos,
     size_type __n = npos);







      basic_string(const basic_string& __str, size_type __pos,
     size_type __n, const _Alloc& __a);
# 384 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/basic_string.h" 3
      basic_string(const _CharT* __s, size_type __n,
     const _Alloc& __a = _Alloc());





      basic_string(const _CharT* __s, const _Alloc& __a = _Alloc());






      basic_string(size_type __n, _CharT __c, const _Alloc& __a = _Alloc());







      template<class _InputIterator>
        basic_string(_InputIterator __beg, _InputIterator __end,
       const _Alloc& __a = _Alloc());




      ~basic_string()
      { _M_rep()->_M_dispose(this->get_allocator()); }





      basic_string&
      operator=(const basic_string& __str)
      {
 this->assign(__str);
 return *this;
      }





      basic_string&
      operator=(const _CharT* __s)
      {
 this->assign(__s);
 return *this;
      }
# 445 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/basic_string.h" 3
      basic_string&
      operator=(_CharT __c)
      {
 this->assign(1, __c);
 return *this;
      }






      iterator
      begin()
      {
 _M_leak();
 return iterator(_M_data());
      }





      const_iterator
      begin() const
      { return const_iterator(_M_data()); }





      iterator
      end()
      {
 _M_leak();
 return iterator(_M_data() + this->size());
      }





      const_iterator
      end() const
      { return const_iterator(_M_data() + this->size()); }






      reverse_iterator
      rbegin()
      { return reverse_iterator(this->end()); }






      const_reverse_iterator
      rbegin() const
      { return const_reverse_iterator(this->end()); }






      reverse_iterator
      rend()
      { return reverse_iterator(this->begin()); }






      const_reverse_iterator
      rend() const
      { return const_reverse_iterator(this->begin()); }

    public:



      size_type
      size() const { return _M_rep()->_M_length; }



      size_type
      length() const { return _M_rep()->_M_length; }


      size_type
      max_size() const { return _Rep::_S_max_size; }
# 553 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/basic_string.h" 3
      void
      resize(size_type __n, _CharT __c);
# 566 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/basic_string.h" 3
      void
      resize(size_type __n) { this->resize(__n, _CharT()); }





      size_type
      capacity() const { return _M_rep()->_M_capacity; }
# 593 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/basic_string.h" 3
      void
      reserve(size_type __res_arg = 0);




      void
      clear() { _M_mutate(0, this->size(), 0); }




      bool
      empty() const { return this->size() == 0; }
# 619 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/basic_string.h" 3
      const_reference
      operator[] (size_type __pos) const
      {
 ;
 return _M_data()[__pos];
      }
# 636 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/basic_string.h" 3
      reference
      operator[](size_type __pos)
      {
 ;
 _M_leak();
 return _M_data()[__pos];
      }
# 654 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/basic_string.h" 3
      const_reference
      at(size_type __n) const
      {
 if (__n >= this->size())
   __throw_out_of_range(("basic_string::at"));
 return _M_data()[__n];
      }
# 673 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/basic_string.h" 3
      reference
      at(size_type __n)
      {
 if (__n >= size())
   __throw_out_of_range(("basic_string::at"));
 _M_leak();
 return _M_data()[__n];
      }







      basic_string&
      operator+=(const basic_string& __str) { return this->append(__str); }






      basic_string&
      operator+=(const _CharT* __s) { return this->append(__s); }






      basic_string&
      operator+=(_CharT __c) { return this->append(size_type(1), __c); }






      basic_string&
      append(const basic_string& __str);
# 727 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/basic_string.h" 3
      basic_string&
      append(const basic_string& __str, size_type __pos, size_type __n);







      basic_string&
      append(const _CharT* __s, size_type __n);






      basic_string&
      append(const _CharT* __s)
      {
 ;
 return this->append(__s, traits_type::length(__s));
      }
# 759 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/basic_string.h" 3
      basic_string&
      append(size_type __n, _CharT __c)
      { return _M_replace_aux(this->size(), size_type(0), __n, __c); }
# 771 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/basic_string.h" 3
      template<class _InputIterator>
        basic_string&
        append(_InputIterator __first, _InputIterator __last)
        { return this->replace(_M_iend(), _M_iend(), __first, __last); }





      void
      push_back(_CharT __c)
      { _M_replace_aux(this->size(), size_type(0), size_type(1), __c); }






      basic_string&
      assign(const basic_string& __str);
# 804 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/basic_string.h" 3
      basic_string&
      assign(const basic_string& __str, size_type __pos, size_type __n)
      { return this->assign(__str._M_data()
       + __str._M_check(__pos, "basic_string::assign"),
       __str._M_limit(__pos, __n)); }
# 820 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/basic_string.h" 3
      basic_string&
      assign(const _CharT* __s, size_type __n);
# 832 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/basic_string.h" 3
      basic_string&
      assign(const _CharT* __s)
      {
 ;
 return this->assign(__s, traits_type::length(__s));
      }
# 848 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/basic_string.h" 3
      basic_string&
      assign(size_type __n, _CharT __c)
      { return _M_replace_aux(size_type(0), this->size(), __n, __c); }
# 860 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/basic_string.h" 3
      template<class _InputIterator>
        basic_string&
        assign(_InputIterator __first, _InputIterator __last)
        { return this->replace(_M_ibegin(), _M_iend(), __first, __last); }
# 877 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/basic_string.h" 3
      void
      insert(iterator __p, size_type __n, _CharT __c)
      { this->replace(__p, __p, __n, __c); }
# 892 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/basic_string.h" 3
      template<class _InputIterator>
        void insert(iterator __p, _InputIterator __beg, _InputIterator __end)
        { this->replace(__p, __p, __beg, __end); }
# 907 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos1, const basic_string& __str)
      { return this->insert(__pos1, __str, size_type(0), __str.size()); }
# 929 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos1, const basic_string& __str,
      size_type __pos2, size_type __n)
      { return this->insert(__pos1, __str._M_data()
       + __str._M_check(__pos2, "basic_string::insert"),
       __str._M_limit(__pos2, __n)); }
# 952 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos, const _CharT* __s, size_type __n);
# 970 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos, const _CharT* __s)
      {
 ;
 return this->insert(__pos, __s, traits_type::length(__s));
      }
# 993 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos, size_type __n, _CharT __c)
      { return _M_replace_aux(_M_check(__pos, "basic_string::insert"),
         size_type(0), __n, __c); }
# 1010 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/basic_string.h" 3
      iterator
      insert(iterator __p, _CharT __c)
      {
 ;
 const size_type __pos = __p - _M_ibegin();
 _M_replace_aux(__pos, size_type(0), size_type(1), __c);
 _M_rep()->_M_set_leaked();
 return this->_M_ibegin() + __pos;
      }
# 1034 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/basic_string.h" 3
      basic_string&
      erase(size_type __pos = 0, size_type __n = npos)
      { return _M_replace_safe(_M_check(__pos, "basic_string::erase"),
          _M_limit(__pos, __n), __null, size_type(0)); }
# 1047 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/basic_string.h" 3
      iterator
      erase(iterator __position)
      {
 ;

 const size_type __pos = __position - _M_ibegin();
 _M_replace_safe(__pos, size_type(1), __null, size_type(0));
 _M_rep()->_M_set_leaked();
 return _M_ibegin() + __pos;
      }
# 1067 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/basic_string.h" 3
      iterator
      erase(iterator __first, iterator __last)
      {
 ;

        const size_type __pos = __first - _M_ibegin();
 _M_replace_safe(__pos, __last - __first, __null, size_type(0));
 _M_rep()->_M_set_leaked();
 return _M_ibegin() + __pos;
      }
# 1094 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos, size_type __n, const basic_string& __str)
      { return this->replace(__pos, __n, __str._M_data(), __str.size()); }
# 1116 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos1, size_type __n1, const basic_string& __str,
       size_type __pos2, size_type __n2)
      { return this->replace(__pos1, __n1, __str._M_data()
        + __str._M_check(__pos2, "basic_string::replace"),
        __str._M_limit(__pos2, __n2)); }
# 1140 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos, size_type __n1, const _CharT* __s,
       size_type __n2);
# 1159 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos, size_type __n1, const _CharT* __s)
      {
 ;
 return this->replace(__pos, __n1, __s, traits_type::length(__s));
      }
# 1182 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos, size_type __n1, size_type __n2, _CharT __c)
      { return _M_replace_aux(_M_check(__pos, "basic_string::replace"),
         _M_limit(__pos, __n1), __n2, __c); }
# 1200 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/basic_string.h" 3
      basic_string&
      replace(iterator __i1, iterator __i2, const basic_string& __str)
      { return this->replace(__i1, __i2, __str._M_data(), __str.size()); }
# 1218 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/basic_string.h" 3
      basic_string&
      replace(iterator __i1, iterator __i2, const _CharT* __s, size_type __n)
      {
 ;

 return this->replace(__i1 - _M_ibegin(), __i2 - __i1, __s, __n);
      }
# 1239 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/basic_string.h" 3
      basic_string&
      replace(iterator __i1, iterator __i2, const _CharT* __s)
      {
 ;
 return this->replace(__i1, __i2, __s, traits_type::length(__s));
      }
# 1260 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/basic_string.h" 3
      basic_string&
      replace(iterator __i1, iterator __i2, size_type __n, _CharT __c)
      {
 ;

 return _M_replace_aux(__i1 - _M_ibegin(), __i2 - __i1, __n, __c);
      }
# 1282 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/basic_string.h" 3
      template<class _InputIterator>
        basic_string&
        replace(iterator __i1, iterator __i2,
  _InputIterator __k1, _InputIterator __k2)
        {
   ;

   ;
   typedef typename _Is_integer<_InputIterator>::_Integral _Integral;
   return _M_replace_dispatch(__i1, __i2, __k1, __k2, _Integral());
 }



      basic_string&
        replace(iterator __i1, iterator __i2, _CharT* __k1, _CharT* __k2)
        {
   ;

   ;
   return this->replace(__i1 - _M_ibegin(), __i2 - __i1,
          __k1, __k2 - __k1);
 }

      basic_string&
        replace(iterator __i1, iterator __i2,
  const _CharT* __k1, const _CharT* __k2)
        {
   ;

   ;
   return this->replace(__i1 - _M_ibegin(), __i2 - __i1,
          __k1, __k2 - __k1);
 }

      basic_string&
        replace(iterator __i1, iterator __i2, iterator __k1, iterator __k2)
        {
   ;

   ;
   return this->replace(__i1 - _M_ibegin(), __i2 - __i1,
          __k1.base(), __k2 - __k1);
 }

      basic_string&
        replace(iterator __i1, iterator __i2,
  const_iterator __k1, const_iterator __k2)
        {
   ;

   ;
   return this->replace(__i1 - _M_ibegin(), __i2 - __i1,
          __k1.base(), __k2 - __k1);
 }

    private:
      template<class _Integer>
 basic_string&
 _M_replace_dispatch(iterator __i1, iterator __i2, _Integer __n,
       _Integer __val, __true_type)
        { return _M_replace_aux(__i1 - _M_ibegin(), __i2 - __i1, __n, __val); }

      template<class _InputIterator>
 basic_string&
 _M_replace_dispatch(iterator __i1, iterator __i2, _InputIterator __k1,
       _InputIterator __k2, __false_type);

      basic_string&
      _M_replace_aux(size_type __pos1, size_type __n1, size_type __n2,
       _CharT __c)
      {
 if (this->max_size() - (this->size() - __n1) < __n2)
   __throw_length_error(("basic_string::_M_replace_aux"));
 _M_mutate(__pos1, __n1, __n2);
 if (__n2 == 1)
   _M_data()[__pos1] = __c;
 else if (__n2)
   traits_type::assign(_M_data() + __pos1, __n2, __c);
 return *this;
      }

      basic_string&
      _M_replace_safe(size_type __pos1, size_type __n1, const _CharT* __s,
        size_type __n2)
      {
 _M_mutate(__pos1, __n1, __n2);
 if (__n2 == 1)
   _M_data()[__pos1] = *__s;
 else if (__n2)
   traits_type::copy(_M_data() + __pos1, __s, __n2);
 return *this;
      }



      template<class _InIterator>
        static _CharT*
        _S_construct_aux(_InIterator __beg, _InIterator __end,
    const _Alloc& __a, __false_type)
 {
          typedef typename iterator_traits<_InIterator>::iterator_category _Tag;
          return _S_construct(__beg, __end, __a, _Tag());
 }

      template<class _InIterator>
        static _CharT*
        _S_construct_aux(_InIterator __beg, _InIterator __end,
    const _Alloc& __a, __true_type)
 { return _S_construct(static_cast<size_type>(__beg),
         static_cast<value_type>(__end), __a); }

      template<class _InIterator>
        static _CharT*
        _S_construct(_InIterator __beg, _InIterator __end, const _Alloc& __a)
 {
   typedef typename _Is_integer<_InIterator>::_Integral _Integral;
   return _S_construct_aux(__beg, __end, __a, _Integral());
        }


      template<class _InIterator>
        static _CharT*
         _S_construct(_InIterator __beg, _InIterator __end, const _Alloc& __a,
        input_iterator_tag);



      template<class _FwdIterator>
        static _CharT*
        _S_construct(_FwdIterator __beg, _FwdIterator __end, const _Alloc& __a,
       forward_iterator_tag);

      static _CharT*
      _S_construct(size_type __req, _CharT __c, const _Alloc& __a);

    public:
# 1431 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/basic_string.h" 3
      size_type
      copy(_CharT* __s, size_type __n, size_type __pos = 0) const;
# 1441 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/basic_string.h" 3
      void
      swap(basic_string& __s);
# 1451 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/basic_string.h" 3
      const _CharT*
      c_str() const { return _M_data(); }







      const _CharT*
      data() const { return _M_data(); }




      allocator_type
      get_allocator() const { return _M_dataplus; }
# 1480 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/basic_string.h" 3
      size_type
      find(const _CharT* __s, size_type __pos, size_type __n) const;
# 1493 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/basic_string.h" 3
      size_type
      find(const basic_string& __str, size_type __pos = 0) const
      { return this->find(__str.data(), __pos, __str.size()); }
# 1507 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/basic_string.h" 3
      size_type
      find(const _CharT* __s, size_type __pos = 0) const
      {
 ;
 return this->find(__s, __pos, traits_type::length(__s));
      }
# 1524 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/basic_string.h" 3
      size_type
      find(_CharT __c, size_type __pos = 0) const;
# 1537 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/basic_string.h" 3
      size_type
      rfind(const basic_string& __str, size_type __pos = npos) const
      { return this->rfind(__str.data(), __pos, __str.size()); }
# 1552 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/basic_string.h" 3
      size_type
      rfind(const _CharT* __s, size_type __pos, size_type __n) const;
# 1565 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/basic_string.h" 3
      size_type
      rfind(const _CharT* __s, size_type __pos = npos) const
      {
 ;
 return this->rfind(__s, __pos, traits_type::length(__s));
      }
# 1582 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/basic_string.h" 3
      size_type
      rfind(_CharT __c, size_type __pos = npos) const;
# 1595 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/basic_string.h" 3
      size_type
      find_first_of(const basic_string& __str, size_type __pos = 0) const
      { return this->find_first_of(__str.data(), __pos, __str.size()); }
# 1610 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/basic_string.h" 3
      size_type
      find_first_of(const _CharT* __s, size_type __pos, size_type __n) const;
# 1623 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/basic_string.h" 3
      size_type
      find_first_of(const _CharT* __s, size_type __pos = 0) const
      {
 ;
 return this->find_first_of(__s, __pos, traits_type::length(__s));
      }
# 1642 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/basic_string.h" 3
      size_type
      find_first_of(_CharT __c, size_type __pos = 0) const
      { return this->find(__c, __pos); }
# 1656 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/basic_string.h" 3
      size_type
      find_last_of(const basic_string& __str, size_type __pos = npos) const
      { return this->find_last_of(__str.data(), __pos, __str.size()); }
# 1671 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/basic_string.h" 3
      size_type
      find_last_of(const _CharT* __s, size_type __pos, size_type __n) const;
# 1684 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/basic_string.h" 3
      size_type
      find_last_of(const _CharT* __s, size_type __pos = npos) const
      {
 ;
 return this->find_last_of(__s, __pos, traits_type::length(__s));
      }
# 1703 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/basic_string.h" 3
      size_type
      find_last_of(_CharT __c, size_type __pos = npos) const
      { return this->rfind(__c, __pos); }
# 1717 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/basic_string.h" 3
      size_type
      find_first_not_of(const basic_string& __str, size_type __pos = 0) const
      { return this->find_first_not_of(__str.data(), __pos, __str.size()); }
# 1732 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/basic_string.h" 3
      size_type
      find_first_not_of(const _CharT* __s, size_type __pos,
   size_type __n) const;
# 1746 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/basic_string.h" 3
      size_type
      find_first_not_of(const _CharT* __s, size_type __pos = 0) const
      {
 ;
 return this->find_first_not_of(__s, __pos, traits_type::length(__s));
      }
# 1763 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/basic_string.h" 3
      size_type
      find_first_not_of(_CharT __c, size_type __pos = 0) const;
# 1776 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/basic_string.h" 3
      size_type
      find_last_not_of(const basic_string& __str, size_type __pos = npos) const
      { return this->find_last_not_of(__str.data(), __pos, __str.size()); }
# 1792 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/basic_string.h" 3
      size_type
      find_last_not_of(const _CharT* __s, size_type __pos,
         size_type __n) const;
# 1805 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/basic_string.h" 3
      size_type
      find_last_not_of(const _CharT* __s, size_type __pos = npos) const
      {
 ;
 return this->find_last_not_of(__s, __pos, traits_type::length(__s));
      }
# 1822 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/basic_string.h" 3
      size_type
      find_last_not_of(_CharT __c, size_type __pos = npos) const;
# 1837 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/basic_string.h" 3
      basic_string
      substr(size_type __pos = 0, size_type __n = npos) const
      { return basic_string(*this,
       _M_check(__pos, "basic_string::substr"), __n); }
# 1853 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/basic_string.h" 3
      int
      compare(const basic_string& __str) const
      {
 const size_type __size = this->size();
 const size_type __osize = __str.size();
 const size_type __len = std::min(__size, __osize);

 int __r = traits_type::compare(_M_data(), __str.data(), __len);
 if (!__r)
   __r = __size - __osize;
 return __r;
      }
# 1881 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/basic_string.h" 3
      int
      compare(size_type __pos, size_type __n, const basic_string& __str) const;
# 1903 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/basic_string.h" 3
      int
      compare(size_type __pos1, size_type __n1, const basic_string& __str,
       size_type __pos2, size_type __n2) const;
# 1918 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/basic_string.h" 3
      int
      compare(const _CharT* __s) const;
# 1938 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/basic_string.h" 3
      int
      compare(size_type __pos, size_type __n1, const _CharT* __s) const;
# 1961 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/basic_string.h" 3
      int
      compare(size_type __pos, size_type __n1, const _CharT* __s,
       size_type __n2) const;
  };


  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>::
    basic_string()
    : _M_dataplus(_S_empty_rep()._M_refdata(), _Alloc()) { }
# 1979 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    {
      basic_string<_CharT, _Traits, _Alloc> __str(__lhs);
      __str.append(__rhs);
      return __str;
    }







  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT,_Traits,_Alloc>
    operator+(const _CharT* __lhs,
       const basic_string<_CharT,_Traits,_Alloc>& __rhs);







  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT,_Traits,_Alloc>
    operator+(_CharT __lhs, const basic_string<_CharT,_Traits,_Alloc>& __rhs);







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
      const _CharT* __rhs)
    {
      basic_string<_CharT, _Traits, _Alloc> __str(__lhs);
      __str.append(__rhs);
      return __str;
    }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs, _CharT __rhs)
    {
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;
      __string_type __str(__lhs);
      __str.append(__size_type(1), __rhs);
      return __str;
    }
# 2050 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __lhs.compare(__rhs) == 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator==(const _CharT* __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) == 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return __lhs.compare(__rhs) == 0; }
# 2087 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) != 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator!=(const _CharT* __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) != 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return __lhs.compare(__rhs) != 0; }
# 2124 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __lhs.compare(__rhs) < 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const _CharT* __rhs)
    { return __lhs.compare(__rhs) < 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<(const _CharT* __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) > 0; }
# 2161 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __lhs.compare(__rhs) > 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const _CharT* __rhs)
    { return __lhs.compare(__rhs) > 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>(const _CharT* __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) < 0; }
# 2198 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __lhs.compare(__rhs) <= 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return __lhs.compare(__rhs) <= 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<=(const _CharT* __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
  { return __rhs.compare(__lhs) >= 0; }
# 2235 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __lhs.compare(__rhs) >= 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return __lhs.compare(__rhs) >= 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>=(const _CharT* __lhs,
      const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) <= 0; }
# 2272 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline void
    swap(basic_string<_CharT, _Traits, _Alloc>& __lhs,
  basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { __lhs.swap(__rhs); }
# 2289 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is,
        basic_string<_CharT, _Traits, _Alloc>& __str);
# 2303 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os,
        const basic_string<_CharT, _Traits, _Alloc>& __str);
# 2321 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT,_Traits>&
    getline(basic_istream<_CharT, _Traits>& __is,
     basic_string<_CharT, _Traits, _Alloc>& __str, _CharT __delim);
# 2338 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_istream<_CharT,_Traits>&
    getline(basic_istream<_CharT, _Traits>& __is,
     basic_string<_CharT, _Traits, _Alloc>& __str);
}
# 54 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/string" 2 3


# 1 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/algorithm" 1 3
# 64 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/algorithm" 3
       
# 65 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/algorithm" 3




# 1 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_algo.h" 1 3
# 64 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_algo.h" 3
# 1 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_heap.h" 1 3
# 65 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_heap.h" 3
namespace std
{



  template<typename _RandomAccessIterator, typename _Distance>
    bool
    __is_heap(_RandomAccessIterator __first, _Distance __n)
    {
      _Distance __parent = 0;
      for (_Distance __child = 1; __child < __n; ++__child)
 {
   if (__first[__parent] < __first[__child])
     return false;
   if ((__child & 1) == 0)
     ++__parent;
 }
      return true;
    }

  template<typename _RandomAccessIterator, typename _Distance,
           typename _StrictWeakOrdering>
    bool
    __is_heap(_RandomAccessIterator __first, _StrictWeakOrdering __comp,
       _Distance __n)
    {
      _Distance __parent = 0;
      for (_Distance __child = 1; __child < __n; ++__child)
 {
   if (__comp(__first[__parent], __first[__child]))
     return false;
   if ((__child & 1) == 0)
     ++__parent;
 }
      return true;
    }

  template<typename _RandomAccessIterator>
    bool
    __is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    { return std::__is_heap(__first, std::distance(__first, __last)); }

  template<typename _RandomAccessIterator, typename _StrictWeakOrdering>
    bool
    __is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
     _StrictWeakOrdering __comp)
    { return std::__is_heap(__first, __comp, std::distance(__first, __last)); }



  template<typename _RandomAccessIterator, typename _Distance, typename _Tp>
    void
    __push_heap(_RandomAccessIterator __first,
  _Distance __holeIndex, _Distance __topIndex, _Tp __value)
    {
      _Distance __parent = (__holeIndex - 1) / 2;
      while (__holeIndex > __topIndex && *(__first + __parent) < __value)
 {
   *(__first + __holeIndex) = *(__first + __parent);
   __holeIndex = __parent;
   __parent = (__holeIndex - 1) / 2;
 }
      *(__first + __holeIndex) = __value;
    }
# 139 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator>
    inline void
    push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
   _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
   _DistanceType;


     

     
      ;


      std::__push_heap(__first, _DistanceType((__last - __first) - 1),
         _DistanceType(0), _ValueType(*(__last - 1)));
    }

  template<typename _RandomAccessIterator, typename _Distance, typename _Tp,
     typename _Compare>
    void
    __push_heap(_RandomAccessIterator __first, _Distance __holeIndex,
  _Distance __topIndex, _Tp __value, _Compare __comp)
    {
      _Distance __parent = (__holeIndex - 1) / 2;
      while (__holeIndex > __topIndex
      && __comp(*(__first + __parent), __value))
 {
   *(__first + __holeIndex) = *(__first + __parent);
   __holeIndex = __parent;
   __parent = (__holeIndex - 1) / 2;
 }
      *(__first + __holeIndex) = __value;
    }
# 187 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
       _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
   _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
   _DistanceType;


     

      ;
      ;

      std::__push_heap(__first, _DistanceType((__last - __first) - 1),
         _DistanceType(0), _ValueType(*(__last - 1)), __comp);
    }

  template<typename _RandomAccessIterator, typename _Distance, typename _Tp>
    void
    __adjust_heap(_RandomAccessIterator __first, _Distance __holeIndex,
    _Distance __len, _Tp __value)
    {
      const _Distance __topIndex = __holeIndex;
      _Distance __secondChild = 2 * __holeIndex + 2;
      while (__secondChild < __len)
 {
   if (*(__first + __secondChild) < *(__first + (__secondChild - 1)))
     __secondChild--;
   *(__first + __holeIndex) = *(__first + __secondChild);
   __holeIndex = __secondChild;
   __secondChild = 2 * (__secondChild + 1);
 }
      if (__secondChild == __len)
 {
   *(__first + __holeIndex) = *(__first + (__secondChild - 1));
   __holeIndex = __secondChild - 1;
 }
      std::__push_heap(__first, __holeIndex, __topIndex, __value);
    }

  template<typename _RandomAccessIterator, typename _Tp>
    inline void
    __pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
        _RandomAccessIterator __result, _Tp __value)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _Distance;
      *__result = *__first;
      std::__adjust_heap(__first, _Distance(0), _Distance(__last - __first),
    __value);
    }
# 251 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator>
    inline void
    pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;


     

     
      ;
      ;

      std::__pop_heap(__first, __last - 1, __last - 1,
        _ValueType(*(__last - 1)));
    }

  template<typename _RandomAccessIterator, typename _Distance,
    typename _Tp, typename _Compare>
    void
    __adjust_heap(_RandomAccessIterator __first, _Distance __holeIndex,
    _Distance __len, _Tp __value, _Compare __comp)
    {
      const _Distance __topIndex = __holeIndex;
      _Distance __secondChild = 2 * __holeIndex + 2;
      while (__secondChild < __len)
 {
   if (__comp(*(__first + __secondChild),
       *(__first + (__secondChild - 1))))
     __secondChild--;
   *(__first + __holeIndex) = *(__first + __secondChild);
   __holeIndex = __secondChild;
   __secondChild = 2 * (__secondChild + 1);
 }
      if (__secondChild == __len)
 {
   *(__first + __holeIndex) = *(__first + (__secondChild - 1));
   __holeIndex = __secondChild - 1;
 }
      std::__push_heap(__first, __holeIndex, __topIndex, __value, __comp);
    }

  template<typename _RandomAccessIterator, typename _Tp, typename _Compare>
    inline void
    __pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
        _RandomAccessIterator __result, _Tp __value, _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _Distance;
      *__result = *__first;
      std::__adjust_heap(__first, _Distance(0), _Distance(__last - __first),
    __value, __comp);
    }
# 317 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    pop_heap(_RandomAccessIterator __first,
      _RandomAccessIterator __last, _Compare __comp)
    {

     

      ;
      ;

      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;
      std::__pop_heap(__first, __last - 1, __last - 1,
        _ValueType(*(__last - 1)), __comp);
    }
# 342 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator>
    void
    make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
   _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
   _DistanceType;


     

     
      ;

      if (__last - __first < 2)
 return;

      const _DistanceType __len = __last - __first;
      _DistanceType __parent = (__len - 2) / 2;
      while (true)
 {
   std::__adjust_heap(__first, __parent, __len,
        _ValueType(*(__first + __parent)));
   if (__parent == 0)
     return;
   __parent--;
 }
    }
# 382 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
       _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
   _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
   _DistanceType;


     

      ;

      if (__last - __first < 2)
 return;

      const _DistanceType __len = __last - __first;
      _DistanceType __parent = (__len - 2) / 2;
      while (true)
 {
   std::__adjust_heap(__first, __parent, __len,
        _ValueType(*(__first + __parent)), __comp);
   if (__parent == 0)
     return;
   __parent--;
 }
    }
# 420 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator>
    void
    sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {

     

     

      ;


      while (__last - __first > 1)
 std::pop_heap(__first, __last--);
    }
# 446 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    void
    sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
       _Compare __comp)
    {

     

      ;
      ;

      while (__last - __first > 1)
 std::pop_heap(__first, __last--, __comp);
    }

}
# 65 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_algo.h" 2 3
# 1 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_tempbuf.h" 1 3
# 66 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_tempbuf.h" 3
namespace std
{







  template<typename _ForwardIterator, typename _Tp>
    class _Temporary_buffer
    {

     

 public:
      typedef _Tp value_type;
      typedef value_type* pointer;
      typedef pointer iterator;
      typedef ptrdiff_t size_type;

    protected:
      size_type _M_original_len;
      size_type _M_len;
      pointer _M_buffer;

      void
      _M_initialize_buffer(const _Tp&, __true_type) { }

      void
      _M_initialize_buffer(const _Tp& val, __false_type)
      { std::uninitialized_fill_n(_M_buffer, _M_len, val); }

    public:

      size_type
      size() const
      { return _M_len; }


      size_type
      requested_size() const
      { return _M_original_len; }


      iterator
      begin()
      { return _M_buffer; }


      iterator
      end()
      { return _M_buffer + _M_len; }





      _Temporary_buffer(_ForwardIterator __first, _ForwardIterator __last);

      ~_Temporary_buffer()
      {
 std::_Destroy(_M_buffer, _M_buffer + _M_len);
 std::return_temporary_buffer(_M_buffer);
      }

    private:

      _Temporary_buffer(const _Temporary_buffer&);

      void
      operator=(const _Temporary_buffer&);
    };


  template<typename _ForwardIterator, typename _Tp>
    _Temporary_buffer<_ForwardIterator, _Tp>::
    _Temporary_buffer(_ForwardIterator __first, _ForwardIterator __last)
    : _M_original_len(std::distance(__first, __last)),
      _M_len(0), _M_buffer(0)
    {

      typedef typename __type_traits<_Tp>::has_trivial_default_constructor
       _Trivial;

      try
 {
   pair<pointer, size_type> __p(get_temporary_buffer<
           value_type>(_M_original_len));
   _M_buffer = __p.first;
   _M_len = __p.second;
   if (_M_len > 0)
     _M_initialize_buffer(*__first, _Trivial());
 }
      catch(...)
 {
   std::return_temporary_buffer(_M_buffer);
   _M_buffer = 0;
   _M_len = 0;
   throw;
 }
    }
}
# 66 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_algo.h" 2 3




namespace std
{
# 84 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_algo.h" 3
  template<typename _Tp>
    inline const _Tp&
    __median(const _Tp& __a, const _Tp& __b, const _Tp& __c)
    {

     
      if (__a < __b)
 if (__b < __c)
   return __b;
 else if (__a < __c)
   return __c;
 else
   return __a;
      else if (__a < __c)
 return __a;
      else if (__b < __c)
 return __c;
      else
 return __b;
    }
# 118 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_algo.h" 3
  template<typename _Tp, typename _Compare>
    inline const _Tp&
    __median(const _Tp& __a, const _Tp& __b, const _Tp& __c, _Compare __comp)
    {

     
      if (__comp(__a, __b))
 if (__comp(__b, __c))
   return __b;
 else if (__comp(__a, __c))
   return __c;
 else
   return __a;
      else if (__comp(__a, __c))
 return __a;
      else if (__comp(__b, __c))
 return __c;
      else
 return __b;
    }
# 150 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Function>
    _Function
    for_each(_InputIterator __first, _InputIterator __last, _Function __f)
    {

     
      ;
      for ( ; __first != __last; ++__first)
 __f(*__first);
      return __f;
    }






  template<typename _InputIterator, typename _Tp>
    inline _InputIterator
    find(_InputIterator __first, _InputIterator __last,
  const _Tp& __val, input_iterator_tag)
    {
      while (__first != __last && !(*__first == __val))
 ++__first;
      return __first;
    }






  template<typename _InputIterator, typename _Predicate>
    inline _InputIterator
    find_if(_InputIterator __first, _InputIterator __last,
     _Predicate __pred, input_iterator_tag)
    {
      while (__first != __last && !__pred(*__first))
 ++__first;
      return __first;
    }






  template<typename _RandomAccessIterator, typename _Tp>
    _RandomAccessIterator
    find(_RandomAccessIterator __first, _RandomAccessIterator __last,
  const _Tp& __val, random_access_iterator_tag)
    {
      typename iterator_traits<_RandomAccessIterator>::difference_type
 __trip_count = (__last - __first) >> 2;

      for ( ; __trip_count > 0 ; --__trip_count)
 {
   if (*__first == __val)
     return __first;
   ++__first;

   if (*__first == __val)
     return __first;
   ++__first;

   if (*__first == __val)
     return __first;
   ++__first;

   if (*__first == __val)
     return __first;
   ++__first;
 }

      switch (__last - __first)
 {
 case 3:
   if (*__first == __val)
     return __first;
   ++__first;
 case 2:
   if (*__first == __val)
     return __first;
   ++__first;
 case 1:
   if (*__first == __val)
     return __first;
   ++__first;
 case 0:
 default:
   return __last;
 }
    }






  template<typename _RandomAccessIterator, typename _Predicate>
    _RandomAccessIterator
    find_if(_RandomAccessIterator __first, _RandomAccessIterator __last,
     _Predicate __pred, random_access_iterator_tag)
    {
      typename iterator_traits<_RandomAccessIterator>::difference_type
 __trip_count = (__last - __first) >> 2;

      for ( ; __trip_count > 0 ; --__trip_count)
 {
   if (__pred(*__first))
     return __first;
   ++__first;

   if (__pred(*__first))
     return __first;
   ++__first;

   if (__pred(*__first))
     return __first;
   ++__first;

   if (__pred(*__first))
     return __first;
   ++__first;
 }

      switch (__last - __first)
 {
 case 3:
   if (__pred(*__first))
     return __first;
   ++__first;
 case 2:
   if (__pred(*__first))
     return __first;
   ++__first;
 case 1:
   if (__pred(*__first))
     return __first;
   ++__first;
 case 0:
 default:
   return __last;
 }
    }
# 304 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Tp>
    inline _InputIterator
    find(_InputIterator __first, _InputIterator __last,
  const _Tp& __val)
    {

     
     

      ;
      return std::find(__first, __last, __val,
         std::__iterator_category(__first));
    }
# 326 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Predicate>
    inline _InputIterator
    find_if(_InputIterator __first, _InputIterator __last,
     _Predicate __pred)
    {

     
     

      ;
      return std::find_if(__first, __last, __pred,
     std::__iterator_category(__first));
    }
# 348 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_algo.h" 3
  template<typename _ForwardIterator>
    _ForwardIterator
    adjacent_find(_ForwardIterator __first, _ForwardIterator __last)
    {

     
     

      ;
      if (__first == __last)
 return __last;
      _ForwardIterator __next = __first;
      while(++__next != __last)
 {
   if (*__first == *__next)
     return __first;
   __first = __next;
 }
      return __last;
    }
# 379 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _BinaryPredicate>
    _ForwardIterator
    adjacent_find(_ForwardIterator __first, _ForwardIterator __last,
    _BinaryPredicate __binary_pred)
    {

     
     


      ;
      if (__first == __last)
 return __last;
      _ForwardIterator __next = __first;
      while(++__next != __last)
 {
   if (__binary_pred(*__first, *__next))
     return __first;
   __first = __next;
 }
      return __last;
    }
# 410 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Tp>
    typename iterator_traits<_InputIterator>::difference_type
    count(_InputIterator __first, _InputIterator __last, const _Tp& __value)
    {

     
     

     
      ;
      typename iterator_traits<_InputIterator>::difference_type __n = 0;
      for ( ; __first != __last; ++__first)
 if (*__first == __value)
   ++__n;
      return __n;
    }
# 435 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Predicate>
    typename iterator_traits<_InputIterator>::difference_type
    count_if(_InputIterator __first, _InputIterator __last, _Predicate __pred)
    {

     
     

      ;
      typename iterator_traits<_InputIterator>::difference_type __n = 0;
      for ( ; __first != __last; ++__first)
 if (__pred(*__first))
   ++__n;
      return __n;
    }
# 474 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    _ForwardIterator1
    search(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
    _ForwardIterator2 __first2, _ForwardIterator2 __last2)
    {

     
     
     


      ;
      ;

      if (__first1 == __last1 || __first2 == __last2)
 return __first1;


      _ForwardIterator2 __tmp(__first2);
      ++__tmp;
      if (__tmp == __last2)
 return std::find(__first1, __last1, *__first2);


      _ForwardIterator2 __p1, __p;
      __p1 = __first2; ++__p1;
      _ForwardIterator1 __current = __first1;

      while (__first1 != __last1)
 {
   __first1 = std::find(__first1, __last1, *__first2);
   if (__first1 == __last1)
     return __last1;

   __p = __p1;
   __current = __first1;
   if (++__current == __last1)
     return __last1;

   while (*__current == *__p)
     {
       if (++__p == __last2)
  return __first1;
       if (++__current == __last1)
  return __last1;
     }
   ++__first1;
 }
      return __first1;
    }
# 545 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
    _ForwardIterator1
    search(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
    _ForwardIterator2 __first2, _ForwardIterator2 __last2,
    _BinaryPredicate __predicate)
    {

     
     
     


      ;
      ;


      if (__first1 == __last1 || __first2 == __last2)
 return __first1;


      _ForwardIterator2 __tmp(__first2);
      ++__tmp;
      if (__tmp == __last2)
 {
   while (__first1 != __last1 && !__predicate(*__first1, *__first2))
     ++__first1;
   return __first1;
 }


      _ForwardIterator2 __p1, __p;
      __p1 = __first2; ++__p1;
      _ForwardIterator1 __current = __first1;

      while (__first1 != __last1)
 {
   while (__first1 != __last1)
     {
       if (__predicate(*__first1, *__first2))
  break;
       ++__first1;
     }
   while (__first1 != __last1 && !__predicate(*__first1, *__first2))
     ++__first1;
   if (__first1 == __last1)
     return __last1;

   __p = __p1;
   __current = __first1;
   if (++__current == __last1)
     return __last1;

   while (__predicate(*__current, *__p))
     {
       if (++__p == __last2)
  return __first1;
       if (++__current == __last1)
  return __last1;
     }
   ++__first1;
 }
      return __first1;
    }
# 623 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Integer, typename _Tp>
    _ForwardIterator
    search_n(_ForwardIterator __first, _ForwardIterator __last,
      _Integer __count, const _Tp& __val)
    {

     
     

     
      ;

      if (__count <= 0)
 return __first;
      else
 {
   __first = std::find(__first, __last, __val);
   while (__first != __last)
     {
       typename iterator_traits<_ForwardIterator>::difference_type
  __n = __count;
       _ForwardIterator __i = __first;
       ++__i;
       while (__i != __last && __n != 1 && *__i == __val)
  {
    ++__i;
    --__n;
  }
       if (__n == 1)
  return __first;
       else
  __first = std::find(__i, __last, __val);
     }
   return __last;
 }
    }
# 675 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Integer, typename _Tp,
           typename _BinaryPredicate>
    _ForwardIterator
    search_n(_ForwardIterator __first, _ForwardIterator __last,
      _Integer __count, const _Tp& __val,
      _BinaryPredicate __binary_pred)
    {

     
     

      ;

      if (__count <= 0)
 return __first;
      else
 {
   while (__first != __last)
     {
       if (__binary_pred(*__first, __val))
  break;
       ++__first;
     }
   while (__first != __last)
     {
       typename iterator_traits<_ForwardIterator>::difference_type
  __n = __count;
       _ForwardIterator __i = __first;
       ++__i;
       while (__i != __last && __n != 1 && __binary_pred(*__i, __val))
  {
    ++__i;
    --__n;
  }
       if (__n == 1)
  return __first;
       else
  {
    while (__i != __last)
      {
        if (__binary_pred(*__i, __val))
   break;
        ++__i;
      }
    __first = __i;
  }
     }
   return __last;
 }
    }
# 737 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    _ForwardIterator2
    swap_ranges(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
  _ForwardIterator2 __first2)
    {

     

     

     


     


      ;

      for ( ; __first1 != __last1; ++__first1, ++__first2)
 std::iter_swap(__first1, __first2);
      return __first2;
    }
# 775 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator,
    typename _UnaryOperation>
    _OutputIterator
    transform(_InputIterator __first, _InputIterator __last,
       _OutputIterator __result, _UnaryOperation __unary_op)
    {

     
     


      ;

      for ( ; __first != __last; ++__first, ++__result)
 *__result = __unary_op(*__first);
      return __result;
    }
# 810 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _BinaryOperation>
    _OutputIterator
    transform(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _OutputIterator __result,
       _BinaryOperation __binary_op)
    {

     
     
     


      ;

      for ( ; __first1 != __last1; ++__first1, ++__first2, ++__result)
 *__result = __binary_op(*__first1, *__first2);
      return __result;
    }
# 842 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp>
    void
    replace(_ForwardIterator __first, _ForwardIterator __last,
     const _Tp& __old_value, const _Tp& __new_value)
    {

     

     

     

      ;

      for ( ; __first != __last; ++__first)
 if (*__first == __old_value)
   *__first = __new_value;
    }
# 873 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Predicate, typename _Tp>
    void
    replace_if(_ForwardIterator __first, _ForwardIterator __last,
        _Predicate __pred, const _Tp& __new_value)
    {

     

     

     

      ;

      for ( ; __first != __last; ++__first)
 if (__pred(*__first))
   *__first = __new_value;
    }
# 906 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator, typename _Tp>
    _OutputIterator
    replace_copy(_InputIterator __first, _InputIterator __last,
   _OutputIterator __result,
   const _Tp& __old_value, const _Tp& __new_value)
    {

     
     

     

      ;

      for ( ; __first != __last; ++__first, ++__result)
 *__result = *__first == __old_value ? __new_value : *__first;
      return __result;
    }
# 939 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator,
    typename _Predicate, typename _Tp>
    _OutputIterator
    replace_copy_if(_InputIterator __first, _InputIterator __last,
      _OutputIterator __result,
      _Predicate __pred, const _Tp& __new_value)
    {

     
     

     

      ;

      for ( ; __first != __last; ++__first, ++__result)
 *__result = __pred(*__first) ? __new_value : *__first;
      return __result;
    }
# 970 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Generator>
    void
    generate(_ForwardIterator __first, _ForwardIterator __last,
      _Generator __gen)
    {

     
     

      ;

      for ( ; __first != __last; ++__first)
 *__first = __gen();
    }
# 996 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_algo.h" 3
  template<typename _OutputIterator, typename _Size, typename _Generator>
    _OutputIterator
    generate_n(_OutputIterator __first, _Size __n, _Generator __gen)
    {

     



      for ( ; __n > 0; --__n, ++__first)
 *__first = __gen();
      return __first;
    }
# 1023 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator, typename _Tp>
    _OutputIterator
    remove_copy(_InputIterator __first, _InputIterator __last,
  _OutputIterator __result, const _Tp& __value)
    {

     
     

     

      ;

      for ( ; __first != __last; ++__first)
 if (!(*__first == __value))
   {
     *__result = *__first;
     ++__result;
   }
      return __result;
    }
# 1059 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator,
    typename _Predicate>
    _OutputIterator
    remove_copy_if(_InputIterator __first, _InputIterator __last,
     _OutputIterator __result, _Predicate __pred)
    {

     
     

     

      ;

      for ( ; __first != __last; ++__first)
 if (!__pred(*__first))
   {
     *__result = *__first;
     ++__result;
   }
      return __result;
    }
# 1098 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp>
    _ForwardIterator
    remove(_ForwardIterator __first, _ForwardIterator __last,
    const _Tp& __value)
    {

     

     

     

      ;

      __first = std::find(__first, __last, __value);
      _ForwardIterator __i = __first;
      return __first == __last ? __first
          : std::remove_copy(++__i, __last,
        __first, __value);
    }
# 1135 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Predicate>
    _ForwardIterator
    remove_if(_ForwardIterator __first, _ForwardIterator __last,
       _Predicate __pred)
    {

     

     

      ;

      __first = std::find_if(__first, __last, __pred);
      _ForwardIterator __i = __first;
      return __first == __last ? __first
          : std::remove_copy_if(++__i, __last,
           __first, __pred);
    }
# 1161 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator>
    _OutputIterator
    __unique_copy(_InputIterator __first, _InputIterator __last,
    _OutputIterator __result,
    output_iterator_tag)
    {

      typename iterator_traits<_InputIterator>::value_type __value = *__first;
      *__result = __value;
      while (++__first != __last)
 if (!(__value == *__first))
   {
     __value = *__first;
     *++__result = __value;
   }
      return ++__result;
    }
# 1186 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _ForwardIterator>
    _ForwardIterator
    __unique_copy(_InputIterator __first, _InputIterator __last,
    _ForwardIterator __result,
    forward_iterator_tag)
    {

      *__result = *__first;
      while (++__first != __last)
 if (!(*__result == *__first))
   *++__result = *__first;
      return ++__result;
    }
# 1208 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator,
    typename _BinaryPredicate>
    _OutputIterator
    __unique_copy(_InputIterator __first, _InputIterator __last,
    _OutputIterator __result,
    _BinaryPredicate __binary_pred,
    output_iterator_tag)
    {

     



      typename iterator_traits<_InputIterator>::value_type __value = *__first;
      *__result = __value;
      while (++__first != __last)
 if (!__binary_pred(__value, *__first))
   {
     __value = *__first;
     *++__result = __value;
   }
      return ++__result;
    }
# 1240 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _ForwardIterator,
    typename _BinaryPredicate>
    _ForwardIterator
    __unique_copy(_InputIterator __first, _InputIterator __last,
    _ForwardIterator __result,
    _BinaryPredicate __binary_pred,
    forward_iterator_tag)
    {

     



      *__result = *__first;
      while (++__first != __last)
 if (!__binary_pred(*__result, *__first)) *++__result = *__first;
      return ++__result;
    }
# 1272 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator>
    inline _OutputIterator
    unique_copy(_InputIterator __first, _InputIterator __last,
  _OutputIterator __result)
    {

     
     

     

      ;

      typedef typename iterator_traits<_OutputIterator>::iterator_category
 _IterType;

      if (__first == __last) return __result;
      return std::__unique_copy(__first, __last, __result, _IterType());
    }
# 1307 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator,
    typename _BinaryPredicate>
    inline _OutputIterator
    unique_copy(_InputIterator __first, _InputIterator __last,
  _OutputIterator __result,
  _BinaryPredicate __binary_pred)
    {

     
     

      ;

      typedef typename iterator_traits<_OutputIterator>::iterator_category
 _IterType;

      if (__first == __last) return __result;
      return std::__unique_copy(__first, __last, __result,
    __binary_pred, _IterType());
    }
# 1341 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_algo.h" 3
  template<typename _ForwardIterator>
    _ForwardIterator
    unique(_ForwardIterator __first, _ForwardIterator __last)
    {

     

     

      ;


      __first = std::adjacent_find(__first, __last);
      if (__first == __last)
 return __last;


      _ForwardIterator __dest = __first;
      ++__first;
      while (++__first != __last)
 if (!(*__dest == *__first))
   *++__dest = *__first;
      return ++__dest;
    }
# 1380 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _BinaryPredicate>
    _ForwardIterator
    unique(_ForwardIterator __first, _ForwardIterator __last,
           _BinaryPredicate __binary_pred)
    {

     

     


      ;


      __first = std::adjacent_find(__first, __last, __binary_pred);
      if (__first == __last)
 return __last;


      _ForwardIterator __dest = __first;
      ++__first;
      while (++__first != __last)
 if (!__binary_pred(*__dest, *__first))
   *++__dest = *__first;
      return ++__dest;
    }
# 1414 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator>
    void
    __reverse(_BidirectionalIterator __first, _BidirectionalIterator __last,
     bidirectional_iterator_tag)
    {
      while (true)
 if (__first == __last || __first == --__last)
   return;
 else
   std::iter_swap(__first++, __last);
    }
# 1433 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator>
    void
    __reverse(_RandomAccessIterator __first, _RandomAccessIterator __last,
     random_access_iterator_tag)
    {
      while (__first < __last)
 std::iter_swap(__first++, --__last);
    }
# 1453 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator>
    inline void
    reverse(_BidirectionalIterator __first, _BidirectionalIterator __last)
    {

     

      ;
      std::__reverse(__first, __last, std::__iterator_category(__first));
    }
# 1479 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator, typename _OutputIterator>
    _OutputIterator
    reverse_copy(_BidirectionalIterator __first, _BidirectionalIterator __last,
        _OutputIterator __result)
    {

     

     

      ;

      while (__first != __last)
 {
   --__last;
   *__result = *__last;
   ++__result;
 }
      return __result;
    }
# 1507 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_algo.h" 3
  template<typename _EuclideanRingElement>
    _EuclideanRingElement
    __gcd(_EuclideanRingElement __m, _EuclideanRingElement __n)
    {
      while (__n != 0)
 {
   _EuclideanRingElement __t = __m % __n;
   __m = __n;
   __n = __t;
 }
      return __m;
    }






  template<typename _ForwardIterator>
    void
    __rotate(_ForwardIterator __first,
      _ForwardIterator __middle,
      _ForwardIterator __last,
       forward_iterator_tag)
    {
      if ((__first == __middle) || (__last == __middle))
 return;

      _ForwardIterator __first2 = __middle;
      do
 {
   swap(*__first++, *__first2++);
   if (__first == __middle)
     __middle = __first2;
 }
      while (__first2 != __last);

      __first2 = __middle;

      while (__first2 != __last)
 {
   swap(*__first++, *__first2++);
   if (__first == __middle)
     __middle = __first2;
   else if (__first2 == __last)
     __first2 = __middle;
 }
    }






  template<typename _BidirectionalIterator>
    void
    __rotate(_BidirectionalIterator __first,
      _BidirectionalIterator __middle,
      _BidirectionalIterator __last,
       bidirectional_iterator_tag)
    {

     


      if ((__first == __middle) || (__last == __middle))
 return;

      std::__reverse(__first, __middle, bidirectional_iterator_tag());
      std::__reverse(__middle, __last, bidirectional_iterator_tag());

      while (__first != __middle && __middle != __last)
 swap(*__first++, *--__last);

      if (__first == __middle)
 std::__reverse(__middle, __last, bidirectional_iterator_tag());
      else
 std::__reverse(__first, __middle, bidirectional_iterator_tag());
    }






  template<typename _RandomAccessIterator>
    void
    __rotate(_RandomAccessIterator __first,
      _RandomAccessIterator __middle,
      _RandomAccessIterator __last,
      random_access_iterator_tag)
    {

     


      if ((__first == __middle) || (__last == __middle))
 return;

      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _Distance;
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;

      const _Distance __n = __last - __first;
      const _Distance __k = __middle - __first;
      const _Distance __l = __n - __k;

      if (__k == __l)
 {
   std::swap_ranges(__first, __middle, __middle);
   return;
 }

      const _Distance __d = __gcd(__n, __k);

      for (_Distance __i = 0; __i < __d; __i++)
 {
   const _ValueType __tmp = *__first;
   _RandomAccessIterator __p = __first;

   if (__k < __l)
     {
       for (_Distance __j = 0; __j < __l / __d; __j++)
  {
    if (__p > __first + __l)
      {
        *__p = *(__p - __l);
        __p -= __l;
      }

    *__p = *(__p + __k);
    __p += __k;
  }
     }
   else
     {
       for (_Distance __j = 0; __j < __k / __d - 1; __j ++)
  {
    if (__p < __last - __k)
      {
        *__p = *(__p + __k);
        __p += __k;
      }
    *__p = * (__p - __l);
    __p -= __l;
  }
     }

   *__p = __tmp;
   ++__first;
 }
    }
# 1679 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_algo.h" 3
  template<typename _ForwardIterator>
    inline void
    rotate(_ForwardIterator __first, _ForwardIterator __middle,
    _ForwardIterator __last)
    {

     

      ;
      ;

      typedef typename iterator_traits<_ForwardIterator>::iterator_category
 _IterType;
      std::__rotate(__first, __middle, __last, _IterType());
    }
# 1712 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _OutputIterator>
    _OutputIterator
    rotate_copy(_ForwardIterator __first, _ForwardIterator __middle,
                _ForwardIterator __last, _OutputIterator __result)
    {

     
     

      ;
      ;

      return std::copy(__first, __middle, copy(__middle, __last, __result));
    }
# 1737 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator>
    inline void
    random_shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {

     

      ;

      if (__first != __last)
 for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)
   std::iter_swap(__i, __first + (std::rand() % ((__i - __first) + 1)));
    }
# 1764 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator, typename _RandomNumberGenerator>
    void
    random_shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last,
     _RandomNumberGenerator& __rand)
    {

     

      ;

      if (__first == __last)
 return;
      for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)
 std::iter_swap(__i, __first + __rand((__i - __first) + 1));
    }







  template<typename _ForwardIterator, typename _Predicate>
    _ForwardIterator
    __partition(_ForwardIterator __first, _ForwardIterator __last,
  _Predicate __pred,
  forward_iterator_tag)
    {
      if (__first == __last)
 return __first;

      while (__pred(*__first))
 if (++__first == __last)
   return __first;

      _ForwardIterator __next = __first;

      while (++__next != __last)
 if (__pred(*__next))
   {
     swap(*__first, *__next);
     ++__first;
   }

      return __first;
    }






  template<typename _BidirectionalIterator, typename _Predicate>
    _BidirectionalIterator
    __partition(_BidirectionalIterator __first, _BidirectionalIterator __last,
  _Predicate __pred,
  bidirectional_iterator_tag)
    {
      while (true)
 {
   while (true)
     if (__first == __last)
       return __first;
     else if (__pred(*__first))
       ++__first;
     else
       break;
   --__last;
   while (true)
     if (__first == __last)
       return __first;
     else if (!__pred(*__last))
       --__last;
     else
       break;
   std::iter_swap(__first, __last);
   ++__first;
 }
    }
# 1858 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Predicate>
    inline _ForwardIterator
    partition(_ForwardIterator __first, _ForwardIterator __last,
       _Predicate __pred)
    {

     

     

      ;

      return std::__partition(__first, __last, __pred,
         std::__iterator_category(__first));
    }







  template<typename _ForwardIterator, typename _Predicate, typename _Distance>
    _ForwardIterator
    __inplace_stable_partition(_ForwardIterator __first,
          _ForwardIterator __last,
          _Predicate __pred, _Distance __len)
    {
      if (__len == 1)
 return __pred(*__first) ? __last : __first;
      _ForwardIterator __middle = __first;
      std::advance(__middle, __len / 2);
      _ForwardIterator __begin = std::__inplace_stable_partition(__first,
         __middle,
         __pred,
         __len / 2);
      _ForwardIterator __end = std::__inplace_stable_partition(__middle, __last,
              __pred,
              __len
              - __len / 2);
      std::rotate(__begin, __middle, __end);
      std::advance(__begin, std::distance(__middle, __end));
      return __begin;
    }






  template<typename _ForwardIterator, typename _Pointer, typename _Predicate,
    typename _Distance>
    _ForwardIterator
    __stable_partition_adaptive(_ForwardIterator __first,
    _ForwardIterator __last,
    _Predicate __pred, _Distance __len,
    _Pointer __buffer,
    _Distance __buffer_size)
    {
      if (__len <= __buffer_size)
 {
   _ForwardIterator __result1 = __first;
   _Pointer __result2 = __buffer;
   for ( ; __first != __last ; ++__first)
     if (__pred(*__first))
       {
  *__result1 = *__first;
  ++__result1;
       }
     else
       {
  *__result2 = *__first;
  ++__result2;
       }
   std::copy(__buffer, __result2, __result1);
   return __result1;
 }
      else
 {
   _ForwardIterator __middle = __first;
   std::advance(__middle, __len / 2);
   _ForwardIterator __begin =
     std::__stable_partition_adaptive(__first, __middle, __pred,
          __len / 2, __buffer,
          __buffer_size);
   _ForwardIterator __end =
     std::__stable_partition_adaptive(__middle, __last, __pred,
          __len - __len / 2,
          __buffer, __buffer_size);
   std::rotate(__begin, __middle, __end);
   std::advance(__begin, std::distance(__middle, __end));
   return __begin;
 }
    }
# 1969 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Predicate>
    _ForwardIterator
    stable_partition(_ForwardIterator __first, _ForwardIterator __last,
       _Predicate __pred)
    {

     

     

      ;

      if (__first == __last)
 return __first;
      else
 {
   typedef typename iterator_traits<_ForwardIterator>::value_type
     _ValueType;
   typedef typename iterator_traits<_ForwardIterator>::difference_type
     _DistanceType;

   _Temporary_buffer<_ForwardIterator, _ValueType> __buf(__first,
        __last);
 if (__buf.size() > 0)
   return
     std::__stable_partition_adaptive(__first, __last, __pred,
       _DistanceType(__buf.requested_size()),
       __buf.begin(), __buf.size());
 else
   return
     std::__inplace_stable_partition(__first, __last, __pred,
      _DistanceType(__buf.requested_size()));
 }
    }






  template<typename _RandomAccessIterator, typename _Tp>
    _RandomAccessIterator
    __unguarded_partition(_RandomAccessIterator __first,
     _RandomAccessIterator __last, _Tp __pivot)
    {
      while (true)
 {
   while (*__first < __pivot)
     ++__first;
   --__last;
   while (__pivot < *__last)
     --__last;
   if (!(__first < __last))
     return __first;
   std::iter_swap(__first, __last);
   ++__first;
 }
    }






  template<typename _RandomAccessIterator, typename _Tp, typename _Compare>
    _RandomAccessIterator
    __unguarded_partition(_RandomAccessIterator __first,
     _RandomAccessIterator __last,
     _Tp __pivot, _Compare __comp)
    {
      while (true)
 {
   while (__comp(*__first, __pivot))
     ++__first;
   --__last;
   while (__comp(__pivot, *__last))
     --__last;
   if (!(__first < __last))
     return __first;
   std::iter_swap(__first, __last);
   ++__first;
 }
    }







  enum { _S_threshold = 16 };






  template<typename _RandomAccessIterator, typename _Tp>
    void
    __unguarded_linear_insert(_RandomAccessIterator __last, _Tp __val)
    {
      _RandomAccessIterator __next = __last;
      --__next;
      while (__val < *__next)
 {
   *__last = *__next;
   __last = __next;
   --__next;
 }
      *__last = __val;
    }






  template<typename _RandomAccessIterator, typename _Tp, typename _Compare>
    void
    __unguarded_linear_insert(_RandomAccessIterator __last, _Tp __val,
         _Compare __comp)
    {
      _RandomAccessIterator __next = __last;
      --__next;
      while (__comp(__val, *__next))
 {
   *__last = *__next;
   __last = __next;
   --__next;
 }
      *__last = __val;
    }






  template<typename _RandomAccessIterator>
    void
    __insertion_sort(_RandomAccessIterator __first,
       _RandomAccessIterator __last)
    {
      if (__first == __last)
 return;

      for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)
 {
   typename iterator_traits<_RandomAccessIterator>::value_type
     __val = *__i;
   if (__val < *__first)
     {
       std::copy_backward(__first, __i, __i + 1);
       *__first = __val;
     }
   else
     std::__unguarded_linear_insert(__i, __val);
 }
    }






  template<typename _RandomAccessIterator, typename _Compare>
    void
    __insertion_sort(_RandomAccessIterator __first,
       _RandomAccessIterator __last, _Compare __comp)
    {
      if (__first == __last) return;

      for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)
 {
   typename iterator_traits<_RandomAccessIterator>::value_type
     __val = *__i;
   if (__comp(__val, *__first))
     {
       std::copy_backward(__first, __i, __i + 1);
       *__first = __val;
     }
   else
     std::__unguarded_linear_insert(__i, __val, __comp);
 }
    }






  template<typename _RandomAccessIterator>
    inline void
    __unguarded_insertion_sort(_RandomAccessIterator __first,
          _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;

      for (_RandomAccessIterator __i = __first; __i != __last; ++__i)
 std::__unguarded_linear_insert(__i, _ValueType(*__i));
    }






  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    __unguarded_insertion_sort(_RandomAccessIterator __first,
          _RandomAccessIterator __last, _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;

      for (_RandomAccessIterator __i = __first; __i != __last; ++__i)
 std::__unguarded_linear_insert(__i, _ValueType(*__i), __comp);
    }






  template<typename _RandomAccessIterator>
    void
    __final_insertion_sort(_RandomAccessIterator __first,
      _RandomAccessIterator __last)
    {
      if (__last - __first > _S_threshold)
 {
   std::__insertion_sort(__first, __first + _S_threshold);
   std::__unguarded_insertion_sort(__first + _S_threshold, __last);
 }
      else
 std::__insertion_sort(__first, __last);
    }






  template<typename _RandomAccessIterator, typename _Compare>
    void
    __final_insertion_sort(_RandomAccessIterator __first,
      _RandomAccessIterator __last, _Compare __comp)
    {
      if (__last - __first > _S_threshold)
 {
   std::__insertion_sort(__first, __first + _S_threshold, __comp);
   std::__unguarded_insertion_sort(__first + _S_threshold, __last,
       __comp);
 }
      else
 std::__insertion_sort(__first, __last, __comp);
    }






  template<typename _Size>
    inline _Size
    __lg(_Size __n)
    {
      _Size __k;
      for (__k = 0; __n != 1; __n >>= 1)
 ++__k;
      return __k;
    }
# 2258 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator>
    void
    partial_sort(_RandomAccessIterator __first,
   _RandomAccessIterator __middle,
   _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;


     

     
      ;
      ;

      std::make_heap(__first, __middle);
      for (_RandomAccessIterator __i = __middle; __i < __last; ++__i)
 if (*__i < *__first)
   std::__pop_heap(__first, __middle, __i, _ValueType(*__i));
      std::sort_heap(__first, __middle);
    }
# 2299 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    void
    partial_sort(_RandomAccessIterator __first,
   _RandomAccessIterator __middle,
   _RandomAccessIterator __last,
   _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;


     

     

      ;
      ;

      std::make_heap(__first, __middle, __comp);
      for (_RandomAccessIterator __i = __middle; __i < __last; ++__i)
 if (__comp(*__i, *__first))
   std::__pop_heap(__first, __middle, __i, _ValueType(*__i), __comp);
      std::sort_heap(__first, __middle, __comp);
    }
# 2341 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _RandomAccessIterator>
    _RandomAccessIterator
    partial_sort_copy(_InputIterator __first, _InputIterator __last,
        _RandomAccessIterator __result_first,
        _RandomAccessIterator __result_last)
    {
      typedef typename iterator_traits<_InputIterator>::value_type
 _InputValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _OutputValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _DistanceType;


     
     

     
     
      ;
      ;

      if (__result_first == __result_last)
 return __result_last;
      _RandomAccessIterator __result_real_last = __result_first;
      while(__first != __last && __result_real_last != __result_last)
 {
   *__result_real_last = *__first;
   ++__result_real_last;
   ++__first;
 }
      std::make_heap(__result_first, __result_real_last);
      while (__first != __last)
 {
   if (*__first < *__result_first)
     std::__adjust_heap(__result_first, _DistanceType(0),
          _DistanceType(__result_real_last
          - __result_first),
          _InputValueType(*__first));
   ++__first;
 }
      std::sort_heap(__result_first, __result_real_last);
      return __result_real_last;
    }
# 2405 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _RandomAccessIterator, typename _Compare>
    _RandomAccessIterator
    partial_sort_copy(_InputIterator __first, _InputIterator __last,
        _RandomAccessIterator __result_first,
        _RandomAccessIterator __result_last,
        _Compare __comp)
    {
      typedef typename iterator_traits<_InputIterator>::value_type
 _InputValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _OutputValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _DistanceType;


     
     

     

     

      ;
      ;

      if (__result_first == __result_last)
 return __result_last;
      _RandomAccessIterator __result_real_last = __result_first;
      while(__first != __last && __result_real_last != __result_last)
 {
   *__result_real_last = *__first;
   ++__result_real_last;
   ++__first;
 }
      std::make_heap(__result_first, __result_real_last, __comp);
      while (__first != __last)
 {
   if (__comp(*__first, *__result_first))
     std::__adjust_heap(__result_first, _DistanceType(0),
          _DistanceType(__result_real_last
          - __result_first),
          _InputValueType(*__first),
          __comp);
   ++__first;
 }
      std::sort_heap(__result_first, __result_real_last, __comp);
      return __result_real_last;
    }






  template<typename _RandomAccessIterator, typename _Size>
    void
    __introsort_loop(_RandomAccessIterator __first,
       _RandomAccessIterator __last,
       _Size __depth_limit)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;

      while (__last - __first > _S_threshold)
 {
   if (__depth_limit == 0)
     {
       std::partial_sort(__first, __last, __last);
       return;
     }
   --__depth_limit;
   _RandomAccessIterator __cut =
     std::__unguarded_partition(__first, __last,
           _ValueType(std::__median(*__first,
        *(__first
          + (__last
             - __first)
          / 2),
        *(__last
          - 1))));
   std::__introsort_loop(__cut, __last, __depth_limit);
   __last = __cut;
 }
    }






  template<typename _RandomAccessIterator, typename _Size, typename _Compare>
    void
    __introsort_loop(_RandomAccessIterator __first,
       _RandomAccessIterator __last,
       _Size __depth_limit, _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;

      while (__last - __first > _S_threshold)
 {
   if (__depth_limit == 0)
     {
       std::partial_sort(__first, __last, __last, __comp);
       return;
     }
   --__depth_limit;
   _RandomAccessIterator __cut =
     std::__unguarded_partition(__first, __last,
           _ValueType(std::__median(*__first,
        *(__first
          + (__last
             - __first)
          / 2),
        *(__last - 1),
        __comp)),
           __comp);
   std::__introsort_loop(__cut, __last, __depth_limit, __comp);
   __last = __cut;
 }
    }
# 2540 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator>
    inline void
    sort(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;


     

     
      ;

      if (__first != __last)
 {
   std::__introsort_loop(__first, __last, __lg(__last - __first) * 2);
   std::__final_insertion_sort(__first, __last);
 }
    }
# 2574 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    sort(_RandomAccessIterator __first, _RandomAccessIterator __last,
  _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;


     

     

      ;

      if (__first != __last)
 {
   std::__introsort_loop(__first, __last, __lg(__last - __first) * 2,
    __comp);
   std::__final_insertion_sort(__first, __last, __comp);
 }
    }
# 2607 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp>
    _ForwardIterator
    lower_bound(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;






     
     
     
      ;

      _DistanceType __len = std::distance(__first, __last);
      _DistanceType __half;
      _ForwardIterator __middle;

      while (__len > 0)
 {
   __half = __len >> 1;
   __middle = __first;
   std::advance(__middle, __half);
   if (*__middle < __val)
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
   else
     __len = __half;
 }
      return __first;
    }
# 2662 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp, typename _Compare>
    _ForwardIterator
    lower_bound(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val, _Compare __comp)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;


     
     

      ;

      _DistanceType __len = std::distance(__first, __last);
      _DistanceType __half;
      _ForwardIterator __middle;

      while (__len > 0)
 {
   __half = __len >> 1;
   __middle = __first;
   std::advance(__middle, __half);
   if (__comp(*__middle, __val))
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
   else
     __len = __half;
 }
      return __first;
    }
# 2709 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp>
    _ForwardIterator
    upper_bound(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;



     
     
     
      ;

      _DistanceType __len = std::distance(__first, __last);
      _DistanceType __half;
      _ForwardIterator __middle;

      while (__len > 0)
 {
   __half = __len >> 1;
   __middle = __first;
   std::advance(__middle, __half);
   if (__val < *__middle)
     __len = __half;
   else
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
 }
      return __first;
    }
# 2761 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp, typename _Compare>
    _ForwardIterator
    upper_bound(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val, _Compare __comp)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;


     
     

      ;

      _DistanceType __len = std::distance(__first, __last);
      _DistanceType __half;
      _ForwardIterator __middle;

      while (__len > 0)
 {
   __half = __len >> 1;
   __middle = __first;
   std::advance(__middle, __half);
   if (__comp(__val, *__middle))
     __len = __half;
   else
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
 }
      return __first;
    }






  template<typename _BidirectionalIterator, typename _Distance>
    void
    __merge_without_buffer(_BidirectionalIterator __first,
      _BidirectionalIterator __middle,
      _BidirectionalIterator __last,
      _Distance __len1, _Distance __len2)
    {
      if (__len1 == 0 || __len2 == 0)
 return;
      if (__len1 + __len2 == 2)
 {
   if (*__middle < *__first)
     std::iter_swap(__first, __middle);
   return;
 }
      _BidirectionalIterator __first_cut = __first;
      _BidirectionalIterator __second_cut = __middle;
      _Distance __len11 = 0;
      _Distance __len22 = 0;
      if (__len1 > __len2)
 {
   __len11 = __len1 / 2;
   std::advance(__first_cut, __len11);
   __second_cut = std::lower_bound(__middle, __last, *__first_cut);
   __len22 = std::distance(__middle, __second_cut);
 }
      else
 {
   __len22 = __len2 / 2;
   std::advance(__second_cut, __len22);
   __first_cut = std::upper_bound(__first, __middle, *__second_cut);
   __len11 = std::distance(__first, __first_cut);
 }
      std::rotate(__first_cut, __middle, __second_cut);
      _BidirectionalIterator __new_middle = __first_cut;
      std::advance(__new_middle, std::distance(__middle, __second_cut));
      std::__merge_without_buffer(__first, __first_cut, __new_middle,
      __len11, __len22);
      std::__merge_without_buffer(__new_middle, __second_cut, __last,
      __len1 - __len11, __len2 - __len22);
    }






  template<typename _BidirectionalIterator, typename _Distance,
    typename _Compare>
    void
    __merge_without_buffer(_BidirectionalIterator __first,
                           _BidirectionalIterator __middle,
      _BidirectionalIterator __last,
      _Distance __len1, _Distance __len2,
      _Compare __comp)
    {
      if (__len1 == 0 || __len2 == 0)
 return;
      if (__len1 + __len2 == 2)
 {
   if (__comp(*__middle, *__first))
     std::iter_swap(__first, __middle);
   return;
 }
      _BidirectionalIterator __first_cut = __first;
      _BidirectionalIterator __second_cut = __middle;
      _Distance __len11 = 0;
      _Distance __len22 = 0;
      if (__len1 > __len2)
 {
   __len11 = __len1 / 2;
   std::advance(__first_cut, __len11);
   __second_cut = std::lower_bound(__middle, __last, *__first_cut,
       __comp);
   __len22 = std::distance(__middle, __second_cut);
 }
      else
 {
   __len22 = __len2 / 2;
   std::advance(__second_cut, __len22);
   __first_cut = std::upper_bound(__first, __middle, *__second_cut,
      __comp);
   __len11 = std::distance(__first, __first_cut);
 }
      std::rotate(__first_cut, __middle, __second_cut);
      _BidirectionalIterator __new_middle = __first_cut;
      std::advance(__new_middle, std::distance(__middle, __second_cut));
      std::__merge_without_buffer(__first, __first_cut, __new_middle,
      __len11, __len22, __comp);
      std::__merge_without_buffer(__new_middle, __second_cut, __last,
      __len1 - __len11, __len2 - __len22, __comp);
    }






  template<typename _RandomAccessIterator>
    void
    __inplace_stable_sort(_RandomAccessIterator __first,
     _RandomAccessIterator __last)
    {
      if (__last - __first < 15)
 {
   std::__insertion_sort(__first, __last);
   return;
 }
      _RandomAccessIterator __middle = __first + (__last - __first) / 2;
      std::__inplace_stable_sort(__first, __middle);
      std::__inplace_stable_sort(__middle, __last);
      std::__merge_without_buffer(__first, __middle, __last,
      __middle - __first,
      __last - __middle);
    }






  template<typename _RandomAccessIterator, typename _Compare>
    void
    __inplace_stable_sort(_RandomAccessIterator __first,
     _RandomAccessIterator __last, _Compare __comp)
    {
      if (__last - __first < 15)
 {
   std::__insertion_sort(__first, __last, __comp);
   return;
 }
      _RandomAccessIterator __middle = __first + (__last - __first) / 2;
      std::__inplace_stable_sort(__first, __middle, __comp);
      std::__inplace_stable_sort(__middle, __last, __comp);
      std::__merge_without_buffer(__first, __middle, __last,
      __middle - __first,
      __last - __middle,
      __comp);
    }
# 2959 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator>
    _OutputIterator
    merge(_InputIterator1 __first1, _InputIterator1 __last1,
   _InputIterator2 __first2, _InputIterator2 __last2,
   _OutputIterator __result)
    {

     
     
     

     


     

      ;
      ;

      while (__first1 != __last1 && __first2 != __last2)
 {
   if (*__first2 < *__first1)
     {
       *__result = *__first2;
       ++__first2;
     }
   else
     {
       *__result = *__first1;
       ++__first1;
     }
   ++__result;
 }
      return std::copy(__first2, __last2, std::copy(__first1, __last1,
          __result));
    }
# 3017 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    _OutputIterator
    merge(_InputIterator1 __first1, _InputIterator1 __last1,
   _InputIterator2 __first2, _InputIterator2 __last2,
   _OutputIterator __result, _Compare __comp)
    {

     
     
     


     

     


      ;
      ;

      while (__first1 != __last1 && __first2 != __last2)
 {
   if (__comp(*__first2, *__first1))
     {
       *__result = *__first2;
       ++__first2;
     }
   else
     {
       *__result = *__first1;
       ++__first1;
     }
   ++__result;
 }
      return std::copy(__first2, __last2, std::copy(__first1, __last1,
          __result));
    }

  template<typename _RandomAccessIterator1, typename _RandomAccessIterator2,
    typename _Distance>
    void
    __merge_sort_loop(_RandomAccessIterator1 __first,
        _RandomAccessIterator1 __last,
        _RandomAccessIterator2 __result,
        _Distance __step_size)
    {
      const _Distance __two_step = 2 * __step_size;

      while (__last - __first >= __two_step)
 {
   __result = std::merge(__first, __first + __step_size,
    __first + __step_size, __first + __two_step,
    __result);
   __first += __two_step;
 }

      __step_size = std::min(_Distance(__last - __first), __step_size);
      std::merge(__first, __first + __step_size, __first + __step_size, __last,
   __result);
    }

  template<typename _RandomAccessIterator1, typename _RandomAccessIterator2,
    typename _Distance, typename _Compare>
    void
    __merge_sort_loop(_RandomAccessIterator1 __first,
        _RandomAccessIterator1 __last,
        _RandomAccessIterator2 __result, _Distance __step_size,
        _Compare __comp)
    {
      const _Distance __two_step = 2 * __step_size;

      while (__last - __first >= __two_step)
 {
   __result = std::merge(__first, __first + __step_size,
    __first + __step_size, __first + __two_step,
    __result,
    __comp);
   __first += __two_step;
 }
      __step_size = std::min(_Distance(__last - __first), __step_size);

      std::merge(__first, __first + __step_size,
   __first + __step_size, __last,
   __result,
   __comp);
    }

  enum { _S_chunk_size = 7 };

  template<typename _RandomAccessIterator, typename _Distance>
    void
    __chunk_insertion_sort(_RandomAccessIterator __first,
      _RandomAccessIterator __last,
      _Distance __chunk_size)
    {
      while (__last - __first >= __chunk_size)
 {
   std::__insertion_sort(__first, __first + __chunk_size);
   __first += __chunk_size;
 }
      std::__insertion_sort(__first, __last);
    }

  template<typename _RandomAccessIterator, typename _Distance, typename _Compare>
    void
    __chunk_insertion_sort(_RandomAccessIterator __first,
      _RandomAccessIterator __last,
      _Distance __chunk_size, _Compare __comp)
    {
      while (__last - __first >= __chunk_size)
 {
   std::__insertion_sort(__first, __first + __chunk_size, __comp);
   __first += __chunk_size;
 }
      std::__insertion_sort(__first, __last, __comp);
    }

  template<typename _RandomAccessIterator, typename _Pointer>
    void
    __merge_sort_with_buffer(_RandomAccessIterator __first,
        _RandomAccessIterator __last,
                             _Pointer __buffer)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _Distance;

      const _Distance __len = __last - __first;
      const _Pointer __buffer_last = __buffer + __len;

      _Distance __step_size = _S_chunk_size;
      std::__chunk_insertion_sort(__first, __last, __step_size);

      while (__step_size < __len)
 {
   std::__merge_sort_loop(__first, __last, __buffer, __step_size);
   __step_size *= 2;
   std::__merge_sort_loop(__buffer, __buffer_last, __first, __step_size);
   __step_size *= 2;
 }
    }

  template<typename _RandomAccessIterator, typename _Pointer, typename _Compare>
    void
    __merge_sort_with_buffer(_RandomAccessIterator __first,
        _RandomAccessIterator __last,
                             _Pointer __buffer, _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _Distance;

      const _Distance __len = __last - __first;
      const _Pointer __buffer_last = __buffer + __len;

      _Distance __step_size = _S_chunk_size;
      std::__chunk_insertion_sort(__first, __last, __step_size, __comp);

      while (__step_size < __len)
 {
   std::__merge_sort_loop(__first, __last, __buffer,
     __step_size, __comp);
   __step_size *= 2;
   std::__merge_sort_loop(__buffer, __buffer_last, __first,
     __step_size, __comp);
   __step_size *= 2;
 }
    }






  template<typename _BidirectionalIterator1, typename _BidirectionalIterator2,
    typename _BidirectionalIterator3>
    _BidirectionalIterator3
    __merge_backward(_BidirectionalIterator1 __first1,
       _BidirectionalIterator1 __last1,
       _BidirectionalIterator2 __first2,
       _BidirectionalIterator2 __last2,
       _BidirectionalIterator3 __result)
    {
      if (__first1 == __last1)
 return std::copy_backward(__first2, __last2, __result);
      if (__first2 == __last2)
 return std::copy_backward(__first1, __last1, __result);
      --__last1;
      --__last2;
      while (true)
 {
   if (*__last2 < *__last1)
     {
       *--__result = *__last1;
       if (__first1 == __last1)
  return std::copy_backward(__first2, ++__last2, __result);
       --__last1;
     }
   else
     {
       *--__result = *__last2;
       if (__first2 == __last2)
  return std::copy_backward(__first1, ++__last1, __result);
       --__last2;
     }
 }
    }






  template<typename _BidirectionalIterator1, typename _BidirectionalIterator2,
    typename _BidirectionalIterator3, typename _Compare>
    _BidirectionalIterator3
    __merge_backward(_BidirectionalIterator1 __first1,
       _BidirectionalIterator1 __last1,
       _BidirectionalIterator2 __first2,
       _BidirectionalIterator2 __last2,
       _BidirectionalIterator3 __result,
       _Compare __comp)
    {
      if (__first1 == __last1)
 return std::copy_backward(__first2, __last2, __result);
      if (__first2 == __last2)
 return std::copy_backward(__first1, __last1, __result);
      --__last1;
      --__last2;
      while (true)
 {
   if (__comp(*__last2, *__last1))
     {
       *--__result = *__last1;
       if (__first1 == __last1)
  return std::copy_backward(__first2, ++__last2, __result);
       --__last1;
     }
   else
     {
       *--__result = *__last2;
       if (__first2 == __last2)
  return std::copy_backward(__first1, ++__last1, __result);
       --__last2;
     }
 }
    }






  template<typename _BidirectionalIterator1, typename _BidirectionalIterator2,
    typename _Distance>
    _BidirectionalIterator1
    __rotate_adaptive(_BidirectionalIterator1 __first,
        _BidirectionalIterator1 __middle,
        _BidirectionalIterator1 __last,
        _Distance __len1, _Distance __len2,
        _BidirectionalIterator2 __buffer,
        _Distance __buffer_size)
    {
      _BidirectionalIterator2 __buffer_end;
      if (__len1 > __len2 && __len2 <= __buffer_size)
 {
   __buffer_end = std::copy(__middle, __last, __buffer);
   std::copy_backward(__first, __middle, __last);
   return std::copy(__buffer, __buffer_end, __first);
 }
      else if (__len1 <= __buffer_size)
 {
   __buffer_end = std::copy(__first, __middle, __buffer);
   std::copy(__middle, __last, __first);
   return std::copy_backward(__buffer, __buffer_end, __last);
 }
      else
 {
   std::rotate(__first, __middle, __last);
   std::advance(__first, std::distance(__middle, __last));
   return __first;
 }
    }






  template<typename _BidirectionalIterator, typename _Distance,
    typename _Pointer>
    void
    __merge_adaptive(_BidirectionalIterator __first,
                     _BidirectionalIterator __middle,
       _BidirectionalIterator __last,
       _Distance __len1, _Distance __len2,
       _Pointer __buffer, _Distance __buffer_size)
    {
      if (__len1 <= __len2 && __len1 <= __buffer_size)
 {
   _Pointer __buffer_end = std::copy(__first, __middle, __buffer);
   std::merge(__buffer, __buffer_end, __middle, __last, __first);
 }
      else if (__len2 <= __buffer_size)
 {
   _Pointer __buffer_end = std::copy(__middle, __last, __buffer);
   std::__merge_backward(__first, __middle, __buffer,
    __buffer_end, __last);
 }
      else
 {
   _BidirectionalIterator __first_cut = __first;
   _BidirectionalIterator __second_cut = __middle;
   _Distance __len11 = 0;
   _Distance __len22 = 0;
   if (__len1 > __len2)
     {
       __len11 = __len1 / 2;
       std::advance(__first_cut, __len11);
       __second_cut = std::lower_bound(__middle, __last,
           *__first_cut);
       __len22 = std::distance(__middle, __second_cut);
     }
   else
     {
       __len22 = __len2 / 2;
       std::advance(__second_cut, __len22);
       __first_cut = std::upper_bound(__first, __middle,
          *__second_cut);
       __len11 = std::distance(__first, __first_cut);
     }
   _BidirectionalIterator __new_middle =
     std::__rotate_adaptive(__first_cut, __middle, __second_cut,
       __len1 - __len11, __len22, __buffer,
       __buffer_size);
   std::__merge_adaptive(__first, __first_cut, __new_middle, __len11,
    __len22, __buffer, __buffer_size);
   std::__merge_adaptive(__new_middle, __second_cut, __last,
    __len1 - __len11,
    __len2 - __len22, __buffer, __buffer_size);
 }
    }






  template<typename _BidirectionalIterator, typename _Distance, typename _Pointer,
    typename _Compare>
    void
    __merge_adaptive(_BidirectionalIterator __first,
                     _BidirectionalIterator __middle,
       _BidirectionalIterator __last,
       _Distance __len1, _Distance __len2,
       _Pointer __buffer, _Distance __buffer_size,
       _Compare __comp)
    {
      if (__len1 <= __len2 && __len1 <= __buffer_size)
 {
   _Pointer __buffer_end = std::copy(__first, __middle, __buffer);
   std::merge(__buffer, __buffer_end, __middle, __last, __first, __comp);
 }
      else if (__len2 <= __buffer_size)
 {
   _Pointer __buffer_end = std::copy(__middle, __last, __buffer);
   std::__merge_backward(__first, __middle, __buffer, __buffer_end,
    __last, __comp);
 }
      else
 {
   _BidirectionalIterator __first_cut = __first;
   _BidirectionalIterator __second_cut = __middle;
   _Distance __len11 = 0;
   _Distance __len22 = 0;
   if (__len1 > __len2)
     {
       __len11 = __len1 / 2;
       std::advance(__first_cut, __len11);
       __second_cut = std::lower_bound(__middle, __last, *__first_cut,
           __comp);
       __len22 = std::distance(__middle, __second_cut);
     }
   else
     {
       __len22 = __len2 / 2;
       std::advance(__second_cut, __len22);
       __first_cut = std::upper_bound(__first, __middle, *__second_cut,
          __comp);
       __len11 = std::distance(__first, __first_cut);
     }
   _BidirectionalIterator __new_middle =
     std::__rotate_adaptive(__first_cut, __middle, __second_cut,
       __len1 - __len11, __len22, __buffer,
       __buffer_size);
   std::__merge_adaptive(__first, __first_cut, __new_middle, __len11,
    __len22, __buffer, __buffer_size, __comp);
   std::__merge_adaptive(__new_middle, __second_cut, __last,
    __len1 - __len11,
    __len2 - __len22, __buffer,
    __buffer_size, __comp);
 }
    }
# 3437 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator>
    void
    inplace_merge(_BidirectionalIterator __first,
    _BidirectionalIterator __middle,
    _BidirectionalIterator __last)
    {
      typedef typename iterator_traits<_BidirectionalIterator>::value_type
          _ValueType;
      typedef typename iterator_traits<_BidirectionalIterator>::difference_type
          _DistanceType;


     

     
      ;
      ;

      if (__first == __middle || __middle == __last)
 return;

      _DistanceType __len1 = std::distance(__first, __middle);
      _DistanceType __len2 = std::distance(__middle, __last);

      _Temporary_buffer<_BidirectionalIterator, _ValueType> __buf(__first,
          __last);
      if (__buf.begin() == 0)
 std::__merge_without_buffer(__first, __middle, __last, __len1, __len2);
      else
 std::__merge_adaptive(__first, __middle, __last, __len1, __len2,
         __buf.begin(), _DistanceType(__buf.size()));
    }
# 3491 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator, typename _Compare>
    void
    inplace_merge(_BidirectionalIterator __first,
    _BidirectionalIterator __middle,
    _BidirectionalIterator __last,
    _Compare __comp)
    {
      typedef typename iterator_traits<_BidirectionalIterator>::value_type
          _ValueType;
      typedef typename iterator_traits<_BidirectionalIterator>::difference_type
          _DistanceType;


     

     

      ;
      ;

      if (__first == __middle || __middle == __last)
 return;

      const _DistanceType __len1 = std::distance(__first, __middle);
      const _DistanceType __len2 = std::distance(__middle, __last);

      _Temporary_buffer<_BidirectionalIterator, _ValueType> __buf(__first,
          __last);
      if (__buf.begin() == 0)
 std::__merge_without_buffer(__first, __middle, __last, __len1,
        __len2, __comp);
      else
 std::__merge_adaptive(__first, __middle, __last, __len1, __len2,
         __buf.begin(), _DistanceType(__buf.size()),
         __comp);
    }

  template<typename _RandomAccessIterator, typename _Pointer,
    typename _Distance>
    void
    __stable_sort_adaptive(_RandomAccessIterator __first,
      _RandomAccessIterator __last,
                           _Pointer __buffer, _Distance __buffer_size)
    {
      const _Distance __len = (__last - __first + 1) / 2;
      const _RandomAccessIterator __middle = __first + __len;
      if (__len > __buffer_size)
 {
   std::__stable_sort_adaptive(__first, __middle,
          __buffer, __buffer_size);
   std::__stable_sort_adaptive(__middle, __last,
          __buffer, __buffer_size);
 }
      else
 {
   std::__merge_sort_with_buffer(__first, __middle, __buffer);
   std::__merge_sort_with_buffer(__middle, __last, __buffer);
 }
      std::__merge_adaptive(__first, __middle, __last,
       _Distance(__middle - __first),
       _Distance(__last - __middle),
       __buffer, __buffer_size);
    }

  template<typename _RandomAccessIterator, typename _Pointer,
    typename _Distance, typename _Compare>
    void
    __stable_sort_adaptive(_RandomAccessIterator __first,
      _RandomAccessIterator __last,
                           _Pointer __buffer, _Distance __buffer_size,
                           _Compare __comp)
    {
      const _Distance __len = (__last - __first + 1) / 2;
      const _RandomAccessIterator __middle = __first + __len;
      if (__len > __buffer_size)
 {
   std::__stable_sort_adaptive(__first, __middle, __buffer,
          __buffer_size, __comp);
   std::__stable_sort_adaptive(__middle, __last, __buffer,
          __buffer_size, __comp);
 }
      else
 {
   std::__merge_sort_with_buffer(__first, __middle, __buffer, __comp);
   std::__merge_sort_with_buffer(__middle, __last, __buffer, __comp);
 }
      std::__merge_adaptive(__first, __middle, __last,
       _Distance(__middle - __first),
       _Distance(__last - __middle),
       __buffer, __buffer_size,
       __comp);
    }
# 3600 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator>
    inline void
    stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _DistanceType;


     

     
      ;

      _Temporary_buffer<_RandomAccessIterator, _ValueType>
 buf(__first, __last);
      if (buf.begin() == 0)
 std::__inplace_stable_sort(__first, __last);
      else
 std::__stable_sort_adaptive(__first, __last, buf.begin(),
        _DistanceType(buf.size()));
    }
# 3641 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last,
  _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _DistanceType;


     

     


      ;

      _Temporary_buffer<_RandomAccessIterator, _ValueType> buf(__first, __last);
      if (buf.begin() == 0)
 std::__inplace_stable_sort(__first, __last, __comp);
      else
 std::__stable_sort_adaptive(__first, __last, buf.begin(),
        _DistanceType(buf.size()), __comp);
    }
# 3682 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator>
    void
    nth_element(_RandomAccessIterator __first,
  _RandomAccessIterator __nth,
  _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;


     

     
      ;
      ;

      while (__last - __first > 3)
 {
   _RandomAccessIterator __cut =
     std::__unguarded_partition(__first, __last,
           _ValueType(std::__median(*__first,
        *(__first
          + (__last
             - __first)
          / 2),
        *(__last
          - 1))));
   if (__cut <= __nth)
     __first = __cut;
   else
     __last = __cut;
 }
      std::__insertion_sort(__first, __last);
    }
# 3733 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    void
    nth_element(_RandomAccessIterator __first,
  _RandomAccessIterator __nth,
  _RandomAccessIterator __last,
       _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;


     

     

      ;
      ;

      while (__last - __first > 3)
 {
   _RandomAccessIterator __cut =
     std::__unguarded_partition(__first, __last,
           _ValueType(std::__median(*__first,
        *(__first
          + (__last
             - __first)
          / 2),
        *(__last - 1),
             __comp)), __comp);
   if (__cut <= __nth)
     __first = __cut;
   else
     __last = __cut;
 }
      std::__insertion_sort(__first, __last, __comp);
    }
# 3786 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp>
    pair<_ForwardIterator, _ForwardIterator>
    equal_range(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;



     
     
     
      ;

      _DistanceType __len = std::distance(__first, __last);
      _DistanceType __half;
      _ForwardIterator __middle, __left, __right;

      while (__len > 0)
 {
   __half = __len >> 1;
   __middle = __first;
   std::advance(__middle, __half);
   if (*__middle < __val)
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
   else if (__val < *__middle)
     __len = __half;
   else
     {
       __left = std::lower_bound(__first, __middle, __val);
       std::advance(__first, __len);
       __right = std::upper_bound(++__middle, __first, __val);
       return pair<_ForwardIterator, _ForwardIterator>(__left, __right);
     }
 }
      return pair<_ForwardIterator, _ForwardIterator>(__first, __first);
    }
# 3848 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp, typename _Compare>
    pair<_ForwardIterator, _ForwardIterator>
    equal_range(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val,
  _Compare __comp)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;


     
     

     

      ;

      _DistanceType __len = std::distance(__first, __last);
      _DistanceType __half;
      _ForwardIterator __middle, __left, __right;

      while (__len > 0)
 {
   __half = __len >> 1;
   __middle = __first;
   std::advance(__middle, __half);
   if (__comp(*__middle, __val))
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
   else if (__comp(__val, *__middle))
     __len = __half;
   else
     {
       __left = std::lower_bound(__first, __middle, __val, __comp);
       std::advance(__first, __len);
       __right = std::upper_bound(++__middle, __first, __val, __comp);
       return pair<_ForwardIterator, _ForwardIterator>(__left, __right);
     }
 }
      return pair<_ForwardIterator, _ForwardIterator>(__first, __first);
    }
# 3906 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp>
    bool
    binary_search(_ForwardIterator __first, _ForwardIterator __last,
                  const _Tp& __val)
    {


     
     

     
      ;

      _ForwardIterator __i = std::lower_bound(__first, __last, __val);
      return __i != __last && !(__val < *__i);
    }
# 3938 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp, typename _Compare>
    bool
    binary_search(_ForwardIterator __first, _ForwardIterator __last,
                  const _Tp& __val, _Compare __comp)
    {

     
     

     

      ;

      _ForwardIterator __i = std::lower_bound(__first, __last, __val, __comp);
      return __i != __last && !__comp(__val, *__i);
    }
# 3976 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2>
    bool
    includes(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _InputIterator2 __last2)
    {

     
     
     


     

      ;
      ;

      while (__first1 != __last1 && __first2 != __last2)
 if (*__first2 < *__first1)
   return false;
 else if(*__first1 < *__first2)
   ++__first1;
 else
   ++__first1, ++__first2;

      return __first2 == __last2;
    }
# 4022 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _Compare>
    bool
    includes(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _InputIterator2 __last2, _Compare __comp)
    {

     
     
     


     


      ;
      ;

      while (__first1 != __last1 && __first2 != __last2)
 if (__comp(*__first2, *__first1))
   return false;
 else if(__comp(*__first1, *__first2))
   ++__first1;
 else
   ++__first1, ++__first2;

      return __first2 == __last2;
    }
# 4068 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator>
    _OutputIterator
    set_union(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _InputIterator2 __last2,
       _OutputIterator __result)
    {

     
     
     

     


     

      ;
      ;

      while (__first1 != __last1 && __first2 != __last2)
 {
   if (*__first1 < *__first2)
     {
       *__result = *__first1;
       ++__first1;
     }
   else if (*__first2 < *__first1)
     {
       *__result = *__first2;
       ++__first2;
     }
   else
     {
       *__result = *__first1;
       ++__first1;
       ++__first2;
     }
   ++__result;
 }
      return std::copy(__first2, __last2, std::copy(__first1, __last1,
          __result));
    }
# 4130 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    _OutputIterator
    set_union(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _InputIterator2 __last2,
       _OutputIterator __result, _Compare __comp)
    {

     
     
     


     

     


      ;
      ;

      while (__first1 != __last1 && __first2 != __last2)
 {
   if (__comp(*__first1, *__first2))
     {
       *__result = *__first1;
       ++__first1;
     }
   else if (__comp(*__first2, *__first1))
     {
       *__result = *__first2;
       ++__first2;
     }
   else
     {
       *__result = *__first1;
       ++__first1;
       ++__first2;
     }
   ++__result;
 }
      return std::copy(__first2, __last2, std::copy(__first1, __last1,
          __result));
    }
# 4191 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator>
    _OutputIterator
    set_intersection(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _InputIterator2 __last2,
       _OutputIterator __result)
    {

     
     
     

     


     

      ;
      ;

      while (__first1 != __last1 && __first2 != __last2)
 if (*__first1 < *__first2)
   ++__first1;
 else if (*__first2 < *__first1)
   ++__first2;
 else
   {
     *__result = *__first1;
     ++__first1;
     ++__first2;
     ++__result;
   }
      return __result;
    }
# 4245 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    _OutputIterator
    set_intersection(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _InputIterator2 __last2,
       _OutputIterator __result, _Compare __comp)
    {

     
     
     


     

     


      ;
      ;

      while (__first1 != __last1 && __first2 != __last2)
 if (__comp(*__first1, *__first2))
   ++__first1;
 else if (__comp(*__first2, *__first1))
   ++__first2;
 else
   {
     *__result = *__first1;
     ++__first1;
     ++__first2;
     ++__result;
   }
      return __result;
    }
# 4299 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator>
    _OutputIterator
    set_difference(_InputIterator1 __first1, _InputIterator1 __last1,
     _InputIterator2 __first2, _InputIterator2 __last2,
     _OutputIterator __result)
    {

     
     
     

     


     

      ;
      ;

      while (__first1 != __last1 && __first2 != __last2)
 if (*__first1 < *__first2)
   {
     *__result = *__first1;
     ++__first1;
     ++__result;
   }
 else if (*__first2 < *__first1)
   ++__first2;
 else
   {
     ++__first1;
     ++__first2;
   }
      return std::copy(__first1, __last1, __result);
    }
# 4357 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    _OutputIterator
    set_difference(_InputIterator1 __first1, _InputIterator1 __last1,
     _InputIterator2 __first2, _InputIterator2 __last2,
     _OutputIterator __result, _Compare __comp)
    {

     
     
     


     

     


      ;
      ;

      while (__first1 != __last1 && __first2 != __last2)
 if (__comp(*__first1, *__first2))
   {
     *__result = *__first1;
     ++__first1;
     ++__result;
   }
 else if (__comp(*__first2, *__first1))
   ++__first2;
 else
   {
     ++__first1;
     ++__first2;
   }
      return std::copy(__first1, __last1, __result);
    }
# 4411 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator>
    _OutputIterator
    set_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,
        _InputIterator2 __first2, _InputIterator2 __last2,
        _OutputIterator __result)
    {

     
     
     

     


     

      ;
      ;

      while (__first1 != __last1 && __first2 != __last2)
 if (*__first1 < *__first2)
   {
     *__result = *__first1;
     ++__first1;
     ++__result;
   }
 else if (*__first2 < *__first1)
   {
     *__result = *__first2;
     ++__first2;
     ++__result;
   }
 else
   {
     ++__first1;
     ++__first2;
   }
      return std::copy(__first2, __last2, std::copy(__first1,
          __last1, __result));
    }
# 4472 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    _OutputIterator
    set_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,
        _InputIterator2 __first2, _InputIterator2 __last2,
        _OutputIterator __result,
        _Compare __comp)
    {

     
     
     


     

     


      ;
      ;

      while (__first1 != __last1 && __first2 != __last2)
 if (__comp(*__first1, *__first2))
   {
     *__result = *__first1;
     ++__first1;
     ++__result;
   }
 else if (__comp(*__first2, *__first1))
   {
     *__result = *__first2;
     ++__first2;
     ++__result;
   }
 else
   {
     ++__first1;
     ++__first2;
   }
      return std::copy(__first2, __last2, std::copy(__first1,
          __last1, __result));
    }
# 4525 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_algo.h" 3
  template<typename _ForwardIterator>
    _ForwardIterator
    max_element(_ForwardIterator __first, _ForwardIterator __last)
    {

     
     

      ;

      if (__first == __last)
 return __first;
      _ForwardIterator __result = __first;
      while (++__first != __last)
 if (*__result < *__first)
   __result = __first;
      return __result;
    }
# 4552 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Compare>
    _ForwardIterator
    max_element(_ForwardIterator __first, _ForwardIterator __last,
  _Compare __comp)
    {

     
     


      ;

      if (__first == __last) return __first;
      _ForwardIterator __result = __first;
      while (++__first != __last)
 if (__comp(*__result, *__first)) __result = __first;
      return __result;
    }







  template<typename _ForwardIterator>
    _ForwardIterator
    min_element(_ForwardIterator __first, _ForwardIterator __last)
    {

     
     

      ;

      if (__first == __last)
 return __first;
      _ForwardIterator __result = __first;
      while (++__first != __last)
 if (*__first < *__result)
   __result = __first;
      return __result;
    }
# 4604 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Compare>
    _ForwardIterator
    min_element(_ForwardIterator __first, _ForwardIterator __last,
  _Compare __comp)
    {

     
     


      ;

      if (__first == __last)
 return __first;
      _ForwardIterator __result = __first;
      while (++__first != __last)
 if (__comp(*__first, *__result))
   __result = __first;
      return __result;
    }
# 4639 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator>
    bool
    next_permutation(_BidirectionalIterator __first,
       _BidirectionalIterator __last)
    {

     

     

      ;

      if (__first == __last)
 return false;
      _BidirectionalIterator __i = __first;
      ++__i;
      if (__i == __last)
 return false;
      __i = __last;
      --__i;

      for(;;)
 {
   _BidirectionalIterator __ii = __i;
   --__i;
   if (*__i < *__ii)
     {
       _BidirectionalIterator __j = __last;
       while (!(*__i < *--__j))
  {}
       std::iter_swap(__i, __j);
       std::reverse(__ii, __last);
       return true;
     }
   if (__i == __first)
     {
       std::reverse(__first, __last);
       return false;
     }
 }
    }
# 4695 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator, typename _Compare>
    bool
    next_permutation(_BidirectionalIterator __first,
       _BidirectionalIterator __last, _Compare __comp)
    {

     

     


      ;

      if (__first == __last)
 return false;
      _BidirectionalIterator __i = __first;
      ++__i;
      if (__i == __last)
 return false;
      __i = __last;
      --__i;

      for(;;)
 {
   _BidirectionalIterator __ii = __i;
   --__i;
   if (__comp(*__i, *__ii))
     {
       _BidirectionalIterator __j = __last;
       while (!__comp(*__i, *--__j))
  {}
       std::iter_swap(__i, __j);
       std::reverse(__ii, __last);
       return true;
     }
   if (__i == __first)
     {
       std::reverse(__first, __last);
       return false;
     }
 }
    }
# 4750 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator>
    bool
    prev_permutation(_BidirectionalIterator __first,
       _BidirectionalIterator __last)
    {

     

     

      ;

      if (__first == __last)
 return false;
      _BidirectionalIterator __i = __first;
      ++__i;
      if (__i == __last)
 return false;
      __i = __last;
      --__i;

      for(;;)
 {
   _BidirectionalIterator __ii = __i;
   --__i;
   if (*__ii < *__i)
     {
       _BidirectionalIterator __j = __last;
       while (!(*--__j < *__i))
  {}
       std::iter_swap(__i, __j);
       std::reverse(__ii, __last);
       return true;
     }
   if (__i == __first)
     {
       std::reverse(__first, __last);
       return false;
     }
 }
    }
# 4806 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator, typename _Compare>
    bool
    prev_permutation(_BidirectionalIterator __first,
       _BidirectionalIterator __last, _Compare __comp)
    {

     

     


      ;

      if (__first == __last)
 return false;
      _BidirectionalIterator __i = __first;
      ++__i;
      if (__i == __last)
 return false;
      __i = __last;
      --__i;

      for(;;)
 {
   _BidirectionalIterator __ii = __i;
   --__i;
   if (__comp(*__ii, *__i))
     {
       _BidirectionalIterator __j = __last;
       while (!__comp(*--__j, *__i))
  {}
       std::iter_swap(__i, __j);
       std::reverse(__ii, __last);
       return true;
     }
   if (__i == __first)
     {
       std::reverse(__first, __last);
       return false;
     }
 }
    }
# 4865 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _ForwardIterator>
    _InputIterator
    find_first_of(_InputIterator __first1, _InputIterator __last1,
    _ForwardIterator __first2, _ForwardIterator __last2)
    {

     
     
     


      ;
      ;

      for ( ; __first1 != __last1; ++__first1)
 for (_ForwardIterator __iter = __first2; __iter != __last2; ++__iter)
   if (*__first1 == *__iter)
     return __first1;
      return __last1;
    }
# 4901 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _ForwardIterator,
    typename _BinaryPredicate>
    _InputIterator
    find_first_of(_InputIterator __first1, _InputIterator __last1,
    _ForwardIterator __first2, _ForwardIterator __last2,
    _BinaryPredicate __comp)
    {

     
     
     


     


      ;
      ;

      for ( ; __first1 != __last1; ++__first1)
 for (_ForwardIterator __iter = __first2; __iter != __last2; ++__iter)
   if (__comp(*__first1, *__iter))
     return __first1;
      return __last1;
    }
# 4934 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    _ForwardIterator1
    __find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
        _ForwardIterator2 __first2, _ForwardIterator2 __last2,
        forward_iterator_tag, forward_iterator_tag)
    {
      if (__first2 == __last2)
 return __last1;
      else
 {
   _ForwardIterator1 __result = __last1;
   while (1)
     {
       _ForwardIterator1 __new_result
  = std::search(__first1, __last1, __first2, __last2);
       if (__new_result == __last1)
  return __result;
       else
  {
    __result = __new_result;
    __first1 = __new_result;
    ++__first1;
  }
     }
 }
    }

  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
    _ForwardIterator1
    __find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
        _ForwardIterator2 __first2, _ForwardIterator2 __last2,
        forward_iterator_tag, forward_iterator_tag,
        _BinaryPredicate __comp)
    {
      if (__first2 == __last2)
 return __last1;
      else
 {
   _ForwardIterator1 __result = __last1;
   while (1)
     {
       _ForwardIterator1 __new_result
  = std::search(__first1, __last1, __first2, __last2, __comp);
       if (__new_result == __last1)
  return __result;
       else
  {
    __result = __new_result;
    __first1 = __new_result;
    ++__first1;
  }
     }
 }
    }


  template<typename _BidirectionalIterator1, typename _BidirectionalIterator2>
    _BidirectionalIterator1
    __find_end(_BidirectionalIterator1 __first1,
        _BidirectionalIterator1 __last1,
        _BidirectionalIterator2 __first2,
        _BidirectionalIterator2 __last2,
        bidirectional_iterator_tag, bidirectional_iterator_tag)
    {

     

     


      typedef reverse_iterator<_BidirectionalIterator1> _RevIterator1;
      typedef reverse_iterator<_BidirectionalIterator2> _RevIterator2;

      _RevIterator1 __rlast1(__first1);
      _RevIterator2 __rlast2(__first2);
      _RevIterator1 __rresult = std::search(_RevIterator1(__last1), __rlast1,
         _RevIterator2(__last2), __rlast2);

      if (__rresult == __rlast1)
 return __last1;
      else
 {
   _BidirectionalIterator1 __result = __rresult.base();
   std::advance(__result, -std::distance(__first2, __last2));
   return __result;
 }
    }

  template<typename _BidirectionalIterator1, typename _BidirectionalIterator2,
    typename _BinaryPredicate>
    _BidirectionalIterator1
    __find_end(_BidirectionalIterator1 __first1,
        _BidirectionalIterator1 __last1,
        _BidirectionalIterator2 __first2,
        _BidirectionalIterator2 __last2,
        bidirectional_iterator_tag, bidirectional_iterator_tag,
        _BinaryPredicate __comp)
    {

     

     


      typedef reverse_iterator<_BidirectionalIterator1> _RevIterator1;
      typedef reverse_iterator<_BidirectionalIterator2> _RevIterator2;

      _RevIterator1 __rlast1(__first1);
      _RevIterator2 __rlast2(__first2);
      _RevIterator1 __rresult = std::search(_RevIterator1(__last1), __rlast1,
         _RevIterator2(__last2), __rlast2,
         __comp);

      if (__rresult == __rlast1)
 return __last1;
      else
 {
   _BidirectionalIterator1 __result = __rresult.base();
   std::advance(__result, -std::distance(__first2, __last2));
   return __result;
 }
    }
# 5084 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    inline _ForwardIterator1
    find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
      _ForwardIterator2 __first2, _ForwardIterator2 __last2)
    {

     
     
     


      ;
      ;

      return std::__find_end(__first1, __last1, __first2, __last2,
        std::__iterator_category(__first1),
        std::__iterator_category(__first2));
    }
# 5129 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
    inline _ForwardIterator1
    find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
      _ForwardIterator2 __first2, _ForwardIterator2 __last2,
      _BinaryPredicate __comp)
    {

     
     
     


      ;
      ;

      return std::__find_end(__first1, __last1, __first2, __last2,
        std::__iterator_category(__first1),
        std::__iterator_category(__first2),
        __comp);
    }

}
# 70 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/algorithm" 2 3
# 57 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/string" 2 3
# 1 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/basic_string.tcc" 1 3
# 44 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/basic_string.tcc" 3
       
# 45 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/basic_string.tcc" 3

namespace std
{
  template<typename _Type>
    inline bool
    __is_null_pointer(_Type* __ptr)
    { return __ptr == 0; }

  template<typename _Type>
    inline bool
    __is_null_pointer(_Type)
    { return false; }

  template<typename _CharT, typename _Traits, typename _Alloc>
    const typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    _Rep::_S_max_size = (((npos - sizeof(_Rep_base))/sizeof(_CharT)) - 1) / 4;

  template<typename _CharT, typename _Traits, typename _Alloc>
    const _CharT
    basic_string<_CharT, _Traits, _Alloc>::
    _Rep::_S_terminal = _CharT();

  template<typename _CharT, typename _Traits, typename _Alloc>
    const typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::npos;



  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::_Rep::_S_empty_rep_storage[
    (sizeof(_Rep_base) + sizeof(_CharT) + sizeof(size_type) - 1) /
      sizeof(size_type)];





  template<typename _CharT, typename _Traits, typename _Alloc>
    template<typename _InIterator>
      _CharT*
      basic_string<_CharT, _Traits, _Alloc>::
      _S_construct(_InIterator __beg, _InIterator __end, const _Alloc& __a,
     input_iterator_tag)
      {
 if (__beg == __end && __a == _Alloc())
   return _S_empty_rep()._M_refdata();

 _CharT __buf[128];
 size_type __len = 0;
 while (__beg != __end && __len < sizeof(__buf) / sizeof(_CharT))
   {
     __buf[__len++] = *__beg;
     ++__beg;
   }
 _Rep* __r = _Rep::_S_create(__len, size_type(0), __a);
 traits_type::copy(__r->_M_refdata(), __buf, __len);
 try
   {
     while (__beg != __end)
       {
  if (__len == __r->_M_capacity)
    {

      _Rep* __another = _Rep::_S_create(__len + 1, __len, __a);
      traits_type::copy(__another->_M_refdata(),
          __r->_M_refdata(), __len);
      __r->_M_destroy(__a);
      __r = __another;
    }
  __r->_M_refdata()[__len++] = *__beg;
  ++__beg;
       }
   }
 catch(...)
   {
     __r->_M_destroy(__a);
     throw;
   }
 __r->_M_length = __len;
 __r->_M_refdata()[__len] = _Rep::_S_terminal;
 return __r->_M_refdata();
      }

  template<typename _CharT, typename _Traits, typename _Alloc>
    template <typename _InIterator>
      _CharT*
      basic_string<_CharT, _Traits, _Alloc>::
      _S_construct(_InIterator __beg, _InIterator __end, const _Alloc& __a,
     forward_iterator_tag)
      {
 if (__beg == __end && __a == _Alloc())
   return _S_empty_rep()._M_refdata();


 if (__builtin_expect(__is_null_pointer(__beg), 0))
   __throw_logic_error(("basic_string::_S_construct NULL not valid"));

 const size_type __dnew = static_cast<size_type>(std::distance(__beg,
              __end));

 _Rep* __r = _Rep::_S_create(__dnew, size_type(0), __a);
 try
   { _S_copy_chars(__r->_M_refdata(), __beg, __end); }
 catch(...)
   {
     __r->_M_destroy(__a);
     throw;
   }
 __r->_M_length = __dnew;
 __r->_M_refdata()[__dnew] = _Rep::_S_terminal;
 return __r->_M_refdata();
      }

  template<typename _CharT, typename _Traits, typename _Alloc>
    _CharT*
    basic_string<_CharT, _Traits, _Alloc>::
    _S_construct(size_type __n, _CharT __c, const _Alloc& __a)
    {
      if (__n == 0 && __a == _Alloc())
 return _S_empty_rep()._M_refdata();


      _Rep* __r = _Rep::_S_create(__n, size_type(0), __a);
      if (__n)
 traits_type::assign(__r->_M_refdata(), __n, __c);

      __r->_M_length = __n;
      __r->_M_refdata()[__n] = _Rep::_S_terminal;
      return __r->_M_refdata();
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const basic_string& __str)
    : _M_dataplus(__str._M_rep()->_M_grab(_Alloc(__str.get_allocator()),
       __str.get_allocator()),
    __str.get_allocator())
    { }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const _Alloc& __a)
    : _M_dataplus(_S_construct(size_type(), _CharT(), __a), __a)
    { }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const basic_string& __str, size_type __pos, size_type __n)
    : _M_dataplus(_S_construct(__str._M_data()
          + __str._M_check(__pos,
      "basic_string::basic_string"),
          __str._M_data() + __str._M_limit(__pos, __n)
          + __pos, _Alloc()), _Alloc())
    { }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const basic_string& __str, size_type __pos,
   size_type __n, const _Alloc& __a)
    : _M_dataplus(_S_construct(__str._M_data()
          + __str._M_check(__pos,
      "basic_string::basic_string"),
          __str._M_data() + __str._M_limit(__pos, __n)
          + __pos, __a), __a)
    { }


  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const _CharT* __s, size_type __n, const _Alloc& __a)
    : _M_dataplus(_S_construct(__s, __s + __n, __a), __a)
    { }


  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const _CharT* __s, const _Alloc& __a)
    : _M_dataplus(_S_construct(__s, __s ? __s + traits_type::length(__s) :
          __s + npos, __a), __a)
    { }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(size_type __n, _CharT __c, const _Alloc& __a)
    : _M_dataplus(_S_construct(__n, __c, __a), __a)
    { }


  template<typename _CharT, typename _Traits, typename _Alloc>
    template<typename _InputIterator>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(_InputIterator __beg, _InputIterator __end, const _Alloc& __a)
    : _M_dataplus(_S_construct(__beg, __end, __a), __a)
    { }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    assign(const basic_string& __str)
    {
      if (_M_rep() != __str._M_rep())
 {

   const allocator_type __a = this->get_allocator();
   _CharT* __tmp = __str._M_rep()->_M_grab(__a, __str.get_allocator());
   _M_rep()->_M_dispose(__a);
   _M_data(__tmp);
 }
      return *this;
    }

   template<typename _CharT, typename _Traits, typename _Alloc>
     basic_string<_CharT, _Traits, _Alloc>&
     basic_string<_CharT, _Traits, _Alloc>::
     assign(const _CharT* __s, size_type __n)
     {
       ;
       if (__n > this->max_size())
  __throw_length_error(("basic_string::assign"));
       if (_M_rep()->_M_is_shared() || less<const _CharT*>()(__s, _M_data())
    || less<const _CharT*>()(_M_data() + this->size(), __s))
  return _M_replace_safe(size_type(0), this->size(), __s, __n);
       else
  {

    const size_type __pos = __s - _M_data();
    if (__pos >= __n)
      traits_type::copy(_M_data(), __s, __n);
    else if (__pos)
      traits_type::move(_M_data(), __s, __n);
    _M_rep()->_M_set_sharable();
    _M_rep()->_M_length = __n;
    _M_data()[__n] = _Rep::_S_terminal;
    return *this;
  }
     }

   template<typename _CharT, typename _Traits, typename _Alloc>
     basic_string<_CharT, _Traits, _Alloc>&
     basic_string<_CharT, _Traits, _Alloc>::
     insert(size_type __pos, const _CharT* __s, size_type __n)
     {
       ;
       _M_check(__pos, "basic_string::insert");
       if (this->max_size() - this->size() < __n)
  __throw_length_error(("basic_string::insert"));
       if (_M_rep()->_M_is_shared() || less<const _CharT*>()(__s, _M_data())
           || less<const _CharT*>()(_M_data() + this->size(), __s))
         return _M_replace_safe(__pos, size_type(0), __s, __n);
       else
         {



           const size_type __off = __s - _M_data();
           _M_mutate(__pos, 0, __n);
           __s = _M_data() + __off;
           _CharT* __p = _M_data() + __pos;
           if (__s + __n <= __p)
             traits_type::copy(__p, __s, __n);
           else if (__s >= __p)
             traits_type::copy(__p, __s + __n, __n);
           else
             {
        const size_type __nleft = __p - __s;
               traits_type::copy(__p, __s, __nleft);
               traits_type::copy(__p + __nleft, __p + __n, __n - __nleft);
             }
           return *this;
         }
     }

   template<typename _CharT, typename _Traits, typename _Alloc>
     basic_string<_CharT, _Traits, _Alloc>&
     basic_string<_CharT, _Traits, _Alloc>::
     replace(size_type __pos, size_type __n1, const _CharT* __s,
      size_type __n2)
     {
       ;
       _M_check(__pos, "basic_string::replace");
       __n1 = _M_limit(__pos, __n1);
       if (this->max_size() - (this->size() - __n1) < __n2)
         __throw_length_error(("basic_string::replace"));
       bool __left;
       if (_M_rep()->_M_is_shared() || less<const _CharT*>()(__s, _M_data())
    || less<const _CharT*>()(_M_data() + this->size(), __s))
         return _M_replace_safe(__pos, __n1, __s, __n2);
       else if ((__left = __s + __n2 <= _M_data() + __pos)
  || _M_data() + __pos + __n1 <= __s)
  {

    const size_type __off = __s - _M_data();
    _M_mutate(__pos, __n1, __n2);
    if (__left)
      traits_type::copy(_M_data() + __pos,
          _M_data() + __off, __n2);
    else
      traits_type::copy(_M_data() + __pos,
          _M_data() + __off + __n2 - __n1, __n2);
    return *this;
  }
       else
  {

    const basic_string __tmp(__s, __n2);
    return _M_replace_safe(__pos, __n1, __tmp._M_data(), __n2);
  }
     }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::_Rep::
    _M_destroy(const _Alloc& __a) throw ()
    {
      if (this == &_S_empty_rep())
        return;
      const size_type __size = sizeof(_Rep_base) +
                        (this->_M_capacity + 1) * sizeof(_CharT);
      _Raw_bytes_alloc(__a).deallocate(reinterpret_cast<char*>(this), __size);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::_M_leak_hard()
    {
      if (_M_rep() == &_S_empty_rep())
        return;
      if (_M_rep()->_M_is_shared())
 _M_mutate(0, 0, 0);
      _M_rep()->_M_set_leaked();
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    _M_mutate(size_type __pos, size_type __len1, size_type __len2)
    {
      const size_type __old_size = this->size();
      const size_type __new_size = __old_size + __len2 - __len1;
      const size_type __how_much = __old_size - __pos - __len1;

      if (_M_rep() == &_S_empty_rep()
   || _M_rep()->_M_is_shared() || __new_size > capacity())
 {

   const allocator_type __a = get_allocator();
   _Rep* __r = _Rep::_S_create(__new_size, capacity(), __a);

   if (__pos)
     traits_type::copy(__r->_M_refdata(), _M_data(), __pos);
   if (__how_much)
     traits_type::copy(__r->_M_refdata() + __pos + __len2,
         _M_data() + __pos + __len1, __how_much);

   _M_rep()->_M_dispose(__a);
   _M_data(__r->_M_refdata());
 }
      else if (__how_much && __len1 != __len2)
 {

   traits_type::move(_M_data() + __pos + __len2,
       _M_data() + __pos + __len1, __how_much);
 }
      _M_rep()->_M_set_sharable();
      _M_rep()->_M_length = __new_size;
      _M_data()[__new_size] = _Rep::_S_terminal;

    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::reserve(size_type __res)
    {
      if (__res != this->capacity() || _M_rep()->_M_is_shared())
        {
   if (__res > this->max_size())
     __throw_length_error(("basic_string::reserve"));

   if (__res < this->size())
     __res = this->size();
   const allocator_type __a = get_allocator();
   _CharT* __tmp = _M_rep()->_M_clone(__a, __res - this->size());
   _M_rep()->_M_dispose(__a);
   _M_data(__tmp);
        }
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void basic_string<_CharT, _Traits, _Alloc>::swap(basic_string& __s)
    {
      if (_M_rep()->_M_is_leaked())
 _M_rep()->_M_set_sharable();
      if (__s._M_rep()->_M_is_leaked())
 __s._M_rep()->_M_set_sharable();
      if (this->get_allocator() == __s.get_allocator())
 {
   _CharT* __tmp = _M_data();
   _M_data(__s._M_data());
   __s._M_data(__tmp);
 }

      else
 {
   const basic_string __tmp1(_M_ibegin(), _M_iend(),
        __s.get_allocator());
   const basic_string __tmp2(__s._M_ibegin(), __s._M_iend(),
        this->get_allocator());
   *this = __tmp2;
   __s = __tmp1;
 }
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::_Rep*
    basic_string<_CharT, _Traits, _Alloc>::_Rep::
    _S_create(size_type __capacity, size_type __old_capacity,
       const _Alloc& __alloc)
    {
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;


      if (__capacity > _S_max_size)
 __throw_length_error(("basic_string::_S_create"));
# 494 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/basic_string.tcc" 3
      const size_type __pagesize = 4096;
      const size_type __subpagesize = 128;
      const size_type __malloc_header_size = 4 * sizeof (void*);
# 506 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/basic_string.tcc" 3
      const size_type __page_capacity = ((__pagesize - __malloc_header_size
       - sizeof(_Rep) - sizeof(_CharT))
      / sizeof(_CharT));

      if (__capacity > __old_capacity && __capacity < 2 * __old_capacity
   && __capacity > __page_capacity)
 __capacity = 2 * __old_capacity;




      size_type __size = (__capacity + 1) * sizeof(_CharT) + sizeof(_Rep);

      const size_type __adj_size = __size + __malloc_header_size;
      if (__adj_size > __pagesize)
 {
   const size_type __extra = __pagesize - __adj_size % __pagesize;
   __capacity += __extra / sizeof(_CharT);

   if (__capacity > _S_max_size)
     __capacity = _S_max_size;
   __size = (__capacity + 1) * sizeof(_CharT) + sizeof(_Rep);
 }
      else if (__size > __subpagesize)
 {
   const size_type __extra = __subpagesize - __adj_size % __subpagesize;
   __capacity += __extra / sizeof(_CharT);
   __size = (__capacity + 1) * sizeof(_CharT) + sizeof(_Rep);
 }



      void* __place = _Raw_bytes_alloc(__alloc).allocate(__size);
      _Rep *__p = new (__place) _Rep;
      __p->_M_capacity = __capacity;
      __p->_M_set_sharable();
      __p->_M_length = 0;
      return __p;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    _CharT*
    basic_string<_CharT, _Traits, _Alloc>::_Rep::
    _M_clone(const _Alloc& __alloc, size_type __res)
    {

      const size_type __requested_cap = this->_M_length + __res;
      _Rep* __r = _Rep::_S_create(__requested_cap, this->_M_capacity,
      __alloc);
      if (this->_M_length)
 traits_type::copy(__r->_M_refdata(), _M_refdata(),
     this->_M_length);

      __r->_M_length = this->_M_length;
      __r->_M_refdata()[this->_M_length] = _Rep::_S_terminal;
      return __r->_M_refdata();
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::resize(size_type __n, _CharT __c)
    {
      if (__n > max_size())
 __throw_length_error(("basic_string::resize"));
      const size_type __size = this->size();
      if (__size < __n)
 this->append(__n - __size, __c);
      else if (__n < __size)
 this->erase(__n);

    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    template<typename _InputIterator>
      basic_string<_CharT, _Traits, _Alloc>&
      basic_string<_CharT, _Traits, _Alloc>::
      _M_replace_dispatch(iterator __i1, iterator __i2, _InputIterator __k1,
     _InputIterator __k2, __false_type)
      {
 const basic_string __s(__k1, __k2);
 const size_type __n1 = __i2 - __i1;
 if (this->max_size() - (this->size() - __n1) < __s.size())
   __throw_length_error(("basic_string::_M_replace_dispatch"));
 return _M_replace_safe(__i1 - _M_ibegin(), __n1, __s._M_data(),
          __s.size());
      }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    append(const basic_string& __str)
    {



      const size_type __size = __str.size();
      const size_type __len = __size + this->size();
      if (__len > this->capacity())
 this->reserve(__len);
      return _M_replace_safe(this->size(), size_type(0), __str._M_data(),
        __str.size());
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    append(const basic_string& __str, size_type __pos, size_type __n)
    {



      __str._M_check(__pos, "basic_string::append");
      __n = __str._M_limit(__pos, __n);
      const size_type __len = __n + this->size();
      if (__len > this->capacity())
 this->reserve(__len);
      return _M_replace_safe(this->size(), size_type(0), __str._M_data()
        + __pos, __n);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    append(const _CharT* __s, size_type __n)
    {
      ;
      const size_type __len = __n + this->size();
      if (__len > this->capacity())
 this->reserve(__len);
      return _M_replace_safe(this->size(), size_type(0), __s, __n);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>
    operator+(const _CharT* __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    {
      ;
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;
      const __size_type __len = _Traits::length(__lhs);
      __string_type __str;
      __str.reserve(__len + __rhs.size());
      __str.append(__lhs, __len);
      __str.append(__rhs);
      return __str;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>
    operator+(_CharT __lhs, const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    {
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;
      __string_type __str;
      const __size_type __len = __rhs.size();
      __str.reserve(__len + 1);
      __str.append(__size_type(1), __lhs);
      __str.append(__rhs);
      return __str;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    copy(_CharT* __s, size_type __n, size_type __pos) const
    {
      _M_check(__pos, "basic_string::copy");
      __n = _M_limit(__pos, __n);
      ;
      if (__n)
 traits_type::copy(__s, _M_data() + __pos, __n);

      return __n;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find(const _CharT* __s, size_type __pos, size_type __n) const
    {
      ;
      const size_type __size = this->size();
      const _CharT* __data = _M_data();
      for (; __pos + __n <= __size; ++__pos)
 if (traits_type::compare(__data + __pos, __s, __n) == 0)
   return __pos;
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find(_CharT __c, size_type __pos) const
    {
      const size_type __size = this->size();
      size_type __ret = npos;
      if (__pos < __size)
 {
   const _CharT* __data = _M_data();
   const size_type __n = __size - __pos;
   const _CharT* __p = traits_type::find(__data + __pos, __n, __c);
   if (__p)
     __ret = __p - __data;
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    rfind(const _CharT* __s, size_type __pos, size_type __n) const
    {
      ;
      const size_type __size = this->size();
      if (__n <= __size)
 {
   __pos = std::min(size_type(__size - __n), __pos);
   const _CharT* __data = _M_data();
   do
     {
       if (traits_type::compare(__data + __pos, __s, __n) == 0)
  return __pos;
     }
   while (__pos-- > 0);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    rfind(_CharT __c, size_type __pos) const
    {
      size_type __size = this->size();
      if (__size)
 {
   if (--__size > __pos)
     __size = __pos;
   for (++__size; __size-- > 0; )
     if (traits_type::eq(_M_data()[__size], __c))
       return __size;
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_first_of(const _CharT* __s, size_type __pos, size_type __n) const
    {
      ;
      for (; __n && __pos < this->size(); ++__pos)
 {
   const _CharT* __p = traits_type::find(__s, __n, _M_data()[__pos]);
   if (__p)
     return __pos;
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_last_of(const _CharT* __s, size_type __pos, size_type __n) const
    {
      ;
      size_type __size = this->size();
      if (__size && __n)
 {
   if (--__size > __pos)
     __size = __pos;
   do
     {
       if (traits_type::find(__s, __n, _M_data()[__size]))
  return __size;
     }
   while (__size-- != 0);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_first_not_of(const _CharT* __s, size_type __pos, size_type __n) const
    {
      ;
      for (; __pos < this->size(); ++__pos)
 if (!traits_type::find(__s, __n, _M_data()[__pos]))
   return __pos;
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_first_not_of(_CharT __c, size_type __pos) const
    {
      for (; __pos < this->size(); ++__pos)
 if (!traits_type::eq(_M_data()[__pos], __c))
   return __pos;
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_last_not_of(const _CharT* __s, size_type __pos, size_type __n) const
    {
      ;
      size_type __size = this->size();
      if (__size)
 {
   if (--__size > __pos)
     __size = __pos;
   do
     {
       if (!traits_type::find(__s, __n, _M_data()[__size]))
  return __size;
     }
   while (__size--);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_last_not_of(_CharT __c, size_type __pos) const
    {
      size_type __size = this->size();
      if (__size)
 {
   if (--__size > __pos)
     __size = __pos;
   do
     {
       if (!traits_type::eq(_M_data()[__size], __c))
  return __size;
     }
   while (__size--);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string<_CharT, _Traits, _Alloc>::
    compare(size_type __pos, size_type __n, const basic_string& __str) const
    {
      _M_check(__pos, "basic_string::compare");
      __n = _M_limit(__pos, __n);
      const size_type __osize = __str.size();
      const size_type __len = std::min(__n, __osize);
      int __r = traits_type::compare(_M_data() + __pos, __str.data(), __len);
      if (!__r)
 __r = __n - __osize;
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string<_CharT, _Traits, _Alloc>::
    compare(size_type __pos1, size_type __n1, const basic_string& __str,
     size_type __pos2, size_type __n2) const
    {
      _M_check(__pos1, "basic_string::compare");
      __str._M_check(__pos2, "basic_string::compare");
      __n1 = _M_limit(__pos1, __n1);
      __n2 = __str._M_limit(__pos2, __n2);
      const size_type __len = std::min(__n1, __n2);
      int __r = traits_type::compare(_M_data() + __pos1,
         __str.data() + __pos2, __len);
      if (!__r)
 __r = __n1 - __n2;
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string<_CharT, _Traits, _Alloc>::
    compare(const _CharT* __s) const
    {
      ;
      const size_type __size = this->size();
      const size_type __osize = traits_type::length(__s);
      const size_type __len = std::min(__size, __osize);
      int __r = traits_type::compare(_M_data(), __s, __len);
      if (!__r)
 __r = __size - __osize;
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string <_CharT, _Traits, _Alloc>::
    compare(size_type __pos, size_type __n1, const _CharT* __s) const
    {
      ;
      _M_check(__pos, "basic_string::compare");
      __n1 = _M_limit(__pos, __n1);
      const size_type __osize = traits_type::length(__s);
      const size_type __len = std::min(__n1, __osize);
      int __r = traits_type::compare(_M_data() + __pos, __s, __len);
      if (!__r)
 __r = __n1 - __osize;
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string <_CharT, _Traits, _Alloc>::
    compare(size_type __pos, size_type __n1, const _CharT* __s,
     size_type __n2) const
    {
      ;
      _M_check(__pos, "basic_string::compare");
      __n1 = _M_limit(__pos, __n1);
      const size_type __len = std::min(__n1, __n2);
      int __r = traits_type::compare(_M_data() + __pos, __s, __len);
      if (!__r)
 __r = __n1 - __n2;
      return __r;
    }





  extern template class basic_string<char>;
  extern template
    basic_istream<char>&
    operator>>(basic_istream<char>&, string&);
  extern template
    basic_ostream<char>&
    operator<<(basic_ostream<char>&, const string&);
  extern template
    basic_istream<char>&
    getline(basic_istream<char>&, string&, char);
  extern template
    basic_istream<char>&
    getline(basic_istream<char>&, string&);
# 966 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/basic_string.tcc" 3
}
# 58 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/string" 2 3
# 48 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_classes.h" 2 3



namespace std
{
# 67 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_classes.h" 3
  class locale
  {
  public:


    typedef int category;


    class facet;
    class id;
    class _Impl;

    friend class facet;
    friend class _Impl;

    template<typename _Facet>
      friend bool
      has_facet(const locale&) throw();

    template<typename _Facet>
      friend const _Facet&
      use_facet(const locale&);

    template<typename _Cache>
      friend struct __use_cache;
# 105 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_classes.h" 3
    static const category none = 0;
    static const category ctype = 1L << 0;
    static const category numeric = 1L << 1;
    static const category collate = 1L << 2;
    static const category time = 1L << 3;
    static const category monetary = 1L << 4;
    static const category messages = 1L << 5;
    static const category all = (ctype | numeric | collate |
        time | monetary | messages);
# 124 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_classes.h" 3
    locale() throw();
# 133 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_classes.h" 3
    locale(const locale& __other) throw();
# 143 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_classes.h" 3
    explicit
    locale(const char* __s);
# 158 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_classes.h" 3
    locale(const locale& __base, const char* __s, category __cat);
# 171 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_classes.h" 3
    locale(const locale& __base, const locale& __add, category __cat);
# 183 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_classes.h" 3
    template<typename _Facet>
      locale(const locale& __other, _Facet* __f);


    ~locale() throw();
# 197 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_classes.h" 3
    const locale&
    operator=(const locale& __other) throw();
# 212 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_classes.h" 3
    template<typename _Facet>
      locale
      combine(const locale& __other) const;






    string
    name() const;
# 231 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_classes.h" 3
    bool
    operator==(const locale& __other) const throw ();







    inline bool
    operator!=(const locale& __other) const throw ()
    { return !(this->operator==(__other)); }
# 259 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_classes.h" 3
    template<typename _Char, typename _Traits, typename _Alloc>
      bool
      operator()(const basic_string<_Char, _Traits, _Alloc>& __s1,
   const basic_string<_Char, _Traits, _Alloc>& __s2) const;
# 275 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_classes.h" 3
    static locale
    global(const locale&);




    static const locale&
    classic();

  private:

    _Impl* _M_impl;


    static _Impl* _S_classic;


    static _Impl* _S_global;





    static const char* const* const _S_categories;
# 310 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_classes.h" 3
    static const size_t _S_categories_size = 6 + 0;


    static __gthread_once_t _S_once;


    explicit
    locale(_Impl*) throw();

    static void
    _S_initialize();

    static void
    _S_initialize_once();

    static category
    _S_normalize_category(category);

    void
    _M_coalesce(const locale& __base, const locale& __add, category __cat);
  };
# 343 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_classes.h" 3
  class locale::facet
  {
  private:
    friend class locale;
    friend class locale::_Impl;

    mutable _Atomic_word _M_refcount;


    static __c_locale _S_c_locale;


    static const char _S_c_name[2];


    static __gthread_once_t _S_once;


    static void
    _S_initialize_once();

  protected:
# 374 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_classes.h" 3
    explicit
    facet(size_t __refs = 0) throw() : _M_refcount(__refs ? 1 : 0)
    { }


    virtual
    ~facet();

    static void
    _S_create_c_locale(__c_locale& __cloc, const char* __s,
         __c_locale __old = 0);

    static __c_locale
    _S_clone_c_locale(__c_locale& __cloc);

    static void
    _S_destroy_c_locale(__c_locale& __cloc);



    static __c_locale
    _S_get_c_locale();

    static const char*
    _S_get_c_name();

  private:
    inline void
    _M_add_reference() const throw()
    { __gnu_cxx::__atomic_add(&_M_refcount, 1); }

    inline void
    _M_remove_reference() const throw()
    {
      if (__gnu_cxx::__exchange_and_add(&_M_refcount, -1) == 1)
 {
   try
     { delete this; }
   catch (...)
     { }
 }
    }

    facet(const facet&);

    facet&
    operator=(const facet&);
  };
# 434 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_classes.h" 3
  class locale::id
  {
  private:
    friend class locale;
    friend class locale::_Impl;

    template<typename _Facet>
      friend const _Facet&
      use_facet(const locale&);

    template<typename _Facet>
      friend bool
      has_facet(const locale&) throw ();




    mutable size_t _M_index;


    static _Atomic_word _S_refcount;

    void
    operator=(const id&);

    id(const id&);

  public:



    id() { }

    size_t
    _M_id() const;
  };



  class locale::_Impl
  {
  public:

    friend class locale;
    friend class locale::facet;

    template<typename _Facet>
      friend bool
      has_facet(const locale&) throw();

    template<typename _Facet>
      friend const _Facet&
      use_facet(const locale&);

    template<typename _Cache>
      friend struct __use_cache;

  private:

    _Atomic_word _M_refcount;
    const facet** _M_facets;
    size_t _M_facets_size;
    const facet** _M_caches;
    char** _M_names;
    static const locale::id* const _S_id_ctype[];
    static const locale::id* const _S_id_numeric[];
    static const locale::id* const _S_id_collate[];
    static const locale::id* const _S_id_time[];
    static const locale::id* const _S_id_monetary[];
    static const locale::id* const _S_id_messages[];
    static const locale::id* const* const _S_facet_categories[];

    inline void
    _M_add_reference() throw()
    { __gnu_cxx::__atomic_add(&_M_refcount, 1); }

    inline void
    _M_remove_reference() throw()
    {
      if (__gnu_cxx::__exchange_and_add(&_M_refcount, -1) == 1)
 {
   try
     { delete this; }
   catch(...)
     { }
 }
    }

    _Impl(const _Impl&, size_t);
    _Impl(const char*, size_t);
    _Impl(size_t) throw();

   ~_Impl() throw();

    _Impl(const _Impl&);

    void
    operator=(const _Impl&);

    inline bool
    _M_check_same_name()
    {
      bool __ret = true;
      for (size_t __i = 0; __ret && __i < _S_categories_size - 1; ++__i)
 __ret = std::strcmp(_M_names[__i], _M_names[__i + 1]) == 0;
      return __ret;
    }

    void
    _M_replace_categories(const _Impl*, category);

    void
    _M_replace_category(const _Impl*, const locale::id* const*);

    void
    _M_replace_facet(const _Impl*, const locale::id*);

    void
    _M_install_facet(const locale::id*, const facet*);

    template<typename _Facet>
      inline void
      _M_init_facet(_Facet* __facet)
      { _M_install_facet(&_Facet::id, __facet); }

    void
    _M_install_cache(const facet* __cache, size_t __index) throw()
    {
      __cache->_M_add_reference();
      _M_caches[__index] = __cache;
    }
  };

  template<typename _Facet>
    locale::locale(const locale& __other, _Facet* __f)
    {
      _M_impl = new _Impl(*__other._M_impl, 1);

      char* _M_tmp_names[_S_categories_size];
      size_t __i = 0;
      try
 {
   for (; __i < _S_categories_size; ++__i)
     {
       _M_tmp_names[__i] = new char[2];
       std::strcpy(_M_tmp_names[__i], "*");
     }
   _M_impl->_M_install_facet(&_Facet::id, __f);
 }
      catch(...)
 {
   _M_impl->_M_remove_reference();
   for (size_t __j = 0; __j < __i; ++__j)
     delete [] _M_tmp_names[__j];
   throw;
 }

      for (size_t __k = 0; __k < _S_categories_size; ++__k)
 {
   delete [] _M_impl->_M_names[__k];
   _M_impl->_M_names[__k] = _M_tmp_names[__k];
 }
    }
}
# 48 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/ios_base.h" 2 3

namespace std
{




  enum _Ios_Fmtflags { _S_ios_fmtflags_end = 1L << 16 };

  inline _Ios_Fmtflags
  operator&(_Ios_Fmtflags __a, _Ios_Fmtflags __b)
  { return _Ios_Fmtflags(static_cast<int>(__a) & static_cast<int>(__b)); }

  inline _Ios_Fmtflags
  operator|(_Ios_Fmtflags __a, _Ios_Fmtflags __b)
  { return _Ios_Fmtflags(static_cast<int>(__a) | static_cast<int>(__b)); }

  inline _Ios_Fmtflags
  operator^(_Ios_Fmtflags __a, _Ios_Fmtflags __b)
  { return _Ios_Fmtflags(static_cast<int>(__a) ^ static_cast<int>(__b)); }

  inline _Ios_Fmtflags
  operator|=(_Ios_Fmtflags& __a, _Ios_Fmtflags __b)
  { return __a = __a | __b; }

  inline _Ios_Fmtflags
  operator&=(_Ios_Fmtflags& __a, _Ios_Fmtflags __b)
  { return __a = __a & __b; }

  inline _Ios_Fmtflags
  operator^=(_Ios_Fmtflags& __a, _Ios_Fmtflags __b)
  { return __a = __a ^ __b; }

  inline _Ios_Fmtflags
  operator~(_Ios_Fmtflags __a)
  { return _Ios_Fmtflags(~static_cast<int>(__a)); }


  enum _Ios_Openmode { _S_ios_openmode_end = 1L << 16 };

  inline _Ios_Openmode
  operator&(_Ios_Openmode __a, _Ios_Openmode __b)
  { return _Ios_Openmode(static_cast<int>(__a) & static_cast<int>(__b)); }

  inline _Ios_Openmode
  operator|(_Ios_Openmode __a, _Ios_Openmode __b)
  { return _Ios_Openmode(static_cast<int>(__a) | static_cast<int>(__b)); }

  inline _Ios_Openmode
  operator^(_Ios_Openmode __a, _Ios_Openmode __b)
  { return _Ios_Openmode(static_cast<int>(__a) ^ static_cast<int>(__b)); }

  inline _Ios_Openmode
  operator|=(_Ios_Openmode& __a, _Ios_Openmode __b)
  { return __a = __a | __b; }

  inline _Ios_Openmode
  operator&=(_Ios_Openmode& __a, _Ios_Openmode __b)
  { return __a = __a & __b; }

  inline _Ios_Openmode
  operator^=(_Ios_Openmode& __a, _Ios_Openmode __b)
  { return __a = __a ^ __b; }

  inline _Ios_Openmode
  operator~(_Ios_Openmode __a)
  { return _Ios_Openmode(~static_cast<int>(__a)); }


  enum _Ios_Iostate { _S_ios_iostate_end = 1L << 16 };

  inline _Ios_Iostate
  operator&(_Ios_Iostate __a, _Ios_Iostate __b)
  { return _Ios_Iostate(static_cast<int>(__a) & static_cast<int>(__b)); }

  inline _Ios_Iostate
  operator|(_Ios_Iostate __a, _Ios_Iostate __b)
  { return _Ios_Iostate(static_cast<int>(__a) | static_cast<int>(__b)); }

  inline _Ios_Iostate
  operator^(_Ios_Iostate __a, _Ios_Iostate __b)
  { return _Ios_Iostate(static_cast<int>(__a) ^ static_cast<int>(__b)); }

  inline _Ios_Iostate
  operator|=(_Ios_Iostate& __a, _Ios_Iostate __b)
  { return __a = __a | __b; }

  inline _Ios_Iostate
  operator&=(_Ios_Iostate& __a, _Ios_Iostate __b)
  { return __a = __a & __b; }

  inline _Ios_Iostate
  operator^=(_Ios_Iostate& __a, _Ios_Iostate __b)
  { return __a = __a ^ __b; }

  inline _Ios_Iostate
  operator~(_Ios_Iostate __a)
  { return _Ios_Iostate(~static_cast<int>(__a)); }

  enum _Ios_Seekdir { _S_ios_seekdir_end = 1L << 16 };
# 158 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/ios_base.h" 3
  class ios_base
  {
  public:



    class failure : public exception
    {
    public:


      explicit
      failure(const string& __str) throw();



      virtual
      ~failure() throw();

      virtual const char*
      what() const throw();

    private:
      string _M_msg;
    };
# 210 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/ios_base.h" 3
    typedef _Ios_Fmtflags fmtflags;


    static const fmtflags boolalpha = fmtflags(__ios_flags::_S_boolalpha);


    static const fmtflags dec = fmtflags(__ios_flags::_S_dec);


    static const fmtflags fixed = fmtflags(__ios_flags::_S_fixed);


    static const fmtflags hex = fmtflags(__ios_flags::_S_hex);




    static const fmtflags internal = fmtflags(__ios_flags::_S_internal);



    static const fmtflags left = fmtflags(__ios_flags::_S_left);


    static const fmtflags oct = fmtflags(__ios_flags::_S_oct);



    static const fmtflags right = fmtflags(__ios_flags::_S_right);


    static const fmtflags scientific = fmtflags(__ios_flags::_S_scientific);



    static const fmtflags showbase = fmtflags(__ios_flags::_S_showbase);



    static const fmtflags showpoint = fmtflags(__ios_flags::_S_showpoint);


    static const fmtflags showpos = fmtflags(__ios_flags::_S_showpos);


    static const fmtflags skipws = fmtflags(__ios_flags::_S_skipws);


    static const fmtflags unitbuf = fmtflags(__ios_flags::_S_unitbuf);



    static const fmtflags uppercase = fmtflags(__ios_flags::_S_uppercase);


    static const fmtflags adjustfield = fmtflags(__ios_flags::_S_adjustfield);


    static const fmtflags basefield = fmtflags(__ios_flags::_S_basefield);


    static const fmtflags floatfield = fmtflags(__ios_flags::_S_floatfield);
# 285 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/ios_base.h" 3
    typedef _Ios_Iostate iostate;



    static const iostate badbit = iostate(__ios_flags::_S_badbit);


    static const iostate eofbit = iostate(__ios_flags::_S_eofbit);




    static const iostate failbit = iostate(__ios_flags::_S_failbit);


    static const iostate goodbit = iostate(0);
# 316 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/ios_base.h" 3
    typedef _Ios_Openmode openmode;


    static const openmode app = openmode(__ios_flags::_S_app);


    static const openmode ate = openmode(__ios_flags::_S_ate);





    static const openmode binary = openmode(__ios_flags::_S_bin);


    static const openmode in = openmode(__ios_flags::_S_in);


    static const openmode out = openmode(__ios_flags::_S_out);


    static const openmode trunc = openmode(__ios_flags::_S_trunc);
# 349 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/ios_base.h" 3
    typedef _Ios_Seekdir seekdir;


    static const seekdir beg = seekdir(0);


    static const seekdir cur = seekdir((1));


    static const seekdir end = seekdir((2));
# 377 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/ios_base.h" 3
    enum event
    {
      erase_event,
      imbue_event,
      copyfmt_event
    };
# 394 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/ios_base.h" 3
    typedef void (*event_callback) (event, ios_base&, int);
# 406 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/ios_base.h" 3
    void
    register_callback(event_callback __fn, int __index);

  protected:






    streamsize _M_precision;
    streamsize _M_width;
    fmtflags _M_flags;
    iostate _M_exception;
    iostate _M_streambuf_state;




    struct _Callback_list
    {

      _Callback_list* _M_next;
      ios_base::event_callback _M_fn;
      int _M_index;
      _Atomic_word _M_refcount;

      _Callback_list(ios_base::event_callback __fn, int __index,
       _Callback_list* __cb)
      : _M_next(__cb), _M_fn(__fn), _M_index(__index), _M_refcount(0) { }

      void
      _M_add_reference() { __gnu_cxx::__atomic_add(&_M_refcount, 1); }


      int
      _M_remove_reference()
      { return __gnu_cxx::__exchange_and_add(&_M_refcount, -1); }
    };

     _Callback_list* _M_callbacks;

    void
    _M_call_callbacks(event __ev) throw();

    void
    _M_dispose_callbacks(void);


    struct _Words
    {
      void* _M_pword;
      long _M_iword;
      _Words() : _M_pword(0), _M_iword(0) { }
    };


    _Words _M_word_zero;



    static const int _S_local_word_size = 8;
    _Words _M_local_word[_S_local_word_size];


    int _M_word_size;
    _Words* _M_word;

    _Words&
    _M_grow_words(int __index, bool __iword);


    locale _M_ios_locale;

    void
    _M_init();

  public:





    class Init
    {
      friend class ios_base;
    public:
      Init();
      ~Init();

    private:
      static _Atomic_word _S_refcount;
      static bool _S_synced_with_stdio;
    };






    inline fmtflags
    flags() const { return _M_flags; }
# 516 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/ios_base.h" 3
    inline fmtflags
    flags(fmtflags __fmtfl)
    {
      fmtflags __old = _M_flags;
      _M_flags = __fmtfl;
      return __old;
    }
# 532 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/ios_base.h" 3
    inline fmtflags
    setf(fmtflags __fmtfl)
    {
      fmtflags __old = _M_flags;
      _M_flags |= __fmtfl;
      return __old;
    }
# 549 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/ios_base.h" 3
    inline fmtflags
    setf(fmtflags __fmtfl, fmtflags __mask)
    {
      fmtflags __old = _M_flags;
      _M_flags &= ~__mask;
      _M_flags |= (__fmtfl & __mask);
      return __old;
    }







    inline void
    unsetf(fmtflags __mask) { _M_flags &= ~__mask; }
# 576 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/ios_base.h" 3
    inline streamsize
    precision() const { return _M_precision; }






    inline streamsize
    precision(streamsize __prec)
    {
      streamsize __old = _M_precision;
      _M_precision = __prec;
      return __old;
    }







    inline streamsize
    width() const { return _M_width; }






    inline streamsize
    width(streamsize __wide)
    {
      streamsize __old = _M_width;
      _M_width = __wide;
      return __old;
    }
# 625 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/ios_base.h" 3
    static bool
    sync_with_stdio(bool __sync = true);
# 637 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/ios_base.h" 3
    locale
    imbue(const locale& __loc);
# 648 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/ios_base.h" 3
    inline locale
    getloc() const { return _M_ios_locale; }
# 658 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/ios_base.h" 3
    inline const locale&
    _M_getloc() const { return _M_ios_locale; }
# 676 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/ios_base.h" 3
    static int
    xalloc() throw();
# 692 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/ios_base.h" 3
    inline long&
    iword(int __ix)
    {
      _Words& __word = (__ix < _M_word_size)
   ? _M_word[__ix] : _M_grow_words(__ix, true);
      return __word._M_iword;
    }
# 713 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/ios_base.h" 3
    inline void*&
    pword(int __ix)
    {
      _Words& __word = (__ix < _M_word_size)
   ? _M_word[__ix] : _M_grow_words(__ix, false);
      return __word._M_pword;
    }
# 730 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/ios_base.h" 3
    virtual ~ios_base();

  protected:
    ios_base();



  private:
    ios_base(const ios_base&);

    ios_base&
    operator=(const ios_base&);
  };



  inline ios_base&
  boolalpha(ios_base& __base)
  {
    __base.setf(ios_base::boolalpha);
    return __base;
  }


  inline ios_base&
  noboolalpha(ios_base& __base)
  {
    __base.unsetf(ios_base::boolalpha);
    return __base;
  }


  inline ios_base&
  showbase(ios_base& __base)
  {
    __base.setf(ios_base::showbase);
    return __base;
  }


  inline ios_base&
  noshowbase(ios_base& __base)
  {
    __base.unsetf(ios_base::showbase);
    return __base;
  }


  inline ios_base&
  showpoint(ios_base& __base)
  {
    __base.setf(ios_base::showpoint);
    return __base;
  }


  inline ios_base&
  noshowpoint(ios_base& __base)
  {
    __base.unsetf(ios_base::showpoint);
    return __base;
  }


  inline ios_base&
  showpos(ios_base& __base)
  {
    __base.setf(ios_base::showpos);
    return __base;
  }


  inline ios_base&
  noshowpos(ios_base& __base)
  {
    __base.unsetf(ios_base::showpos);
    return __base;
  }


  inline ios_base&
  skipws(ios_base& __base)
  {
    __base.setf(ios_base::skipws);
    return __base;
  }


  inline ios_base&
  noskipws(ios_base& __base)
  {
    __base.unsetf(ios_base::skipws);
    return __base;
  }


  inline ios_base&
  uppercase(ios_base& __base)
  {
    __base.setf(ios_base::uppercase);
    return __base;
  }


  inline ios_base&
  nouppercase(ios_base& __base)
  {
    __base.unsetf(ios_base::uppercase);
    return __base;
  }


  inline ios_base&
  unitbuf(ios_base& __base)
  {
     __base.setf(ios_base::unitbuf);
     return __base;
  }


  inline ios_base&
  nounitbuf(ios_base& __base)
  {
     __base.unsetf(ios_base::unitbuf);
     return __base;
  }



  inline ios_base&
  internal(ios_base& __base)
  {
     __base.setf(ios_base::internal, ios_base::adjustfield);
     return __base;
  }


  inline ios_base&
  left(ios_base& __base)
  {
    __base.setf(ios_base::left, ios_base::adjustfield);
    return __base;
  }


  inline ios_base&
  right(ios_base& __base)
  {
    __base.setf(ios_base::right, ios_base::adjustfield);
    return __base;
  }



  inline ios_base&
  dec(ios_base& __base)
  {
    __base.setf(ios_base::dec, ios_base::basefield);
    return __base;
  }


  inline ios_base&
  hex(ios_base& __base)
  {
    __base.setf(ios_base::hex, ios_base::basefield);
    return __base;
  }


  inline ios_base&
  oct(ios_base& __base)
  {
    __base.setf(ios_base::oct, ios_base::basefield);
    return __base;
  }



  inline ios_base&
  fixed(ios_base& __base)
  {
    __base.setf(ios_base::fixed, ios_base::floatfield);
    return __base;
  }


  inline ios_base&
  scientific(ios_base& __base)
  {
    __base.setf(ios_base::scientific, ios_base::floatfield);
    return __base;
  }
}
# 50 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/ios" 2 3
# 1 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/streambuf" 1 3
# 43 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/streambuf" 3
       
# 44 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/streambuf" 3






namespace std
{





  template<typename _CharT, typename _Traits>
    streamsize
    __copy_streambufs(basic_streambuf<_CharT, _Traits>* __sbin,
        basic_streambuf<_CharT, _Traits>* __sbout);
# 122 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/streambuf" 3
  template<typename _CharT, typename _Traits>
    class basic_streambuf
    {
    public:






      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;
# 145 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/streambuf" 3
      typedef basic_streambuf<char_type, traits_type> __streambuf_type;


      friend class basic_ios<char_type, traits_type>;
      friend class basic_istream<char_type, traits_type>;
      friend class basic_ostream<char_type, traits_type>;
      friend class istreambuf_iterator<char_type, traits_type>;
      friend class ostreambuf_iterator<char_type, traits_type>;

      friend streamsize
      __copy_streambufs<>(__streambuf_type* __sbin,
     __streambuf_type* __sbout);

    protected:
# 169 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/streambuf" 3
      char_type* _M_in_beg;
      char_type* _M_in_cur;
      char_type* _M_in_end;
      char_type* _M_out_beg;
      char_type* _M_out_cur;
      char_type* _M_out_end;






      locale _M_buf_locale;

  public:

      virtual
      ~basic_streambuf()
      { }
# 197 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/streambuf" 3
      locale
      pubimbue(const locale &__loc)
      {
 locale __tmp(this->getloc());
 this->imbue(__loc);
 _M_buf_locale = __loc;
 return __tmp;
      }
# 214 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/streambuf" 3
      locale
      getloc() const
      { return _M_buf_locale; }
# 227 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/streambuf" 3
      __streambuf_type*
      pubsetbuf(char_type* __s, streamsize __n)
      { return this->setbuf(__s, __n); }

      pos_type
      pubseekoff(off_type __off, ios_base::seekdir __way,
   ios_base::openmode __mode = ios_base::in | ios_base::out)
      { return this->seekoff(__off, __way, __mode); }

      pos_type
      pubseekpos(pos_type __sp,
   ios_base::openmode __mode = ios_base::in | ios_base::out)
      { return this->seekpos(__sp, __mode); }

      int
      pubsync() { return this->sync(); }
# 254 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/streambuf" 3
      streamsize
      in_avail()
      {
 const streamsize __ret = this->egptr() - this->gptr();
 return __ret ? __ret : this->showmanyc();
      }
# 268 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/streambuf" 3
      int_type
      snextc()
      {
 int_type __ret = traits_type::eof();
 if (__builtin_expect(!traits_type::eq_int_type(this->sbumpc(),
             __ret), true))
   __ret = this->sgetc();
 return __ret;
      }
# 286 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/streambuf" 3
      int_type
      sbumpc()
      {
 int_type __ret;
 if (__builtin_expect(this->gptr() < this->egptr(), true))
   {
     __ret = traits_type::to_int_type(*this->gptr());
     this->gbump(1);
   }
 else
   __ret = this->uflow();
 return __ret;
      }
# 308 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/streambuf" 3
      int_type
      sgetc()
      {
 int_type __ret;
 if (__builtin_expect(this->gptr() < this->egptr(), true))
   __ret = traits_type::to_int_type(*this->gptr());
 else
   __ret = this->underflow();
 return __ret;
      }
# 327 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/streambuf" 3
      streamsize
      sgetn(char_type* __s, streamsize __n)
      { return this->xsgetn(__s, __n); }
# 341 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/streambuf" 3
      int_type
      sputbackc(char_type __c)
      {
 int_type __ret;
 const bool __testpos = this->eback() < this->gptr();
 if (__builtin_expect(!__testpos ||
        !traits_type::eq(__c, this->gptr()[-1]), false))
   __ret = this->pbackfail(traits_type::to_int_type(__c));
 else
   {
     this->gbump(-1);
     __ret = traits_type::to_int_type(*this->gptr());
   }
 return __ret;
      }
# 366 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/streambuf" 3
      int_type
      sungetc()
      {
 int_type __ret;
 if (__builtin_expect(this->eback() < this->gptr(), true))
   {
     this->gbump(-1);
     __ret = traits_type::to_int_type(*this->gptr());
   }
 else
   __ret = this->pbackfail();
 return __ret;
      }
# 393 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/streambuf" 3
      int_type
      sputc(char_type __c)
      {
 int_type __ret;
 if (__builtin_expect(this->pptr() < this->epptr(), true))
   {
     *this->pptr() = __c;
     this->pbump(1);
     __ret = traits_type::to_int_type(__c);
   }
 else
   __ret = this->overflow(traits_type::to_int_type(__c));
 return __ret;
      }
# 419 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/streambuf" 3
      streamsize
      sputn(const char_type* __s, streamsize __n)
      { return this->xsputn(__s, __n); }

    protected:
# 433 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/streambuf" 3
      basic_streambuf()
      : _M_in_beg(0), _M_in_cur(0), _M_in_end(0),
      _M_out_beg(0), _M_out_cur(0), _M_out_end(0),
      _M_buf_locale(locale())
      { }
# 451 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/streambuf" 3
      char_type*
      eback() const { return _M_in_beg; }

      char_type*
      gptr() const { return _M_in_cur; }

      char_type*
      egptr() const { return _M_in_end; }
# 467 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/streambuf" 3
      void
      gbump(int __n) { _M_in_cur += __n; }
# 478 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/streambuf" 3
      void
      setg(char_type* __gbeg, char_type* __gnext, char_type* __gend)
      {
 _M_in_beg = __gbeg;
 _M_in_cur = __gnext;
 _M_in_end = __gend;
      }
# 498 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/streambuf" 3
      char_type*
      pbase() const { return _M_out_beg; }

      char_type*
      pptr() const { return _M_out_cur; }

      char_type*
      epptr() const { return _M_out_end; }
# 514 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/streambuf" 3
      void
      pbump(int __n) { _M_out_cur += __n; }
# 524 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/streambuf" 3
      void
      setp(char_type* __pbeg, char_type* __pend)
      {
 _M_out_beg = _M_out_cur = __pbeg;
 _M_out_end = __pend;
      }
# 545 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/streambuf" 3
      virtual void
      imbue(const locale&)
      { }
# 560 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/streambuf" 3
      virtual basic_streambuf<char_type,_Traits>*
      setbuf(char_type*, streamsize)
      { return this; }
# 571 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/streambuf" 3
      virtual pos_type
      seekoff(off_type, ios_base::seekdir,
       ios_base::openmode = ios_base::in | ios_base::out)
      { return pos_type(off_type(-1)); }
# 583 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/streambuf" 3
      virtual pos_type
      seekpos(pos_type,
       ios_base::openmode = ios_base::in | ios_base::out)
      { return pos_type(off_type(-1)); }
# 596 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/streambuf" 3
      virtual int
      sync() { return 0; }
# 618 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/streambuf" 3
      virtual streamsize
      showmanyc() { return 0; }
# 634 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/streambuf" 3
      virtual streamsize
      xsgetn(char_type* __s, streamsize __n);
# 656 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/streambuf" 3
      virtual int_type
      underflow()
      { return traits_type::eof(); }
# 669 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/streambuf" 3
      virtual int_type
      uflow()
      {
 int_type __ret = traits_type::eof();
 const bool __testeof = traits_type::eq_int_type(this->underflow(),
       __ret);
 if (!__testeof)
   {
     __ret = traits_type::to_int_type(*this->gptr());
     this->gbump(1);
   }
 return __ret;
      }
# 693 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/streambuf" 3
      virtual int_type
      pbackfail(int_type = traits_type::eof())
      { return traits_type::eof(); }
# 711 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/streambuf" 3
      virtual streamsize
      xsputn(const char_type* __s, streamsize __n);
# 736 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/streambuf" 3
      virtual int_type
      overflow(int_type = traits_type::eof())
      { return traits_type::eof(); }
# 765 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/streambuf" 3
    private:


      basic_streambuf(const __streambuf_type& __sb)
      : _M_in_beg(__sb._M_in_beg), _M_in_cur(__sb._M_in_cur),
      _M_in_end(__sb._M_in_end), _M_out_beg(__sb._M_out_beg),
      _M_out_cur(__sb._M_out_cur), _M_out_end(__sb._M_out_cur),
      _M_buf_locale(__sb._M_buf_locale)
      { }

      __streambuf_type&
      operator=(const __streambuf_type&) { return *this; };
    };
}


# 1 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/streambuf.tcc" 1 3
# 38 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/streambuf.tcc" 3
       
# 39 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/streambuf.tcc" 3

namespace std
{
  template<typename _CharT, typename _Traits>
    streamsize
    basic_streambuf<_CharT, _Traits>::
    xsgetn(char_type* __s, streamsize __n)
    {
      streamsize __ret = 0;
      while (__ret < __n)
 {
   const size_t __buf_len = this->egptr() - this->gptr();
   if (__buf_len)
     {
       const size_t __remaining = __n - __ret;
       const size_t __len = std::min(__buf_len, __remaining);
       traits_type::copy(__s, this->gptr(), __len);
       __ret += __len;
       __s += __len;
       this->gbump(__len);
     }

   if (__ret < __n)
     {
       const int_type __c = this->uflow();
       if (!traits_type::eq_int_type(__c, traits_type::eof()))
  {
    traits_type::assign(*__s++, traits_type::to_char_type(__c));
    ++__ret;
  }
       else
  break;
     }
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    streamsize
    basic_streambuf<_CharT, _Traits>::
    xsputn(const char_type* __s, streamsize __n)
    {
      streamsize __ret = 0;
      while (__ret < __n)
 {
   const size_t __buf_len = this->epptr() - this->pptr();
   if (__buf_len)
     {
       const size_t __remaining = __n - __ret;
       const size_t __len = std::min(__buf_len, __remaining);
       traits_type::copy(this->pptr(), __s, __len);
       __ret += __len;
       __s += __len;
       this->pbump(__len);
     }

   if (__ret < __n)
     {
       int_type __c = this->overflow(traits_type::to_int_type(*__s));
       if (!traits_type::eq_int_type(__c, traits_type::eof()))
  {
    ++__ret;
    ++__s;
  }
       else
  break;
     }
 }
      return __ret;
    }





  template<typename _CharT, typename _Traits>
    streamsize
    __copy_streambufs(basic_streambuf<_CharT, _Traits>* __sbin,
        basic_streambuf<_CharT, _Traits>* __sbout)
    {
      streamsize __ret = 0;
      typename _Traits::int_type __c = __sbin->sgetc();
      while (!_Traits::eq_int_type(__c, _Traits::eof()))
 {
   const size_t __n = __sbin->egptr() - __sbin->gptr();
   if (__n > 1)
     {
       const size_t __wrote = __sbout->sputn(__sbin->gptr(), __n);
       __sbin->gbump(__wrote);
       __ret += __wrote;
       if (__wrote < __n)
  break;
       __c = __sbin->underflow();
     }
   else
     {
       __c = __sbout->sputc(_Traits::to_char_type(__c));
       if (_Traits::eq_int_type(__c, _Traits::eof()))
  break;
       ++__ret;
       __c = __sbin->snextc();
     }
 }
      return __ret;
    }





  extern template class basic_streambuf<char>;
  extern template
    streamsize
    __copy_streambufs(basic_streambuf<char>*, basic_streambuf<char>*);
# 161 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/streambuf.tcc" 3
}
# 782 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/streambuf" 2 3
# 51 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/ios" 2 3
# 1 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/basic_ios.h" 1 3
# 39 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/basic_ios.h" 3
       
# 40 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/basic_ios.h" 3

# 1 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/streambuf_iterator.h" 1 3
# 39 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/streambuf_iterator.h" 3
       
# 40 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/streambuf_iterator.h" 3






namespace std
{


  template<typename _CharT, typename _Traits>
    class istreambuf_iterator
    : public iterator<input_iterator_tag, _CharT, typename _Traits::off_type,
        _CharT*, _CharT&>
    {
    public:



      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef typename _Traits::int_type int_type;
      typedef basic_streambuf<_CharT, _Traits> streambuf_type;
      typedef basic_istream<_CharT, _Traits> istream_type;


    private:







      mutable streambuf_type* _M_sbuf;
      int_type _M_c;

    public:

      istreambuf_iterator() throw()
      : _M_sbuf(0), _M_c(traits_type::eof()) { }


      istreambuf_iterator(istream_type& __s) throw()
      : _M_sbuf(__s.rdbuf()), _M_c(traits_type::eof()) { }


      istreambuf_iterator(streambuf_type* __s) throw()
      : _M_sbuf(__s), _M_c(traits_type::eof()) { }




      char_type
      operator*() const
      {







 return traits_type::to_char_type(_M_get());
      }


      istreambuf_iterator&
      operator++()
      {
 ;


 const int_type __eof = traits_type::eof();
 if (_M_sbuf && traits_type::eq_int_type(_M_sbuf->sbumpc(), __eof))
   _M_sbuf = 0;
 else
   _M_c = __eof;
 return *this;
      }


      istreambuf_iterator
      operator++(int)
      {
 ;



 const int_type __eof = traits_type::eof();
 istreambuf_iterator __old = *this;
 if (_M_sbuf
     && traits_type::eq_int_type((__old._M_c = _M_sbuf->sbumpc()),
     __eof))
   _M_sbuf = 0;
 else
   _M_c = __eof;
 return __old;
      }





      bool
      equal(const istreambuf_iterator& __b) const
      {
 const bool __thiseof = _M_at_eof();
 const bool __beof = __b._M_at_eof();
 return (__thiseof && __beof || (!__thiseof && !__beof));
      }

    private:
      int_type
      _M_get() const
      {
 const int_type __eof = traits_type::eof();
 int_type __ret = __eof;
 if (_M_sbuf)
   {
     if (!traits_type::eq_int_type(_M_c, __eof))
       __ret = _M_c;
     else if (traits_type::eq_int_type((__ret = _M_sbuf->sgetc()),
           __eof))
       _M_sbuf = 0;
   }
 return __ret;
      }

      bool
      _M_at_eof() const
      {
 const int_type __eof = traits_type::eof();
 return traits_type::eq_int_type(_M_get(), __eof);
      }
    };

  template<typename _CharT, typename _Traits>
    inline bool
    operator==(const istreambuf_iterator<_CharT, _Traits>& __a,
        const istreambuf_iterator<_CharT, _Traits>& __b)
    { return __a.equal(__b); }

  template<typename _CharT, typename _Traits>
    inline bool
    operator!=(const istreambuf_iterator<_CharT, _Traits>& __a,
        const istreambuf_iterator<_CharT, _Traits>& __b)
    { return !__a.equal(__b); }


  template<typename _CharT, typename _Traits>
    class ostreambuf_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    public:



      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef basic_streambuf<_CharT, _Traits> streambuf_type;
      typedef basic_ostream<_CharT, _Traits> ostream_type;


    private:
      streambuf_type* _M_sbuf;
      bool _M_failed;

    public:

      ostreambuf_iterator(ostream_type& __s) throw ()
      : _M_sbuf(__s.rdbuf()), _M_failed(!_M_sbuf) { }


      ostreambuf_iterator(streambuf_type* __s) throw ()
      : _M_sbuf(__s), _M_failed(!_M_sbuf) { }


      ostreambuf_iterator&
      operator=(_CharT __c)
      {
 if (!_M_failed &&
     _Traits::eq_int_type(_M_sbuf->sputc(__c), _Traits::eof()))
   _M_failed = true;
 return *this;
      }


      ostreambuf_iterator&
      operator*()
      { return *this; }


      ostreambuf_iterator&
      operator++(int)
      { return *this; }


      ostreambuf_iterator&
      operator++()
      { return *this; }


      bool
      failed() const throw()
      { return _M_failed; }

      ostreambuf_iterator&
      _M_put(const _CharT* __ws, streamsize __len)
      {
 if (__builtin_expect(!_M_failed, true)
     && __builtin_expect(this->_M_sbuf->sputn(__ws, __len) != __len,
    false))
   _M_failed = true;
 return *this;
      }
    };
}
# 42 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/basic_ios.h" 2 3


# 1 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.h" 1 3
# 43 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.h" 3
       
# 44 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.h" 3


# 1 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/cwctype" 1 3
# 47 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/cwctype" 3
       
# 48 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/cwctype" 3
# 79 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/cwctype" 3
namespace std
{
  using ::wint_t;

  using ::wctype_t;
  using ::wctrans_t;

  using ::iswalnum;
  using ::iswalpha;



  using ::iswcntrl;
  using ::iswdigit;
  using ::iswgraph;
  using ::iswlower;
  using ::iswprint;
  using ::iswprint;
  using ::iswpunct;
  using ::iswspace;
  using ::iswupper;
  using ::iswxdigit;
  using ::iswctype;
  using ::towlower;
  using ::towupper;
  using ::towctrans;
  using ::wctrans;
  using ::wctype;
}
# 47 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.h" 2 3




namespace std
{
# 63 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.h" 3
  template<typename _Tv>
    void
    __convert_to_v(const char* __in, _Tv& __out, ios_base::iostate& __err,
     const __c_locale& __cloc);


  template<>
    void
    __convert_to_v(const char*, float&, ios_base::iostate&,
     const __c_locale&);

  template<>
    void
    __convert_to_v(const char*, double&, ios_base::iostate&,
     const __c_locale&);

  template<>
    void
    __convert_to_v(const char*, long double&, ios_base::iostate&,
     const __c_locale&);



  template<typename _CharT, typename _Traits>
    struct __pad
    {
      static void
      _S_pad(ios_base& __io, _CharT __fill, _CharT* __news,
      const _CharT* __olds, const streamsize __newlen,
      const streamsize __oldlen, const bool __num);
    };






  template<typename _CharT>
    _CharT*
    __add_grouping(_CharT* __s, _CharT __sep,
     const char* __gbeg, size_t __gsize,
     const _CharT* __first, const _CharT* __last);




  template<typename _CharT>
    inline
    ostreambuf_iterator<_CharT>
    __write(ostreambuf_iterator<_CharT> __s, const _CharT* __ws, int __len)
    {
      __s._M_put(__ws, __len);
      return __s;
    }


  template<typename _CharT, typename _OutIter>
    inline
    _OutIter
    __write(_OutIter __s, const _CharT* __ws, int __len)
    {
      for (int __j = 0; __j < __len; __j++, ++__s)
 *__s = __ws[__j];
      return __s;
    }




# 1 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/mingw32/bits/ctype_base.h" 1 3
# 36 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/mingw32/bits/ctype_base.h" 3
  struct ctype_base
  {

    typedef const int* __to_type;



    typedef unsigned short mask;
    static const mask upper = 0x0001;
    static const mask lower = 0x0002;
    static const mask alpha = 0x0103;
    static const mask digit = 0x0004;
    static const mask xdigit = 0x0080;
    static const mask space = 0x0008;
    static const mask print = (0x0040 | 0x0010| 0x0103 | 0x0004);
    static const mask graph = (0x0010 | 0x0103 | 0x0004);
    static const mask cntrl = 0x0020;
    static const mask punct = 0x0010;
    static const mask alnum = (0x0103 | 0x0004);
  };
# 133 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.h" 2 3
# 144 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.h" 3
  template<typename _CharT>
    class __ctype_abstract_base : public locale::facet, public ctype_base
    {
    public:


      typedef _CharT char_type;
# 162 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.h" 3
      bool
      is(mask __m, char_type __c) const
      { return this->do_is(__m, __c); }
# 179 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.h" 3
      const char_type*
      is(const char_type *__lo, const char_type *__hi, mask *__vec) const
      { return this->do_is(__lo, __hi, __vec); }
# 195 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.h" 3
      const char_type*
      scan_is(mask __m, const char_type* __lo, const char_type* __hi) const
      { return this->do_scan_is(__m, __lo, __hi); }
# 211 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.h" 3
      const char_type*
      scan_not(mask __m, const char_type* __lo, const char_type* __hi) const
      { return this->do_scan_not(__m, __lo, __hi); }
# 225 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.h" 3
      char_type
      toupper(char_type __c) const
      { return this->do_toupper(__c); }
# 240 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.h" 3
      const char_type*
      toupper(char_type *__lo, const char_type* __hi) const
      { return this->do_toupper(__lo, __hi); }
# 254 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.h" 3
      char_type
      tolower(char_type __c) const
      { return this->do_tolower(__c); }
# 269 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.h" 3
      const char_type*
      tolower(char_type* __lo, const char_type* __hi) const
      { return this->do_tolower(__lo, __hi); }
# 286 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.h" 3
      char_type
      widen(char __c) const
      { return this->do_widen(__c); }
# 305 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.h" 3
      const char*
      widen(const char* __lo, const char* __hi, char_type* __to) const
      { return this->do_widen(__lo, __hi, __to); }
# 324 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.h" 3
      char
      narrow(char_type __c, char __dfault) const
      { return this->do_narrow(__c, __dfault); }
# 346 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.h" 3
      const char_type*
      narrow(const char_type* __lo, const char_type* __hi,
       char __dfault, char *__to) const
      { return this->do_narrow(__lo, __hi, __dfault, __to); }

    protected:
      explicit
      __ctype_abstract_base(size_t __refs = 0): facet(__refs) { }

      virtual
      ~__ctype_abstract_base() { }
# 371 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.h" 3
      virtual bool
      do_is(mask __m, char_type __c) const = 0;
# 390 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.h" 3
      virtual const char_type*
      do_is(const char_type* __lo, const char_type* __hi,
     mask* __vec) const = 0;
# 409 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.h" 3
      virtual const char_type*
      do_scan_is(mask __m, const char_type* __lo,
   const char_type* __hi) const = 0;
# 428 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.h" 3
      virtual const char_type*
      do_scan_not(mask __m, const char_type* __lo,
    const char_type* __hi) const = 0;
# 446 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.h" 3
      virtual char_type
      do_toupper(char_type) const = 0;
# 463 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.h" 3
      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const = 0;
# 479 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.h" 3
      virtual char_type
      do_tolower(char_type) const = 0;
# 496 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.h" 3
      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const = 0;
# 515 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.h" 3
      virtual char_type
      do_widen(char) const = 0;
# 536 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.h" 3
      virtual const char*
      do_widen(const char* __lo, const char* __hi,
        char_type* __dest) const = 0;
# 558 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.h" 3
      virtual char
      do_narrow(char_type, char __dfault) const = 0;
# 582 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.h" 3
      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
  char __dfault, char* __dest) const = 0;
    };
# 605 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.h" 3
  template<typename _CharT>
    class ctype : public __ctype_abstract_base<_CharT>
    {
    public:

      typedef _CharT char_type;
      typedef typename __ctype_abstract_base<_CharT>::mask mask;


      static locale::id id;

      explicit
      ctype(size_t __refs = 0) : __ctype_abstract_base<_CharT>(__refs) { }

   protected:
      virtual
      ~ctype();

      virtual bool
      do_is(mask __m, char_type __c) const;

      virtual const char_type*
      do_is(const char_type* __lo, const char_type* __hi, mask* __vec) const;

      virtual const char_type*
      do_scan_is(mask __m, const char_type* __lo, const char_type* __hi) const;

      virtual const char_type*
      do_scan_not(mask __m, const char_type* __lo,
    const char_type* __hi) const;

      virtual char_type
      do_toupper(char_type __c) const;

      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const;

      virtual char_type
      do_tolower(char_type __c) const;

      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const;

      virtual char_type
      do_widen(char __c) const;

      virtual const char*
      do_widen(const char* __lo, const char* __hi, char_type* __dest) const;

      virtual char
      do_narrow(char_type, char __dfault) const;

      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
  char __dfault, char* __dest) const;
    };

  template<typename _CharT>
    locale::id ctype<_CharT>::id;
# 674 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.h" 3
  template<>
    class ctype<char> : public locale::facet, public ctype_base
    {
    public:


      typedef char char_type;

    protected:

      __c_locale _M_c_locale_ctype;
      bool _M_del;
      __to_type _M_toupper;
      __to_type _M_tolower;
      const mask* _M_table;
      mutable char _M_widen_ok;
      mutable char _M_widen[1 + static_cast<unsigned char>(-1)];
      mutable char _M_narrow[1 + static_cast<unsigned char>(-1)];
      mutable char _M_narrow_ok;


    public:

      static locale::id id;

      static const size_t table_size = 1 + static_cast<unsigned char>(-1);
# 711 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.h" 3
      explicit
      ctype(const mask* __table = 0, bool __del = false, size_t __refs = 0);
# 724 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.h" 3
      explicit
      ctype(__c_locale __cloc, const mask* __table = 0, bool __del = false,
     size_t __refs = 0);
# 737 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.h" 3
      inline bool
      is(mask __m, char __c) const;
# 752 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.h" 3
      inline const char*
      is(const char* __lo, const char* __hi, mask* __vec) const;
# 766 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.h" 3
      inline const char*
      scan_is(mask __m, const char* __lo, const char* __hi) const;
# 780 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.h" 3
      inline const char*
      scan_not(mask __m, const char* __lo, const char* __hi) const;
# 795 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.h" 3
      char_type
      toupper(char_type __c) const
      { return this->do_toupper(__c); }
# 812 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.h" 3
      const char_type*
      toupper(char_type *__lo, const char_type* __hi) const
      { return this->do_toupper(__lo, __hi); }
# 828 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.h" 3
      char_type
      tolower(char_type __c) const
      { return this->do_tolower(__c); }
# 845 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.h" 3
      const char_type*
      tolower(char_type* __lo, const char_type* __hi) const
      { return this->do_tolower(__lo, __hi); }
# 865 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.h" 3
      char_type
      widen(char __c) const
      {
 if (_M_widen_ok) return _M_widen[static_cast<unsigned char>(__c)];
 this->_M_widen_init();
 return this->do_widen(__c);
      }
# 891 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.h" 3
      const char*
      widen(const char* __lo, const char* __hi, char_type* __to) const
      {
 if (_M_widen_ok == 1)
   {
     memcpy(__to, __lo, __hi - __lo);
     return __hi;
   }
 if (!_M_widen_ok) _M_widen_init();
 return this->do_widen(__lo, __hi, __to);
      }
# 921 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.h" 3
      char
      narrow(char_type __c, char __dfault) const
      {
 if (_M_narrow[static_cast<unsigned char>(__c)])
   return _M_narrow[static_cast<unsigned char>(__c)];
 const char __t = do_narrow(__c, __dfault);
 if (__t != __dfault) _M_narrow[static_cast<unsigned char>(__c)] = __t;
 return __t;
      }
# 953 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.h" 3
      const char_type*
      narrow(const char_type* __lo, const char_type* __hi,
      char __dfault, char *__to) const
      {
 if (__builtin_expect(_M_narrow_ok == 1,true))
   {
     memcpy(__to, __lo, __hi - __lo);
     return __hi;
   }
 if (!_M_narrow_ok)
   _M_narrow_init();
 return this->do_narrow(__lo, __hi, __dfault, __to);
      }

    protected:


      const mask*
      table() const throw()
      { return _M_table; }


      static const mask*
      classic_table() throw();







      virtual
      ~ctype();
# 1000 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.h" 3
      virtual char_type
      do_toupper(char_type) const;
# 1017 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.h" 3
      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const;
# 1033 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.h" 3
      virtual char_type
      do_tolower(char_type) const;
# 1050 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.h" 3
      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const;
# 1070 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.h" 3
      virtual char_type
      do_widen(char __c) const
      { return __c; }
# 1093 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.h" 3
      virtual const char*
      do_widen(const char* __lo, const char* __hi, char_type* __dest) const
      {
 memcpy(__dest, __lo, __hi - __lo);
 return __hi;
      }
# 1119 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.h" 3
      virtual char
      do_narrow(char_type __c, char) const
      { return __c; }
# 1145 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.h" 3
      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
  char, char* __dest) const
      {
 memcpy(__dest, __lo, __hi - __lo);
 return __hi;
      }

    private:

      void _M_widen_init() const
      {
 char __tmp[sizeof(_M_widen)];
 for (size_t __i = 0; __i < sizeof(_M_widen); ++__i)
   __tmp[__i] = __i;
 do_widen(__tmp, __tmp + sizeof(__tmp), _M_widen);

 _M_widen_ok = 1;

 for (size_t __j = 0; __j < sizeof(_M_widen); ++__j)
   if (__tmp[__j] != _M_widen[__j])
     {
       _M_widen_ok = 2;
       break;
     }
      }




      void _M_narrow_init() const
      {
 char __tmp[sizeof(_M_narrow)];
 for (size_t __i = 0; __i < sizeof(_M_narrow); ++__i)
   __tmp[__i] = __i;
 do_narrow(__tmp, __tmp + sizeof(__tmp), 0, _M_narrow);



 bool __consecutive = true;
 for (size_t __j = 0; __j < sizeof(_M_narrow); ++__j)
   if (!_M_narrow[__j])
     {
       char __c;
       do_narrow(__tmp + __j, __tmp + __j + 1, 1, &__c);
       if (__c == 1)
  {
    __consecutive = false;
    break;
  }
     }
 _M_narrow_ok = __consecutive ? 1 : 2;
      }
    };

  template<>
    const ctype<char>&
    use_facet<ctype<char> >(const locale& __loc);
# 1512 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.h" 3
# 1 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/mingw32/bits/ctype_inline.h" 1 3
# 38 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/mingw32/bits/ctype_inline.h" 3
  bool
  ctype<char>::
  is(mask __m, char __c) const
  {
 return (_M_table[static_cast<unsigned char>(__c) ] & __m);
  }


  const char*
  ctype<char>::
  is(const char* __low, const char* __high, mask* __vec) const
  {
    while (__low < __high)
      *__vec++ = _M_table[static_cast<unsigned char>(*__low++)];
    return __high;
  }

  const char*
  ctype<char>::
  scan_is(mask __m, const char* __low, const char* __high) const
  {
    while (__low < __high && !this->is(__m, *__low))
      ++__low;
    return __low;
  }

  const char*
  ctype<char>::
  scan_not(mask __m, const char* __low, const char* __high) const
  {
    while (__low < __high && this->is(__m, *__low) != 0)
      ++__low;
    return __low;
  }
# 1513 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.h" 2 3


  template<typename _CharT>
    class ctype_byname : public ctype<_CharT>
    {
    public:
      typedef _CharT char_type;

      explicit
      ctype_byname(const char* __s, size_t __refs = 0);

    protected:
      virtual
      ~ctype_byname() { };
    };


  template<>
    ctype_byname<char>::ctype_byname(const char*, size_t refs);

  template<>
    ctype_byname<wchar_t>::ctype_byname(const char*, size_t refs);


# 1 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/codecvt.h" 1 3
# 44 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/codecvt.h" 3
       
# 45 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/codecvt.h" 3



  class codecvt_base
  {
  public:
    enum result
    {
      ok,
      partial,
      error,
      noconv
    };
  };
# 73 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/codecvt.h" 3
  template<typename _InternT, typename _ExternT, typename _StateT>
    class __codecvt_abstract_base
    : public locale::facet, public codecvt_base
    {
    public:

      typedef codecvt_base::result result;
      typedef _InternT intern_type;
      typedef _ExternT extern_type;
      typedef _StateT state_type;
# 120 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/codecvt.h" 3
      result
      out(state_type& __state, const intern_type* __from,
   const intern_type* __from_end, const intern_type*& __from_next,
   extern_type* __to, extern_type* __to_end,
   extern_type*& __to_next) const
      {
 return this->do_out(__state, __from, __from_end, __from_next,
       __to, __to_end, __to_next);
      }
# 159 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/codecvt.h" 3
      result
      unshift(state_type& __state, extern_type* __to, extern_type* __to_end,
       extern_type*& __to_next) const
      { return this->do_unshift(__state, __to,__to_end,__to_next); }
# 199 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/codecvt.h" 3
      result
      in(state_type& __state, const extern_type* __from,
  const extern_type* __from_end, const extern_type*& __from_next,
  intern_type* __to, intern_type* __to_end,
  intern_type*& __to_next) const
      {
 return this->do_in(__state, __from, __from_end, __from_next,
      __to, __to_end, __to_next);
      }

      int
      encoding() const throw()
      { return this->do_encoding(); }

      bool
      always_noconv() const throw()
      { return this->do_always_noconv(); }

      int
      length(state_type& __state, const extern_type* __from,
      const extern_type* __end, size_t __max) const
      { return this->do_length(__state, __from, __end, __max); }

      int
      max_length() const throw()
      { return this->do_max_length(); }

    protected:
      explicit
      __codecvt_abstract_base(size_t __refs = 0) : locale::facet(__refs) { }

      virtual
      ~__codecvt_abstract_base() { }
# 240 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/codecvt.h" 3
      virtual result
      do_out(state_type& __state, const intern_type* __from,
      const intern_type* __from_end, const intern_type*& __from_next,
      extern_type* __to, extern_type* __to_end,
      extern_type*& __to_next) const = 0;

      virtual result
      do_unshift(state_type& __state, extern_type* __to,
   extern_type* __to_end, extern_type*& __to_next) const = 0;

      virtual result
      do_in(state_type& __state, const extern_type* __from,
     const extern_type* __from_end, const extern_type*& __from_next,
     intern_type* __to, intern_type* __to_end,
     intern_type*& __to_next) const = 0;

      virtual int
      do_encoding() const throw() = 0;

      virtual bool
      do_always_noconv() const throw() = 0;

      virtual int
      do_length(state_type&, const extern_type* __from,
  const extern_type* __end, size_t __max) const = 0;

      virtual int
      do_max_length() const throw() = 0;
    };



  template<typename _InternT, typename _ExternT, typename _StateT>
    class codecvt
    : public __codecvt_abstract_base<_InternT, _ExternT, _StateT>
    {
    public:

      typedef codecvt_base::result result;
      typedef _InternT intern_type;
      typedef _ExternT extern_type;
      typedef _StateT state_type;

    protected:
      __c_locale _M_c_locale_codecvt;

    public:
      static locale::id id;

      explicit
      codecvt(size_t __refs = 0)
      : __codecvt_abstract_base<_InternT, _ExternT, _StateT> (__refs) { }

      explicit
      codecvt(__c_locale __cloc, size_t __refs = 0);

    protected:
      virtual
      ~codecvt() { }

      virtual result
      do_out(state_type& __state, const intern_type* __from,
      const intern_type* __from_end, const intern_type*& __from_next,
      extern_type* __to, extern_type* __to_end,
      extern_type*& __to_next) const;

      virtual result
      do_unshift(state_type& __state, extern_type* __to,
   extern_type* __to_end, extern_type*& __to_next) const;

      virtual result
      do_in(state_type& __state, const extern_type* __from,
     const extern_type* __from_end, const extern_type*& __from_next,
     intern_type* __to, intern_type* __to_end,
     intern_type*& __to_next) const;

      virtual int
      do_encoding() const throw();

      virtual bool
      do_always_noconv() const throw();

      virtual int
      do_length(state_type&, const extern_type* __from,
  const extern_type* __end, size_t __max) const;

      virtual int
      do_max_length() const throw();
    };

  template<typename _InternT, typename _ExternT, typename _StateT>
    locale::id codecvt<_InternT, _ExternT, _StateT>::id;


  template<>
    class codecvt<char, char, mbstate_t>
    : public __codecvt_abstract_base<char, char, mbstate_t>
    {
    public:

      typedef char intern_type;
      typedef char extern_type;
      typedef mbstate_t state_type;

    protected:
      __c_locale _M_c_locale_codecvt;

    public:
      static locale::id id;

      explicit
      codecvt(size_t __refs = 0);

      explicit
      codecvt(__c_locale __cloc, size_t __refs = 0);

    protected:
      virtual
      ~codecvt();

      virtual result
      do_out(state_type& __state, const intern_type* __from,
      const intern_type* __from_end, const intern_type*& __from_next,
      extern_type* __to, extern_type* __to_end,
      extern_type*& __to_next) const;

      virtual result
      do_unshift(state_type& __state, extern_type* __to,
   extern_type* __to_end, extern_type*& __to_next) const;

      virtual result
      do_in(state_type& __state, const extern_type* __from,
     const extern_type* __from_end, const extern_type*& __from_next,
     intern_type* __to, intern_type* __to_end,
     intern_type*& __to_next) const;

      virtual int
      do_encoding() const throw();

      virtual bool
      do_always_noconv() const throw();

      virtual int
      do_length(state_type&, const extern_type* __from,
  const extern_type* __end, size_t __max) const;

      virtual int
      do_max_length() const throw();
  };
# 452 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/codecvt.h" 3
  template<typename _InternT, typename _ExternT, typename _StateT>
    class codecvt_byname : public codecvt<_InternT, _ExternT, _StateT>
    {
    public:
      explicit
      codecvt_byname(const char* __s, size_t __refs = 0)
      : codecvt<_InternT, _ExternT, _StateT>(__refs)
      {
 if (std::strcmp(__s, "C") != 0 && std::strcmp(__s, "POSIX") != 0)
   {
     this->_S_destroy_c_locale(this->_M_c_locale_codecvt);
     this->_S_create_c_locale(this->_M_c_locale_codecvt, __s);
   }
      }

    protected:
      virtual
      ~codecvt_byname() { }
    };
# 1538 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.h" 2 3


  class __num_base
  {
  public:


    enum
      {
        _S_ominus,
        _S_oplus,
        _S_ox,
        _S_oX,
        _S_odigits,
        _S_odigits_end = _S_odigits + 16,
        _S_oudigits = _S_odigits_end,
        _S_oudigits_end = _S_oudigits + 16,
        _S_oe = _S_odigits + 14,
        _S_oE = _S_oudigits + 14,
 _S_oend = _S_oudigits_end
      };






    static const char* _S_atoms_out;



    static const char* _S_atoms_in;

    enum
    {
      _S_iminus,
      _S_iplus,
      _S_ix,
      _S_iX,
      _S_izero,
      _S_ie = _S_izero + 14,
      _S_iE = _S_izero + 20,
      _S_iend = 26
    };



    static void
    _S_format_float(const ios_base& __io, char* __fptr, char __mod);
  };

  template<typename _CharT>
    struct __numpunct_cache : public locale::facet
    {
      const char* _M_grouping;
      size_t _M_grouping_size;
      bool _M_use_grouping;
      const _CharT* _M_truename;
      size_t _M_truename_size;
      const _CharT* _M_falsename;
      size_t _M_falsename_size;
      _CharT _M_decimal_point;
      _CharT _M_thousands_sep;





      _CharT _M_atoms_out[__num_base::_S_oend];





      _CharT _M_atoms_in[__num_base::_S_iend];

      bool _M_allocated;

      __numpunct_cache(size_t __refs = 0) : facet(__refs),
      _M_grouping(__null), _M_grouping_size(0), _M_use_grouping(false),
      _M_truename(__null), _M_truename_size(0), _M_falsename(__null),
      _M_falsename_size(0), _M_decimal_point(_CharT()),
      _M_thousands_sep(_CharT()), _M_allocated(false)
      { }

      ~__numpunct_cache();

      void
      _M_cache(const locale& __loc);

    private:
      __numpunct_cache&
      operator=(const __numpunct_cache&);

      explicit
      __numpunct_cache(const __numpunct_cache&);
    };

  template<typename _CharT>
    __numpunct_cache<_CharT>::~__numpunct_cache()
    {
      if (_M_allocated)
 {
   delete [] _M_grouping;
   delete [] _M_truename;
   delete [] _M_falsename;
 }
    }
# 1660 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.h" 3
  template<typename _CharT>
    class numpunct : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;

      typedef __numpunct_cache<_CharT> __cache_type;

    protected:
      __cache_type* _M_data;

    public:

      static locale::id id;






      explicit
      numpunct(size_t __refs = 0) : facet(__refs), _M_data(__null)
      { _M_initialize_numpunct(); }
# 1697 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.h" 3
      explicit
      numpunct(__cache_type* __cache, size_t __refs = 0)
      : facet(__refs), _M_data(__cache)
      { _M_initialize_numpunct(); }
# 1711 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.h" 3
      explicit
      numpunct(__c_locale __cloc, size_t __refs = 0)
      : facet(__refs), _M_data(__null)
      { _M_initialize_numpunct(__cloc); }
# 1725 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.h" 3
      char_type
      decimal_point() const
      { return this->do_decimal_point(); }
# 1738 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.h" 3
      char_type
      thousands_sep() const
      { return this->do_thousands_sep(); }
# 1769 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.h" 3
      string
      grouping() const
      { return this->do_grouping(); }
# 1782 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.h" 3
      string_type
      truename() const
      { return this->do_truename(); }
# 1795 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.h" 3
      string_type
      falsename() const
      { return this->do_falsename(); }

    protected:

      virtual
      ~numpunct();
# 1812 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.h" 3
      virtual char_type
      do_decimal_point() const
      { return _M_data->_M_decimal_point; }
# 1824 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.h" 3
      virtual char_type
      do_thousands_sep() const
      { return _M_data->_M_thousands_sep; }
# 1837 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.h" 3
      virtual string
      do_grouping() const
      { return _M_data->_M_grouping; }
# 1850 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.h" 3
      virtual string_type
      do_truename() const
      { return _M_data->_M_truename; }
# 1863 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.h" 3
      virtual string_type
      do_falsename() const
      { return _M_data->_M_falsename; }


      void
      _M_initialize_numpunct(__c_locale __cloc = __null);
    };

  template<typename _CharT>
    locale::id numpunct<_CharT>::id;

  template<>
    numpunct<char>::~numpunct();

  template<>
    void
    numpunct<char>::_M_initialize_numpunct(__c_locale __cloc);
# 1891 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.h" 3
  template<typename _CharT>
    class numpunct_byname : public numpunct<_CharT>
    {
    public:
      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;

      explicit
      numpunct_byname(const char* __s, size_t __refs = 0)
      : numpunct<_CharT>(__refs)
      {
 if (std::strcmp(__s, "C") != 0 && std::strcmp(__s, "POSIX") != 0)
   {
     __c_locale __tmp;
     this->_S_create_c_locale(__tmp, __s);
     this->_M_initialize_numpunct(__tmp);
     this->_S_destroy_c_locale(__tmp);
   }
      }

    protected:
      virtual
      ~numpunct_byname() { }
    };
# 1928 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.h" 3
  template<typename _CharT, typename _InIter>
    class num_get : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef _InIter iter_type;



      static locale::id id;
# 1949 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.h" 3
      explicit
      num_get(size_t __refs = 0) : facet(__refs) { }
# 1975 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.h" 3
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, bool& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }
# 2011 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.h" 3
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, unsigned short& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, unsigned int& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, unsigned long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }


      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, long long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, unsigned long long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }
# 2070 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.h" 3
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, float& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, double& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, long double& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }
# 2112 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.h" 3
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, void*& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

    protected:

      virtual ~num_get() { }

      iter_type
      _M_extract_float(iter_type, iter_type, ios_base&, ios_base::iostate&,
         string& __xtrc) const;

      template<typename _ValueT>
        iter_type
        _M_extract_int(iter_type, iter_type, ios_base&, ios_base::iostate&,
         _ValueT& __v) const;
# 2145 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.h" 3
      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&, bool&) const;


      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&, long&) const;

      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err,
       unsigned short&) const;

      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err,
      unsigned int&) const;

      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err,
      unsigned long&) const;


      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err,
      long long&) const;

      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err,
      unsigned long long&) const;


      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err,
      float&) const;

      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err,
      double&) const;

      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err,
      long double&) const;

      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err,
      void*&) const;

    };

  template<typename _CharT, typename _InIter>
    locale::id num_get<_CharT, _InIter>::id;
# 2207 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.h" 3
  template<typename _CharT, typename _OutIter>
    class num_put : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef _OutIter iter_type;



      static locale::id id;
# 2228 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.h" 3
      explicit
      num_put(size_t __refs = 0) : facet(__refs) { }
# 2246 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.h" 3
      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill, bool __v) const
      { return this->do_put(__s, __f, __fill, __v); }
# 2288 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.h" 3
      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill, long __v) const
      { return this->do_put(__s, __f, __fill, __v); }

      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill,
   unsigned long __v) const
      { return this->do_put(__s, __f, __fill, __v); }


      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill, long long __v) const
      { return this->do_put(__s, __f, __fill, __v); }

      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill,
   unsigned long long __v) const
      { return this->do_put(__s, __f, __fill, __v); }
# 2351 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.h" 3
      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill, double __v) const
      { return this->do_put(__s, __f, __fill, __v); }

      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill,
   long double __v) const
      { return this->do_put(__s, __f, __fill, __v); }
# 2376 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.h" 3
      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill,
   const void* __v) const
      { return this->do_put(__s, __f, __fill, __v); }

    protected:
      template<typename _ValueT>
        iter_type
        _M_insert_float(iter_type, ios_base& __io, char_type __fill,
   char __mod, _ValueT __v) const;

      void
      _M_group_float(const char* __grouping, size_t __grouping_size,
       char_type __sep, const char_type* __p, char_type* __new,
       char_type* __cs, int& __len) const;

      template<typename _ValueT>
        iter_type
        _M_insert_int(iter_type, ios_base& __io, char_type __fill,
        _ValueT __v) const;

      void
      _M_group_int(const char* __grouping, size_t __grouping_size,
     char_type __sep, ios_base& __io, char_type* __new,
     char_type* __cs, int& __len) const;

      void
      _M_pad(char_type __fill, streamsize __w, ios_base& __io,
      char_type* __new, const char_type* __cs, int& __len) const;


      virtual
      ~num_put() { };
# 2424 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.h" 3
      virtual iter_type
      do_put(iter_type, ios_base&, char_type __fill, bool __v) const;

      virtual iter_type
      do_put(iter_type, ios_base&, char_type __fill, long __v) const;

      virtual iter_type
      do_put(iter_type, ios_base&, char_type __fill, unsigned long) const;


      virtual iter_type
      do_put(iter_type, ios_base&, char_type __fill, long long __v) const;

      virtual iter_type
      do_put(iter_type, ios_base&, char_type __fill, unsigned long long) const;


      virtual iter_type
      do_put(iter_type, ios_base&, char_type __fill, double __v) const;

      virtual iter_type
      do_put(iter_type, ios_base&, char_type __fill, long double __v) const;

      virtual iter_type
      do_put(iter_type, ios_base&, char_type __fill, const void* __v) const;

    };

  template <typename _CharT, typename _OutIter>
    locale::id num_put<_CharT, _OutIter>::id;
# 2468 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.h" 3
  template<typename _CharT>
    class collate : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;


    protected:


      __c_locale _M_c_locale_collate;

    public:

      static locale::id id;
# 2495 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.h" 3
      explicit
      collate(size_t __refs = 0)
      : facet(__refs), _M_c_locale_collate(_S_get_c_locale())
      { }
# 2509 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.h" 3
      explicit
      collate(__c_locale __cloc, size_t __refs = 0)
      : facet(__refs), _M_c_locale_collate(_S_clone_c_locale(__cloc))
      { }
# 2526 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.h" 3
      int
      compare(const _CharT* __lo1, const _CharT* __hi1,
       const _CharT* __lo2, const _CharT* __hi2) const
      { return this->do_compare(__lo1, __hi1, __lo2, __hi2); }
# 2545 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.h" 3
      string_type
      transform(const _CharT* __lo, const _CharT* __hi) const
      { return this->do_transform(__lo, __hi); }
# 2559 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.h" 3
      long
      hash(const _CharT* __lo, const _CharT* __hi) const
      { return this->do_hash(__lo, __hi); }


      int
      _M_compare(const _CharT*, const _CharT*) const;

      size_t
      _M_transform(_CharT*, const _CharT*, size_t) const;

  protected:

      virtual
      ~collate()
      { _S_destroy_c_locale(_M_c_locale_collate); }
# 2588 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.h" 3
      virtual int
      do_compare(const _CharT* __lo1, const _CharT* __hi1,
   const _CharT* __lo2, const _CharT* __hi2) const;
# 2604 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.h" 3
      virtual string_type
      do_transform(const _CharT* __lo, const _CharT* __hi) const;
# 2617 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.h" 3
      virtual long
      do_hash(const _CharT* __lo, const _CharT* __hi) const;
    };

  template<typename _CharT>
    locale::id collate<_CharT>::id;


  template<>
    int
    collate<char>::_M_compare(const char*, const char*) const;

  template<>
    size_t
    collate<char>::_M_transform(char*, const char*, size_t) const;
# 2643 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.h" 3
  template<typename _CharT>
    class collate_byname : public collate<_CharT>
    {
    public:


      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;


      explicit
      collate_byname(const char* __s, size_t __refs = 0)
      : collate<_CharT>(__refs)
      {
 if (std::strcmp(__s, "C") != 0 && std::strcmp(__s, "POSIX") != 0)
   {
     this->_S_destroy_c_locale(this->_M_c_locale_collate);
     this->_S_create_c_locale(this->_M_c_locale_collate, __s);
   }
      }

    protected:
      virtual
      ~collate_byname() { }
    };
# 2676 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.h" 3
  class time_base
  {
  public:
    enum dateorder { no_order, dmy, mdy, ymd, ydm };
  };

  template<typename _CharT>
    struct __timepunct_cache : public locale::facet
    {

      static const _CharT* _S_timezones[14];

      const _CharT* _M_date_format;
      const _CharT* _M_date_era_format;
      const _CharT* _M_time_format;
      const _CharT* _M_time_era_format;
      const _CharT* _M_date_time_format;
      const _CharT* _M_date_time_era_format;
      const _CharT* _M_am;
      const _CharT* _M_pm;
      const _CharT* _M_am_pm_format;


      const _CharT* _M_day1;
      const _CharT* _M_day2;
      const _CharT* _M_day3;
      const _CharT* _M_day4;
      const _CharT* _M_day5;
      const _CharT* _M_day6;
      const _CharT* _M_day7;


      const _CharT* _M_aday1;
      const _CharT* _M_aday2;
      const _CharT* _M_aday3;
      const _CharT* _M_aday4;
      const _CharT* _M_aday5;
      const _CharT* _M_aday6;
      const _CharT* _M_aday7;


      const _CharT* _M_month01;
      const _CharT* _M_month02;
      const _CharT* _M_month03;
      const _CharT* _M_month04;
      const _CharT* _M_month05;
      const _CharT* _M_month06;
      const _CharT* _M_month07;
      const _CharT* _M_month08;
      const _CharT* _M_month09;
      const _CharT* _M_month10;
      const _CharT* _M_month11;
      const _CharT* _M_month12;


      const _CharT* _M_amonth01;
      const _CharT* _M_amonth02;
      const _CharT* _M_amonth03;
      const _CharT* _M_amonth04;
      const _CharT* _M_amonth05;
      const _CharT* _M_amonth06;
      const _CharT* _M_amonth07;
      const _CharT* _M_amonth08;
      const _CharT* _M_amonth09;
      const _CharT* _M_amonth10;
      const _CharT* _M_amonth11;
      const _CharT* _M_amonth12;

      bool _M_allocated;

      __timepunct_cache(size_t __refs = 0) : facet(__refs),
      _M_date_format(__null), _M_date_era_format(__null), _M_time_format(__null),
      _M_time_era_format(__null), _M_date_time_format(__null),
      _M_date_time_era_format(__null), _M_am(__null), _M_pm(__null),
      _M_am_pm_format(__null), _M_day1(__null), _M_day2(__null), _M_day3(__null),
      _M_day4(__null), _M_day5(__null), _M_day6(__null), _M_day7(__null),
      _M_aday1(__null), _M_aday2(__null), _M_aday3(__null), _M_aday4(__null),
      _M_aday5(__null), _M_aday6(__null), _M_aday7(__null), _M_month01(__null),
      _M_month02(__null), _M_month03(__null), _M_month04(__null), _M_month05(__null),
      _M_month06(__null), _M_month07(__null), _M_month08(__null), _M_month09(__null),
      _M_month10(__null), _M_month11(__null), _M_month12(__null), _M_amonth01(__null),
      _M_amonth02(__null), _M_amonth03(__null), _M_amonth04(__null),
      _M_amonth05(__null), _M_amonth06(__null), _M_amonth07(__null),
      _M_amonth08(__null), _M_amonth09(__null), _M_amonth10(__null),
      _M_amonth11(__null), _M_amonth12(__null), _M_allocated(false)
      { }

      ~__timepunct_cache();

      void
      _M_cache(const locale& __loc);

    private:
      __timepunct_cache&
      operator=(const __timepunct_cache&);

      explicit
      __timepunct_cache(const __timepunct_cache&);
    };

  template<typename _CharT>
    __timepunct_cache<_CharT>::~__timepunct_cache()
    {
      if (_M_allocated)
 {

 }
    }


  template<>
    const char*
    __timepunct_cache<char>::_S_timezones[14];
# 2797 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.h" 3
  template<typename _CharT>
    const _CharT* __timepunct_cache<_CharT>::_S_timezones[14];

  template<typename _CharT>
    class __timepunct : public locale::facet
    {
    public:

      typedef _CharT __char_type;
      typedef basic_string<_CharT> __string_type;
      typedef __timepunct_cache<_CharT> __cache_type;

    protected:
      __cache_type* _M_data;
      __c_locale _M_c_locale_timepunct;
      const char* _M_name_timepunct;

    public:

      static locale::id id;

      explicit
      __timepunct(size_t __refs = 0);

      explicit
      __timepunct(__cache_type* __cache, size_t __refs = 0);
# 2834 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.h" 3
      explicit
      __timepunct(__c_locale __cloc, const char* __s, size_t __refs = 0);

      void
      _M_put(_CharT* __s, size_t __maxlen, const _CharT* __format,
      const tm* __tm) const;

      void
      _M_date_formats(const _CharT** __date) const
      {

 __date[0] = _M_data->_M_date_format;
 __date[1] = _M_data->_M_date_era_format;
      }

      void
      _M_time_formats(const _CharT** __time) const
      {

 __time[0] = _M_data->_M_time_format;
 __time[1] = _M_data->_M_time_era_format;
      }

      void
      _M_date_time_formats(const _CharT** __dt) const
      {

 __dt[0] = _M_data->_M_date_time_format;
 __dt[1] = _M_data->_M_date_time_era_format;
      }

      void
      _M_am_pm_format(const _CharT* __ampm) const
      { __ampm = _M_data->_M_am_pm_format; }

      void
      _M_am_pm(const _CharT** __ampm) const
      {
 __ampm[0] = _M_data->_M_am;
 __ampm[1] = _M_data->_M_pm;
      }

      void
      _M_days(const _CharT** __days) const
      {
 __days[0] = _M_data->_M_day1;
 __days[1] = _M_data->_M_day2;
 __days[2] = _M_data->_M_day3;
 __days[3] = _M_data->_M_day4;
 __days[4] = _M_data->_M_day5;
 __days[5] = _M_data->_M_day6;
 __days[6] = _M_data->_M_day7;
      }

      void
      _M_days_abbreviated(const _CharT** __days) const
      {
 __days[0] = _M_data->_M_aday1;
 __days[1] = _M_data->_M_aday2;
 __days[2] = _M_data->_M_aday3;
 __days[3] = _M_data->_M_aday4;
 __days[4] = _M_data->_M_aday5;
 __days[5] = _M_data->_M_aday6;
 __days[6] = _M_data->_M_aday7;
      }

      void
      _M_months(const _CharT** __months) const
      {
 __months[0] = _M_data->_M_month01;
 __months[1] = _M_data->_M_month02;
 __months[2] = _M_data->_M_month03;
 __months[3] = _M_data->_M_month04;
 __months[4] = _M_data->_M_month05;
 __months[5] = _M_data->_M_month06;
 __months[6] = _M_data->_M_month07;
 __months[7] = _M_data->_M_month08;
 __months[8] = _M_data->_M_month09;
 __months[9] = _M_data->_M_month10;
 __months[10] = _M_data->_M_month11;
 __months[11] = _M_data->_M_month12;
      }

      void
      _M_months_abbreviated(const _CharT** __months) const
      {
 __months[0] = _M_data->_M_amonth01;
 __months[1] = _M_data->_M_amonth02;
 __months[2] = _M_data->_M_amonth03;
 __months[3] = _M_data->_M_amonth04;
 __months[4] = _M_data->_M_amonth05;
 __months[5] = _M_data->_M_amonth06;
 __months[6] = _M_data->_M_amonth07;
 __months[7] = _M_data->_M_amonth08;
 __months[8] = _M_data->_M_amonth09;
 __months[9] = _M_data->_M_amonth10;
 __months[10] = _M_data->_M_amonth11;
 __months[11] = _M_data->_M_amonth12;
      }

    protected:
      virtual
      ~__timepunct();


      void
      _M_initialize_timepunct(__c_locale __cloc = __null);
    };

  template<typename _CharT>
    locale::id __timepunct<_CharT>::id;


  template<>
    void
    __timepunct<char>::_M_initialize_timepunct(__c_locale __cloc);

  template<>
    void
    __timepunct<char>::_M_put(char*, size_t, const char*, const tm*) const;
# 2967 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.h" 3
# 1 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/mingw32/bits/time_members.h" 1 3
# 37 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/mingw32/bits/time_members.h" 3
  template<typename _CharT>
    __timepunct<_CharT>::__timepunct(size_t __refs)
    : facet(__refs), _M_data(__null)
    {
      _M_name_timepunct = _S_get_c_name();
      _M_initialize_timepunct();
    }

  template<typename _CharT>
    __timepunct<_CharT>::__timepunct(__cache_type* __cache, size_t __refs)
    : facet(__refs), _M_data(__cache)
    {
      _M_name_timepunct = _S_get_c_name();
      _M_initialize_timepunct();
    }

  template<typename _CharT>
    __timepunct<_CharT>::__timepunct(__c_locale __cloc, const char* __s,
         size_t __refs)
    : facet(__refs), _M_data(__null)
    {
      char* __tmp = new char[std::strlen(__s) + 1];
      std::strcpy(__tmp, __s);
      _M_name_timepunct = __tmp;
      _M_initialize_timepunct(__cloc);
    }

  template<typename _CharT>
    __timepunct<_CharT>::~__timepunct()
    {
      if (_M_name_timepunct != _S_get_c_name())
 delete [] _M_name_timepunct;
      delete _M_data;
      _S_destroy_c_locale(_M_c_locale_timepunct);
    }
# 2968 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.h" 2 3
# 2981 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.h" 3
  template<typename _CharT, typename _InIter>
    class time_get : public locale::facet, public time_base
    {
    public:



      typedef _CharT char_type;
      typedef _InIter iter_type;

      typedef basic_string<_CharT> __string_type;


      static locale::id id;
# 3003 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.h" 3
      explicit
      time_get(size_t __refs = 0)
      : facet (__refs) { }
# 3020 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.h" 3
      dateorder
      date_order() const
      { return this->do_date_order(); }
# 3044 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.h" 3
      iter_type
      get_time(iter_type __beg, iter_type __end, ios_base& __io,
        ios_base::iostate& __err, tm* __tm) const
      { return this->do_get_time(__beg, __end, __io, __err, __tm); }
# 3069 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.h" 3
      iter_type
      get_date(iter_type __beg, iter_type __end, ios_base& __io,
        ios_base::iostate& __err, tm* __tm) const
      { return this->do_get_date(__beg, __end, __io, __err, __tm); }
# 3097 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.h" 3
      iter_type
      get_weekday(iter_type __beg, iter_type __end, ios_base& __io,
    ios_base::iostate& __err, tm* __tm) const
      { return this->do_get_weekday(__beg, __end, __io, __err, __tm); }
# 3126 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.h" 3
      iter_type
      get_monthname(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, tm* __tm) const
      { return this->do_get_monthname(__beg, __end, __io, __err, __tm); }
# 3152 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.h" 3
      iter_type
      get_year(iter_type __beg, iter_type __end, ios_base& __io,
        ios_base::iostate& __err, tm* __tm) const
      { return this->do_get_year(__beg, __end, __io, __err, __tm); }

    protected:

      virtual
      ~time_get() { }
# 3172 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.h" 3
      virtual dateorder
      do_date_order() const;
# 3190 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.h" 3
      virtual iter_type
      do_get_time(iter_type __beg, iter_type __end, ios_base& __io,
    ios_base::iostate& __err, tm* __tm) const;
# 3209 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.h" 3
      virtual iter_type
      do_get_date(iter_type __beg, iter_type __end, ios_base& __io,
    ios_base::iostate& __err, tm* __tm) const;
# 3228 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.h" 3
      virtual iter_type
      do_get_weekday(iter_type __beg, iter_type __end, ios_base&,
       ios_base::iostate& __err, tm* __tm) const;
# 3247 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.h" 3
      virtual iter_type
      do_get_monthname(iter_type __beg, iter_type __end, ios_base&,
         ios_base::iostate& __err, tm* __tm) const;
# 3266 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.h" 3
      virtual iter_type
      do_get_year(iter_type __beg, iter_type __end, ios_base& __io,
    ios_base::iostate& __err, tm* __tm) const;


      iter_type
      _M_extract_num(iter_type __beg, iter_type __end, int& __member,
       int __min, int __max, size_t __len,
       ios_base& __io, ios_base::iostate& __err) const;



      iter_type
      _M_extract_name(iter_type __beg, iter_type __end, int& __member,
        const _CharT** __names, size_t __indexlen,
        ios_base& __io, ios_base::iostate& __err) const;


      iter_type
      _M_extract_via_format(iter_type __beg, iter_type __end, ios_base& __io,
       ios_base::iostate& __err, tm* __tm,
       const _CharT* __format) const;
    };

  template<typename _CharT, typename _InIter>
    locale::id time_get<_CharT, _InIter>::id;

  template<typename _CharT, typename _InIter>
    class time_get_byname : public time_get<_CharT, _InIter>
    {
    public:

      typedef _CharT char_type;
      typedef _InIter iter_type;

      explicit
      time_get_byname(const char*, size_t __refs = 0)
      : time_get<_CharT, _InIter>(__refs) { }

    protected:
      virtual
      ~time_get_byname() { }
    };
# 3321 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.h" 3
  template<typename _CharT, typename _OutIter>
    class time_put : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef _OutIter iter_type;



      static locale::id id;
# 3342 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.h" 3
      explicit
      time_put(size_t __refs = 0)
      : facet(__refs) { }
# 3361 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.h" 3
      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill, const tm* __tm,
   const _CharT* __beg, const _CharT* __end) const;
# 3381 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.h" 3
      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill,
   const tm* __tm, char __format, char __mod = 0) const
      { return this->do_put(__s, __io, __fill, __tm, __format, __mod); }

    protected:

      virtual
      ~time_put()
      { }
# 3408 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.h" 3
      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill, const tm* __tm,
      char __format, char __mod) const;
    };

  template<typename _CharT, typename _OutIter>
    locale::id time_put<_CharT, _OutIter>::id;

  template<typename _CharT, typename _OutIter>
    class time_put_byname : public time_put<_CharT, _OutIter>
    {
    public:

      typedef _CharT char_type;
      typedef _OutIter iter_type;

      explicit
      time_put_byname(const char*, size_t __refs = 0)
      : time_put<_CharT, _OutIter>(__refs)
      { };

    protected:
      virtual
      ~time_put_byname() { }
    };
# 3445 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.h" 3
  class money_base
  {
  public:
    enum part { none, space, symbol, sign, value };
    struct pattern { char field[4]; };

    static const pattern _S_default_pattern;

    enum
    {
      _S_minus,
      _S_zero,
      _S_end = 11
    };



    static const char* _S_atoms;



    static pattern
    _S_construct_pattern(char __precedes, char __space, char __posn);
  };

  template<typename _CharT, bool _Intl>
    struct __moneypunct_cache : public locale::facet
    {
      const char* _M_grouping;
      size_t _M_grouping_size;
      bool _M_use_grouping;
      _CharT _M_decimal_point;
      _CharT _M_thousands_sep;
      const _CharT* _M_curr_symbol;
      size_t _M_curr_symbol_size;
      const _CharT* _M_positive_sign;
      size_t _M_positive_sign_size;
      const _CharT* _M_negative_sign;
      size_t _M_negative_sign_size;
      int _M_frac_digits;
      money_base::pattern _M_pos_format;
      money_base::pattern _M_neg_format;




      _CharT _M_atoms[money_base::_S_end];

      bool _M_allocated;

      __moneypunct_cache(size_t __refs = 0) : facet(__refs),
      _M_grouping(__null), _M_grouping_size(0), _M_use_grouping(false),
      _M_decimal_point(_CharT()), _M_thousands_sep(_CharT()),
      _M_curr_symbol(__null), _M_curr_symbol_size(0),
      _M_positive_sign(__null), _M_positive_sign_size(0),
      _M_negative_sign(__null), _M_negative_sign_size(0),
      _M_frac_digits(0),
      _M_pos_format(money_base::pattern()),
      _M_neg_format(money_base::pattern()), _M_allocated(false)
      { }

      ~__moneypunct_cache();

      void
      _M_cache(const locale& __loc);

    private:
      __moneypunct_cache&
      operator=(const __moneypunct_cache&);

      explicit
      __moneypunct_cache(const __moneypunct_cache&);
    };

  template<typename _CharT, bool _Intl>
    __moneypunct_cache<_CharT, _Intl>::~__moneypunct_cache()
    {
      if (_M_allocated)
 {
   delete [] _M_grouping;
   delete [] _M_curr_symbol;
   delete [] _M_positive_sign;
   delete [] _M_negative_sign;
 }
    }







  template<typename _CharT, bool _Intl>
    class moneypunct : public locale::facet, public money_base
    {
    public:



      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;

      typedef __moneypunct_cache<_CharT, _Intl> __cache_type;

    private:
      __cache_type* _M_data;

    public:


      static const bool intl = _Intl;

      static locale::id id;
# 3566 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.h" 3
      explicit
      moneypunct(size_t __refs = 0) : facet(__refs), _M_data(__null)
      { _M_initialize_moneypunct(); }
# 3578 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.h" 3
      explicit
      moneypunct(__cache_type* __cache, size_t __refs = 0)
      : facet(__refs), _M_data(__cache)
      { _M_initialize_moneypunct(); }
# 3593 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.h" 3
      explicit
      moneypunct(__c_locale __cloc, const char* __s, size_t __refs = 0)
      : facet(__refs), _M_data(__null)
      { _M_initialize_moneypunct(__cloc, __s); }
# 3607 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.h" 3
      char_type
      decimal_point() const
      { return this->do_decimal_point(); }
# 3620 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.h" 3
      char_type
      thousands_sep() const
      { return this->do_thousands_sep(); }
# 3649 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.h" 3
      string
      grouping() const
      { return this->do_grouping(); }
# 3662 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.h" 3
      string_type
      curr_symbol() const
      { return this->do_curr_symbol(); }
# 3679 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.h" 3
      string_type
      positive_sign() const
      { return this->do_positive_sign(); }
# 3696 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.h" 3
      string_type
      negative_sign() const
      { return this->do_negative_sign(); }
# 3712 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.h" 3
      int
      frac_digits() const
      { return this->do_frac_digits(); }
# 3747 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.h" 3
      pattern
      pos_format() const
      { return this->do_pos_format(); }

      pattern
      neg_format() const
      { return this->do_neg_format(); }


    protected:

      virtual
      ~moneypunct();
# 3769 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.h" 3
      virtual char_type
      do_decimal_point() const
      { return _M_data->_M_decimal_point; }
# 3781 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.h" 3
      virtual char_type
      do_thousands_sep() const
      { return _M_data->_M_thousands_sep; }
# 3794 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.h" 3
      virtual string
      do_grouping() const
      { return _M_data->_M_grouping; }
# 3807 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.h" 3
      virtual string_type
      do_curr_symbol() const
      { return _M_data->_M_curr_symbol; }
# 3820 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.h" 3
      virtual string_type
      do_positive_sign() const
      { return _M_data->_M_positive_sign; }
# 3833 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.h" 3
      virtual string_type
      do_negative_sign() const
      { return _M_data->_M_negative_sign; }
# 3847 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.h" 3
      virtual int
      do_frac_digits() const
      { return _M_data->_M_frac_digits; }
# 3861 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.h" 3
      virtual pattern
      do_pos_format() const
      { return _M_data->_M_pos_format; }
# 3875 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.h" 3
      virtual pattern
      do_neg_format() const
      { return _M_data->_M_neg_format; }


       void
       _M_initialize_moneypunct(__c_locale __cloc = __null,
    const char* __name = __null);
    };

  template<typename _CharT, bool _Intl>
    locale::id moneypunct<_CharT, _Intl>::id;

  template<typename _CharT, bool _Intl>
    const bool moneypunct<_CharT, _Intl>::intl;

  template<>
    moneypunct<char, true>::~moneypunct();

  template<>
    moneypunct<char, false>::~moneypunct();

  template<>
    void
    moneypunct<char, true>::_M_initialize_moneypunct(__c_locale, const char*);

  template<>
    void
    moneypunct<char, false>::_M_initialize_moneypunct(__c_locale, const char*);
# 3923 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.h" 3
  template<typename _CharT, bool _Intl>
    class moneypunct_byname : public moneypunct<_CharT, _Intl>
    {
    public:
      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;

      static const bool intl = _Intl;

      explicit
      moneypunct_byname(const char* __s, size_t __refs = 0)
      : moneypunct<_CharT, _Intl>(__refs)
      {
 if (std::strcmp(__s, "C") != 0 && std::strcmp(__s, "POSIX") != 0)
   {
     __c_locale __tmp;
     this->_S_create_c_locale(__tmp, __s);
     this->_M_initialize_moneypunct(__tmp);
     this->_S_destroy_c_locale(__tmp);
   }
      }

    protected:
      virtual
      ~moneypunct_byname() { }
    };

  template<typename _CharT, bool _Intl>
    const bool moneypunct_byname<_CharT, _Intl>::intl;
# 3965 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.h" 3
  template<typename _CharT, typename _InIter>
    class money_get : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef _InIter iter_type;
      typedef basic_string<_CharT> string_type;



      static locale::id id;
# 3987 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.h" 3
      explicit
      money_get(size_t __refs = 0) : facet(__refs) { }
# 4017 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.h" 3
      iter_type
      get(iter_type __s, iter_type __end, bool __intl, ios_base& __io,
   ios_base::iostate& __err, long double& __units) const
      { return this->do_get(__s, __end, __intl, __io, __err, __units); }
# 4047 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.h" 3
      iter_type
      get(iter_type __s, iter_type __end, bool __intl, ios_base& __io,
   ios_base::iostate& __err, string_type& __digits) const
      { return this->do_get(__s, __end, __intl, __io, __err, __digits); }

    protected:

      virtual
      ~money_get() { }
# 4064 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.h" 3
      virtual iter_type
      do_get(iter_type __s, iter_type __end, bool __intl, ios_base& __io,
      ios_base::iostate& __err, long double& __units) const;
# 4075 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.h" 3
      virtual iter_type
      do_get(iter_type __s, iter_type __end, bool __intl, ios_base& __io,
      ios_base::iostate& __err, string_type& __digits) const;

      template<bool _Intl>
        iter_type
        _M_extract(iter_type __s, iter_type __end, ios_base& __io,
     ios_base::iostate& __err, string& __digits) const;
    };

  template<typename _CharT, typename _InIter>
    locale::id money_get<_CharT, _InIter>::id;
# 4100 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.h" 3
  template<typename _CharT, typename _OutIter>
    class money_put : public locale::facet
    {
    public:


      typedef _CharT char_type;
      typedef _OutIter iter_type;
      typedef basic_string<_CharT> string_type;



      static locale::id id;
# 4121 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.h" 3
      explicit
      money_put(size_t __refs = 0) : facet(__refs) { }
# 4141 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.h" 3
      iter_type
      put(iter_type __s, bool __intl, ios_base& __io,
   char_type __fill, long double __units) const
      { return this->do_put(__s, __intl, __io, __fill, __units); }
# 4163 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.h" 3
      iter_type
      put(iter_type __s, bool __intl, ios_base& __io,
   char_type __fill, const string_type& __digits) const
      { return this->do_put(__s, __intl, __io, __fill, __digits); }

    protected:

      virtual
      ~money_put() { }
# 4191 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.h" 3
      virtual iter_type
      do_put(iter_type __s, bool __intl, ios_base& __io, char_type __fill,
      long double __units) const;
# 4213 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.h" 3
      virtual iter_type
      do_put(iter_type __s, bool __intl, ios_base& __io, char_type __fill,
      const string_type& __digits) const;

      template<bool _Intl>
        iter_type
        _M_insert(iter_type __s, ios_base& __io, char_type __fill,
    const string_type& __digits) const;
    };

  template<typename _CharT, typename _OutIter>
    locale::id money_put<_CharT, _OutIter>::id;




  struct messages_base
  {
    typedef int catalog;
  };
# 4254 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.h" 3
  template<typename _CharT>
    class messages : public locale::facet, public messages_base
    {
    public:



      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;


    protected:


      __c_locale _M_c_locale_messages;
      const char* _M_name_messages;

    public:

      static locale::id id;
# 4282 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.h" 3
      explicit
      messages(size_t __refs = 0);
# 4296 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.h" 3
      explicit
      messages(__c_locale __cloc, const char* __s, size_t __refs = 0);
# 4309 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.h" 3
      catalog
      open(const basic_string<char>& __s, const locale& __loc) const
      { return this->do_open(__s, __loc); }
# 4327 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.h" 3
      catalog
      open(const basic_string<char>&, const locale&, const char*) const;
# 4345 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.h" 3
      string_type
      get(catalog __c, int __set, int __msgid, const string_type& __s) const
      { return this->do_get(__c, __set, __msgid, __s); }
# 4356 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.h" 3
      void
      close(catalog __c) const
      { return this->do_close(__c); }

    protected:

      virtual
      ~messages();
# 4376 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.h" 3
      virtual catalog
      do_open(const basic_string<char>&, const locale&) const;
# 4395 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.h" 3
      virtual string_type
      do_get(catalog, int, int, const string_type& __dfault) const;






      virtual void
      do_close(catalog) const;


      char*
      _M_convert_to_char(const string_type& __msg) const
      {

 return reinterpret_cast<char*>(const_cast<_CharT*>(__msg.c_str()));
      }


      string_type
      _M_convert_from_char(char*) const
      {
# 4452 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.h" 3
 return string_type();
      }
     };

  template<typename _CharT>
    locale::id messages<_CharT>::id;


  template<>
    string
    messages<char>::do_get(catalog, int, int, const string&) const;







  template<typename _CharT>
    class messages_byname : public messages<_CharT>
    {
    public:
      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;

      explicit
      messages_byname(const char* __s, size_t __refs = 0);

    protected:
      virtual
      ~messages_byname()
      { }
    };


# 1 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/mingw32/bits/messages_members.h" 1 3
# 37 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/mingw32/bits/messages_members.h" 3
  template<typename _CharT>
     messages<_CharT>::messages(size_t __refs)
     : facet(__refs)
     { _M_c_locale_messages = _S_get_c_locale(); }

  template<typename _CharT>
     messages<_CharT>::messages(__c_locale, const char*, size_t __refs)
     : facet(__refs)
     { _M_c_locale_messages = _S_get_c_locale(); }

  template<typename _CharT>
    typename messages<_CharT>::catalog
    messages<_CharT>::open(const basic_string<char>& __s, const locale& __loc,
      const char*) const
    { return this->do_open(__s, __loc); }


  template<typename _CharT>
    messages<_CharT>::~messages()
    { _S_destroy_c_locale(_M_c_locale_messages); }

  template<typename _CharT>
    typename messages<_CharT>::catalog
    messages<_CharT>::do_open(const basic_string<char>&, const locale&) const
    { return 0; }

  template<typename _CharT>
    typename messages<_CharT>::string_type
    messages<_CharT>::do_get(catalog, int, int,
        const string_type& __dfault) const
    { return __dfault; }

  template<typename _CharT>
    void
    messages<_CharT>::do_close(catalog) const
    { }


   template<typename _CharT>
     messages_byname<_CharT>::messages_byname(const char* __s, size_t __refs)
     : messages<_CharT>(__refs)
     {
 if (std::strcmp(__s, "C") != 0 && std::strcmp(__s, "POSIX") != 0)
   {
     this->_S_destroy_c_locale(this->_M_c_locale_messages);
     this->_S_create_c_locale(this->_M_c_locale_messages, __s);
   }
     }
# 4488 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.h" 2 3
# 4496 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.h" 3
  template<typename _CharT>
    inline bool
    isspace(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::space, __c); }

  template<typename _CharT>
    inline bool
    isprint(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::print, __c); }

  template<typename _CharT>
    inline bool
    iscntrl(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::cntrl, __c); }

  template<typename _CharT>
    inline bool
    isupper(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::upper, __c); }

  template<typename _CharT>
    inline bool islower(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::lower, __c); }

  template<typename _CharT>
    inline bool
    isalpha(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::alpha, __c); }

  template<typename _CharT>
    inline bool
    isdigit(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::digit, __c); }

  template<typename _CharT>
    inline bool
    ispunct(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::punct, __c); }

  template<typename _CharT>
    inline bool
    isxdigit(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::xdigit, __c); }

  template<typename _CharT>
    inline bool
    isalnum(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::alnum, __c); }

  template<typename _CharT>
    inline bool
    isgraph(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::graph, __c); }

  template<typename _CharT>
    inline _CharT
    toupper(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).toupper(__c); }

  template<typename _CharT>
    inline _CharT
    tolower(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).tolower(__c); }

}
# 45 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/basic_ios.h" 2 3

namespace std
{







  template<typename _CharT, typename _Traits>
    class basic_ios : public ios_base
    {
    public:






      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;
# 78 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/basic_ios.h" 3
      typedef ctype<_CharT> __ctype_type;
      typedef num_put<_CharT, ostreambuf_iterator<_CharT, _Traits> >
           __num_put_type;
      typedef num_get<_CharT, istreambuf_iterator<_CharT, _Traits> >
           __num_get_type;



    protected:
      basic_ostream<_CharT, _Traits>* _M_tie;
      mutable char_type _M_fill;
      mutable bool _M_fill_init;
      basic_streambuf<_CharT, _Traits>* _M_streambuf;


      const __ctype_type* _M_ctype;

      const __num_put_type* _M_num_put;

      const __num_get_type* _M_num_get;

    public:







      operator void*() const
      { return this->fail() ? 0 : const_cast<basic_ios*>(this); }

      bool
      operator!() const
      { return this->fail(); }
# 122 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/basic_ios.h" 3
      iostate
      rdstate() const
      { return _M_streambuf_state; }
# 133 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/basic_ios.h" 3
      void
      clear(iostate __state = goodbit);







      void
      setstate(iostate __state)
      { this->clear(this->rdstate() | __state); }




      void
      _M_setstate(iostate __state)
      {


 _M_streambuf_state |= __state;
 if (this->exceptions() & __state)
   throw;
      }







      bool
      good() const
      { return this->rdstate() == 0; }







      bool
      eof() const
      { return (this->rdstate() & eofbit) != 0; }
# 186 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/basic_ios.h" 3
      bool
      fail() const
      { return (this->rdstate() & (badbit | failbit)) != 0; }







      bool
      bad() const
      { return (this->rdstate() & badbit) != 0; }
# 207 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/basic_ios.h" 3
      iostate
      exceptions() const
      { return _M_exception; }
# 242 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/basic_ios.h" 3
      void
      exceptions(iostate __except)
      {
        _M_exception = __except;
        this->clear(_M_streambuf_state);
      }







      explicit
      basic_ios(basic_streambuf<_CharT, _Traits>* __sb)
      : ios_base(), _M_tie(0), _M_fill(), _M_fill_init(false), _M_streambuf(0),
      _M_ctype(0), _M_num_put(0), _M_num_get(0)
      { this->init(__sb); }







      virtual
      ~basic_ios() { }
# 280 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/basic_ios.h" 3
      basic_ostream<_CharT, _Traits>*
      tie() const
      { return _M_tie; }
# 292 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/basic_ios.h" 3
      basic_ostream<_CharT, _Traits>*
      tie(basic_ostream<_CharT, _Traits>* __tiestr)
      {
        basic_ostream<_CharT, _Traits>* __old = _M_tie;
        _M_tie = __tiestr;
        return __old;
      }







      basic_streambuf<_CharT, _Traits>*
      rdbuf() const
      { return _M_streambuf; }
# 332 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/basic_ios.h" 3
      basic_streambuf<_CharT, _Traits>*
      rdbuf(basic_streambuf<_CharT, _Traits>* __sb);
# 346 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/basic_ios.h" 3
      basic_ios&
      copyfmt(const basic_ios& __rhs);







      char_type
      fill() const
      {
 if (!_M_fill_init)
   {
     _M_fill = this->widen(' ');
     _M_fill_init = true;
   }
 return _M_fill;
      }
# 375 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/basic_ios.h" 3
      char_type
      fill(char_type __ch)
      {
 char_type __old = this->fill();
 _M_fill = __ch;
 return __old;
      }
# 395 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/basic_ios.h" 3
      locale
      imbue(const locale& __loc);
# 415 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/basic_ios.h" 3
      char
      narrow(char_type __c, char __dfault) const;
# 433 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/basic_ios.h" 3
      char_type
      widen(char __c) const;

    protected:







      basic_ios()
      : ios_base(), _M_tie(0), _M_fill(char_type()), _M_fill_init(false),
      _M_streambuf(0), _M_ctype(0), _M_num_put(0), _M_num_get(0)
      { }







      void
      init(basic_streambuf<_CharT, _Traits>* __sb);

      void
      _M_cache_locale(const locale& __loc);
    };
}


# 1 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/basic_ios.tcc" 1 3
# 33 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/basic_ios.tcc" 3
       
# 34 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/basic_ios.tcc" 3

namespace std
{
  template<typename _CharT, typename _Traits>
    void
    basic_ios<_CharT, _Traits>::clear(iostate __state)
    {
      if (this->rdbuf())
 _M_streambuf_state = __state;
      else
   _M_streambuf_state = __state | badbit;
      if (this->exceptions() & this->rdstate())
 __throw_ios_failure(("basic_ios::clear"));
    }

  template<typename _CharT, typename _Traits>
    basic_streambuf<_CharT, _Traits>*
    basic_ios<_CharT, _Traits>::rdbuf(basic_streambuf<_CharT, _Traits>* __sb)
    {
      basic_streambuf<_CharT, _Traits>* __old = _M_streambuf;
      _M_streambuf = __sb;
      this->clear();
      return __old;
    }

  template<typename _CharT, typename _Traits>
    basic_ios<_CharT, _Traits>&
    basic_ios<_CharT, _Traits>::copyfmt(const basic_ios& __rhs)
    {


      if (this != &__rhs)
 {




   _Words* __words = (__rhs._M_word_size <= _S_local_word_size) ?
                      _M_local_word : new _Words[__rhs._M_word_size];


   _Callback_list* __cb = __rhs._M_callbacks;
   if (__cb)
     __cb->_M_add_reference();
   _M_call_callbacks(erase_event);
   if (_M_word != _M_local_word)
     {
       delete [] _M_word;
       _M_word = 0;
     }
   _M_dispose_callbacks();


   _M_callbacks = __cb;
   for (int __i = 0; __i < __rhs._M_word_size; ++__i)
     __words[__i] = __rhs._M_word[__i];
   if (_M_word != _M_local_word)
     {
       delete [] _M_word;
       _M_word = 0;
     }
   _M_word = __words;
   _M_word_size = __rhs._M_word_size;

   this->flags(__rhs.flags());
   this->width(__rhs.width());
   this->precision(__rhs.precision());
   this->tie(__rhs.tie());
   this->fill(__rhs.fill());
   _M_ios_locale = __rhs.getloc();
   _M_cache_locale(_M_ios_locale);

   _M_call_callbacks(copyfmt_event);


   this->exceptions(__rhs.exceptions());
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    char
    basic_ios<_CharT, _Traits>::narrow(char_type __c, char __dfault) const
    { return __check_facet(_M_ctype).narrow(__c, __dfault); }

  template<typename _CharT, typename _Traits>
    _CharT
    basic_ios<_CharT, _Traits>::widen(char __c) const
    { return __check_facet(_M_ctype).widen(__c); }


  template<typename _CharT, typename _Traits>
    locale
    basic_ios<_CharT, _Traits>::imbue(const locale& __loc)
    {
      locale __old(this->getloc());
      ios_base::imbue(__loc);
      _M_cache_locale(__loc);
      if (this->rdbuf() != 0)
 this->rdbuf()->pubimbue(__loc);
      return __old;
    }

  template<typename _CharT, typename _Traits>
    void
    basic_ios<_CharT, _Traits>::init(basic_streambuf<_CharT, _Traits>* __sb)
    {

      ios_base::_M_init();


      _M_cache_locale(_M_ios_locale);
# 159 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/basic_ios.tcc" 3
      _M_fill = _CharT();
      _M_fill_init = false;

      _M_tie = 0;
      _M_exception = goodbit;
      _M_streambuf = __sb;
      _M_streambuf_state = __sb ? goodbit : badbit;
    }

  template<typename _CharT, typename _Traits>
    void
    basic_ios<_CharT, _Traits>::_M_cache_locale(const locale& __loc)
    {
      if (__builtin_expect(has_facet<__ctype_type>(__loc), true))
 _M_ctype = &use_facet<__ctype_type>(__loc);
      else
 _M_ctype = 0;

      if (__builtin_expect(has_facet<__num_put_type>(__loc), true))
 _M_num_put = &use_facet<__num_put_type>(__loc);
      else
 _M_num_put = 0;

      if (__builtin_expect(has_facet<__num_get_type>(__loc), true))
 _M_num_get = &use_facet<__num_get_type>(__loc);
      else
 _M_num_get = 0;
    }





  extern template class basic_ios<char>;





}
# 465 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/basic_ios.h" 2 3
# 52 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/ios" 2 3
# 46 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/ostream" 2 3

namespace std
{
# 57 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/ostream" 3
  template<typename _CharT, typename _Traits>
    class basic_ostream : virtual public basic_ios<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;


      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef basic_ios<_CharT, _Traits> __ios_type;
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef num_put<_CharT, ostreambuf_iterator<_CharT, _Traits> >
             __num_put_type;
      typedef ctype<_CharT> __ctype_type;

      template<typename _CharT2, typename _Traits2>
        friend basic_ostream<_CharT2, _Traits2>&
        operator<<(basic_ostream<_CharT2, _Traits2>&, _CharT2);

      template<typename _Traits2>
        friend basic_ostream<char, _Traits2>&
        operator<<(basic_ostream<char, _Traits2>&, char);

      template<typename _CharT2, typename _Traits2>
        friend basic_ostream<_CharT2, _Traits2>&
        operator<<(basic_ostream<_CharT2, _Traits2>&, const _CharT2*);

      template<typename _Traits2>
        friend basic_ostream<char, _Traits2>&
        operator<<(basic_ostream<char, _Traits2>&, const char*);

      template<typename _CharT2, typename _Traits2>
        friend basic_ostream<_CharT2, _Traits2>&
        operator<<(basic_ostream<_CharT2, _Traits2>&, const char*);
# 104 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/ostream" 3
      explicit
      basic_ostream(__streambuf_type* __sb)
      { this->init(__sb); }






      virtual
      ~basic_ostream() { }


      class sentry;
      friend class sentry;
# 130 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/ostream" 3
      inline __ostream_type&
      operator<<(__ostream_type& (*__pf)(__ostream_type&));

      inline __ostream_type&
      operator<<(__ios_type& (*__pf)(__ios_type&));

      inline __ostream_type&
      operator<<(ios_base& (*__pf) (ios_base&));
# 167 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/ostream" 3
      __ostream_type&
      operator<<(long __n);

      __ostream_type&
      operator<<(unsigned long __n);

      __ostream_type&
      operator<<(bool __n);

      __ostream_type&
      operator<<(short __n)
      {
 ios_base::fmtflags __fmt = this->flags() & ios_base::basefield;
 if (__fmt & ios_base::oct || __fmt & ios_base::hex)
   return this->operator<<(static_cast<unsigned long>
      (static_cast<unsigned short>(__n)));
 else
   return this->operator<<(static_cast<long>(__n));
      }

      __ostream_type&
      operator<<(unsigned short __n)
      { return this->operator<<(static_cast<unsigned long>(__n)); }

      __ostream_type&
      operator<<(int __n)
      {
 ios_base::fmtflags __fmt = this->flags() & ios_base::basefield;
 if (__fmt & ios_base::oct || __fmt & ios_base::hex)
   return this->operator<<(static_cast<unsigned long>
      (static_cast<unsigned int>(__n)));
 else
   return this->operator<<(static_cast<long>(__n));
      }

      __ostream_type&
      operator<<(unsigned int __n)
      { return this->operator<<(static_cast<unsigned long>(__n)); }


      __ostream_type&
      operator<<(long long __n);

      __ostream_type&
      operator<<(unsigned long long __n);


      __ostream_type&
      operator<<(double __f);

      __ostream_type&
      operator<<(float __f)
      { return this->operator<<(static_cast<double>(__f)); }

      __ostream_type&
      operator<<(long double __f);

      __ostream_type&
      operator<<(const void* __p);
# 248 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/ostream" 3
      __ostream_type&
      operator<<(__streambuf_type* __sb);
# 281 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/ostream" 3
      __ostream_type&
      put(char_type __c);


      void
      _M_write(const char_type* __s, streamsize __n)
      {
 streamsize __put = this->rdbuf()->sputn(__s, __n);
 if (__put != __n)
   this->setstate(ios_base::badbit);
      }
# 309 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/ostream" 3
      __ostream_type&
      write(const char_type* __s, streamsize __n);
# 322 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/ostream" 3
      __ostream_type&
      flush();
# 333 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/ostream" 3
      pos_type
      tellp();
# 344 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/ostream" 3
      __ostream_type&
      seekp(pos_type);
# 356 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/ostream" 3
       __ostream_type&
      seekp(off_type, ios_base::seekdir);

    protected:
      explicit
      basic_ostream() { }
    };
# 374 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/ostream" 3
  template <typename _CharT, typename _Traits>
    class basic_ostream<_CharT, _Traits>::sentry
    {

      bool _M_ok;
      basic_ostream<_CharT,_Traits>& _M_os;

    public:
# 393 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/ostream" 3
      explicit
      sentry(basic_ostream<_CharT,_Traits>& __os);
# 403 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/ostream" 3
      ~sentry()
      {

 if (_M_os.flags() & ios_base::unitbuf && !uncaught_exception())
   {

     if (_M_os.rdbuf() && _M_os.rdbuf()->pubsync() == -1)
       _M_os.setstate(ios_base::badbit);
   }
      }
# 421 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/ostream" 3
      operator bool() const
      { return _M_ok; }
    };
# 442 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/ostream" 3
  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, _CharT __c);

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, char __c)
    { return (__out << __out.widen(__c)); }


  template <class _Traits>
    basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, char __c);


  template<class _Traits>
    basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, signed char __c)
    { return (__out << static_cast<char>(__c)); }

  template<class _Traits>
    basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, unsigned char __c)
    { return (__out << static_cast<char>(__c)); }
# 482 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/ostream" 3
  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, const _CharT* __s);

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits> &
    operator<<(basic_ostream<_CharT, _Traits>& __out, const char* __s);


  template<class _Traits>
    basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, const char* __s);


  template<class _Traits>
    basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, const signed char* __s)
    { return (__out << reinterpret_cast<const char*>(__s)); }

  template<class _Traits>
    basic_ostream<char, _Traits> &
    operator<<(basic_ostream<char, _Traits>& __out, const unsigned char* __s)
    { return (__out << reinterpret_cast<const char*>(__s)); }
# 516 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/ostream" 3
  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    endl(basic_ostream<_CharT, _Traits>& __os)
    { return flush(__os.put(__os.widen('\n'))); }







  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    ends(basic_ostream<_CharT, _Traits>& __os)
    { return __os.put(_CharT()); }






  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    flush(basic_ostream<_CharT, _Traits>& __os)
    { return __os.flush(); }

}


# 1 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/ostream.tcc" 1 3
# 38 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/ostream.tcc" 3
       
# 39 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/ostream.tcc" 3

# 1 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/locale" 1 3
# 42 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/locale" 3
       
# 43 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/locale" 3




# 1 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.tcc" 1 3
# 36 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.tcc" 3
       
# 37 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.tcc" 3

# 1 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/limits" 1 3
# 46 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/limits" 3
       
# 47 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/limits" 3
# 150 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/limits" 3
namespace std
{





  enum float_round_style
  {
    round_indeterminate = -1,
    round_toward_zero = 0,
    round_to_nearest = 1,
    round_toward_infinity = 2,
    round_toward_neg_infinity = 3
  };







  enum float_denorm_style
  {

    denorm_indeterminate = -1,

    denorm_absent = 0,

    denorm_present = 1
  };
# 192 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/limits" 3
  struct __numeric_limits_base
  {


    static const bool is_specialized = false;




    static const int digits = 0;

    static const int digits10 = 0;

    static const bool is_signed = false;





    static const bool is_integer = false;




    static const bool is_exact = false;


    static const int radix = 0;



    static const int min_exponent = 0;


    static const int min_exponent10 = 0;



    static const int max_exponent = 0;


    static const int max_exponent10 = 0;


    static const bool has_infinity = false;


    static const bool has_quiet_NaN = false;


    static const bool has_signaling_NaN = false;

    static const float_denorm_style has_denorm = denorm_absent;


    static const bool has_denorm_loss = false;



    static const bool is_iec559 = false;



    static const bool is_bounded = false;




    static const bool is_modulo = false;


    static const bool traps = false;

    static const bool tinyness_before = false;



    static const float_round_style round_style = round_toward_zero;
  };
# 285 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/limits" 3
  template<typename _Tp>
    struct numeric_limits : public __numeric_limits_base
    {


      static _Tp min() throw() { return static_cast<_Tp>(0); }

      static _Tp max() throw() { return static_cast<_Tp>(0); }


      static _Tp epsilon() throw() { return static_cast<_Tp>(0); }

      static _Tp round_error() throw() { return static_cast<_Tp>(0); }

      static _Tp infinity() throw() { return static_cast<_Tp>(0); }

      static _Tp quiet_NaN() throw() { return static_cast<_Tp>(0); }


      static _Tp signaling_NaN() throw() { return static_cast<_Tp>(0); }



      static _Tp denorm_min() throw() { return static_cast<_Tp>(0); }
    };



  template<>
    struct numeric_limits<bool>
    {
      static const bool is_specialized = true;

      static bool min() throw()
      { return false; }
      static bool max() throw()
      { return true; }

      static const int digits = 1;
      static const int digits10 = 0;
      static const bool is_signed = false;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static bool epsilon() throw()
      { return false; }
      static bool round_error() throw()
      { return false; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;

      static bool infinity() throw()
      { return false; }
      static bool quiet_NaN() throw()
      { return false; }
      static bool signaling_NaN() throw()
      { return false; }
      static bool denorm_min() throw()
      { return false; }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = false;




      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };

  template<>
    struct numeric_limits<char>
    {
      static const bool is_specialized = true;

      static char min() throw()
      { return (((char)(-1) < 0) ? (char)1 << (sizeof(char) * 8 - ((char)(-1) < 0)) : (char)0); }
      static char max() throw()
      { return (((char)(-1) < 0) ? ((char)1 << (sizeof(char) * 8 - ((char)(-1) < 0))) - 1 : ~(char)0); }

      static const int digits = (sizeof(char) * 8 - ((char)(-1) < 0));
      static const int digits10 = ((sizeof(char) * 8 - ((char)(-1) < 0)) * 643 / 2136);
      static const bool is_signed = ((char)(-1) < 0);
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static char epsilon() throw()
      { return 0; }
      static char round_error() throw()
      { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;

      static char infinity() throw()
      { return char(); }
      static char quiet_NaN() throw()
      { return char(); }
      static char signaling_NaN() throw()
      { return char(); }
      static char denorm_min() throw()
      { return static_cast<char>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };

  template<>
    struct numeric_limits<signed char>
    {
      static const bool is_specialized = true;

      static signed char min() throw()
      { return -127 - 1; }
      static signed char max() throw()
      { return 127; }

      static const int digits = (sizeof(signed char) * 8 - ((signed char)(-1) < 0));
      static const int digits10 = ((sizeof(signed char) * 8 - ((signed char)(-1) < 0)) * 643 / 2136);
      static const bool is_signed = true;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static signed char epsilon() throw()
      { return 0; }
      static signed char round_error() throw()
      { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;

      static signed char infinity() throw()
      { return static_cast<signed char>(0); }
      static signed char quiet_NaN() throw()
      { return static_cast<signed char>(0); }
      static signed char signaling_NaN() throw()
      { return static_cast<signed char>(0); }
      static signed char denorm_min() throw()
      { return static_cast<signed char>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };

  template<>
    struct numeric_limits<unsigned char>
    {
      static const bool is_specialized = true;

      static unsigned char min() throw()
      { return 0; }
      static unsigned char max() throw()
      { return 127 * 2U + 1; }

      static const int digits = (sizeof(unsigned char) * 8 - ((unsigned char)(-1) < 0));
      static const int digits10 = ((sizeof(unsigned char) * 8 - ((unsigned char)(-1) < 0)) * 643 / 2136);
      static const bool is_signed = false;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static unsigned char epsilon() throw()
      { return 0; }
      static unsigned char round_error() throw()
      { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;

      static unsigned char infinity() throw()
      { return static_cast<unsigned char>(0); }
      static unsigned char quiet_NaN() throw()
      { return static_cast<unsigned char>(0); }
      static unsigned char signaling_NaN() throw()
      { return static_cast<unsigned char>(0); }
      static unsigned char denorm_min() throw()
      { return static_cast<unsigned char>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };

  template<>
    struct numeric_limits<wchar_t>
    {
      static const bool is_specialized = true;

      static wchar_t min() throw()
      { return (((wchar_t)(-1) < 0) ? (wchar_t)1 << (sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) : (wchar_t)0); }
      static wchar_t max() throw()
      { return (((wchar_t)(-1) < 0) ? ((wchar_t)1 << (sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0))) - 1 : ~(wchar_t)0); }

      static const int digits = (sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0));
      static const int digits10 = ((sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) * 643 / 2136);
      static const bool is_signed = ((wchar_t)(-1) < 0);
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static wchar_t epsilon() throw()
      { return 0; }
      static wchar_t round_error() throw()
      { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;

      static wchar_t infinity() throw()
      { return wchar_t(); }
      static wchar_t quiet_NaN() throw()
      { return wchar_t(); }
      static wchar_t signaling_NaN() throw()
      { return wchar_t(); }
      static wchar_t denorm_min() throw()
      { return wchar_t(); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };

  template<>
    struct numeric_limits<short>
    {
      static const bool is_specialized = true;

      static short min() throw()
      { return -32767 - 1; }
      static short max() throw()
      { return 32767; }

      static const int digits = (sizeof(short) * 8 - ((short)(-1) < 0));
      static const int digits10 = ((sizeof(short) * 8 - ((short)(-1) < 0)) * 643 / 2136);
      static const bool is_signed = true;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static short epsilon() throw()
      { return 0; }
      static short round_error() throw()
      { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;

      static short infinity() throw()
      { return short(); }
      static short quiet_NaN() throw()
      { return short(); }
      static short signaling_NaN() throw()
      { return short(); }
      static short denorm_min() throw()
      { return short(); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };

  template<>
    struct numeric_limits<unsigned short>
    {
      static const bool is_specialized = true;

      static unsigned short min() throw()
      { return 0; }
      static unsigned short max() throw()
      { return 32767 * 2U + 1; }

      static const int digits = (sizeof(unsigned short) * 8 - ((unsigned short)(-1) < 0));
      static const int digits10 = ((sizeof(unsigned short) * 8 - ((unsigned short)(-1) < 0)) * 643 / 2136);
      static const bool is_signed = false;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static unsigned short epsilon() throw()
      { return 0; }
      static unsigned short round_error() throw()
      { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;

      static unsigned short infinity() throw()
      { return static_cast<unsigned short>(0); }
      static unsigned short quiet_NaN() throw()
      { return static_cast<unsigned short>(0); }
      static unsigned short signaling_NaN() throw()
      { return static_cast<unsigned short>(0); }
      static unsigned short denorm_min() throw()
      { return static_cast<unsigned short>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };

  template<>
    struct numeric_limits<int>
    {
      static const bool is_specialized = true;

      static int min() throw()
      { return -2147483647 - 1; }
      static int max() throw()
      { return 2147483647; }

      static const int digits = (sizeof(int) * 8 - ((int)(-1) < 0));
      static const int digits10 = ((sizeof(int) * 8 - ((int)(-1) < 0)) * 643 / 2136);
      static const bool is_signed = true;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static int epsilon() throw()
      { return 0; }
      static int round_error() throw()
      { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;

      static int infinity() throw()
      { return static_cast<int>(0); }
      static int quiet_NaN() throw()
      { return static_cast<int>(0); }
      static int signaling_NaN() throw()
      { return static_cast<int>(0); }
      static int denorm_min() throw()
      { return static_cast<int>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };

  template<>
    struct numeric_limits<unsigned int>
    {
      static const bool is_specialized = true;

      static unsigned int min() throw()
      { return 0; }
      static unsigned int max() throw()
      { return 2147483647 * 2U + 1; }

      static const int digits = (sizeof(unsigned int) * 8 - ((unsigned int)(-1) < 0));
      static const int digits10 = ((sizeof(unsigned int) * 8 - ((unsigned int)(-1) < 0)) * 643 / 2136);
      static const bool is_signed = false;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static unsigned int epsilon() throw()
      { return 0; }
      static unsigned int round_error() throw()
      { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;

      static unsigned int infinity() throw()
      { return static_cast<unsigned int>(0); }
      static unsigned int quiet_NaN() throw()
      { return static_cast<unsigned int>(0); }
      static unsigned int signaling_NaN() throw()
      { return static_cast<unsigned int>(0); }
      static unsigned int denorm_min() throw()
      { return static_cast<unsigned int>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };

  template<>
    struct numeric_limits<long>
    {
      static const bool is_specialized = true;

      static long min() throw()
      { return -2147483647L - 1; }
      static long max() throw()
      { return 2147483647L; }

      static const int digits = (sizeof(long) * 8 - ((long)(-1) < 0));
      static const int digits10 = ((sizeof(long) * 8 - ((long)(-1) < 0)) * 643 / 2136);
      static const bool is_signed = true;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static long epsilon() throw()
      { return 0; }
      static long round_error() throw()
      { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;

      static long infinity() throw()
      { return static_cast<long>(0); }
      static long quiet_NaN() throw()
      { return static_cast<long>(0); }
      static long signaling_NaN() throw()
      { return static_cast<long>(0); }
      static long denorm_min() throw()
      { return static_cast<long>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };

  template<>
    struct numeric_limits<unsigned long>
    {
      static const bool is_specialized = true;

      static unsigned long min() throw()
      { return 0; }
      static unsigned long max() throw()
      { return 2147483647L * 2UL + 1; }

      static const int digits = (sizeof(unsigned long) * 8 - ((unsigned long)(-1) < 0));
      static const int digits10 = ((sizeof(unsigned long) * 8 - ((unsigned long)(-1) < 0)) * 643 / 2136);
      static const bool is_signed = false;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static unsigned long epsilon() throw()
      { return 0; }
      static unsigned long round_error() throw()
      { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;

      static unsigned long infinity() throw()
      { return static_cast<unsigned long>(0); }
      static unsigned long quiet_NaN() throw()
      { return static_cast<unsigned long>(0); }
      static unsigned long signaling_NaN() throw()
      { return static_cast<unsigned long>(0); }
      static unsigned long denorm_min() throw()
      { return static_cast<unsigned long>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };

  template<>
    struct numeric_limits<long long>
    {
      static const bool is_specialized = true;

      static long long min() throw()
      { return -9223372036854775807LL - 1; }
      static long long max() throw()
      { return 9223372036854775807LL; }

      static const int digits = (sizeof(long long) * 8 - ((long long)(-1) < 0));
      static const int digits10 = ((sizeof(long long) * 8 - ((long long)(-1) < 0)) * 643 / 2136);
      static const bool is_signed = true;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static long long epsilon() throw()
      { return 0; }
      static long long round_error() throw()
      { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;

      static long long infinity() throw()
      { return static_cast<long long>(0); }
      static long long quiet_NaN() throw()
      { return static_cast<long long>(0); }
      static long long signaling_NaN() throw()
      { return static_cast<long long>(0); }
      static long long denorm_min() throw()
      { return static_cast<long long>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };

  template<>
    struct numeric_limits<unsigned long long>
    {
      static const bool is_specialized = true;

      static unsigned long long min() throw()
      { return 0; }
      static unsigned long long max() throw()
      { return 9223372036854775807LL * 2ULL + 1; }

      static const int digits = (sizeof(unsigned long long) * 8 - ((unsigned long long)(-1) < 0));
      static const int digits10 = ((sizeof(unsigned long long) * 8 - ((unsigned long long)(-1) < 0)) * 643 / 2136);
      static const bool is_signed = false;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static unsigned long long epsilon() throw()
      { return 0; }
      static unsigned long long round_error() throw()
      { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;

      static unsigned long long infinity() throw()
      { return static_cast<unsigned long long>(0); }
      static unsigned long long quiet_NaN() throw()
      { return static_cast<unsigned long long>(0); }
      static unsigned long long signaling_NaN() throw()
      { return static_cast<unsigned long long>(0); }
      static unsigned long long denorm_min() throw()
      { return static_cast<unsigned long long>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };

  template<>
    struct numeric_limits<float>
    {
      static const bool is_specialized = true;

      static float min() throw()
      { return 1.17549435e-38F; }
      static float max() throw()
      { return 3.40282347e+38F; }

      static const int digits = 24;
      static const int digits10 = 6;
      static const bool is_signed = true;
      static const bool is_integer = false;
      static const bool is_exact = false;
      static const int radix = 2;
      static float epsilon() throw()
      { return 1.19209290e-7F; }
      static float round_error() throw()
      { return 0.5F; }

      static const int min_exponent = (-125);
      static const int min_exponent10 = (-37);
      static const int max_exponent = 128;
      static const int max_exponent10 = 38;

      static const bool has_infinity = 1;
      static const bool has_quiet_NaN = 1;
      static const bool has_signaling_NaN = has_quiet_NaN;
      static const float_denorm_style has_denorm
 = 1.40129846e-45F ? denorm_present : denorm_absent;
      static const bool has_denorm_loss = false;

      static float infinity() throw()
      { return __builtin_huge_valf (); }
      static float quiet_NaN() throw()
      { return __builtin_nanf (""); }
      static float signaling_NaN() throw()
      { return __builtin_nansf (""); }
      static float denorm_min() throw()
      { return 1.40129846e-45F; }

      static const bool is_iec559
 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
      static const bool is_bounded = true;
      static const bool is_modulo = false;

      static const bool traps = false;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_to_nearest;
    };





  template<>
    struct numeric_limits<double>
    {
      static const bool is_specialized = true;

      static double min() throw()
      { return 2.2250738585072014e-308; }
      static double max() throw()
      { return 1.7976931348623157e+308; }

      static const int digits = 53;
      static const int digits10 = 15;
      static const bool is_signed = true;
      static const bool is_integer = false;
      static const bool is_exact = false;
      static const int radix = 2;
      static double epsilon() throw()
      { return 2.2204460492503131e-16; }
      static double round_error() throw()
      { return 0.5; }

      static const int min_exponent = (-1021);
      static const int min_exponent10 = (-307);
      static const int max_exponent = 1024;
      static const int max_exponent10 = 308;

      static const bool has_infinity = 1;
      static const bool has_quiet_NaN = 1;
      static const bool has_signaling_NaN = has_quiet_NaN;
      static const float_denorm_style has_denorm
 = 4.9406564584124654e-324 ? denorm_present : denorm_absent;
      static const bool has_denorm_loss = false;

      static double infinity() throw()
      { return __builtin_huge_val(); }
      static double quiet_NaN() throw()
      { return __builtin_nan (""); }
      static double signaling_NaN() throw()
      { return __builtin_nans (""); }
      static double denorm_min() throw()
      { return 4.9406564584124654e-324; }

      static const bool is_iec559
 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
      static const bool is_bounded = true;
      static const bool is_modulo = false;

      static const bool traps = false;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_to_nearest;
    };





  template<>
    struct numeric_limits<long double>
    {
      static const bool is_specialized = true;

      static long double min() throw()
      { return 3.36210314311209350626e-4932L; }
      static long double max() throw()
      { return 1.18973149535723176502e+4932L; }

      static const int digits = 64;
      static const int digits10 = 18;
      static const bool is_signed = true;
      static const bool is_integer = false;
      static const bool is_exact = false;
      static const int radix = 2;
      static long double epsilon() throw()
      { return 1.08420217248550443401e-19L; }
      static long double round_error() throw()
      { return 0.5L; }

      static const int min_exponent = (-16381);
      static const int min_exponent10 = (-4931);
      static const int max_exponent = 16384;
      static const int max_exponent10 = 4932;

      static const bool has_infinity = 1;
      static const bool has_quiet_NaN = 1;
      static const bool has_signaling_NaN = has_quiet_NaN;
      static const float_denorm_style has_denorm
 = 3.64519953188247460253e-4951L ? denorm_present : denorm_absent;
      static const bool has_denorm_loss
 = false;

      static long double infinity() throw()
      { return __builtin_huge_vall (); }
      static long double quiet_NaN() throw()
      { return __builtin_nanl (""); }
      static long double signaling_NaN() throw()
      { return __builtin_nansl (""); }
      static long double denorm_min() throw()
      { return 3.64519953188247460253e-4951L; }

      static const bool is_iec559
 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
      static const bool is_bounded = true;
      static const bool is_modulo = false;

      static const bool traps = false;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_to_nearest;
    };





}
# 39 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.tcc" 2 3
# 1 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/typeinfo" 1 3
# 40 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/typeinfo" 3
extern "C++" {

namespace __cxxabiv1
{
  class __class_type_info;
}
# 55 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/typeinfo" 3
namespace std
{






  class type_info
  {
  public:




    virtual ~type_info();

  private:

    type_info& operator=(const type_info&);
    type_info(const type_info&);

  protected:
    const char *__name;

  protected:
    explicit type_info(const char *__n): __name(__n) { }

  public:



    const char* name() const
    { return __name; }


    bool before(const type_info& __arg) const;



    bool operator==(const type_info& __arg) const;
# 106 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/typeinfo" 3
    bool operator!=(const type_info& __arg) const
    { return !operator==(__arg); }


  public:

    virtual bool __is_pointer_p() const;

    virtual bool __is_function_p() const;







    virtual bool __do_catch(const type_info *__thr_type, void **__thr_obj,
       unsigned __outer) const;


    virtual bool __do_upcast(const __cxxabiv1::__class_type_info *__target,
        void **__obj_ptr) const;
  };






  class bad_cast : public exception
  {
  public:
    bad_cast() throw() { }


    virtual ~bad_cast() throw();
  };


  class bad_typeid : public exception
  {
  public:
    bad_typeid () throw() { }


    virtual ~bad_typeid() throw();
  };
}

}
# 40 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.tcc" 2 3


namespace std
{
  template<typename _Facet>
    locale
    locale::combine(const locale& __other) const
    {
      _Impl* __tmp = new _Impl(*_M_impl, 1);
      try
 {
   __tmp->_M_replace_facet(__other._M_impl, &_Facet::id);
 }
      catch(...)
 {
   __tmp->_M_remove_reference();
   throw;
 }
      return locale(__tmp);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    bool
    locale::operator()(const basic_string<_CharT, _Traits, _Alloc>& __s1,
                       const basic_string<_CharT, _Traits, _Alloc>& __s2) const
    {
      typedef std::collate<_CharT> __collate_type;
      const __collate_type& __collate = use_facet<__collate_type>(*this);
      return (__collate.compare(__s1.data(), __s1.data() + __s1.length(),
    __s2.data(), __s2.data() + __s2.length()) < 0);
    }
# 83 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.tcc" 3
  template<typename _Facet>
    inline bool
    has_facet(const locale& __loc) throw()
    {
      const size_t __i = _Facet::id._M_id();
      const locale::facet** __facets = __loc._M_impl->_M_facets;
      return (__i < __loc._M_impl->_M_facets_size && __facets[__i]);
    }
# 105 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.tcc" 3
  template<typename _Facet>
    inline const _Facet&
    use_facet(const locale& __loc)
    {
      const size_t __i = _Facet::id._M_id();
      const locale::facet** __facets = __loc._M_impl->_M_facets;
      if (!(__i < __loc._M_impl->_M_facets_size && __facets[__i]))
        __throw_bad_cast();
      return static_cast<const _Facet&>(*__facets[__i]);
    }



  template<typename _Facet>
    struct __use_cache
    {
      const _Facet*
      operator() (const locale& __loc) const;
    };


  template<typename _CharT>
    struct __use_cache<__numpunct_cache<_CharT> >
    {
      const __numpunct_cache<_CharT>*
      operator() (const locale& __loc) const
      {
 const size_t __i = numpunct<_CharT>::id._M_id();
 const locale::facet** __caches = __loc._M_impl->_M_caches;
 if (!__caches[__i])
   {
     __numpunct_cache<_CharT>* __tmp = __null;
     try
       {
  __tmp = new __numpunct_cache<_CharT>;
  __tmp->_M_cache(__loc);
       }
     catch(...)
       {
  delete __tmp;
  throw;
       }
     __loc._M_impl->_M_install_cache(__tmp, __i);
   }
 return static_cast<const __numpunct_cache<_CharT>*>(__caches[__i]);
      }
    };

  template<typename _CharT, bool _Intl>
    struct __use_cache<__moneypunct_cache<_CharT, _Intl> >
    {
      const __moneypunct_cache<_CharT, _Intl>*
      operator() (const locale& __loc) const
      {
 const size_t __i = moneypunct<_CharT, _Intl>::id._M_id();
 const locale::facet** __caches = __loc._M_impl->_M_caches;
 if (!__caches[__i])
   {
     __moneypunct_cache<_CharT, _Intl>* __tmp = __null;
     try
       {
  __tmp = new __moneypunct_cache<_CharT, _Intl>;
  __tmp->_M_cache(__loc);
       }
     catch(...)
       {
  delete __tmp;
  throw;
       }
     __loc._M_impl->_M_install_cache(__tmp, __i);
   }
 return static_cast<
   const __moneypunct_cache<_CharT, _Intl>*>(__caches[__i]);
      }
    };

  template<typename _CharT>
    void
    __numpunct_cache<_CharT>::_M_cache(const locale& __loc)
    {
      _M_allocated = true;

      const numpunct<_CharT>& __np = use_facet<numpunct<_CharT> >(__loc);

      _M_grouping_size = __np.grouping().size();
      char* __grouping = new char[_M_grouping_size];
      __np.grouping().copy(__grouping, _M_grouping_size);
      _M_grouping = __grouping;
      _M_use_grouping = _M_grouping_size && __np.grouping()[0] != 0;

      _M_truename_size = __np.truename().size();
      _CharT* __truename = new _CharT[_M_truename_size];
      __np.truename().copy(__truename, _M_truename_size);
      _M_truename = __truename;

      _M_falsename_size = __np.falsename().size();
      _CharT* __falsename = new _CharT[_M_falsename_size];
      __np.falsename().copy(__falsename, _M_falsename_size);
      _M_falsename = __falsename;

      _M_decimal_point = __np.decimal_point();
      _M_thousands_sep = __np.thousands_sep();

      const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__loc);
      __ct.widen(__num_base::_S_atoms_out,
   __num_base::_S_atoms_out + __num_base::_S_oend, _M_atoms_out);
      __ct.widen(__num_base::_S_atoms_in,
   __num_base::_S_atoms_in + __num_base::_S_iend, _M_atoms_in);
    }

  template<typename _CharT, bool _Intl>
    void
    __moneypunct_cache<_CharT, _Intl>::_M_cache(const locale& __loc)
    {
      _M_allocated = true;

      const moneypunct<_CharT, _Intl>& __mp =
 use_facet<moneypunct<_CharT, _Intl> >(__loc);

      _M_grouping_size = __mp.grouping().size();
      char* __grouping = new char[_M_grouping_size];
      __mp.grouping().copy(__grouping, _M_grouping_size);
      _M_grouping = __grouping;
      _M_use_grouping = _M_grouping_size && __mp.grouping()[0] != 0;

      _M_decimal_point = __mp.decimal_point();
      _M_thousands_sep = __mp.thousands_sep();
      _M_frac_digits = __mp.frac_digits();

      _M_curr_symbol_size = __mp.curr_symbol().size();
      _CharT* __curr_symbol = new _CharT[_M_curr_symbol_size];
      __mp.curr_symbol().copy(__curr_symbol, _M_curr_symbol_size);
      _M_curr_symbol = __curr_symbol;

      _M_positive_sign_size = __mp.positive_sign().size();
      _CharT* __positive_sign = new _CharT[_M_positive_sign_size];
      __mp.positive_sign().copy(__positive_sign, _M_positive_sign_size);
      _M_positive_sign = __positive_sign;

      _M_negative_sign_size = __mp.negative_sign().size();
      _CharT* __negative_sign = new _CharT[_M_negative_sign_size];
      __mp.negative_sign().copy(__negative_sign, _M_negative_sign_size);
      _M_negative_sign = __negative_sign;

      _M_pos_format = __mp.pos_format();
      _M_neg_format = __mp.neg_format();

      const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__loc);
      __ct.widen(money_base::_S_atoms,
   money_base::_S_atoms + money_base::_S_end, _M_atoms);
    }
# 266 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.tcc" 3
  static bool
  __verify_grouping(const char* __grouping, size_t __grouping_size,
      const string& __grouping_tmp);

  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    _M_extract_float(_InIter __beg, _InIter __end, ios_base& __io,
       ios_base::iostate& __err, string& __xtrc) const
    {
      typedef char_traits<_CharT> __traits_type;
      typedef typename numpunct<_CharT>::__cache_type __cache_type;
      __use_cache<__cache_type> __uc;
      const locale& __loc = __io._M_getloc();
      const __cache_type* __lc = __uc(__loc);
      const _CharT* __lit = __lc->_M_atoms_in;


      bool __found_mantissa = false;


      if (__beg != __end)
 {
   const char_type __c = *__beg;
   const bool __plus = __c == __lit[__num_base::_S_iplus];
   if ((__plus || __c == __lit[__num_base::_S_iminus])
       && !(__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
       && !(__c == __lc->_M_decimal_point))
     {
       __xtrc += __plus ? '+' : '-';
       ++__beg;
     }
 }


      while (__beg != __end)
 {
   const char_type __c = *__beg;
   if (__lc->_M_use_grouping && __c == __lc->_M_thousands_sep
       || __c == __lc->_M_decimal_point)
     break;
   else if (__c == __lit[__num_base::_S_izero])
     {
       if (!__found_mantissa)
  {
    __xtrc += '0';
    __found_mantissa = true;
  }
       ++__beg;
     }
   else
     break;
 }


      bool __found_dec = false;
      bool __found_sci = false;
      string __found_grouping;
      if (__lc->_M_use_grouping)
 __found_grouping.reserve(32);
      int __sep_pos = 0;
      const char_type* __lit_zero = __lit + __num_base::_S_izero;
      while (__beg != __end)
        {


   const char_type __c = *__beg;
   const char_type* __q = __traits_type::find(__lit_zero, 10, __c);
          if (__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
     {
       if (!__found_dec && !__found_sci)
  {


    if (__sep_pos)
      {
        __found_grouping += static_cast<char>(__sep_pos);
        __sep_pos = 0;
        ++__beg;
      }
    else
      {
        __err |= ios_base::failbit;
        break;
      }
  }
       else
  break;
            }
   else if (__c == __lc->_M_decimal_point)
     {
       if (!__found_dec && !__found_sci)
  {



    if (__found_grouping.size())
      __found_grouping += static_cast<char>(__sep_pos);
    __xtrc += '.';
    __found_dec = true;
    ++__beg;
  }
       else
  break;
     }
          else if (__q != 0)
     {
       __xtrc += __num_base::_S_atoms_in[__q - __lit];
       __found_mantissa = true;
       ++__sep_pos;
       ++__beg;
     }
   else if ((__c == __lit[__num_base::_S_ie]
      || __c == __lit[__num_base::_S_iE])
     && __found_mantissa && !__found_sci)
     {

       if (__found_grouping.size() && !__found_dec)
  __found_grouping += static_cast<char>(__sep_pos);
       __xtrc += 'e';
       __found_sci = true;


       if (++__beg != __end)
  {
    const bool __plus = *__beg == __lit[__num_base::_S_iplus];
    if ((__plus || *__beg == __lit[__num_base::_S_iminus])
        && !(__lc->_M_use_grouping
      && *__beg == __lc->_M_thousands_sep)
        && !(*__beg == __lc->_M_decimal_point))
      {
        __xtrc += __plus ? '+' : '-';
        ++__beg;
      }
  }
     }
   else

     break;
        }



      if (__lc->_M_use_grouping && __found_grouping.size())
        {

   if (!__found_dec && !__found_sci)
     __found_grouping += static_cast<char>(__sep_pos);

          if (!std::__verify_grouping(__lc->_M_grouping,
          __lc->_M_grouping_size,
          __found_grouping))
     __err |= ios_base::failbit;
        }


      if (__beg == __end)
        __err |= ios_base::eofbit;
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    template<typename _ValueT>
      _InIter
      num_get<_CharT, _InIter>::
      _M_extract_int(_InIter __beg, _InIter __end, ios_base& __io,
       ios_base::iostate& __err, _ValueT& __v) const
      {
        typedef char_traits<_CharT> __traits_type;
 typedef typename numpunct<_CharT>::__cache_type __cache_type;
 __use_cache<__cache_type> __uc;
 const locale& __loc = __io._M_getloc();
 const __cache_type* __lc = __uc(__loc);
 const _CharT* __lit = __lc->_M_atoms_in;


 const ios_base::fmtflags __basefield = __io.flags()
                                        & ios_base::basefield;
 const bool __oct = __basefield == ios_base::oct;
 int __base = __oct ? 8 : (__basefield == ios_base::hex ? 16 : 10);


 bool __found_num = false;


 bool __negative = false;
 if (__beg != __end)
   {
     const char_type __c = *__beg;
     if (numeric_limits<_ValueT>::is_signed)
       __negative = __c == __lit[__num_base::_S_iminus];
     if ((__negative || __c == __lit[__num_base::_S_iplus])
  && !(__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
  && !(__c == __lc->_M_decimal_point))
       ++__beg;
   }



 while (__beg != __end)
   {
     const char_type __c = *__beg;
     if (__lc->_M_use_grouping && __c == __lc->_M_thousands_sep
  || __c == __lc->_M_decimal_point)
       break;
     else if (__c == __lit[__num_base::_S_izero]
       && (!__found_num || __base == 10))
       {
  __found_num = true;
  ++__beg;
       }
     else if (__found_num)
       {
  if (__c == __lit[__num_base::_S_ix]
      || __c == __lit[__num_base::_S_iX])
    {
      if (__basefield == 0)
        __base = 16;
      if (__base == 16)
        {
   __found_num = false;
   ++__beg;
        }
    }
  else if (__basefield == 0)
    __base = 8;
  break;
       }
     else
       break;
   }



 const size_t __len = __base == 16 ? (__num_base::_S_iend
          - __num_base::_S_izero)
                                   : __base;


 string __found_grouping;
 if (__lc->_M_use_grouping)
   __found_grouping.reserve(32);
 int __sep_pos = 0;
 bool __overflow = false;
 _ValueT __result = 0;
 const char_type* __lit_zero = __lit + __num_base::_S_izero;
 if (__negative)
   {
     const _ValueT __min = numeric_limits<_ValueT>::min() / __base;
     for (; __beg != __end; ++__beg)
       {


  const char_type __c = *__beg;
  const char_type* __q = __traits_type::find(__lit_zero,
          __len, __c);
  if (__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
    {


      if (__sep_pos)
        {
   __found_grouping += static_cast<char>(__sep_pos);
   __sep_pos = 0;
        }
      else
        {
   __err |= ios_base::failbit;
   break;
        }
    }
  else if (__c == __lc->_M_decimal_point)
    break;
  else if (__q != 0)
    {
      int __digit = __q - __lit_zero;
      if (__digit > 15)
        __digit -= 6;
      if (__result < __min)
        __overflow = true;
      else
        {
   const _ValueT __new_result = __result * __base
                                - __digit;
   __overflow |= __new_result > __result;
   __result = __new_result;
   ++__sep_pos;
   __found_num = true;
        }
    }
  else

    break;
       }
   }
 else
   {
     const _ValueT __max = numeric_limits<_ValueT>::max() / __base;
     for (; __beg != __end; ++__beg)
       {
  const char_type __c = *__beg;
  const char_type* __q = __traits_type::find(__lit_zero,
          __len, __c);
  if (__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
    {
      if (__sep_pos)
        {
   __found_grouping += static_cast<char>(__sep_pos);
   __sep_pos = 0;
        }
      else
        {
   __err |= ios_base::failbit;
   break;
        }
    }
  else if (__c == __lc->_M_decimal_point)
    break;
  else if (__q != 0)
    {
      int __digit = __q - __lit_zero;
      if (__digit > 15)
        __digit -= 6;
      if (__result > __max)
        __overflow = true;
      else
        {
   const _ValueT __new_result = __result * __base
                                + __digit;
   __overflow |= __new_result < __result;
   __result = __new_result;
   ++__sep_pos;
   __found_num = true;
        }
    }
  else
    break;
       }
   }



 if (__lc->_M_use_grouping && __found_grouping.size())
   {

     __found_grouping += static_cast<char>(__sep_pos);

     if (!std::__verify_grouping(__lc->_M_grouping,
     __lc->_M_grouping_size,
     __found_grouping))
       __err |= ios_base::failbit;
   }

 if (!(__err & ios_base::failbit) && !__overflow
     && __found_num)
   __v = __result;
 else
   __err |= ios_base::failbit;

 if (__beg == __end)
   __err |= ios_base::eofbit;
 return __beg;
      }



  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, bool& __v) const
    {
      if (!(__io.flags() & ios_base::boolalpha))
        {



   long __l = -1;
          __beg = _M_extract_int(__beg, __end, __io, __err, __l);
   if (__l == 0 || __l == 1)
     __v = __l;
   else
            __err |= ios_base::failbit;
        }
      else
        {

   typedef char_traits<_CharT> __traits_type;
   typedef typename numpunct<_CharT>::__cache_type __cache_type;
   __use_cache<__cache_type> __uc;
   const locale& __loc = __io._M_getloc();
   const __cache_type* __lc = __uc(__loc);

   bool __testf = true;
   bool __testt = true;
   size_t __n;
          for (__n = 0; __beg != __end; ++__n, ++__beg)
            {
       if (__testf)
  if (__n < __lc->_M_falsename_size)
    __testf = *__beg == __lc->_M_falsename[__n];
  else
    break;

       if (__testt)
  if (__n < __lc->_M_truename_size)
    __testt = *__beg == __lc->_M_truename[__n];
  else
    break;

       if (!__testf && !__testt)
  break;
            }
   if (__testf && __n == __lc->_M_falsename_size)
     __v = 0;
   else if (__testt && __n == __lc->_M_truename_size)
     __v = 1;
   else
     __err |= ios_base::failbit;

          if (__beg == __end)
            __err |= ios_base::eofbit;
        }
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, long& __v) const
    { return _M_extract_int(__beg, __end, __io, __err, __v); }

  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, unsigned short& __v) const
    { return _M_extract_int(__beg, __end, __io, __err, __v); }

  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, unsigned int& __v) const
    { return _M_extract_int(__beg, __end, __io, __err, __v); }

  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, unsigned long& __v) const
    { return _M_extract_int(__beg, __end, __io, __err, __v); }


  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, long long& __v) const
    { return _M_extract_int(__beg, __end, __io, __err, __v); }

  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, unsigned long long& __v) const
    { return _M_extract_int(__beg, __end, __io, __err, __v); }


  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
    ios_base::iostate& __err, float& __v) const
    {
      string __xtrc;
      __xtrc.reserve(32);
      __beg = _M_extract_float(__beg, __end, __io, __err, __xtrc);
      std::__convert_to_v(__xtrc.c_str(), __v, __err, _S_get_c_locale());
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, double& __v) const
    {
      string __xtrc;
      __xtrc.reserve(32);
      __beg = _M_extract_float(__beg, __end, __io, __err, __xtrc);
      std::__convert_to_v(__xtrc.c_str(), __v, __err, _S_get_c_locale());
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, long double& __v) const
    {
      string __xtrc;
      __xtrc.reserve(32);
      __beg = _M_extract_float(__beg, __end, __io, __err, __xtrc);





      std::__convert_to_v(__xtrc.c_str(), __v, __err, _S_get_c_locale());

      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, void*& __v) const
    {

      typedef ios_base::fmtflags fmtflags;
      const fmtflags __fmt = __io.flags();
      __io.flags(__fmt & ~ios_base::basefield | ios_base::hex);

      unsigned long __ul;
      __beg = _M_extract_int(__beg, __end, __io, __err, __ul);


      __io.flags(__fmt);

      if (!(__err & ios_base::failbit))
 __v = reinterpret_cast<void*>(__ul);
      else
 __err |= ios_base::failbit;
      return __beg;
    }



  template<typename _CharT, typename _OutIter>
    void
    num_put<_CharT, _OutIter>::
    _M_pad(_CharT __fill, streamsize __w, ios_base& __io,
    _CharT* __new, const _CharT* __cs, int& __len) const
    {


      __pad<_CharT, char_traits<_CharT> >::_S_pad(__io, __fill, __new, __cs,
        __w, __len, true);
      __len = static_cast<int>(__w);
    }


  template<typename _CharT>
    inline int
    __int_to_char(_CharT* __bufend, long __v, const _CharT* __lit,
    ios_base::fmtflags __flags)
    {
      unsigned long __ul = static_cast<unsigned long>(__v);
      bool __neg = false;
      if (__v < 0)
 {
   __ul = -__ul;
   __neg = true;
 }
      return __int_to_char(__bufend, __ul, __lit, __flags, __neg);
    }

  template<typename _CharT>
    inline int
    __int_to_char(_CharT* __bufend, unsigned long __v, const _CharT* __lit,
    ios_base::fmtflags __flags)
    {

      return __int_to_char(__bufend, __v, __lit,
      __flags & ~ios_base::showpos, false);
    }


  template<typename _CharT>
    inline int
    __int_to_char(_CharT* __bufend, long long __v, const _CharT* __lit,
    ios_base::fmtflags __flags)
    {
      unsigned long long __ull = static_cast<unsigned long long>(__v);
      bool __neg = false;
      if (__v < 0)
 {
   __ull = -__ull;
   __neg = true;
 }
      return __int_to_char(__bufend, __ull, __lit, __flags, __neg);
    }

  template<typename _CharT>
    inline int
    __int_to_char(_CharT* __bufend, unsigned long long __v,
    const _CharT* __lit, ios_base::fmtflags __flags)
    { return __int_to_char(__bufend, __v, __lit,
      __flags & ~ios_base::showpos, false); }


  template<typename _CharT, typename _ValueT>
    int
    __int_to_char(_CharT* __bufend, _ValueT __v, const _CharT* __lit,
    ios_base::fmtflags __flags, bool __neg)
    {

      const bool __showbase = (__flags & ios_base::showbase) && __v;
      const ios_base::fmtflags __basefield = __flags & ios_base::basefield;
      _CharT* __buf = __bufend - 1;

      if (__builtin_expect(__basefield != ios_base::oct &&
      __basefield != ios_base::hex, true))
 {

   do
     {
       *__buf-- = __lit[(__v % 10) + __num_base::_S_odigits];
       __v /= 10;
     }
   while (__v != 0);
   if (__neg)
     *__buf-- = __lit[__num_base::_S_ominus];
   else if (__flags & ios_base::showpos)
     *__buf-- = __lit[__num_base::_S_oplus];
 }
      else if (__basefield == ios_base::oct)
 {

   do
     {
       *__buf-- = __lit[(__v & 0x7) + __num_base::_S_odigits];
       __v >>= 3;
     }
   while (__v != 0);
   if (__showbase)
     *__buf-- = __lit[__num_base::_S_odigits];
 }
      else
 {

   const bool __uppercase = __flags & ios_base::uppercase;
   const int __case_offset = __uppercase ? __num_base::_S_oudigits
                                         : __num_base::_S_odigits;
   do
     {
       *__buf-- = __lit[(__v & 0xf) + __case_offset];
       __v >>= 4;
     }
   while (__v != 0);
   if (__showbase)
     {

       *__buf-- = __lit[__num_base::_S_ox + __uppercase];

       *__buf-- = __lit[__num_base::_S_odigits];
     }
 }
      return __bufend - __buf - 1;
    }

  template<typename _CharT, typename _OutIter>
    void
    num_put<_CharT, _OutIter>::
    _M_group_int(const char* __grouping, size_t __grouping_size, _CharT __sep,
   ios_base& __io, _CharT* __new, _CharT* __cs, int& __len) const
    {





      streamsize __off = 0;
      const ios_base::fmtflags __basefield = __io.flags()
                                      & ios_base::basefield;
      if ((__io.flags() & ios_base::showbase) && __len > 1)
 if (__basefield == ios_base::oct)
   {
     __off = 1;
     __new[0] = __cs[0];
   }
 else if (__basefield == ios_base::hex)
   {
     __off = 2;
     __new[0] = __cs[0];
     __new[1] = __cs[1];
   }
      _CharT* __p;
      __p = std::__add_grouping(__new + __off, __sep, __grouping,
    __grouping_size, __cs + __off,
    __cs + __len);
      __len = __p - __new;
    }

  template<typename _CharT, typename _OutIter>
    template<typename _ValueT>
      _OutIter
      num_put<_CharT, _OutIter>::
      _M_insert_int(_OutIter __s, ios_base& __io, _CharT __fill,
      _ValueT __v) const
      {
 typedef typename numpunct<_CharT>::__cache_type __cache_type;
 __use_cache<__cache_type> __uc;
 const locale& __loc = __io._M_getloc();
 const __cache_type* __lc = __uc(__loc);
 const _CharT* __lit = __lc->_M_atoms_out;


 const int __ilen = 4 * sizeof(_ValueT);
 _CharT* __cs = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
            * __ilen));



 int __len;
 __len = __int_to_char(__cs + __ilen, __v, __lit, __io.flags());
 __cs += __ilen - __len;


 if (__lc->_M_use_grouping)
   {


     _CharT* __cs2 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
          * __len * 2));
     _M_group_int(__lc->_M_grouping, __lc->_M_grouping_size,
    __lc->_M_thousands_sep, __io, __cs2, __cs, __len);
     __cs = __cs2;
   }


 const streamsize __w = __io.width();
 if (__w > static_cast<streamsize>(__len))
   {
     _CharT* __cs3 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
          * __w));
     _M_pad(__fill, __w, __io, __cs3, __cs, __len);
     __cs = __cs3;
   }
 __io.width(0);



 return std::__write(__s, __cs, __len);
      }

  template<typename _CharT, typename _OutIter>
    void
    num_put<_CharT, _OutIter>::
    _M_group_float(const char* __grouping, size_t __grouping_size,
     _CharT __sep, const _CharT* __p, _CharT* __new,
     _CharT* __cs, int& __len) const
    {



      _CharT* __p2;
      const int __declen = __p ? __p - __cs : __len;
      __p2 = std::__add_grouping(__new, __sep, __grouping, __grouping_size,
     __cs, __cs + __declen);


      int __newlen = __p2 - __new;
      if (__p)
 {
   char_traits<_CharT>::copy(__p2, __p, __len - __declen);
   __newlen += __len - __declen;
 }
      __len = __newlen;
    }
# 1050 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.tcc" 3
  template<typename _CharT, typename _OutIter>
    template<typename _ValueT>
      _OutIter
      num_put<_CharT, _OutIter>::
      _M_insert_float(_OutIter __s, ios_base& __io, _CharT __fill, char __mod,
         _ValueT __v) const
      {
 typedef typename numpunct<_CharT>::__cache_type __cache_type;
 __use_cache<__cache_type> __uc;
 const locale& __loc = __io._M_getloc();
 const __cache_type* __lc = __uc(__loc);


 streamsize __prec = __io.precision();
 if (__prec < static_cast<streamsize>(0))
   __prec = static_cast<streamsize>(6);

 const int __max_digits = numeric_limits<_ValueT>::digits10;


 int __len;

 char __fbuf[16];




 int __cs_size = __max_digits * 3;
 char* __cs = static_cast<char*>(__builtin_alloca(__cs_size));

 __num_base::_S_format_float(__io, __fbuf, __mod);
 __len = std::__convert_from_v(__cs, __cs_size, __fbuf, __v,
          _S_get_c_locale(), __prec);


 if (__len >= __cs_size)
   {
     __cs_size = __len + 1;
     __cs = static_cast<char*>(__builtin_alloca(__cs_size));
     __len = std::__convert_from_v(__cs, __cs_size, __fbuf, __v,
       _S_get_c_locale(), __prec);
   }
# 1114 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.tcc" 3
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);

      _CharT* __ws = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
          * __len));
      __ctype.widen(__cs, __cs + __len, __ws);


      const _CharT __cdec = __ctype.widen('.');
      const _CharT __dec = __lc->_M_decimal_point;
      const _CharT* __p = char_traits<_CharT>::find(__ws, __len, __cdec);
      if (__p)
 __ws[__p - __ws] = __dec;


      if (__lc->_M_use_grouping)
 {


   _CharT* __ws2 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
        * __len * 2));
   _M_group_float(__lc->_M_grouping, __lc->_M_grouping_size,
    __lc->_M_thousands_sep, __p, __ws2, __ws, __len);
   __ws = __ws2;
 }


      const streamsize __w = __io.width();
      if (__w > static_cast<streamsize>(__len))
 {
   _CharT* __ws3 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
        * __w));
   _M_pad(__fill, __w, __io, __ws3, __ws, __len);
   __ws = __ws3;
 }
      __io.width(0);



      return std::__write(__s, __ws, __len);
      }

  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill, bool __v) const
    {
      const ios_base::fmtflags __flags = __io.flags();
      if ((__flags & ios_base::boolalpha) == 0)
        {
          const long __l = __v;
          __s = _M_insert_int(__s, __io, __fill, __l);
        }
      else
        {
   typedef typename numpunct<_CharT>::__cache_type __cache_type;
   __use_cache<__cache_type> __uc;
   const locale& __loc = __io._M_getloc();
   const __cache_type* __lc = __uc(__loc);

   const _CharT* __name = __v ? __lc->_M_truename
                              : __lc->_M_falsename;
   int __len = __v ? __lc->_M_truename_size
                   : __lc->_M_falsename_size;

   const streamsize __w = __io.width();
   if (__w > static_cast<streamsize>(__len))
     {
       _CharT* __cs
  = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
       * __w));
       _M_pad(__fill, __w, __io, __cs, __name, __len);
       __name = __cs;
     }
   __io.width(0);
   __s = std::__write(__s, __name, __len);
 }
      return __s;
    }

  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill, long __v) const
    { return _M_insert_int(__s, __io, __fill, __v); }

  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill,
           unsigned long __v) const
    { return _M_insert_int(__s, __io, __fill, __v); }


  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __b, char_type __fill, long long __v) const
    { return _M_insert_int(__s, __b, __fill, __v); }

  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill,
           unsigned long long __v) const
    { return _M_insert_int(__s, __io, __fill, __v); }


  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill, double __v) const
    { return _M_insert_float(__s, __io, __fill, char(), __v); }

  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill,
    long double __v) const
    {

      return _M_insert_float(__s, __io, __fill, char_type(),
         static_cast<double>(__v));



    }

  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill,
           const void* __v) const
    {
      const ios_base::fmtflags __flags = __io.flags();
      const ios_base::fmtflags __fmt = ~(ios_base::basefield
      | ios_base::uppercase
      | ios_base::internal);
      __io.flags(__flags & __fmt | (ios_base::hex | ios_base::showbase));

      __s = _M_insert_int(__s, __io, __fill,
     reinterpret_cast<unsigned long>(__v));
      __io.flags(__flags);
      return __s;
    }

  template<typename _CharT, typename _InIter>
    template<bool _Intl>
      _InIter
      money_get<_CharT, _InIter>::
      _M_extract(iter_type __beg, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, string& __units) const
      {
 typedef char_traits<_CharT> __traits_type;
 typedef typename string_type::size_type size_type;
 typedef money_base::part part;
 typedef moneypunct<_CharT, _Intl> __moneypunct_type;
 typedef typename __moneypunct_type::__cache_type __cache_type;

 const locale& __loc = __io._M_getloc();
 const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);

 __use_cache<__cache_type> __uc;
 const __cache_type* __lc = __uc(__loc);
 const char_type* __lit = __lc->_M_atoms;


 bool __negative = false;

 size_type __sign_size = 0;

 const bool __mandatory_sign = (__lc->_M_positive_sign_size
           && __lc->_M_negative_sign_size);

 string __grouping_tmp;
 if (__lc->_M_use_grouping)
   __grouping_tmp.reserve(32);

 int __last_pos = 0;

 int __n = 0;

 bool __testvalid = true;

 bool __testdecfound = false;


 string __res;
 __res.reserve(32);

 const char_type* __lit_zero = __lit + money_base::_S_zero;
 const money_base::pattern __p = __lc->_M_neg_format;
 for (int __i = 0; __i < 4 && __testvalid; ++__i)
   {
     const part __which = static_cast<part>(__p.field[__i]);
     switch (__which)
       {
       case money_base::symbol:




  if (__io.flags() & ios_base::showbase || __sign_size > 1
      || __i == 0
      || (__i == 1 && (__mandatory_sign
         || (static_cast<part>(__p.field[0])
      == money_base::sign)
         || (static_cast<part>(__p.field[2])
      == money_base::space)))
      || (__i == 2 && ((static_cast<part>(__p.field[3])
          == money_base::value)
         || __mandatory_sign
         && (static_cast<part>(__p.field[3])
      == money_base::sign))))
    {
      const size_type __len = __lc->_M_curr_symbol_size;
      size_type __j = 0;
      for (; __beg != __end && __j < __len
      && *__beg == __lc->_M_curr_symbol[__j];
    ++__beg, ++__j);
      if (__j != __len
   && (__j || __io.flags() & ios_base::showbase))
        __testvalid = false;
    }
  break;
       case money_base::sign:

  if (__lc->_M_positive_sign_size && __beg != __end
      && *__beg == __lc->_M_positive_sign[0])
    {
      __sign_size = __lc->_M_positive_sign_size;
      ++__beg;
    }
  else if (__lc->_M_negative_sign_size && __beg != __end
    && *__beg == __lc->_M_negative_sign[0])
    {
      __negative = true;
      __sign_size = __lc->_M_negative_sign_size;
      ++__beg;
    }
  else if (__lc->_M_positive_sign_size
    && !__lc->_M_negative_sign_size)


    __negative = true;
  else if (__mandatory_sign)
    __testvalid = false;
  break;
       case money_base::value:


  for (; __beg != __end; ++__beg)
    {
      const char_type* __q = __traits_type::find(__lit_zero,
              10, *__beg);
      if (__q != 0)
        {
   __res += money_base::_S_atoms[__q - __lit];
   ++__n;
        }
      else if (*__beg == __lc->_M_decimal_point
        && !__testdecfound)
        {
   __last_pos = __n;
   __n = 0;
   __testdecfound = true;
        }
      else if (__lc->_M_use_grouping
        && *__beg == __lc->_M_thousands_sep
        && !__testdecfound)
        {
   if (__n)
     {

       __grouping_tmp += static_cast<char>(__n);
       __n = 0;
     }
   else
     {
       __testvalid = false;
       break;
     }
        }
      else
        break;
    }
  if (__res.empty())
    __testvalid = false;
  break;
       case money_base::space:

  if (__beg != __end && __ctype.is(ctype_base::space, *__beg))
    ++__beg;
  else
    __testvalid = false;
       case money_base::none:

  if (__i != 3)
    for (; __beg != __end
    && __ctype.is(ctype_base::space, *__beg); ++__beg);
  break;
       }
   }


 if (__sign_size > 1 && __testvalid)
   {
     const char_type* __sign = __negative ? __lc->_M_negative_sign
                                          : __lc->_M_positive_sign;
     size_type __i = 1;
     for (; __beg != __end && __i < __sign_size
     && *__beg == __sign[__i]; ++__beg, ++__i);

     if (__i != __sign_size)
       __testvalid = false;
   }

 if (__testvalid)
   {

     if (__res.size() > 1)
       {
  const size_type __first = __res.find_first_not_of('0');
  const bool __only_zeros = __first == string::npos;
  if (__first)
    __res.erase(0, __only_zeros ? __res.size() - 1 : __first);
       }


     if (__negative && __res[0] != '0')
       __res.insert(__res.begin(), '-');


     if (__grouping_tmp.size())
       {

  __grouping_tmp += static_cast<char>(__testdecfound ? __last_pos
                         : __n);
  if (!std::__verify_grouping(__lc->_M_grouping,
         __lc->_M_grouping_size,
         __grouping_tmp))
    __testvalid = false;
       }


     if (__testdecfound && __lc->_M_frac_digits > 0
  && __n != __lc->_M_frac_digits)
       __testvalid = false;
   }


 if (__beg == __end)
   __err |= ios_base::eofbit;


 if (!__testvalid)
   __err |= ios_base::failbit;
 else
   __units.swap(__res);

 return __beg;
      }

  template<typename _CharT, typename _InIter>
    _InIter
    money_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, bool __intl, ios_base& __io,
    ios_base::iostate& __err, long double& __units) const
    {
      string __str;
      if (__intl)
 __beg = _M_extract<true>(__beg, __end, __io, __err, __str);
      else
 __beg = _M_extract<false>(__beg, __end, __io, __err, __str);





      std::__convert_to_v(__str.c_str(), __units, __err, _S_get_c_locale());

      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    money_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, bool __intl, ios_base& __io,
    ios_base::iostate& __err, string_type& __units) const
    {
      typedef typename string::size_type size_type;

      const locale& __loc = __io._M_getloc();
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);

      string __str;
      const iter_type __ret = __intl ? _M_extract<true>(__beg, __end, __io,
       __err, __str)
                              : _M_extract<false>(__beg, __end, __io,
        __err, __str);
      const size_type __len = __str.size();
      if (__len)
 {
   _CharT* __ws = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
              * __len));
   __ctype.widen(__str.data(), __str.data() + __len, __ws);
   __units.assign(__ws, __len);
 }

      return __ret;
    }

  template<typename _CharT, typename _OutIter>
    template<bool _Intl>
      _OutIter
      money_put<_CharT, _OutIter>::
      _M_insert(iter_type __s, ios_base& __io, char_type __fill,
  const string_type& __digits) const
      {
 typedef typename string_type::size_type size_type;
 typedef money_base::part part;
 typedef moneypunct<_CharT, _Intl> __moneypunct_type;
 typedef typename __moneypunct_type::__cache_type __cache_type;

 const locale& __loc = __io._M_getloc();
 const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);

 __use_cache<__cache_type> __uc;
 const __cache_type* __lc = __uc(__loc);
 const char_type* __lit = __lc->_M_atoms;



 const char_type* __beg = __digits.data();

 money_base::pattern __p;
 const char_type* __sign;
 size_type __sign_size;
 if (*__beg != __lit[money_base::_S_minus])
   {
     __p = __lc->_M_pos_format;
     __sign = __lc->_M_positive_sign;
     __sign_size = __lc->_M_positive_sign_size;
   }
 else
   {
     __p = __lc->_M_neg_format;
     __sign = __lc->_M_negative_sign;
     __sign_size = __lc->_M_negative_sign_size;
     if (__digits.size())
       ++__beg;
   }


 size_type __len = __ctype.scan_not(ctype_base::digit, __beg,
        __beg + __digits.size()) - __beg;
 if (__len)
   {



     string_type __value;
     __value.reserve(2 * __len);



     int __paddec = __len - __lc->_M_frac_digits;
     if (__paddec > 0)
         {
  if (__lc->_M_frac_digits < 0)
    __paddec = __len;
    if (__lc->_M_grouping_size)
      {
      _CharT* __ws =
          static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
             * 2 * __len));
        _CharT* __ws_end =
        std::__add_grouping(__ws, __lc->_M_thousands_sep,
       __lc->_M_grouping,
       __lc->_M_grouping_size,
       __beg, __beg + __paddec);
      __value.assign(__ws, __ws_end - __ws);
      }
    else
    __value.assign(__beg, __paddec);
       }


     if (__lc->_M_frac_digits > 0)
       {
  __value += __lc->_M_decimal_point;
  if (__paddec >= 0)
    __value.append(__beg + __paddec, __lc->_M_frac_digits);
  else
    {

      __value.append(-__paddec, __lit[money_base::_S_zero]);
      __value.append(__beg, __len);
    }
         }


     const ios_base::fmtflags __f = __io.flags()
                                    & ios_base::adjustfield;
     __len = __value.size() + __sign_size;
     __len += ((__io.flags() & ios_base::showbase)
        ? __lc->_M_curr_symbol_size : 0);

     string_type __res;
     __res.reserve(2 * __len);

     const size_type __width = static_cast<size_type>(__io.width());
     const bool __testipad = (__f == ios_base::internal
         && __len < __width);

     for (int __i = 0; __i < 4; ++__i)
       {
  const part __which = static_cast<part>(__p.field[__i]);
  switch (__which)
    {
    case money_base::symbol:
      if (__io.flags() & ios_base::showbase)
        __res.append(__lc->_M_curr_symbol,
       __lc->_M_curr_symbol_size);
      break;
    case money_base::sign:



      if (__sign_size)
        __res += __sign[0];
      break;
    case money_base::value:
      __res += __value;
      break;
    case money_base::space:



      if (__testipad)
        __res.append(__width - __len, __fill);
      else
        __res += __fill;
      break;
    case money_base::none:
      if (__testipad)
        __res.append(__width - __len, __fill);
      break;
    }
       }


     if (__sign_size > 1)
       __res.append(__sign + 1, __sign_size - 1);


     __len = __res.size();
     if (__width > __len)
       {
  if (__f == ios_base::left)

    __res.append(__width - __len, __fill);
  else

    __res.insert(0, __width - __len, __fill);
  __len = __width;
       }


     __s = std::__write(__s, __res.data(), __len);
   }
 __io.width(0);
 return __s;
      }

  template<typename _CharT, typename _OutIter>
    _OutIter
    money_put<_CharT, _OutIter>::
    do_put(iter_type __s, bool __intl, ios_base& __io, char_type __fill,
    long double __units) const
    {
      const locale __loc = __io.getloc();
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);

      double __dunits = static_cast<double>(__units);


      int __cs_size = 64;
      char* __cs = static_cast<char*>(__builtin_alloca(__cs_size));


      int __len = std::__convert_from_v(__cs, __cs_size, "%.0f", __dunits,
     _S_get_c_locale(), 0);

      if (__len >= __cs_size)
 {
   __cs_size = __len + 1;
   __cs = static_cast<char*>(__builtin_alloca(__cs_size));
   __len = std::__convert_from_v(__cs, __cs_size, "%.*f", __dunits,
     _S_get_c_locale(), 0);
 }
# 1746 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.tcc" 3
      _CharT* __ws = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
          * __cs_size));
      __ctype.widen(__cs, __cs + __len, __ws);
      const string_type __digits(__ws, __len);
      return __intl ? _M_insert<true>(__s, __io, __fill, __digits)
             : _M_insert<false>(__s, __io, __fill, __digits);
    }

  template<typename _CharT, typename _OutIter>
    _OutIter
    money_put<_CharT, _OutIter>::
    do_put(iter_type __s, bool __intl, ios_base& __io, char_type __fill,
    const string_type& __digits) const
    { return __intl ? _M_insert<true>(__s, __io, __fill, __digits)
             : _M_insert<false>(__s, __io, __fill, __digits); }





  template<typename _CharT, typename _InIter>
    time_base::dateorder
    time_get<_CharT, _InIter>::do_date_order() const
    { return time_base::no_order; }



  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    _M_extract_via_format(iter_type __beg, iter_type __end, ios_base& __io,
     ios_base::iostate& __err, tm* __tm,
     const _CharT* __format) const
    {
      const locale& __loc = __io._M_getloc();
      const __timepunct<_CharT>& __tp = use_facet<__timepunct<_CharT> >(__loc);
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);
      const size_t __len = char_traits<_CharT>::length(__format);

      for (size_t __i = 0; __beg != __end && __i < __len && !__err; ++__i)
 {
   if (__ctype.narrow(__format[__i], 0) == '%')
     {

       char __c = __ctype.narrow(__format[++__i], 0);
       int __mem = 0;
       if (__c == 'E' || __c == 'O')
  __c = __ctype.narrow(__format[++__i], 0);
       switch (__c)
  {
    const char* __cs;
    _CharT __wcs[10];
  case 'a':

    const char_type* __days1[7];
    __tp._M_days_abbreviated(__days1);
    __beg = _M_extract_name(__beg, __end, __tm->tm_wday, __days1,
       7, __io, __err);
    break;
  case 'A':

    const char_type* __days2[7];
    __tp._M_days(__days2);
    __beg = _M_extract_name(__beg, __end, __tm->tm_wday, __days2,
       7, __io, __err);
    break;
  case 'h':
  case 'b':

    const char_type* __months1[12];
    __tp._M_months_abbreviated(__months1);
    __beg = _M_extract_name(__beg, __end, __tm->tm_mon,
       __months1, 12, __io, __err);
    break;
  case 'B':

    const char_type* __months2[12];
    __tp._M_months(__months2);
    __beg = _M_extract_name(__beg, __end, __tm->tm_mon,
       __months2, 12, __io, __err);
    break;
  case 'c':

    const char_type* __dt[2];
    __tp._M_date_time_formats(__dt);
    __beg = _M_extract_via_format(__beg, __end, __io, __err,
      __tm, __dt[0]);
    break;
  case 'd':

    __beg = _M_extract_num(__beg, __end, __tm->tm_mday, 1, 31, 2,
      __io, __err);
    break;
  case 'e':


    if (__ctype.is(ctype_base::space, *__beg))
      __beg = _M_extract_num(++__beg, __end, __tm->tm_mday, 1, 9,
        1, __io, __err);
    else
      __beg = _M_extract_num(__beg, __end, __tm->tm_mday, 10, 31,
        2, __io, __err);
    break;
  case 'D':

    __cs = "%m/%d/%y";
    __ctype.widen(__cs, __cs + 9, __wcs);
    __beg = _M_extract_via_format(__beg, __end, __io, __err,
      __tm, __wcs);
    break;
  case 'H':

    __beg = _M_extract_num(__beg, __end, __tm->tm_hour, 0, 23, 2,
      __io, __err);
    break;
  case 'I':

    __beg = _M_extract_num(__beg, __end, __tm->tm_hour, 1, 12, 2,
      __io, __err);
    break;
  case 'm':

    __beg = _M_extract_num(__beg, __end, __mem, 1, 12, 2,
      __io, __err);
    if (!__err)
      __tm->tm_mon = __mem - 1;
    break;
  case 'M':

    __beg = _M_extract_num(__beg, __end, __tm->tm_min, 0, 59, 2,
      __io, __err);
    break;
  case 'n':
    if (__ctype.narrow(*__beg, 0) == '\n')
      ++__beg;
    else
      __err |= ios_base::failbit;
    break;
  case 'R':

    __cs = "%H:%M";
    __ctype.widen(__cs, __cs + 6, __wcs);
    __beg = _M_extract_via_format(__beg, __end, __io, __err,
      __tm, __wcs);
    break;
  case 'S':

    __beg = _M_extract_num(__beg, __end, __tm->tm_sec, 0, 59, 2,
      __io, __err);
    break;
  case 't':
    if (__ctype.narrow(*__beg, 0) == '\t')
      ++__beg;
    else
      __err |= ios_base::failbit;
    break;
  case 'T':

    __cs = "%H:%M:%S";
    __ctype.widen(__cs, __cs + 9, __wcs);
    __beg = _M_extract_via_format(__beg, __end, __io, __err,
      __tm, __wcs);
    break;
  case 'x':

    const char_type* __dates[2];
    __tp._M_date_formats(__dates);
    __beg = _M_extract_via_format(__beg, __end, __io, __err,
      __tm, __dates[0]);
    break;
  case 'X':

    const char_type* __times[2];
    __tp._M_time_formats(__times);
    __beg = _M_extract_via_format(__beg, __end, __io, __err,
      __tm, __times[0]);
    break;
  case 'y':
  case 'C':

    __beg = _M_extract_num(__beg, __end, __tm->tm_year, 0, 99, 2,
      __io, __err);
    break;
  case 'Y':

    __beg = _M_extract_num(__beg, __end, __mem, 0, 9999, 4,
      __io, __err);
    if (!__err)
      __tm->tm_year = __mem - 1900;
    break;
  case 'Z':

    if (__ctype.is(ctype_base::upper, *__beg))
      {
        int __tmp;
        __beg = _M_extract_name(__beg, __end, __tmp,
           __timepunct_cache<_CharT>::_S_timezones,
           14, __io, __err);


        if (__beg != __end && !__err && __tmp == 0
     && (*__beg == __ctype.widen('-')
         || *__beg == __ctype.widen('+')))
   {
     __beg = _M_extract_num(__beg, __end, __tmp, 0, 23, 2,
       __io, __err);
     __beg = _M_extract_num(__beg, __end, __tmp, 0, 59, 2,
       __io, __err);
   }
      }
    else
      __err |= ios_base::failbit;
    break;
  default:

    __err |= ios_base::failbit;
  }
     }
   else
     {

       if (__format[__i] == *__beg)
  ++__beg;
       else
  __err |= ios_base::failbit;
     }
 }
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    _M_extract_num(iter_type __beg, iter_type __end, int& __member,
     int __min, int __max, size_t __len,
     ios_base& __io, ios_base::iostate& __err) const
    {
      const locale& __loc = __io._M_getloc();
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);


      int __mult = __len == 2 ? 10 : (__len == 4 ? 1000 : 1);

      ++__min;
      size_t __i = 0;
      int __value = 0;
      for (; __beg != __end && __i < __len; ++__beg, ++__i)
 {
   const char __c = __ctype.narrow(*__beg, '*');
   if (__c >= '0' && __c <= '9')
     {
       __value = __value * 10 + (__c - '0');
       const int __valuec = __value * __mult;
       if (__valuec > __max || __valuec + __mult < __min)
  break;
       __mult /= 10;
     }
   else
     break;
 }
      if (__i == __len)
 __member = __value;
      else
 __err |= ios_base::failbit;
      return __beg;
    }



  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    _M_extract_name(iter_type __beg, iter_type __end, int& __member,
      const _CharT** __names, size_t __indexlen,
      ios_base& __io, ios_base::iostate& __err) const
    {
      typedef char_traits<_CharT> __traits_type;
      const locale& __loc = __io._M_getloc();
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);

      int* __matches = static_cast<int*>(__builtin_alloca(sizeof(int)
         * __indexlen));
      size_t __nmatches = 0;
      size_t __pos = 0;
      bool __testvalid = true;
      const char_type* __name;





      if (__beg != __end)
 {
   const char_type __c = *__beg;
   for (size_t __i1 = 0; __i1 < __indexlen; ++__i1)
     if (__c == __names[__i1][0]
  || __c == __ctype.toupper(__names[__i1][0]))
       __matches[__nmatches++] = __i1;
 }

      while (__nmatches > 1)
 {

   size_t __minlen = __traits_type::length(__names[__matches[0]]);
   for (size_t __i2 = 1; __i2 < __nmatches; ++__i2)
     __minlen = std::min(__minlen,
         __traits_type::length(__names[__matches[__i2]]));
   ++__pos;
   ++__beg;
   if (__pos < __minlen && __beg != __end)
     for (size_t __i3 = 0; __i3 < __nmatches;)
       {
  __name = __names[__matches[__i3]];
  if (__name[__pos] != *__beg)
    __matches[__i3] = __matches[--__nmatches];
  else
    ++__i3;
       }
   else
     break;
 }

      if (__nmatches == 1)
 {

   ++__pos;
   ++__beg;
   __name = __names[__matches[0]];
   const size_t __len = __traits_type::length(__name);
   while (__pos < __len && __beg != __end && __name[__pos] == *__beg)
     ++__beg, ++__pos;

   if (__len == __pos)
     __member = __matches[0];
   else
     __testvalid = false;
 }
      else
 __testvalid = false;
      if (!__testvalid)
 __err |= ios_base::failbit;
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    do_get_time(iter_type __beg, iter_type __end, ios_base& __io,
  ios_base::iostate& __err, tm* __tm) const
    {
      const locale& __loc = __io._M_getloc();
      const __timepunct<_CharT>& __tp = use_facet<__timepunct<_CharT> >(__loc);
      const char_type* __times[2];
      __tp._M_time_formats(__times);
      __beg = _M_extract_via_format(__beg, __end, __io, __err,
        __tm, __times[0]);
      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    do_get_date(iter_type __beg, iter_type __end, ios_base& __io,
  ios_base::iostate& __err, tm* __tm) const
    {
      const locale& __loc = __io._M_getloc();
      const __timepunct<_CharT>& __tp = use_facet<__timepunct<_CharT> >(__loc);
      const char_type* __dates[2];
      __tp._M_date_formats(__dates);
      __beg = _M_extract_via_format(__beg, __end, __io, __err,
        __tm, __dates[0]);
      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    do_get_weekday(iter_type __beg, iter_type __end, ios_base& __io,
     ios_base::iostate& __err, tm* __tm) const
    {
      typedef char_traits<_CharT> __traits_type;
      const locale& __loc = __io._M_getloc();
      const __timepunct<_CharT>& __tp = use_facet<__timepunct<_CharT> >(__loc);
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);
      const char_type* __days[7];
      __tp._M_days_abbreviated(__days);
      int __tmpwday;
      __beg = _M_extract_name(__beg, __end, __tmpwday, __days, 7, __io, __err);







      if (!__err)
 {
   size_t __pos = __traits_type::length(__days[__tmpwday]);
   __tp._M_days(__days);
   const char_type* __name = __days[__tmpwday];
   if (__name[__pos] == *__beg)
     {

       const size_t __len = __traits_type::length(__name);
       while (__pos < __len && __beg != __end
       && __name[__pos] == *__beg)
  ++__beg, ++__pos;
       if (__len != __pos)
  __err |= ios_base::failbit;
     }
   if (!__err)
     __tm->tm_wday = __tmpwday;
 }
      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
     }

  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    do_get_monthname(iter_type __beg, iter_type __end,
                     ios_base& __io, ios_base::iostate& __err, tm* __tm) const
    {
      typedef char_traits<_CharT> __traits_type;
      const locale& __loc = __io._M_getloc();
      const __timepunct<_CharT>& __tp = use_facet<__timepunct<_CharT> >(__loc);
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);
      const char_type* __months[12];
      __tp._M_months_abbreviated(__months);
      int __tmpmon;
      __beg = _M_extract_name(__beg, __end, __tmpmon, __months, 12,
         __io, __err);







      if (!__err)
 {
   size_t __pos = __traits_type::length(__months[__tmpmon]);
   __tp._M_months(__months);
   const char_type* __name = __months[__tmpmon];
   if (__name[__pos] == *__beg)
     {

       const size_t __len = __traits_type::length(__name);
       while (__pos < __len && __beg != __end
       && __name[__pos] == *__beg)
  ++__beg, ++__pos;
       if (__len != __pos)
  __err |= ios_base::failbit;
     }
   if (!__err)
     __tm->tm_mon = __tmpmon;
 }

      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    do_get_year(iter_type __beg, iter_type __end, ios_base& __io,
  ios_base::iostate& __err, tm* __tm) const
    {
      const locale& __loc = __io._M_getloc();
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);

      size_t __i = 0;
      int __value = 0;
      for (; __beg != __end && __i < 4; ++__beg, ++__i)
 {
   const char __c = __ctype.narrow(*__beg, '*');
   if (__c >= '0' && __c <= '9')
     __value = __value * 10 + (__c - '0');
   else
     break;
 }
      if (__i == 2 || __i == 4)
 __tm->tm_year = __i == 2 ? __value : __value - 1900;
      else
 __err |= ios_base::failbit;
      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }

  template<typename _CharT, typename _OutIter>
    _OutIter
    time_put<_CharT, _OutIter>::
    put(iter_type __s, ios_base& __io, char_type __fill, const tm* __tm,
 const _CharT* __beg, const _CharT* __end) const
    {
      const locale& __loc = __io._M_getloc();
      ctype<_CharT> const& __ctype = use_facet<ctype<_CharT> >(__loc);
      for (; __beg != __end; ++__beg)
 if (__ctype.narrow(*__beg, 0) != '%')
   {
     *__s = *__beg;
     ++__s;
   }
 else if (++__beg != __end)
   {
     char __format;
     char __mod = 0;
     const char __c = __ctype.narrow(*__beg, 0);
     if (__c != 'E' && __c != 'O')
       __format = __c;
     else if (++__beg != __end)
       {
  __mod = __c;
  __format = __ctype.narrow(*__beg, 0);
       }
     else
       break;
     __s = this->do_put(__s, __io, __fill, __tm, __format, __mod);
   }
 else
   break;
      return __s;
    }

  template<typename _CharT, typename _OutIter>
    _OutIter
    time_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type, const tm* __tm,
    char __format, char __mod) const
    {
      const locale& __loc = __io._M_getloc();
      ctype<_CharT> const& __ctype = use_facet<ctype<_CharT> >(__loc);
      __timepunct<_CharT> const& __tp = use_facet<__timepunct<_CharT> >(__loc);



      const size_t __maxlen = 128;
      char_type* __res =
       static_cast<char_type*>(__builtin_alloca(sizeof(char_type) * __maxlen));






      char_type __fmt[4];
      __fmt[0] = __ctype.widen('%');
      if (!__mod)
 {
   __fmt[1] = __format;
   __fmt[2] = char_type();
 }
      else
 {
   __fmt[1] = __mod;
   __fmt[2] = __format;
   __fmt[3] = char_type();
 }

      __tp._M_put(__res, __maxlen, __fmt, __tm);


      return std::__write(__s, __res, char_traits<char_type>::length(__res));
    }



  template<typename _CharT>
    int
    collate<_CharT>::_M_compare(const _CharT*, const _CharT*) const
    { return 0; }


  template<typename _CharT>
    size_t
    collate<_CharT>::_M_transform(_CharT*, const _CharT*, size_t) const
    { return 0; }

  template<typename _CharT>
    int
    collate<_CharT>::
    do_compare(const _CharT* __lo1, const _CharT* __hi1,
        const _CharT* __lo2, const _CharT* __hi2) const
    {


      const string_type __one(__lo1, __hi1);
      const string_type __two(__lo2, __hi2);

      const _CharT* __p = __one.c_str();
      const _CharT* __pend = __one.data() + __one.length();
      const _CharT* __q = __two.c_str();
      const _CharT* __qend = __two.data() + __two.length();




      for (;;)
 {
   const int __res = _M_compare(__p, __q);
   if (__res)
     return __res;

   __p += char_traits<_CharT>::length(__p);
   __q += char_traits<_CharT>::length(__q);
   if (__p == __pend && __q == __qend)
     return 0;
   else if (__p == __pend)
     return -1;
   else if (__q == __qend)
     return 1;

   __p++;
   __q++;
 }
    }

  template<typename _CharT>
    typename collate<_CharT>::string_type
    collate<_CharT>::
    do_transform(const _CharT* __lo, const _CharT* __hi) const
    {

      string_type __str(__lo, __hi);

      const _CharT* __p = __str.c_str();
      const _CharT* __pend = __str.data() + __str.length();

      size_t __len = (__hi - __lo) * 2;

      string_type __ret;




      for (;;)
 {

   _CharT* __c =
     static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT) * __len));
   size_t __res = _M_transform(__c, __p, __len);


   if (__res >= __len)
     {
       __len = __res + 1;
       __c = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
         * __len));
       __res = _M_transform(__c, __p, __res + 1);
     }

   __ret.append(__c, __res);
   __p += char_traits<_CharT>::length(__p);
   if (__p == __pend)
     return __ret;

   __p++;
   __ret.push_back(_CharT());
 }
    }

  template<typename _CharT>
    long
    collate<_CharT>::
    do_hash(const _CharT* __lo, const _CharT* __hi) const
    {
      unsigned long __val = 0;
      for (; __lo < __hi; ++__lo)
 __val = *__lo + ((__val << 7) |
         (__val >> (numeric_limits<unsigned long>::digits - 7)));
      return static_cast<long>(__val);
    }
# 2437 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.tcc" 3
  template<typename _CharT, typename _Traits>
    void
    __pad<_CharT, _Traits>::_S_pad(ios_base& __io, _CharT __fill,
       _CharT* __news, const _CharT* __olds,
       const streamsize __newlen,
       const streamsize __oldlen, const bool __num)
    {
      const size_t __plen = static_cast<size_t>(__newlen - __oldlen);
      const ios_base::fmtflags __adjust = __io.flags() & ios_base::adjustfield;


      if (__adjust == ios_base::left)
 {
   _Traits::copy(__news, const_cast<_CharT*>(__olds), __oldlen);
   _Traits::assign(__news + __oldlen, __plen, __fill);
   return;
 }

      size_t __mod = 0;
      if (__adjust == ios_base::internal && __num)
 {



          const locale& __loc = __io._M_getloc();
   const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);

   const bool __testsign = (__ctype.widen('-') == __olds[0]
       || __ctype.widen('+') == __olds[0]);
   const bool __testhex = (__ctype.widen('0') == __olds[0]
      && __oldlen > 1
      && (__ctype.widen('x') == __olds[1]
          || __ctype.widen('X') == __olds[1]));
   if (__testhex)
     {
       __news[0] = __olds[0];
       __news[1] = __olds[1];
       __mod = 2;
       __news += 2;
     }
   else if (__testsign)
     {
       __news[0] = __olds[0];
       __mod = 1;
       ++__news;
     }

 }
      _Traits::assign(__news, __plen, __fill);
      _Traits::copy(__news + __plen, const_cast<_CharT*>(__olds + __mod),
      __oldlen - __mod);
    }

  bool
  __verify_grouping(const char* __grouping, size_t __grouping_size,
      const string& __grouping_tmp)
  {
    const size_t __n = __grouping_tmp.size() - 1;
    const size_t __min = std::min(__n, __grouping_size - 1);
    size_t __i = __n;
    bool __test = true;




    for (size_t __j = 0; __j < __min && __test; --__i, ++__j)
      __test = __grouping_tmp[__i] == __grouping[__j];
    for (; __i && __test; --__i)
      __test = __grouping_tmp[__i] == __grouping[__min];


    __test &= __grouping_tmp[0] <= __grouping[__min];
    return __test;
  }

  template<typename _CharT>
    _CharT*
    __add_grouping(_CharT* __s, _CharT __sep,
     const char* __gbeg, size_t __gsize,
     const _CharT* __first, const _CharT* __last)
    {
      if (__last - __first > *__gbeg)
 {
   const bool __bump = __gsize != 1;
   __s = std::__add_grouping(__s, __sep, __gbeg + __bump,
        __gsize - __bump, __first,
        __last - *__gbeg);
   __first = __last - *__gbeg;
   *__s++ = __sep;
 }
      do
 *__s++ = *__first++;
      while (__first != __last);
      return __s;
    }





  extern template class moneypunct<char, false>;
  extern template class moneypunct<char, true>;
  extern template class moneypunct_byname<char, false>;
  extern template class moneypunct_byname<char, true>;
  extern template class money_get<char>;
  extern template class money_put<char>;
  extern template class numpunct<char>;
  extern template class numpunct_byname<char>;
  extern template class num_get<char>;
  extern template class num_put<char>;
  extern template class __timepunct<char>;
  extern template class time_put<char>;
  extern template class time_put_byname<char>;
  extern template class time_get<char>;
  extern template class time_get_byname<char>;
  extern template class messages<char>;
  extern template class messages_byname<char>;
  extern template class ctype_byname<char>;
  extern template class codecvt_byname<char, char, mbstate_t>;
  extern template class collate<char>;
  extern template class collate_byname<char>;

  extern template
    const codecvt<char, char, mbstate_t>&
    use_facet<codecvt<char, char, mbstate_t> >(const locale&);

  extern template
    const collate<char>&
    use_facet<collate<char> >(const locale&);

  extern template
    const numpunct<char>&
    use_facet<numpunct<char> >(const locale&);

  extern template
    const num_put<char>&
    use_facet<num_put<char> >(const locale&);

  extern template
    const num_get<char>&
    use_facet<num_get<char> >(const locale&);

  extern template
    const moneypunct<char, true>&
    use_facet<moneypunct<char, true> >(const locale&);

  extern template
    const moneypunct<char, false>&
    use_facet<moneypunct<char, false> >(const locale&);

  extern template
    const money_put<char>&
    use_facet<money_put<char> >(const locale&);

  extern template
    const money_get<char>&
    use_facet<money_get<char> >(const locale&);

  extern template
    const __timepunct<char>&
    use_facet<__timepunct<char> >(const locale&);

  extern template
    const time_put<char>&
    use_facet<time_put<char> >(const locale&);

  extern template
    const time_get<char>&
    use_facet<time_get<char> >(const locale&);

  extern template
    const messages<char>&
    use_facet<messages<char> >(const locale&);

  extern template
    bool
    has_facet<ctype<char> >(const locale&);

  extern template
    bool
    has_facet<codecvt<char, char, mbstate_t> >(const locale&);

  extern template
    bool
    has_facet<collate<char> >(const locale&);

  extern template
    bool
    has_facet<numpunct<char> >(const locale&);

  extern template
    bool
    has_facet<num_put<char> >(const locale&);

  extern template
    bool
    has_facet<num_get<char> >(const locale&);

  extern template
    bool
    has_facet<moneypunct<char> >(const locale&);

  extern template
    bool
    has_facet<money_put<char> >(const locale&);

  extern template
    bool
    has_facet<money_get<char> >(const locale&);

  extern template
    bool
    has_facet<__timepunct<char> >(const locale&);

  extern template
    bool
    has_facet<time_put<char> >(const locale&);

  extern template
    bool
    has_facet<time_get<char> >(const locale&);

  extern template
    bool
    has_facet<messages<char> >(const locale&);
# 2791 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/locale_facets.tcc" 3
}
# 48 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/locale" 2 3
# 41 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/ostream.tcc" 2 3

namespace std
{
  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>::sentry::
    sentry(basic_ostream<_CharT, _Traits>& __os)
    : _M_ok(false), _M_os(__os)
    {

      if (__os.tie() && __os.good())
 __os.tie()->flush();

      if (__os.good())
 _M_ok = true;
      else
 __os.setstate(ios_base::failbit);
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(__ostream_type& (*__pf)(__ostream_type&))
    {



      return __pf(*this);
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(__ios_type& (*__pf)(__ios_type&))
    {



      __pf(*this);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(ios_base& (*__pf)(ios_base&))
    {



      __pf(*this);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(bool __n)
    {
      sentry __cerb(*this);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {
       const __num_put_type& __np = __check_facet(this->_M_num_put);
       if (__np.put(*this, *this, this->fill(), __n).failed())
  __err |= ios_base::badbit;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(long __n)
    {
      sentry __cerb(*this);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {
       bool __b = false;
       const char_type __c = this->fill();
       const ios_base::fmtflags __fmt = (this->flags()
      & ios_base::basefield);
       const __num_put_type& __np = __check_facet(this->_M_num_put);
       if ((__fmt & ios_base::oct) || (__fmt & ios_base::hex))
  {
    const unsigned long __l = static_cast<unsigned long>(__n);
    __b = __np.put(*this, *this, __c, __l).failed();
  }
       else
  __b = __np.put(*this, *this, __c, __n).failed();
       if (__b)
  __err |= ios_base::badbit;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(unsigned long __n)
    {
      sentry __cerb(*this);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {
       const __num_put_type& __np = __check_facet(this->_M_num_put);
       if (__np.put(*this, *this, this->fill(), __n).failed())
  __err |= ios_base::badbit;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }


  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(long long __n)
    {
      sentry __cerb(*this);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {
       bool __b = false;
       const char_type __c = this->fill();
       const ios_base::fmtflags __fmt = (this->flags()
      & ios_base::basefield);
       const __num_put_type& __np = __check_facet(this->_M_num_put);
       if ((__fmt & ios_base::oct) || (__fmt & ios_base::hex))
  {
    const unsigned long long __l = (static_cast<
        unsigned long long>(__n));
    __b = __np.put(*this, *this, __c, __l).failed();
  }
       else
  __b = __np.put(*this, *this, __c, __n).failed();
       if (__b)
  __err |= ios_base::badbit;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(unsigned long long __n)
    {
      sentry __cerb(*this);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {
       const __num_put_type& __np = __check_facet(this->_M_num_put);
       if (__np.put(*this, *this, this->fill(), __n).failed())
  __err |= ios_base::badbit;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }


  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(double __n)
    {
      sentry __cerb(*this);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {
       const __num_put_type& __np = __check_facet(this->_M_num_put);
       if (__np.put(*this, *this, this->fill(), __n).failed())
  __err |= ios_base::badbit;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(long double __n)
    {
      sentry __cerb(*this);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {
       const __num_put_type& __np = __check_facet(this->_M_num_put);
       if (__np.put(*this, *this, this->fill(), __n).failed())
  __err |= ios_base::badbit;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(const void* __n)
    {
      sentry __cerb(*this);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {
       const __num_put_type& __np = __check_facet(this->_M_num_put);
       if (__np.put(*this, *this, this->fill(), __n).failed())
  __err |= ios_base::badbit;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(__streambuf_type* __sbin)
    {
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      sentry __cerb(*this);
      if (__cerb && __sbin)
 {
   try
     {
       if (!__copy_streambufs(__sbin, this->rdbuf()))
  __err |= ios_base::failbit;
     }
   catch(...)
     { this->_M_setstate(ios_base::failbit); }
 }
      else if (!__sbin)
 __err |= ios_base::badbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    put(char_type __c)
    {






      sentry __cerb(*this);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {
       const int_type __put = this->rdbuf()->sputc(__c);
       if (traits_type::eq_int_type(__put, traits_type::eof()))
  __err |= ios_base::badbit;
     }
   catch (...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    write(const _CharT* __s, streamsize __n)
    {







      sentry __cerb(*this);
      if (__cerb)
 {
   try
     { _M_write(__s, __n); }
   catch (...)
     { this->_M_setstate(ios_base::badbit); }
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    flush()
    {



      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      try
 {
   if (this->rdbuf() && this->rdbuf()->pubsync() == -1)
     __err |= ios_base::badbit;
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    typename basic_ostream<_CharT, _Traits>::pos_type
    basic_ostream<_CharT, _Traits>::
    tellp()
    {
      pos_type __ret = pos_type(-1);
      try
 {
   if (!this->fail())
     __ret = this->rdbuf()->pubseekoff(0, ios_base::cur, ios_base::out);
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    seekp(pos_type __pos)
    {
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      try
 {
   if (!this->fail())
     {


       const pos_type __p = this->rdbuf()->pubseekpos(__pos,
            ios_base::out);


       if (__p == pos_type(off_type(-1)))
  __err |= ios_base::failbit;
     }
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    seekp(off_type __off, ios_base::seekdir __dir)
    {
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      try
 {
   if (!this->fail())
     {


       const pos_type __p = this->rdbuf()->pubseekoff(__off, __dir,
            ios_base::out);


       if (__p == pos_type(off_type(-1)))
  __err |= ios_base::failbit;
     }
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      if (__err)
 this->setstate(__err);
      return *this;
    }


  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, _CharT __c)
    {
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typename __ostream_type::sentry __cerb(__out);
      if (__cerb)
 {
   try
     {
       const streamsize __w = __out.width();
       streamsize __len = 1;
       _CharT* __cs = &__c;
       if (__w > __len)
  {
    __cs = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
              * __w));
    __pad<_CharT, _Traits>::_S_pad(__out, __out.fill(), __cs,
       &__c, __w, __len, false);
    __len = __w;
  }
       __out._M_write(__cs, __len);
       __out.width(0);
     }
   catch(...)
     { __out._M_setstate(ios_base::badbit); }
 }
      return __out;
    }


  template <class _Traits>
    basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, char __c)
    {
      typedef basic_ostream<char, _Traits> __ostream_type;
      typename __ostream_type::sentry __cerb(__out);
      if (__cerb)
 {
   try
     {
       const streamsize __w = __out.width();
       streamsize __len = 1;
       char* __cs = &__c;
       if (__w > __len)
  {
    __cs = static_cast<char*>(__builtin_alloca(__w));
    __pad<char, _Traits>::_S_pad(__out, __out.fill(), __cs,
            &__c, __w, __len, false);
    __len = __w;
  }
       __out._M_write(__cs, __len);
       __out.width(0);
     }
   catch(...)
     { __out._M_setstate(ios_base::badbit); }
 }
      return __out;
     }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, const _CharT* __s)
    {
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typename __ostream_type::sentry __cerb(__out);
      if (__cerb && __s)
 {
   try
     {
       const streamsize __w = __out.width();
       streamsize __len = static_cast<streamsize>(_Traits::length(__s));
       if (__w > __len)
  {
    _CharT* __cs = (static_cast<
      _CharT*>(__builtin_alloca(sizeof(_CharT)
           * __w)));
    __pad<_CharT, _Traits>::_S_pad(__out, __out.fill(), __cs,
       __s, __w, __len, false);
    __s = __cs;
    __len = __w;
  }
       __out._M_write(__s, __len);
       __out.width(0);
     }
   catch(...)
     { __out._M_setstate(ios_base::badbit); }
 }
      else if (!__s)
 __out.setstate(ios_base::badbit);
      return __out;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, const char* __s)
    {
      typedef basic_ostream<_CharT, _Traits> __ostream_type;



      typedef char_traits<char> __traits_type;
      typename __ostream_type::sentry __cerb(__out);
      if (__cerb && __s)
 {
   size_t __clen = __traits_type::length(__s);
   _CharT* __ws = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
              * __clen));
   for (size_t __i = 0; __i < __clen; ++__i)
     __ws[__i] = __out.widen(__s[__i]);
   _CharT* __str = __ws;

   try
     {
       const streamsize __w = __out.width();
       streamsize __len = static_cast<streamsize>(__clen);
       if (__w > __len)
  {
    _CharT* __cs = (static_cast<
      _CharT*>(__builtin_alloca(sizeof(_CharT)
           * __w)));
    __pad<_CharT, _Traits>::_S_pad(__out, __out.fill(), __cs,
       __ws, __w, __len, false);
    __str = __cs;
    __len = __w;
  }
       __out._M_write(__str, __len);
       __out.width(0);
     }
   catch(...)
     { __out._M_setstate(ios_base::badbit); }
 }
      else if (!__s)
 __out.setstate(ios_base::badbit);
      return __out;
    }


  template<class _Traits>
    basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, const char* __s)
    {
      typedef basic_ostream<char, _Traits> __ostream_type;
      typename __ostream_type::sentry __cerb(__out);
      if (__cerb && __s)
 {
   try
     {
       const streamsize __w = __out.width();
       streamsize __len = static_cast<streamsize>(_Traits::length(__s));
       if (__w > __len)
  {
    char* __cs = static_cast<char*>(__builtin_alloca(__w));
    __pad<char, _Traits>::_S_pad(__out, __out.fill(), __cs,
       __s, __w, __len, false);
    __s = __cs;
    __len = __w;
  }
       __out._M_write(__s, __len);
       __out.width(0);
     }
   catch(...)
     { __out._M_setstate(ios_base::badbit); }
 }
      else if (!__s)
 __out.setstate(ios_base::badbit);
      return __out;
    }


  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out,
        const basic_string<_CharT, _Traits, _Alloc>& __str)
    {
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typename __ostream_type::sentry __cerb(__out);
      if (__cerb)
 {
   const streamsize __w = __out.width();
   streamsize __len = static_cast<streamsize>(__str.size());
   const _CharT* __s = __str.data();



   if (__w > __len)
     {
       _CharT* __cs = (static_cast<
         _CharT*>(__builtin_alloca(sizeof(_CharT) * __w)));
       __pad<_CharT, _Traits>::_S_pad(__out, __out.fill(), __cs, __s,
          __w, __len, false);
       __s = __cs;
       __len = __w;
     }
   __out._M_write(__s, __len);
   __out.width(0);
 }
      return __out;
    }





  extern template class basic_ostream<char>;
  extern template ostream& endl(ostream&);
  extern template ostream& ends(ostream&);
  extern template ostream& flush(ostream&);
  extern template ostream& operator<<(ostream&, char);
  extern template ostream& operator<<(ostream&, unsigned char);
  extern template ostream& operator<<(ostream&, signed char);
  extern template ostream& operator<<(ostream&, const char*);
  extern template ostream& operator<<(ostream&, const unsigned char*);
  extern template ostream& operator<<(ostream&, const signed char*);
# 697 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/ostream.tcc" 3
}
# 546 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/ostream" 2 3
# 46 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/iostream" 2 3
# 1 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/istream" 1 3
# 43 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/istream" 3
       
# 44 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/istream" 3




namespace std
{
# 58 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/istream" 3
  template<typename _CharT, typename _Traits>
    class basic_istream : virtual public basic_ios<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;


      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef basic_ios<_CharT, _Traits> __ios_type;
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef num_get<_CharT, istreambuf_iterator<_CharT, _Traits> >
        __num_get_type;
      typedef ctype<_CharT> __ctype_type;

      template<typename _CharT2, typename _Traits2>
        friend basic_istream<_CharT2, _Traits2>&
        operator>>(basic_istream<_CharT2, _Traits2>&, _CharT2&);

      template<typename _CharT2, typename _Traits2>
        friend basic_istream<_CharT2, _Traits2>&
        operator>>(basic_istream<_CharT2, _Traits2>&, _CharT2*);

    protected:







      streamsize _M_gcount;

    public:
# 104 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/istream" 3
      explicit
      basic_istream(__streambuf_type* __sb): _M_gcount(streamsize(0))
      { this->init(__sb); }






      virtual
      ~basic_istream()
      { _M_gcount = streamsize(0); }


      class sentry;
      friend class sentry;
# 131 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/istream" 3
      inline __istream_type&
      operator>>(__istream_type& (*__pf)(__istream_type&));

      inline __istream_type&
      operator>>(__ios_type& (*__pf)(__ios_type&));

      inline __istream_type&
      operator>>(ios_base& (*__pf)(ios_base&));
# 169 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/istream" 3
      __istream_type&
      operator>>(bool& __n);

      __istream_type&
      operator>>(short& __n);

      __istream_type&
      operator>>(unsigned short& __n);

      __istream_type&
      operator>>(int& __n);

      __istream_type&
      operator>>(unsigned int& __n);

      __istream_type&
      operator>>(long& __n);

      __istream_type&
      operator>>(unsigned long& __n);


      __istream_type&
      operator>>(long long& __n);

      __istream_type&
      operator>>(unsigned long long& __n);


      __istream_type&
      operator>>(float& __f);

      __istream_type&
      operator>>(double& __f);

      __istream_type&
      operator>>(long double& __f);

      __istream_type&
      operator>>(void*& __p);
# 230 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/istream" 3
      __istream_type&
      operator>>(__streambuf_type* __sb);
# 240 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/istream" 3
      inline streamsize
      gcount() const
      { return _M_gcount; }
# 272 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/istream" 3
      int_type
      get();
# 286 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/istream" 3
      __istream_type&
      get(char_type& __c);
# 313 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/istream" 3
      __istream_type&
      get(char_type* __s, streamsize __n, char_type __delim);
# 324 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/istream" 3
      inline __istream_type&
      get(char_type* __s, streamsize __n)
      { return this->get(__s, __n, this->widen('\n')); }
# 347 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/istream" 3
      __istream_type&
      get(__streambuf_type& __sb, char_type __delim);
# 357 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/istream" 3
      inline __istream_type&
      get(__streambuf_type& __sb)
      { return this->get(__sb, this->widen('\n')); }
# 386 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/istream" 3
      __istream_type&
      getline(char_type* __s, streamsize __n, char_type __delim);
# 397 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/istream" 3
      inline __istream_type&
      getline(char_type* __s, streamsize __n)
      { return this->getline(__s, __n, this->widen('\n')); }
# 416 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/istream" 3
      __istream_type&
      ignore(streamsize __n = 1, int_type __delim = traits_type::eof());
# 427 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/istream" 3
      int_type
      peek();
# 445 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/istream" 3
      __istream_type&
      read(char_type* __s, streamsize __n);
# 464 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/istream" 3
      streamsize
      readsome(char_type* __s, streamsize __n);
# 480 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/istream" 3
      __istream_type&
      putback(char_type __c);
# 495 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/istream" 3
      __istream_type&
      unget();
# 513 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/istream" 3
      int
      sync();
# 527 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/istream" 3
      pos_type
      tellg();
# 542 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/istream" 3
      __istream_type&
      seekg(pos_type);
# 558 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/istream" 3
      __istream_type&
      seekg(off_type, ios_base::seekdir);


    protected:
      explicit
      basic_istream(): _M_gcount(streamsize(0)) { }
    };
# 578 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/istream" 3
  template<typename _CharT, typename _Traits>
    class basic_istream<_CharT, _Traits>::sentry
    {
    public:

      typedef _Traits traits_type;
      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::__ctype_type __ctype_type;
      typedef typename _Traits::int_type __int_type;
# 610 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/istream" 3
      explicit
      sentry(basic_istream<_CharT, _Traits>& __is, bool __noskipws = false);
# 620 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/istream" 3
      operator bool() const { return _M_ok; }

    private:
      bool _M_ok;
    };
# 639 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/istream" 3
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT& __c);

  template<class _Traits>
    basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, unsigned char& __c)
    { return (__in >> reinterpret_cast<char&>(__c)); }

  template<class _Traits>
    basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, signed char& __c)
    { return (__in >> reinterpret_cast<char&>(__c)); }
# 680 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/istream" 3
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT* __s);

  template<class _Traits>
    basic_istream<char,_Traits>&
    operator>>(basic_istream<char,_Traits>& __in, unsigned char* __s)
    { return (__in >> reinterpret_cast<char*>(__s)); }

  template<class _Traits>
    basic_istream<char,_Traits>&
    operator>>(basic_istream<char,_Traits>& __in, signed char* __s)
    { return (__in >> reinterpret_cast<char*>(__s)); }
# 702 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/istream" 3
  template<typename _CharT, typename _Traits>
    class basic_iostream
    : public basic_istream<_CharT, _Traits>,
      public basic_ostream<_CharT, _Traits>
    {
    public:



      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;


      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_ostream<_CharT, _Traits> __ostream_type;







      explicit
      basic_iostream(basic_streambuf<_CharT, _Traits>* __sb)
      : __istream_type(), __ostream_type()
      { this->init(__sb); }




      virtual
      ~basic_iostream() { }

    protected:
      explicit
      basic_iostream() : __istream_type(), __ostream_type()
      { }
    };
# 765 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/istream" 3
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    ws(basic_istream<_CharT, _Traits>& __is);
}


# 1 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/istream.tcc" 1 3
# 38 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/istream.tcc" 3
       
# 39 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/istream.tcc" 3




namespace std
{
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>::sentry::
    sentry(basic_istream<_CharT, _Traits>& __in, bool __noskip) : _M_ok(false)
    {
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      if (__in.good())
 {
   if (__in.tie())
     __in.tie()->flush();
   if (!__noskip && (__in.flags() & ios_base::skipws))
     {
       const __int_type __eof = traits_type::eof();
       __streambuf_type* __sb = __in.rdbuf();
       __int_type __c = __sb->sgetc();

       const __ctype_type& __ct = __check_facet(__in._M_ctype);
       while (!traits_type::eq_int_type(__c, __eof)
       && __ct.is(ctype_base::space,
    traits_type::to_char_type(__c)))
  __c = __sb->snextc();




       if (traits_type::eq_int_type(__c, __eof))
  __err |= ios_base::eofbit;
     }
 }

      if (__in.good() && __err == ios_base::goodbit)
 _M_ok = true;
      else
 {
   __err |= ios_base::failbit;
   __in.setstate(__err);
 }
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(__istream_type& (*__pf)(__istream_type&))
    { return __pf(*this); }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(__ios_type& (*__pf)(__ios_type&))
    {
      __pf(*this);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(ios_base& (*__pf)(ios_base&))
    {
      __pf(*this);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(bool& __n)
    {
      sentry __cerb(*this, false);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {
       const __num_get_type& __ng = __check_facet(this->_M_num_get);
       __ng.get(*this, 0, *this, __err, __n);
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(short& __n)
    {
      sentry __cerb(*this, false);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {
       long __l;
       const __num_get_type& __ng = __check_facet(this->_M_num_get);
       __ng.get(*this, 0, *this, __err, __l);


       if (!(__err & ios_base::failbit)
    && (numeric_limits<short>::min() <= __l
        && __l <= numeric_limits<short>::max()))
  __n = __l;
       else
                __err |= ios_base::failbit;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(unsigned short& __n)
    {
      sentry __cerb(*this, false);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {
       const __num_get_type& __ng = __check_facet(this->_M_num_get);
       __ng.get(*this, 0, *this, __err, __n);
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(int& __n)
    {
      sentry __cerb(*this, false);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {
       long __l;
       const __num_get_type& __ng = __check_facet(this->_M_num_get);
       __ng.get(*this, 0, *this, __err, __l);


       if (!(__err & ios_base::failbit)
    && (numeric_limits<int>::min() <= __l
        && __l <= numeric_limits<int>::max()))
  __n = __l;
       else
                __err |= ios_base::failbit;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(unsigned int& __n)
    {
      sentry __cerb(*this, false);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {
       const __num_get_type& __ng = __check_facet(this->_M_num_get);
       __ng.get(*this, 0, *this, __err, __n);
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(long& __n)
    {
      sentry __cerb(*this, false);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {
       const __num_get_type& __ng = __check_facet(this->_M_num_get);
       __ng.get(*this, 0, *this, __err, __n);
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(unsigned long& __n)
    {
      sentry __cerb(*this, false);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {
       const __num_get_type& __ng = __check_facet(this->_M_num_get);
       __ng.get(*this, 0, *this, __err, __n);
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }


  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(long long& __n)
    {
      sentry __cerb(*this, false);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {
       const __num_get_type& __ng = __check_facet(this->_M_num_get);
       __ng.get(*this, 0, *this, __err, __n);
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(unsigned long long& __n)
    {
      sentry __cerb(*this, false);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {
       const __num_get_type& __ng = __check_facet(this->_M_num_get);
       __ng.get(*this, 0, *this, __err, __n);
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }


  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(float& __n)
    {
      sentry __cerb(*this, false);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {
       const __num_get_type& __ng = __check_facet(this->_M_num_get);
       __ng.get(*this, 0, *this, __err, __n);
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(double& __n)
    {
      sentry __cerb(*this, false);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {
       const __num_get_type& __ng = __check_facet(this->_M_num_get);
       __ng.get(*this, 0, *this, __err, __n);
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(long double& __n)
    {
      sentry __cerb(*this, false);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {
       const __num_get_type& __ng = __check_facet(this->_M_num_get);
       __ng.get(*this, 0, *this, __err, __n);
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(void*& __n)
    {
      sentry __cerb(*this, false);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {
       const __num_get_type& __ng = __check_facet(this->_M_num_get);
       __ng.get(*this, 0, *this, __err, __n);
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(__streambuf_type* __sbout)
    {
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      sentry __cerb(*this, false);
      if (__cerb && __sbout)
 {
   try
     {
       if (!__copy_streambufs(this->rdbuf(), __sbout))
  __err |= ios_base::failbit;
     }
   catch(...)
     { this->_M_setstate(ios_base::failbit); }
 }
      else if (!__sbout)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    typename basic_istream<_CharT, _Traits>::int_type
    basic_istream<_CharT, _Traits>::
    get(void)
    {
      const int_type __eof = traits_type::eof();
      int_type __c = __eof;
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   try
     {
       __c = this->rdbuf()->sbumpc();

       if (!traits_type::eq_int_type(__c, __eof))
  _M_gcount = 1;
       else
  __err |= ios_base::eofbit;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }
      if (!_M_gcount)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return __c;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    get(char_type& __c)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   try
     {
       const int_type __cb = this->rdbuf()->sbumpc();

       if (!traits_type::eq_int_type(__cb, traits_type::eof()))
  {
    _M_gcount = 1;
    __c = traits_type::to_char_type(__cb);
  }
       else
  __err |= ios_base::eofbit;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }
      if (!_M_gcount)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    get(char_type* __s, streamsize __n, char_type __delim)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   try
     {
       const int_type __idelim = traits_type::to_int_type(__delim);
       const int_type __eof = traits_type::eof();
       __streambuf_type* __sb = this->rdbuf();
       int_type __c = __sb->sgetc();

       while (_M_gcount + 1 < __n
       && !traits_type::eq_int_type(__c, __eof)
       && !traits_type::eq_int_type(__c, __idelim))
  {
    *__s++ = traits_type::to_char_type(__c);
    ++_M_gcount;
    __c = __sb->snextc();
  }
       if (traits_type::eq_int_type(__c, __eof))
  __err |= ios_base::eofbit;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }
      *__s = char_type();
      if (!_M_gcount)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    get(__streambuf_type& __sb, char_type __delim)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   try
     {
       const int_type __idelim = traits_type::to_int_type(__delim);
       const int_type __eof = traits_type::eof();
       __streambuf_type* __this_sb = this->rdbuf();
       int_type __c = __this_sb->sgetc();
       char_type __c2 = traits_type::to_char_type(__c);

       while (!traits_type::eq_int_type(__c, __eof)
       && !traits_type::eq_int_type(__c, __idelim)
       && !traits_type::eq_int_type(__sb.sputc(__c2), __eof))
  {
    ++_M_gcount;
    __c = __this_sb->snextc();
    __c2 = traits_type::to_char_type(__c);
  }
       if (traits_type::eq_int_type(__c, __eof))
  __err |= ios_base::eofbit;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }
      if (!_M_gcount)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    getline(char_type* __s, streamsize __n, char_type __delim)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      sentry __cerb(*this, true);
      if (__cerb)
 {
          try
     {
       const int_type __idelim = traits_type::to_int_type(__delim);
       const int_type __eof = traits_type::eof();
       __streambuf_type* __sb = this->rdbuf();
       int_type __c = __sb->sgetc();

       while (_M_gcount + 1 < __n
       && !traits_type::eq_int_type(__c, __eof)
       && !traits_type::eq_int_type(__c, __idelim))
  {
    streamsize __size = std::min(streamsize(__sb->egptr()
         - __sb->gptr()),
            __n - _M_gcount - 1);
    if (__size > 1)
      {
        const char_type* __p = traits_type::find(__sb->gptr(),
              __size,
              __delim);
        if (__p)
   __size = __p - __sb->gptr();
        traits_type::copy(__s, __sb->gptr(), __size);
        __s += __size;
        __sb->gbump(__size);
        _M_gcount += __size;
        __c = __sb->sgetc();
      }
    else
      {
        *__s++ = traits_type::to_char_type(__c);
        ++_M_gcount;
        __c = __sb->snextc();
      }
  }

       if (traits_type::eq_int_type(__c, __eof))
  __err |= ios_base::eofbit;
       else if (traits_type::eq_int_type(__c, __idelim))
  {
    ++_M_gcount;
    __sb->sbumpc();
  }
       else
  __err |= ios_base::failbit;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }
      *__s = char_type();
      if (!_M_gcount)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    ignore(streamsize __n, int_type __delim)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb && __n > 0)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {
       const int_type __eof = traits_type::eof();
       __streambuf_type* __sb = this->rdbuf();
       int_type __c;

       if (__n != numeric_limits<streamsize>::max())
  --__n;
       while (_M_gcount <= __n
       && !traits_type::eq_int_type(__c = __sb->sbumpc(), __eof))
  {
    ++_M_gcount;
    if (traits_type::eq_int_type(__c, __delim))
      break;
  }
       if (traits_type::eq_int_type(__c, __eof))
  __err |= ios_base::eofbit;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    typename basic_istream<_CharT, _Traits>::int_type
    basic_istream<_CharT, _Traits>::
    peek(void)
    {
      int_type __c = traits_type::eof();
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {
       __c = this->rdbuf()->sgetc();
       if (traits_type::eq_int_type(__c, traits_type::eof()))
  __err |= ios_base::eofbit;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return __c;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    read(char_type* __s, streamsize __n)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {
       _M_gcount = this->rdbuf()->sgetn(__s, __n);
       if (_M_gcount != __n)
  __err |= (ios_base::eofbit | ios_base::failbit);
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    streamsize
    basic_istream<_CharT, _Traits>::
    readsome(char_type* __s, streamsize __n)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {

       const streamsize __num = this->rdbuf()->in_avail();
       if (__num > 0)
  _M_gcount = this->rdbuf()->sgetn(__s, std::min(__num, __n));
       else if (__num == -1)
  __err |= ios_base::eofbit;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return _M_gcount;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    putback(char_type __c)
    {


      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {
       const int_type __eof = traits_type::eof();
       __streambuf_type* __sb = this->rdbuf();
       if (!__sb
    || traits_type::eq_int_type(__sb->sputbackc(__c), __eof))
  __err |= ios_base::badbit;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    unget(void)
    {


      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {
       const int_type __eof = traits_type::eof();
       __streambuf_type* __sb = this->rdbuf();
       if (!__sb
    || traits_type::eq_int_type(__sb->sungetc(), __eof))
  __err |= ios_base::badbit;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    int
    basic_istream<_CharT, _Traits>::
    sync(void)
    {


      int __ret = -1;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {
       __streambuf_type* __sb = this->rdbuf();
       if (__sb)
  {
    if (__sb->pubsync() == -1)
      __err |= ios_base::badbit;
    else
      __ret = 0;
  }
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    typename basic_istream<_CharT, _Traits>::pos_type
    basic_istream<_CharT, _Traits>::
    tellg(void)
    {


      pos_type __ret = pos_type(-1);
      try
 {
   if (!this->fail())
     __ret = this->rdbuf()->pubseekoff(0, ios_base::cur, ios_base::in);
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    seekg(pos_type __pos)
    {


      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      try
 {
   if (!this->fail())
     {

       const pos_type __p = this->rdbuf()->pubseekpos(__pos,
            ios_base::in);


       if (__p == pos_type(off_type(-1)))
  __err |= ios_base::failbit;
     }
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    seekg(off_type __off, ios_base::seekdir __dir)
    {


      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      try
 {
   if (!this->fail())
     {

       const pos_type __p = this->rdbuf()->pubseekoff(__off, __dir,
            ios_base::in);


       if (__p == pos_type(off_type(-1)))
  __err |= ios_base::failbit;
     }
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      if (__err)
 this->setstate(__err);
      return *this;
    }


  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT& __c)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::int_type __int_type;

      typename __istream_type::sentry __cerb(__in, false);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {
       const __int_type __cb = __in.rdbuf()->sbumpc();
       if (!_Traits::eq_int_type(__cb, _Traits::eof()))
  __c = _Traits::to_char_type(__cb);
       else
  __err |= (ios_base::eofbit | ios_base::failbit);
     }
   catch(...)
     { __in._M_setstate(ios_base::badbit); }
   if (__err)
     __in.setstate(__err);
 }
      return __in;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT* __s)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::__streambuf_type __streambuf_type;
      typedef typename _Traits::int_type int_type;
      typedef _CharT char_type;
      typedef ctype<_CharT> __ctype_type;

      streamsize __extracted = 0;
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      typename __istream_type::sentry __cerb(__in, false);
      if (__cerb)
 {
   try
     {

       streamsize __num = __in.width();
       if (__num <= 0)
  __num = numeric_limits<streamsize>::max();

       const __ctype_type& __ct = use_facet<__ctype_type>(__in.getloc());

       const int_type __eof = _Traits::eof();
       __streambuf_type* __sb = __in.rdbuf();
       int_type __c = __sb->sgetc();

       while (__extracted < __num - 1
       && !_Traits::eq_int_type(__c, __eof)
       && !__ct.is(ctype_base::space,
     _Traits::to_char_type(__c)))
  {
    *__s++ = _Traits::to_char_type(__c);
    ++__extracted;
    __c = __sb->snextc();
  }
       if (_Traits::eq_int_type(__c, __eof))
  __err |= ios_base::eofbit;



       *__s = char_type();
       __in.width(0);
     }
   catch(...)
     { __in._M_setstate(ios_base::badbit); }
 }
      if (!__extracted)
 __err |= ios_base::failbit;
      if (__err)
 __in.setstate(__err);
      return __in;
    }


  template<typename _CharT, typename _Traits>
    basic_istream<_CharT,_Traits>&
    ws(basic_istream<_CharT,_Traits>& __in)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::__streambuf_type __streambuf_type;
      typedef typename __istream_type::__ctype_type __ctype_type;
      typedef typename __istream_type::int_type __int_type;

      const __ctype_type& __ct = use_facet<__ctype_type>(__in.getloc());
      const __int_type __eof = _Traits::eof();
      __streambuf_type* __sb = __in.rdbuf();
      __int_type __c = __sb->sgetc();

      while (!_Traits::eq_int_type(__c, __eof)
      && __ct.is(ctype_base::space, _Traits::to_char_type(__c)))
 __c = __sb->snextc();

       if (_Traits::eq_int_type(__c, __eof))
  __in.setstate(ios_base::eofbit);
      return __in;
    }


  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in,
        basic_string<_CharT, _Traits, _Alloc>& __str)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::int_type __int_type;
      typedef typename __istream_type::__streambuf_type __streambuf_type;
      typedef typename __istream_type::__ctype_type __ctype_type;
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;

      __size_type __extracted = 0;
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      typename __istream_type::sentry __cerb(__in, false);
      if (__cerb)
 {
   try
     {

       __str.erase();
       _CharT __buf[128];
       __size_type __len = 0;
       const streamsize __w = __in.width();
       const __size_type __n = __w > 0 ? static_cast<__size_type>(__w)
                                : __str.max_size();
       const __ctype_type& __ct = use_facet<__ctype_type>(__in.getloc());
       const __int_type __eof = _Traits::eof();
       __streambuf_type* __sb = __in.rdbuf();
       __int_type __c = __sb->sgetc();

       while (__extracted < __n
       && !_Traits::eq_int_type(__c, __eof)
       && !__ct.is(ctype_base::space, _Traits::to_char_type(__c)))
  {
    if (__len == sizeof(__buf) / sizeof(_CharT))
      {
        __str.append(__buf, sizeof(__buf) / sizeof(_CharT));
        __len = 0;
      }
    __buf[__len++] = _Traits::to_char_type(__c);
    ++__extracted;
    __c = __sb->snextc();
  }
       __str.append(__buf, __len);

       if (_Traits::eq_int_type(__c, __eof))
  __err |= ios_base::eofbit;
       __in.width(0);
     }
   catch(...)
     {



       __in._M_setstate(ios_base::badbit);
     }
 }

      if (!__extracted)
 __err |= ios_base::failbit;
      if (__err)
 __in.setstate(__err);
      return __in;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>& __in,
     basic_string<_CharT, _Traits, _Alloc>& __str, _CharT __delim)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::int_type __int_type;
      typedef typename __istream_type::__streambuf_type __streambuf_type;
      typedef typename __istream_type::__ctype_type __ctype_type;
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;

      __size_type __extracted = 0;
      const __size_type __n = __str.max_size();
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      typename __istream_type::sentry __cerb(__in, true);
      if (__cerb)
 {
   try
     {

       __str.erase();
       _CharT __buf[128];
       __size_type __len = 0;
       const __int_type __idelim = _Traits::to_int_type(__delim);
       const __int_type __eof = _Traits::eof();
       __streambuf_type* __sb = __in.rdbuf();
       __int_type __c = __sb->sgetc();

       while (__extracted < __n
       && !_Traits::eq_int_type(__c, __eof)
       && !_Traits::eq_int_type(__c, __idelim))
  {
    if (__len == sizeof(__buf) / sizeof(_CharT))
      {
        __str.append(__buf, sizeof(__buf) / sizeof(_CharT));
        __len = 0;
      }
    __buf[__len++] = _Traits::to_char_type(__c);
    ++__extracted;
    __c = __sb->snextc();
  }
       __str.append(__buf, __len);

       if (_Traits::eq_int_type(__c, __eof))
  __err |= ios_base::eofbit;
       else if (_Traits::eq_int_type(__c, __idelim))
  {
    ++__extracted;
    __sb->sbumpc();
  }
       else
  __err |= ios_base::failbit;
     }
   catch(...)
     {



       __in._M_setstate(ios_base::badbit);
     }
 }
      if (!__extracted)
 __err |= ios_base::failbit;
      if (__err)
 __in.setstate(__err);
      return __in;
    }

  template<class _CharT, class _Traits, class _Alloc>
    inline basic_istream<_CharT,_Traits>&
    getline(basic_istream<_CharT, _Traits>& __in,
     basic_string<_CharT,_Traits,_Alloc>& __str)
    { return getline(__in, __str, __in.widen('\n')); }





  extern template class basic_istream<char>;
  extern template istream& ws(istream&);
  extern template istream& operator>>(istream&, char&);
  extern template istream& operator>>(istream&, char*);
  extern template istream& operator>>(istream&, unsigned char&);
  extern template istream& operator>>(istream&, signed char&);
  extern template istream& operator>>(istream&, unsigned char*);
  extern template istream& operator>>(istream&, signed char*);

  extern template class basic_iostream<char>;
# 1190 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/istream.tcc" 3
}
# 772 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/istream" 2 3
# 47 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/iostream" 2 3

namespace std
{
# 63 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/iostream" 3
  extern istream cin;
  extern ostream cout;
  extern ostream cerr;
  extern ostream clog;
# 77 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/iostream" 3
  static ios_base::Init __ioinit;
}
# 33 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/backward/iostream.h" 2

using std::iostream;
using std::ostream;
using std::istream;
using std::ios;
using std::streambuf;

using std::cout;
using std::cin;
using std::cerr;
using std::clog;







using std::ws;
using std::endl;
using std::ends;
using std::flush;
# 8 "shooter.cpp" 2
# 1 "gamespace.h" 1



# 1 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/backward/list.h" 1
# 60 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/backward/list.h"
# 1 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/backward/algobase.h" 1
# 59 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/backward/algobase.h"
# 1 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/backward/pair.h" 1
# 63 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/backward/pair.h"
using std::pair;
using std::make_pair;
# 60 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/backward/algobase.h" 2
# 1 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/backward/iterator.h" 1
# 60 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/backward/iterator.h"
# 1 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/backward/function.h" 1
# 61 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/backward/function.h"
# 1 "H:/CPP/wxdevcpp6.10/lib/gcc/mingw32/3.4.2/include/stddef.h" 1
# 62 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/backward/function.h" 2

# 1 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/ext/functional" 1
# 65 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/ext/functional"
       
# 66 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/ext/functional" 3

# 1 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/functional" 1 3
# 52 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/functional" 3
       
# 53 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/functional" 3
# 68 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/ext/functional" 2 3

namespace __gnu_cxx
{
using std::unary_function;
using std::binary_function;
using std::mem_fun1_t;
using std::const_mem_fun1_t;
using std::mem_fun1_ref_t;
using std::const_mem_fun1_ref_t;
# 88 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/ext/functional" 3
template <class _Tp> inline _Tp identity_element(std::plus<_Tp>) {
  return _Tp(0);
}

template <class _Tp> inline _Tp identity_element(std::multiplies<_Tp>) {
  return _Tp(1);
}
# 124 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/ext/functional" 3
template <class _Operation1, class _Operation2>
class unary_compose
  : public unary_function<typename _Operation2::argument_type,
         typename _Operation1::result_type>
{
protected:
  _Operation1 _M_fn1;
  _Operation2 _M_fn2;
public:
  unary_compose(const _Operation1& __x, const _Operation2& __y)
    : _M_fn1(__x), _M_fn2(__y) {}
  typename _Operation1::result_type
  operator()(const typename _Operation2::argument_type& __x) const {
    return _M_fn1(_M_fn2(__x));
  }
};


template <class _Operation1, class _Operation2>
inline unary_compose<_Operation1,_Operation2>
compose1(const _Operation1& __fn1, const _Operation2& __fn2)
{
  return unary_compose<_Operation1,_Operation2>(__fn1, __fn2);
}


template <class _Operation1, class _Operation2, class _Operation3>
class binary_compose
  : public unary_function<typename _Operation2::argument_type,
                          typename _Operation1::result_type> {
protected:
  _Operation1 _M_fn1;
  _Operation2 _M_fn2;
  _Operation3 _M_fn3;
public:
  binary_compose(const _Operation1& __x, const _Operation2& __y,
                 const _Operation3& __z)
    : _M_fn1(__x), _M_fn2(__y), _M_fn3(__z) { }
  typename _Operation1::result_type
  operator()(const typename _Operation2::argument_type& __x) const {
    return _M_fn1(_M_fn2(__x), _M_fn3(__x));
  }
};


template <class _Operation1, class _Operation2, class _Operation3>
inline binary_compose<_Operation1, _Operation2, _Operation3>
compose2(const _Operation1& __fn1, const _Operation2& __fn2,
         const _Operation3& __fn3)
{
  return binary_compose<_Operation1,_Operation2,_Operation3>
    (__fn1, __fn2, __fn3);
}
# 185 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/ext/functional" 3
template <class _Tp> struct identity : public std::_Identity<_Tp> {};
# 198 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/ext/functional" 3
template <class _Pair> struct select1st : public std::_Select1st<_Pair> {};

template <class _Pair> struct select2nd : public std::_Select2nd<_Pair> {};



template <class _Arg1, class _Arg2>
struct _Project1st : public binary_function<_Arg1, _Arg2, _Arg1> {
  _Arg1 operator()(const _Arg1& __x, const _Arg2&) const { return __x; }
};

template <class _Arg1, class _Arg2>
struct _Project2nd : public binary_function<_Arg1, _Arg2, _Arg2> {
  _Arg2 operator()(const _Arg1&, const _Arg2& __y) const { return __y; }
};
# 223 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/ext/functional" 3
template <class _Arg1, class _Arg2>
struct project1st : public _Project1st<_Arg1, _Arg2> {};


template <class _Arg1, class _Arg2>
struct project2nd : public _Project2nd<_Arg1, _Arg2> {};



template <class _Result>
struct _Constant_void_fun {
  typedef _Result result_type;
  result_type _M_val;

  _Constant_void_fun(const result_type& __v) : _M_val(__v) {}
  const result_type& operator()() const { return _M_val; }
};

template <class _Result, class _Argument>
struct _Constant_unary_fun {
  typedef _Argument argument_type;
  typedef _Result result_type;
  result_type _M_val;

  _Constant_unary_fun(const result_type& __v) : _M_val(__v) {}
  const result_type& operator()(const _Argument&) const { return _M_val; }
};

template <class _Result, class _Arg1, class _Arg2>
struct _Constant_binary_fun {
  typedef _Arg1 first_argument_type;
  typedef _Arg2 second_argument_type;
  typedef _Result result_type;
  _Result _M_val;

  _Constant_binary_fun(const _Result& __v) : _M_val(__v) {}
  const result_type& operator()(const _Arg1&, const _Arg2&) const {
    return _M_val;
  }
};
# 279 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/ext/functional" 3
template <class _Result>
struct constant_void_fun : public _Constant_void_fun<_Result> {
  constant_void_fun(const _Result& __v) : _Constant_void_fun<_Result>(__v) {}
};


template <class _Result,
          class _Argument = _Result>
struct constant_unary_fun : public _Constant_unary_fun<_Result, _Argument>
{
  constant_unary_fun(const _Result& __v)
    : _Constant_unary_fun<_Result, _Argument>(__v) {}
};


template <class _Result,
          class _Arg1 = _Result,
          class _Arg2 = _Arg1>
struct constant_binary_fun
  : public _Constant_binary_fun<_Result, _Arg1, _Arg2>
{
  constant_binary_fun(const _Result& __v)
    : _Constant_binary_fun<_Result, _Arg1, _Arg2>(__v) {}
};


template <class _Result>
inline constant_void_fun<_Result> constant0(const _Result& __val)
{
  return constant_void_fun<_Result>(__val);
}


template <class _Result>
inline constant_unary_fun<_Result,_Result> constant1(const _Result& __val)
{
  return constant_unary_fun<_Result,_Result>(__val);
}


template <class _Result>
inline constant_binary_fun<_Result,_Result,_Result>
constant2(const _Result& __val)
{
  return constant_binary_fun<_Result,_Result,_Result>(__val);
}
# 333 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/ext/functional" 3
class subtractive_rng : public unary_function<unsigned int, unsigned int> {
private:
  unsigned int _M_table[55];
  size_t _M_index1;
  size_t _M_index2;
public:

  unsigned int operator()(unsigned int __limit) {
    _M_index1 = (_M_index1 + 1) % 55;
    _M_index2 = (_M_index2 + 1) % 55;
    _M_table[_M_index1] = _M_table[_M_index1] - _M_table[_M_index2];
    return _M_table[_M_index1] % __limit;
  }

  void _M_initialize(unsigned int __seed)
  {
    unsigned int __k = 1;
    _M_table[54] = __seed;
    size_t __i;
    for (__i = 0; __i < 54; __i++) {
        size_t __ii = (21 * (__i + 1) % 55) - 1;
        _M_table[__ii] = __k;
        __k = __seed - __k;
        __seed = _M_table[__ii];
    }
    for (int __loop = 0; __loop < 4; __loop++) {
        for (__i = 0; __i < 55; __i++)
            _M_table[__i] = _M_table[__i] - _M_table[(1 + __i + 30) % 55];
    }
    _M_index1 = 0;
    _M_index2 = 31;
  }


  subtractive_rng(unsigned int __seed) { _M_initialize(__seed); }

  subtractive_rng() { _M_initialize(161803398u); }
};





template <class _Ret, class _Tp, class _Arg>
inline mem_fun1_t<_Ret,_Tp,_Arg> mem_fun1(_Ret (_Tp::*__f)(_Arg))
  { return mem_fun1_t<_Ret,_Tp,_Arg>(__f); }

template <class _Ret, class _Tp, class _Arg>
inline const_mem_fun1_t<_Ret,_Tp,_Arg> mem_fun1(_Ret (_Tp::*__f)(_Arg) const)
  { return const_mem_fun1_t<_Ret,_Tp,_Arg>(__f); }

template <class _Ret, class _Tp, class _Arg>
inline mem_fun1_ref_t<_Ret,_Tp,_Arg> mem_fun1_ref(_Ret (_Tp::*__f)(_Arg))
  { return mem_fun1_ref_t<_Ret,_Tp,_Arg>(__f); }

template <class _Ret, class _Tp, class _Arg>
inline const_mem_fun1_ref_t<_Ret,_Tp,_Arg>
mem_fun1_ref(_Ret (_Tp::*__f)(_Arg) const)
  { return const_mem_fun1_ref_t<_Ret,_Tp,_Arg>(__f); }
}
# 64 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/backward/function.h" 2


using std::unary_function;
using std::binary_function;
using std::plus;
using std::minus;
using std::multiplies;
using std::divides;
using std::modulus;
using std::negate;
using std::equal_to;
using std::not_equal_to;
using std::greater;
using std::less;
using std::greater_equal;
using std::less_equal;
using std::logical_and;
using std::logical_or;
using std::logical_not;
using std::unary_negate;
using std::binary_negate;
using std::not1;
using std::not2;
using std::binder1st;
using std::binder2nd;
using std::bind1st;
using std::bind2nd;
using std::pointer_to_unary_function;
using std::pointer_to_binary_function;
using std::ptr_fun;
using std::mem_fun_t;
using std::const_mem_fun_t;
using std::mem_fun_ref_t;
using std::const_mem_fun_ref_t;
using std::mem_fun1_t;
using std::const_mem_fun1_t;
using std::mem_fun1_ref_t;
using std::const_mem_fun1_ref_t;
using std::mem_fun;
using std::mem_fun_ref;


using __gnu_cxx::identity_element;
using __gnu_cxx::unary_compose;
using __gnu_cxx::binary_compose;
using __gnu_cxx::compose1;
using __gnu_cxx::compose2;
using __gnu_cxx::identity;
using __gnu_cxx::select1st;
using __gnu_cxx::select2nd;
using __gnu_cxx::project1st;
using __gnu_cxx::project2nd;
using __gnu_cxx::constant_void_fun;
using __gnu_cxx::constant_unary_fun;
using __gnu_cxx::constant_binary_fun;
using __gnu_cxx::constant0;
using __gnu_cxx::constant1;
using __gnu_cxx::constant2;
using __gnu_cxx::subtractive_rng;
using __gnu_cxx::mem_fun1;
using __gnu_cxx::mem_fun1_ref;
# 61 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/backward/iterator.h" 2
# 1 "H:/CPP/wxdevcpp6.10/lib/gcc/mingw32/3.4.2/include/stddef.h" 1
# 62 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/backward/iterator.h" 2
# 1 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/backward/iostream.h" 1
# 63 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/backward/iterator.h" 2
# 1 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/iterator" 1
# 64 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/iterator"
       
# 65 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/iterator" 3
# 73 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/iterator" 3
# 1 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stream_iterator.h" 1 3
# 38 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stream_iterator.h" 3
       
# 39 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stream_iterator.h" 3



namespace std
{

  template<typename _Tp, typename _CharT = char,
           typename _Traits = char_traits<_CharT>, typename _Dist = ptrdiff_t>
    class istream_iterator
    : public iterator<input_iterator_tag, _Tp, _Dist, const _Tp*, const _Tp&>
    {
    public:
      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef basic_istream<_CharT, _Traits> istream_type;

    private:
      istream_type* _M_stream;
      _Tp _M_value;
      bool _M_ok;

    public:

      istream_iterator()
      : _M_stream(0), _M_ok(false) {}


      istream_iterator(istream_type& __s)
      : _M_stream(&__s)
      { _M_read(); }

      istream_iterator(const istream_iterator& __obj)
      : _M_stream(__obj._M_stream), _M_value(__obj._M_value),
        _M_ok(__obj._M_ok)
      { }

      const _Tp&
      operator*() const
      {
 ;


 return _M_value;
      }

      const _Tp*
      operator->() const { return &(operator*()); }

      istream_iterator&
      operator++()
      {
 ;


 _M_read();
 return *this;
      }

      istream_iterator
      operator++(int)
      {
 ;


 istream_iterator __tmp = *this;
 _M_read();
 return __tmp;
      }

      bool
      _M_equal(const istream_iterator& __x) const
      { return (_M_ok == __x._M_ok) && (!_M_ok || _M_stream == __x._M_stream); }

    private:
      void
      _M_read()
      {
 _M_ok = (_M_stream && *_M_stream) ? true : false;
 if (_M_ok)
   {
     *_M_stream >> _M_value;
     _M_ok = *_M_stream ? true : false;
   }
      }
    };


  template<typename _Tp, typename _CharT, typename _Traits, typename _Dist>
    inline bool
    operator==(const istream_iterator<_Tp, _CharT, _Traits, _Dist>& __x,
        const istream_iterator<_Tp, _CharT, _Traits, _Dist>& __y)
    { return __x._M_equal(__y); }


  template <class _Tp, class _CharT, class _Traits, class _Dist>
    inline bool
    operator!=(const istream_iterator<_Tp, _CharT, _Traits, _Dist>& __x,
        const istream_iterator<_Tp, _CharT, _Traits, _Dist>& __y)
    { return !__x._M_equal(__y); }
# 150 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stream_iterator.h" 3
  template<typename _Tp, typename _CharT = char,
           typename _Traits = char_traits<_CharT> >
    class ostream_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    public:


      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef basic_ostream<_CharT, _Traits> ostream_type;


    private:
      ostream_type* _M_stream;
      const _CharT* _M_string;

    public:

      ostream_iterator(ostream_type& __s) : _M_stream(&__s), _M_string(0) {}
# 181 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stream_iterator.h" 3
      ostream_iterator(ostream_type& __s, const _CharT* __c)
      : _M_stream(&__s), _M_string(__c) { }


      ostream_iterator(const ostream_iterator& __obj)
      : _M_stream(__obj._M_stream), _M_string(__obj._M_string) { }



      ostream_iterator&
      operator=(const _Tp& __value)
      {
 ;


 *_M_stream << __value;
 if (_M_string) *_M_stream << _M_string;
 return *this;
      }

      ostream_iterator&
      operator*()
      { return *this; }

      ostream_iterator&
      operator++()
      { return *this; }

      ostream_iterator&
      operator++(int)
      { return *this; }
    };
}
# 74 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/iterator" 2 3
# 64 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/backward/iterator.h" 2




# 1 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/ext/iterator" 1
# 65 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/ext/iterator"
       
# 66 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/ext/iterator" 3




namespace __gnu_cxx
{





  template<typename _InputIterator, typename _Distance>
    inline void
    __distance(_InputIterator __first, _InputIterator __last,
        _Distance& __n, std::input_iterator_tag)
    {

     
      while (__first != __last) { ++__first; ++__n; }
    }

  template<typename _RandomAccessIterator, typename _Distance>
    inline void
    __distance(_RandomAccessIterator __first, _RandomAccessIterator __last,
        _Distance& __n, std::random_access_iterator_tag)
    {

     
      __n += __last - __first;
    }






  template<typename _InputIterator, typename _Distance>
    inline void
    distance(_InputIterator __first, _InputIterator __last,
             _Distance& __n)
    {

      __distance(__first, __last, __n, std::__iterator_category(__first));
    }
}
# 69 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/backward/iterator.h" 2


using std::input_iterator_tag;
using std::output_iterator_tag;
using std::forward_iterator_tag;
using std::bidirectional_iterator_tag;
using std::random_access_iterator_tag;
# 85 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/backward/iterator.h"
template<typename _Tp, typename _Distance>
  struct input_iterator {
    typedef input_iterator_tag iterator_category;
    typedef _Tp value_type;
    typedef _Distance difference_type;
    typedef _Tp* pointer;
    typedef _Tp& reference;
  };

struct output_iterator {
  typedef output_iterator_tag iterator_category;
  typedef void value_type;
  typedef void difference_type;
  typedef void pointer;
  typedef void reference;
};

template<typename _Tp, typename _Distance>
  struct forward_iterator {
    typedef forward_iterator_tag iterator_category;
    typedef _Tp value_type;
    typedef _Distance difference_type;
    typedef _Tp* pointer;
    typedef _Tp& reference;
  };

template<typename _Tp, typename _Distance>
  struct bidirectional_iterator {
    typedef bidirectional_iterator_tag iterator_category;
    typedef _Tp value_type;
    typedef _Distance difference_type;
    typedef _Tp* pointer;
    typedef _Tp& reference;
  };

template<typename _Tp, typename _Distance>
  struct random_access_iterator {
    typedef random_access_iterator_tag iterator_category;
    typedef _Tp value_type;
    typedef _Distance difference_type;
    typedef _Tp* pointer;
    typedef _Tp& reference;
  };

using std::iterator_traits;

template <class _Iter>
  inline typename iterator_traits<_Iter>::iterator_category
  iterator_category(const _Iter& __i)
  { return __iterator_category(__i); }

template <class _Iter>
  inline typename iterator_traits<_Iter>::difference_type*
  distance_type(const _Iter&)
  { return static_cast<typename iterator_traits<_Iter>::difference_type*>(0); }

template<class _Iter>
  inline typename iterator_traits<_Iter>::value_type*
  value_type(const _Iter& __i)
  { return static_cast<typename iterator_traits<_Iter>::value_type*>(0); }

using std::distance;
using __gnu_cxx::distance;
using std::advance;

using std::insert_iterator;
using std::front_insert_iterator;
using std::back_insert_iterator;
using std::inserter;
using std::front_inserter;
using std::back_inserter;

using std::reverse_iterator;

using std::istream_iterator;
using std::ostream_iterator;


template<class _T1, class _T2>
  inline void
  construct(_T1* __p, const _T2& __value)
  { std::_Construct(__p, __value); }

template<class _T1>
  inline void
  construct(_T1* __p)
  { std::_Construct(__p); }

template <class _Tp>
  inline void
  destroy(_Tp* __pointer)
  { std::_Destroy(__pointer); }

template <class _ForwardIterator>
  inline void
  destroy(_ForwardIterator __first, _ForwardIterator __last)
  { std::_Destroy(__first, __last); }



using std::raw_storage_iterator;
# 61 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/backward/algobase.h" 2


# 1 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/ext/algorithm" 1
# 65 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/ext/algorithm"
       
# 66 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/ext/algorithm" 3



namespace __gnu_cxx
{
  using std::ptrdiff_t;
  using std::min;
  using std::pair;
  using std::input_iterator_tag;
  using std::random_access_iterator_tag;
  using std::iterator_traits;




  template<typename _InputIterator, typename _Size, typename _OutputIterator>
    pair<_InputIterator, _OutputIterator>
    __copy_n(_InputIterator __first, _Size __count,
      _OutputIterator __result,
      input_iterator_tag)
    {
      for ( ; __count > 0; --__count) {
 *__result = *__first;
 ++__first;
 ++__result;
      }
      return pair<_InputIterator, _OutputIterator>(__first, __result);
    }

  template<typename _RAIterator, typename _Size, typename _OutputIterator>
    inline pair<_RAIterator, _OutputIterator>
    __copy_n(_RAIterator __first, _Size __count,
      _OutputIterator __result,
      random_access_iterator_tag)
    {
      _RAIterator __last = __first + __count;
      return pair<_RAIterator, _OutputIterator>(__last,
     std::copy(__first, __last, __result));
    }
# 120 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/ext/algorithm" 3
  template<typename _InputIterator, typename _Size, typename _OutputIterator>
    inline pair<_InputIterator, _OutputIterator>
    copy_n(_InputIterator __first, _Size __count, _OutputIterator __result)
    {

     
     


      return __copy_n(__first, __count, __result,
        std::__iterator_category(__first));
    }

  template<typename _InputIterator1, typename _InputIterator2>
    int
    __lexicographical_compare_3way(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _InputIterator2 __last2)
    {
      while (__first1 != __last1 && __first2 != __last2) {
 if (*__first1 < *__first2)
   return -1;
 if (*__first2 < *__first1)
   return 1;
 ++__first1;
 ++__first2;
      }
      if (__first2 == __last2) {
 return !(__first1 == __last1);
      }
      else {
 return -1;
      }
    }

  inline int
  __lexicographical_compare_3way(const unsigned char* __first1,
     const unsigned char* __last1,
     const unsigned char* __first2,
     const unsigned char* __last2)
  {
    const ptrdiff_t __len1 = __last1 - __first1;
    const ptrdiff_t __len2 = __last2 - __first2;
    const int __result = std::memcmp(__first1, __first2, min(__len1, __len2));
    return __result != 0 ? __result
    : (__len1 == __len2 ? 0 : (__len1 < __len2 ? -1 : 1));
  }

  inline int
  __lexicographical_compare_3way(const char* __first1, const char* __last1,
     const char* __first2, const char* __last2)
  {

    return __lexicographical_compare_3way(
      (const signed char*) __first1,
      (const signed char*) __last1,
      (const signed char*) __first2,
      (const signed char*) __last2);






  }
# 199 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/ext/algorithm" 3
  template<typename _InputIterator1, typename _InputIterator2>
    int
    lexicographical_compare_3way(_InputIterator1 __first1, _InputIterator1 __last1,
     _InputIterator2 __first2, _InputIterator2 __last2)
    {

     
     
     

     

      ;
      ;

      return __lexicographical_compare_3way(__first1, __last1, __first2, __last2);
    }




  template<typename _InputIterator, typename _Tp, typename _Size>
    void
    count(_InputIterator __first, _InputIterator __last,
   const _Tp& __value,
   _Size& __n)
    {

     
     

     
      ;

      for ( ; __first != __last; ++__first)
 if (*__first == __value)
   ++__n;
    }

  template<typename _InputIterator, typename _Predicate, typename _Size>
    void
    count_if(_InputIterator __first, _InputIterator __last,
      _Predicate __pred,
      _Size& __n)
    {

     
     

      ;

      for ( ; __first != __last; ++__first)
 if (__pred(*__first))
   ++__n;
    }
# 262 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/ext/algorithm" 3
  template<typename _ForwardIterator, typename _OutputIterator, typename _Distance>
    _OutputIterator
    random_sample_n(_ForwardIterator __first, _ForwardIterator __last,
                    _OutputIterator __out, const _Distance __n)
    {

     
     

      ;

      _Distance __remaining = std::distance(__first, __last);
      _Distance __m = min(__n, __remaining);

      while (__m > 0) {
 if ((std::rand() % __remaining) < __m) {
       *__out = *__first;
       ++__out;
       --__m;
 }

 --__remaining;
 ++__first;
      }
      return __out;
    }






  template<typename _ForwardIterator, typename _OutputIterator, typename _Distance,
    typename _RandomNumberGenerator>
    _OutputIterator
    random_sample_n(_ForwardIterator __first, _ForwardIterator __last,
                   _OutputIterator __out, const _Distance __n,
     _RandomNumberGenerator& __rand)
    {

     
     

     

      ;

      _Distance __remaining = std::distance(__first, __last);
      _Distance __m = min(__n, __remaining);

      while (__m > 0) {
 if (__rand(__remaining) < __m) {
       *__out = *__first;
       ++__out;
       --__m;
 }

 --__remaining;
 ++__first;
      }
      return __out;
    }

  template<typename _InputIterator, typename _RandomAccessIterator, typename _Distance>
    _RandomAccessIterator
    __random_sample(_InputIterator __first, _InputIterator __last,
      _RandomAccessIterator __out,
      const _Distance __n)
    {
      _Distance __m = 0;
      _Distance __t = __n;
      for ( ; __first != __last && __m < __n; ++__m, ++__first)
 __out[__m] = *__first;

      while (__first != __last) {
 ++__t;
 _Distance __M = std::rand() % (__t);
 if (__M < __n)
   __out[__M] = *__first;
 ++__first;
      }

      return __out + __m;
    }

  template<typename _InputIterator, typename _RandomAccessIterator,
    typename _RandomNumberGenerator, typename _Distance>
    _RandomAccessIterator
    __random_sample(_InputIterator __first, _InputIterator __last,
      _RandomAccessIterator __out,
      _RandomNumberGenerator& __rand,
      const _Distance __n)
    {

     


      _Distance __m = 0;
      _Distance __t = __n;
      for ( ; __first != __last && __m < __n; ++__m, ++__first)
 __out[__m] = *__first;

      while (__first != __last) {
 ++__t;
 _Distance __M = __rand(__t);
 if (__M < __n)
   __out[__M] = *__first;
 ++__first;
      }

      return __out + __m;
    }






  template<typename _InputIterator, typename _RandomAccessIterator>
    inline _RandomAccessIterator
    random_sample(_InputIterator __first, _InputIterator __last,
    _RandomAccessIterator __out_first, _RandomAccessIterator __out_last)
    {

     
     

      ;
      ;

      return __random_sample(__first, __last,
        __out_first, __out_last - __out_first);
    }






  template<typename _InputIterator, typename _RandomAccessIterator,
    typename _RandomNumberGenerator>
    inline _RandomAccessIterator
    random_sample(_InputIterator __first, _InputIterator __last,
    _RandomAccessIterator __out_first, _RandomAccessIterator __out_last,
    _RandomNumberGenerator& __rand)
    {

     
     

      ;
      ;

      return __random_sample(__first, __last,
        __out_first, __rand,
        __out_last - __out_first);
    }






  template<typename _RandomAccessIterator>
    inline bool
    is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {

     
     

      ;

      return std::__is_heap(__first, __last - __first);
    }






  template<typename _RandomAccessIterator, typename _StrictWeakOrdering>
    inline bool
    is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
     _StrictWeakOrdering __comp)
    {

     
     


      ;

      return std::__is_heap(__first, __comp, __last - __first);
    }
# 467 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/ext/algorithm" 3
  template<typename _ForwardIterator>
    bool
    is_sorted(_ForwardIterator __first, _ForwardIterator __last)
    {

     
     

      ;

      if (__first == __last)
 return true;

      _ForwardIterator __next = __first;
      for (++__next; __next != __last; __first = __next, ++__next) {
 if (*__next < *__first)
   return false;
      }

      return true;
    }






  template<typename _ForwardIterator, typename _StrictWeakOrdering>
    bool
    is_sorted(_ForwardIterator __first, _ForwardIterator __last, _StrictWeakOrdering __comp)
    {

     
     


      ;

      if (__first == __last)
 return true;

      _ForwardIterator __next = __first;
      for (++__next; __next != __last; __first = __next, ++__next) {
 if (__comp(*__next, *__first))
   return false;
      }

      return true;
    }
}
# 64 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/backward/algobase.h" 2
# 1 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/ext/memory" 1
# 65 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/ext/memory"
       
# 66 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/ext/memory" 3




namespace __gnu_cxx
{
  using std::ptrdiff_t;
  using std::pair;
  using std::__iterator_category;
  using std::_Temporary_buffer;

  template<typename _InputIter, typename _Size, typename _ForwardIter>
    pair<_InputIter, _ForwardIter>
    __uninitialized_copy_n(_InputIter __first, _Size __count,
      _ForwardIter __result, std::input_iterator_tag)
    {
      _ForwardIter __cur = __result;
      try
 {
   for ( ; __count > 0 ; --__count, ++__first, ++__cur)
     std::_Construct(&*__cur, *__first);
   return pair<_InputIter, _ForwardIter>(__first, __cur);
 }
      catch(...)
 {
   std::_Destroy(__result, __cur);
   throw;
 }
    }

  template<typename _RandomAccessIter, typename _Size, typename _ForwardIter>
    inline pair<_RandomAccessIter, _ForwardIter>
    __uninitialized_copy_n(_RandomAccessIter __first, _Size __count,
      _ForwardIter __result,
      std::random_access_iterator_tag)
    {
      _RandomAccessIter __last = __first + __count;
      return pair<_RandomAccessIter, _ForwardIter>(
       __last,
       std::uninitialized_copy(__first, __last, __result));
    }

  template<typename _InputIter, typename _Size, typename _ForwardIter>
    inline pair<_InputIter, _ForwardIter>
    __uninitialized_copy_n(_InputIter __first, _Size __count,
    _ForwardIter __result)
    {
      return __uninitialized_copy_n(__first, __count, __result,
        __iterator_category(__first));
    }
# 127 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/ext/memory" 3
  template<typename _InputIter, typename _Size, typename _ForwardIter>
    inline pair<_InputIter, _ForwardIter>
    uninitialized_copy_n(_InputIter __first, _Size __count,
    _ForwardIter __result)
    {
      return __uninitialized_copy_n(__first, __count, __result,
        __iterator_category(__first));
    }
# 157 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/ext/memory" 3
  template <class _ForwardIterator, class _Tp
       = typename std::iterator_traits<_ForwardIterator>::value_type >
  struct temporary_buffer : public _Temporary_buffer<_ForwardIterator, _Tp>
  {

    temporary_buffer(_ForwardIterator __first, _ForwardIterator __last)
    : _Temporary_buffer<_ForwardIterator, _Tp>(__first, __last) { }


    ~temporary_buffer() { }
  };
}
# 65 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/backward/algobase.h" 2


using std::iter_swap;
using std::swap;
using std::min;
using std::max;
using std::copy;
using std::copy_backward;
using std::fill;
using std::fill_n;
using std::mismatch;
using std::equal;
using std::lexicographical_compare;


using std::uninitialized_copy;
using std::uninitialized_fill;
using std::uninitialized_fill_n;


using __gnu_cxx::copy_n;
using __gnu_cxx::lexicographical_compare_3way;


using __gnu_cxx::uninitialized_copy_n;
# 61 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/backward/list.h" 2
# 1 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/backward/alloc.h" 1
# 50 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/backward/alloc.h"
using std::allocator;
# 62 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/backward/list.h" 2
# 1 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/list" 1
# 64 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/list"
       
# 65 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/list" 3

# 1 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/functexcept.h" 1 3
# 36 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/functexcept.h" 3
namespace std
{

  void
  __throw_bad_exception(void);


  void
  __throw_bad_alloc(void);


  void
  __throw_bad_cast(void);

  void
  __throw_bad_typeid(void);


  void
  __throw_logic_error(const char* __s);

  void
  __throw_domain_error(const char* __s);

  void
  __throw_invalid_argument(const char* __s);

  void
  __throw_length_error(const char* __s);

  void
  __throw_out_of_range(const char* __s);

  void
  __throw_runtime_error(const char* __s);

  void
  __throw_range_error(const char* __s);

  void
  __throw_overflow_error(const char* __s);

  void
  __throw_underflow_error(const char* __s);


  void
  __throw_ios_failure(const char* __s);
}
# 67 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/list" 2 3




# 1 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_list.h" 1 3
# 66 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_list.h" 3
namespace std
{






  struct _List_node_base
  {
    _List_node_base* _M_next;
    _List_node_base* _M_prev;

    static void
    swap(_List_node_base& __x, _List_node_base& __y);

    void
    transfer(_List_node_base * const __first,
      _List_node_base * const __last);

    void
    reverse();

    void
    hook(_List_node_base * const __position);

    void
    unhook();
  };


  template<typename _Tp>
    struct _List_node : public _List_node_base
    {
      _Tp _M_data;
    };
# 110 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_list.h" 3
  template<typename _Tp>
    struct _List_iterator
    {
      typedef _List_iterator<_Tp> _Self;
      typedef _List_node<_Tp> _Node;

      typedef ptrdiff_t difference_type;
      typedef bidirectional_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef _Tp* pointer;
      typedef _Tp& reference;

      _List_iterator() { }

      _List_iterator(_List_node_base* __x)
      : _M_node(__x) { }


      reference
      operator*() const
      { return static_cast<_Node*>(_M_node)->_M_data; }

      pointer
      operator->() const
      { return &static_cast<_Node*>(_M_node)->_M_data; }

      _Self&
      operator++()
      {
 _M_node = _M_node->_M_next;
 return *this;
      }

      _Self
      operator++(int)
      {
 _Self __tmp = *this;
 _M_node = _M_node->_M_next;
 return __tmp;
      }

      _Self&
      operator--()
      {
 _M_node = _M_node->_M_prev;
 return *this;
      }

      _Self
      operator--(int)
      {
 _Self __tmp = *this;
 _M_node = _M_node->_M_prev;
 return __tmp;
      }

      bool
      operator==(const _Self& __x) const
      { return _M_node == __x._M_node; }

      bool
      operator!=(const _Self& __x) const
      { return _M_node != __x._M_node; }


      _List_node_base* _M_node;
    };
# 185 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_list.h" 3
  template<typename _Tp>
    struct _List_const_iterator
    {
      typedef _List_const_iterator<_Tp> _Self;
      typedef const _List_node<_Tp> _Node;
      typedef _List_iterator<_Tp> iterator;

      typedef ptrdiff_t difference_type;
      typedef bidirectional_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef const _Tp* pointer;
      typedef const _Tp& reference;

      _List_const_iterator() { }

      _List_const_iterator(const _List_node_base* __x)
      : _M_node(__x) { }

      _List_const_iterator(const iterator& __x)
      : _M_node(__x._M_node) { }



      reference
      operator*() const
      { return static_cast<_Node*>(_M_node)->_M_data; }

      pointer
      operator->() const
      { return &static_cast<_Node*>(_M_node)->_M_data; }

      _Self&
      operator++()
      {
 _M_node = _M_node->_M_next;
 return *this;
      }

      _Self
      operator++(int)
      {
 _Self __tmp = *this;
 _M_node = _M_node->_M_next;
 return __tmp;
      }

      _Self&
      operator--()
      {
 _M_node = _M_node->_M_prev;
 return *this;
      }

      _Self
      operator--(int)
      {
 _Self __tmp = *this;
 _M_node = _M_node->_M_prev;
 return __tmp;
      }

      bool
      operator==(const _Self& __x) const
      { return _M_node == __x._M_node; }

      bool
      operator!=(const _Self& __x) const
      { return _M_node != __x._M_node; }


      const _List_node_base* _M_node;
    };

  template<typename _Val>
    inline bool
    operator==(const _List_iterator<_Val>& __x,
        const _List_const_iterator<_Val>& __y)
    { return __x._M_node == __y._M_node; }

  template<typename _Val>
    inline bool
    operator!=(const _List_iterator<_Val>& __x,
               const _List_const_iterator<_Val>& __y)
    { return __x._M_node != __y._M_node; }







  template<typename _Tp, typename _Alloc>
    class _List_base
    {
    protected:
# 293 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_list.h" 3
      typedef typename _Alloc::template rebind<_List_node<_Tp> >::other

      _Node_Alloc_type;

      struct _List_impl
 : public _Node_Alloc_type {
 _List_node_base _M_node;
 _List_impl (const _Node_Alloc_type& __a)
   : _Node_Alloc_type(__a)
 { }
      };

      _List_impl _M_impl;

      _List_node<_Tp>*
      _M_get_node()
      { return _M_impl._Node_Alloc_type::allocate(1); }

      void
      _M_put_node(_List_node<_Tp>* __p)
      { _M_impl._Node_Alloc_type::deallocate(__p, 1); }

  public:
      typedef _Alloc allocator_type;

      allocator_type
      get_allocator() const
      { return allocator_type(*static_cast<const _Node_Alloc_type*>(&this->_M_impl)); }

      _List_base(const allocator_type& __a)
 : _M_impl(__a)
      { _M_init(); }


      ~_List_base()
      { _M_clear(); }

      void
      _M_clear();

      void
      _M_init()
      {
        this->_M_impl._M_node._M_next = &this->_M_impl._M_node;
        this->_M_impl._M_node._M_prev = &this->_M_impl._M_node;
      }
    };
# 386 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_list.h" 3
  template<typename _Tp, typename _Alloc = allocator<_Tp> >
    class list : protected _List_base<_Tp, _Alloc>
    {

     

      typedef _List_base<_Tp, _Alloc> _Base;

    public:
      typedef _Tp value_type;
      typedef typename _Alloc::pointer pointer;
      typedef typename _Alloc::const_pointer const_pointer;
      typedef typename _Alloc::reference reference;
      typedef typename _Alloc::const_reference const_reference;
      typedef _List_iterator<_Tp> iterator;
      typedef _List_const_iterator<_Tp> const_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
      typedef std::reverse_iterator<iterator> reverse_iterator;
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef typename _Base::allocator_type allocator_type;

    protected:


      typedef _List_node<_Tp> _Node;







      using _Base::_M_impl;
      using _Base::_M_put_node;
      using _Base::_M_get_node;
# 430 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_list.h" 3
      _Node*
      _M_create_node(const value_type& __x)
      {
 _Node* __p = this->_M_get_node();
 try
   {
     std::_Construct(&__p->_M_data, __x);
   }
 catch(...)
   {
     _M_put_node(__p);
     throw;
   }
 return __p;
      }







      _Node*
      _M_create_node()
      {
 _Node* __p = this->_M_get_node();
 try
   {
     std::_Construct(&__p->_M_data);
   }
 catch(...)
   {
     _M_put_node(__p);
     throw;
   }
 return __p;
      }

    public:





      explicit
      list(const allocator_type& __a = allocator_type())
      : _Base(__a) { }
# 485 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_list.h" 3
      list(size_type __n, const value_type& __value,
    const allocator_type& __a = allocator_type())
      : _Base(__a)
      { this->insert(begin(), __n, __value); }
# 497 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_list.h" 3
      explicit
      list(size_type __n)
      : _Base(allocator_type())
      { this->insert(begin(), __n, value_type()); }
# 509 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_list.h" 3
      list(const list& __x)
      : _Base(__x.get_allocator())
      { this->insert(begin(), __x.begin(), __x.end()); }
# 527 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_list.h" 3
      template<typename _InputIterator>
        list(_InputIterator __first, _InputIterator __last,
      const allocator_type& __a = allocator_type())
        : _Base(__a)
        { this->insert(begin(), __first, __last); }
# 548 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_list.h" 3
      list&
      operator=(const list& __x);
# 561 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_list.h" 3
      void
      assign(size_type __n, const value_type& __val)
      { _M_fill_assign(__n, __val); }
# 577 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_list.h" 3
      template<typename _InputIterator>
        void
        assign(_InputIterator __first, _InputIterator __last)
        {

   typedef typename _Is_integer<_InputIterator>::_Integral _Integral;
   _M_assign_dispatch(__first, __last, _Integral());
 }


      allocator_type
      get_allocator() const
      { return _Base::get_allocator(); }






      iterator
      begin()
      { return this->_M_impl._M_node._M_next; }






      const_iterator
      begin() const
      { return this->_M_impl._M_node._M_next; }






      iterator
      end() { return &this->_M_impl._M_node; }






      const_iterator
      end() const
      { return &this->_M_impl._M_node; }






      reverse_iterator
      rbegin()
      { return reverse_iterator(end()); }






      const_reverse_iterator
      rbegin() const
      { return const_reverse_iterator(end()); }






      reverse_iterator
      rend()
      { return reverse_iterator(begin()); }






      const_reverse_iterator
      rend() const
      { return const_reverse_iterator(begin()); }






      bool
      empty() const
      { return this->_M_impl._M_node._M_next == &this->_M_impl._M_node; }


      size_type
      size() const
      { return std::distance(begin(), end()); }


      size_type
      max_size() const
      { return size_type(-1); }
# 691 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_list.h" 3
      void
      resize(size_type __new_size, const value_type& __x);
# 703 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_list.h" 3
      void
      resize(size_type __new_size)
      { this->resize(__new_size, value_type()); }






      reference
      front()
      { return *begin(); }





      const_reference
      front() const
      { return *begin(); }





      reference
      back()
      { return *(--end()); }





      const_reference
      back() const
      { return *(--end()); }
# 751 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_list.h" 3
      void
      push_front(const value_type& __x)
      { this->_M_insert(begin(), __x); }
# 767 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_list.h" 3
      void
      pop_front()
      { this->_M_erase(begin()); }
# 781 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_list.h" 3
      void
      push_back(const value_type& __x)
      { this->_M_insert(end(), __x); }
# 796 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_list.h" 3
      void
      pop_back()
      { this->_M_erase(this->_M_impl._M_node._M_prev); }
# 811 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_list.h" 3
      iterator
      insert(iterator __position, const value_type& __x);
# 827 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_list.h" 3
      void
      insert(iterator __position, size_type __n, const value_type& __x)
      { _M_fill_insert(__position, __n, __x); }
# 845 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_list.h" 3
      template<typename _InputIterator>
        void
        insert(iterator __position, _InputIterator __first,
        _InputIterator __last)
        {

   typedef typename _Is_integer<_InputIterator>::_Integral _Integral;
   _M_insert_dispatch(__position, __first, __last, _Integral());
 }
# 870 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_list.h" 3
      iterator
      erase(iterator __position);
# 892 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_list.h" 3
      iterator
      erase(iterator __first, iterator __last)
      {
 while (__first != __last)
   __first = erase(__first);
 return __last;
      }
# 909 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_list.h" 3
      void
      swap(list& __x)
      { _List_node_base::swap(this->_M_impl._M_node,__x._M_impl._M_node); }







      void
      clear()
      {
        _Base::_M_clear();
        _Base::_M_init();
      }
# 936 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_list.h" 3
      void
      splice(iterator __position, list& __x)
      {
 if (!__x.empty())
   this->_M_transfer(__position, __x.begin(), __x.end());
      }
# 952 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_list.h" 3
      void
      splice(iterator __position, list&, iterator __i)
      {
 iterator __j = __i;
 ++__j;
 if (__position == __i || __position == __j)
   return;
 this->_M_transfer(__position, __i, __j);
      }
# 974 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_list.h" 3
      void
      splice(iterator __position, list&, iterator __first, iterator __last)
      {
 if (__first != __last)
   this->_M_transfer(__position, __first, __last);
      }
# 992 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_list.h" 3
      void
      remove(const _Tp& __value);
# 1006 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_list.h" 3
      template<typename _Predicate>
      void
      remove_if(_Predicate);
# 1020 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_list.h" 3
      void
      unique();
# 1035 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_list.h" 3
      template<typename _BinaryPredicate>
        void
        unique(_BinaryPredicate);
# 1048 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_list.h" 3
      void
      merge(list& __x);
# 1063 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_list.h" 3
      template<typename _StrictWeakOrdering>
        void
        merge(list&, _StrictWeakOrdering);






      void
      reverse()
      { this->_M_impl._M_node.reverse(); }







      void
      sort();







      template<typename _StrictWeakOrdering>
        void
        sort(_StrictWeakOrdering);

    protected:



      template<typename _Integer>
        void
        _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)
        {
   _M_fill_assign(static_cast<size_type>(__n),
    static_cast<value_type>(__val));
 }


      template<typename _InputIterator>
        void
        _M_assign_dispatch(_InputIterator __first, _InputIterator __last,
      __false_type);



      void
      _M_fill_assign(size_type __n, const value_type& __val);





      template<typename _Integer>
        void
        _M_insert_dispatch(iterator __pos, _Integer __n, _Integer __x,
      __true_type)
        {
   _M_fill_insert(__pos, static_cast<size_type>(__n),
    static_cast<value_type>(__x));
 }


      template<typename _InputIterator>
        void
        _M_insert_dispatch(iterator __pos,
      _InputIterator __first, _InputIterator __last,
      __false_type)
        {
   for ( ; __first != __last; ++__first)
     _M_insert(__pos, *__first);
 }



      void
      _M_fill_insert(iterator __pos, size_type __n, const value_type& __x)
      {
 for ( ; __n > 0; --__n)
   _M_insert(__pos, __x);
      }



      void
      _M_transfer(iterator __position, iterator __first, iterator __last)
      { __position._M_node->transfer(__first._M_node,__last._M_node); }


      void
      _M_insert(iterator __position, const value_type& __x)
      {
        _Node* __tmp = _M_create_node(__x);
        __tmp->hook(__position._M_node);
      }


      void
      _M_erase(iterator __position)
      {
        __position._M_node->unhook();
        _Node* __n = static_cast<_Node*>(__position._M_node);
        std::_Destroy(&__n->_M_data);
        _M_put_node(__n);
      }
    };
# 1186 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_list.h" 3
  template<typename _Tp, typename _Alloc>
    inline bool
    operator==(const list<_Tp,_Alloc>& __x, const list<_Tp,_Alloc>& __y)
    {
      typedef typename list<_Tp,_Alloc>::const_iterator const_iterator;
      const_iterator __end1 = __x.end();
      const_iterator __end2 = __y.end();

      const_iterator __i1 = __x.begin();
      const_iterator __i2 = __y.begin();
      while (__i1 != __end1 && __i2 != __end2 && *__i1 == *__i2)
 {
   ++__i1;
   ++__i2;
 }
      return __i1 == __end1 && __i2 == __end2;
    }
# 1215 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_list.h" 3
  template<typename _Tp, typename _Alloc>
    inline bool
    operator<(const list<_Tp,_Alloc>& __x, const list<_Tp,_Alloc>& __y)
    { return std::lexicographical_compare(__x.begin(), __x.end(),
       __y.begin(), __y.end()); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator!=(const list<_Tp,_Alloc>& __x, const list<_Tp,_Alloc>& __y)
    { return !(__x == __y); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator>(const list<_Tp,_Alloc>& __x, const list<_Tp,_Alloc>& __y)
    { return __y < __x; }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator<=(const list<_Tp,_Alloc>& __x, const list<_Tp,_Alloc>& __y)
    { return !(__y < __x); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator>=(const list<_Tp,_Alloc>& __x, const list<_Tp,_Alloc>& __y)
    { return !(__x < __y); }


  template<typename _Tp, typename _Alloc>
    inline void
    swap(list<_Tp, _Alloc>& __x, list<_Tp, _Alloc>& __y)
    { __x.swap(__y); }
}
# 72 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/list" 2 3


# 1 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/list.tcc" 1 3
# 64 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/list.tcc" 3
namespace std
{
  template<typename _Tp, typename _Alloc>
    void
    _List_base<_Tp,_Alloc>::
    _M_clear()
    {
      typedef _List_node<_Tp> _Node;
      _Node* __cur = static_cast<_Node*>(this->_M_impl._M_node._M_next);
      while (__cur != &this->_M_impl._M_node)
      {
        _Node* __tmp = __cur;
        __cur = static_cast<_Node*>(__cur->_M_next);
        std::_Destroy(&__tmp->_M_data);
        _M_put_node(__tmp);
      }
    }

  template<typename _Tp, typename _Alloc>
    typename list<_Tp,_Alloc>::iterator
    list<_Tp,_Alloc>::
    insert(iterator __position, const value_type& __x)
    {
      _Node* __tmp = _M_create_node(__x);
      __tmp->hook(__position._M_node);
      return __tmp;
    }

  template<typename _Tp, typename _Alloc>
    typename list<_Tp,_Alloc>::iterator
    list<_Tp,_Alloc>::
    erase(iterator __position)
    {
      iterator __ret = __position._M_node->_M_next;
      _M_erase(__position);
      return __ret;
    }

  template<typename _Tp, typename _Alloc>
    void
    list<_Tp,_Alloc>::
    resize(size_type __new_size, const value_type& __x)
    {
      iterator __i = begin();
      size_type __len = 0;
      for ( ; __i != end() && __len < __new_size; ++__i, ++__len)
        ;
      if (__len == __new_size)
        erase(__i, end());
      else
        insert(end(), __new_size - __len, __x);
    }

  template<typename _Tp, typename _Alloc>
    list<_Tp,_Alloc>&
    list<_Tp,_Alloc>::
    operator=(const list& __x)
    {
      if (this != &__x)
 {
   iterator __first1 = begin();
   iterator __last1 = end();
   const_iterator __first2 = __x.begin();
   const_iterator __last2 = __x.end();
   while (__first1 != __last1 && __first2 != __last2)
     *__first1++ = *__first2++;
   if (__first2 == __last2)
     erase(__first1, __last1);
   else
     insert(__last1, __first2, __last2);
 }
      return *this;
    }

  template<typename _Tp, typename _Alloc>
    void
    list<_Tp,_Alloc>::
    _M_fill_assign(size_type __n, const value_type& __val)
    {
      iterator __i = begin();
      for ( ; __i != end() && __n > 0; ++__i, --__n)
        *__i = __val;
      if (__n > 0)
        insert(end(), __n, __val);
      else
        erase(__i, end());
    }

  template<typename _Tp, typename _Alloc>
    template <typename _InputIterator>
      void
      list<_Tp,_Alloc>::
      _M_assign_dispatch(_InputIterator __first2, _InputIterator __last2,
    __false_type)
      {
        iterator __first1 = begin();
        iterator __last1 = end();
        for (; __first1 != __last1 && __first2 != __last2;
      ++__first1, ++__first2)
          *__first1 = *__first2;
        if (__first2 == __last2)
          erase(__first1, __last1);
        else
          insert(__last1, __first2, __last2);
      }

  template<typename _Tp, typename _Alloc>
    void
    list<_Tp,_Alloc>::
    remove(const value_type& __value)
    {
      iterator __first = begin();
      iterator __last = end();
      while (__first != __last)
      {
        iterator __next = __first;
        ++__next;
        if (*__first == __value)
          _M_erase(__first);
        __first = __next;
      }
    }

  template<typename _Tp, typename _Alloc>
    void
    list<_Tp,_Alloc>::
    unique()
    {
      iterator __first = begin();
      iterator __last = end();
      if (__first == __last)
 return;
      iterator __next = __first;
      while (++__next != __last)
      {
        if (*__first == *__next)
          _M_erase(__next);
        else
          __first = __next;
        __next = __first;
      }
    }

  template<typename _Tp, typename _Alloc>
    void
    list<_Tp,_Alloc>::
    merge(list& __x)
    {


      if (this != &__x)
 {
   iterator __first1 = begin();
   iterator __last1 = end();
   iterator __first2 = __x.begin();
   iterator __last2 = __x.end();
   while (__first1 != __last1 && __first2 != __last2)
     if (*__first2 < *__first1)
       {
  iterator __next = __first2;
  _M_transfer(__first1, __first2, ++__next);
  __first2 = __next;
       }
     else
       ++__first1;
   if (__first2 != __last2)
     _M_transfer(__last1, __first2, __last2);
 }
    }

  template<typename _Tp, typename _Alloc>
    void
    list<_Tp,_Alloc>::
    sort()
    {

      if (this->_M_impl._M_node._M_next != &this->_M_impl._M_node
   && this->_M_impl._M_node._M_next->_M_next != &this->_M_impl._M_node)
      {
        list __carry;
        list __tmp[64];
        list * __fill = &__tmp[0];
        list * __counter;

        do
   {
     __carry.splice(__carry.begin(), *this, begin());

     for(__counter = &__tmp[0];
  (__counter != __fill) && !__counter->empty();
  ++__counter)
       {
  __counter->merge(__carry);
  __carry.swap(*__counter);
       }
     __carry.swap(*__counter);
     if (__counter == __fill)
       ++__fill;
   }
 while ( !empty() );

        for (__counter = &__tmp[1]; __counter != __fill; ++__counter)
          __counter->merge( *(__counter-1) );
        swap( *(__fill-1) );
      }
    }

  template<typename _Tp, typename _Alloc>
    template <typename _Predicate>
      void
      list<_Tp,_Alloc>::
      remove_if(_Predicate __pred)
      {
        iterator __first = begin();
        iterator __last = end();
        while (__first != __last)
        {
          iterator __next = __first;
          ++__next;
          if (__pred(*__first))
     _M_erase(__first);
          __first = __next;
        }
      }

  template<typename _Tp, typename _Alloc>
    template <typename _BinaryPredicate>
      void
      list<_Tp,_Alloc>::
      unique(_BinaryPredicate __binary_pred)
      {
        iterator __first = begin();
        iterator __last = end();
        if (__first == __last) return;
        iterator __next = __first;
        while (++__next != __last)
        {
          if (__binary_pred(*__first, *__next))
            _M_erase(__next);
          else
            __first = __next;
          __next = __first;
        }
      }

  template<typename _Tp, typename _Alloc>
    template <typename _StrictWeakOrdering>
      void
      list<_Tp,_Alloc>::
      merge(list& __x, _StrictWeakOrdering __comp)
      {


 if (this != &__x)
   {
     iterator __first1 = begin();
     iterator __last1 = end();
     iterator __first2 = __x.begin();
     iterator __last2 = __x.end();
     while (__first1 != __last1 && __first2 != __last2)
       if (__comp(*__first2, *__first1))
  {
    iterator __next = __first2;
    _M_transfer(__first1, __first2, ++__next);
    __first2 = __next;
  }
       else
  ++__first1;
     if (__first2 != __last2)
       _M_transfer(__last1, __first2, __last2);
   }
      }

  template<typename _Tp, typename _Alloc>
    template <typename _StrictWeakOrdering>
      void
      list<_Tp,_Alloc>::
      sort(_StrictWeakOrdering __comp)
      {

 if (this->_M_impl._M_node._M_next != &this->_M_impl._M_node
     && this->_M_impl._M_node._M_next->_M_next != &this->_M_impl._M_node)
   {
     list __carry;
     list __tmp[64];
     list * __fill = &__tmp[0];
     list * __counter;

     do
       {
  __carry.splice(__carry.begin(), *this, begin());

  for(__counter = &__tmp[0];
      (__counter != __fill) && !__counter->empty();
      ++__counter)
    {
      __counter->merge(__carry, __comp);
      __carry.swap(*__counter);
    }
  __carry.swap(*__counter);
  if (__counter == __fill)
    ++__fill;
       }
     while ( !empty() );

     for (__counter = &__tmp[1]; __counter != __fill; ++__counter)
       __counter->merge( *(__counter-1), __comp );
     swap( *(__fill-1) );
   }
      }
}
# 75 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/list" 2 3
# 63 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/backward/list.h" 2

using std::list;
# 5 "gamespace.h" 2
# 1 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/backward/vector.h" 1
# 62 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/backward/vector.h"
# 1 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/vector" 1
# 64 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/vector"
       
# 65 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/vector" 3

# 1 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/functexcept.h" 1 3
# 36 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/functexcept.h" 3
namespace std
{

  void
  __throw_bad_exception(void);


  void
  __throw_bad_alloc(void);


  void
  __throw_bad_cast(void);

  void
  __throw_bad_typeid(void);


  void
  __throw_logic_error(const char* __s);

  void
  __throw_domain_error(const char* __s);

  void
  __throw_invalid_argument(const char* __s);

  void
  __throw_length_error(const char* __s);

  void
  __throw_out_of_range(const char* __s);

  void
  __throw_runtime_error(const char* __s);

  void
  __throw_range_error(const char* __s);

  void
  __throw_overflow_error(const char* __s);

  void
  __throw_underflow_error(const char* __s);


  void
  __throw_ios_failure(const char* __s);
}
# 67 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/vector" 2 3




# 1 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_vector.h" 1 3
# 65 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_vector.h" 3
# 1 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/functexcept.h" 1 3
# 36 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/functexcept.h" 3
namespace std
{

  void
  __throw_bad_exception(void);


  void
  __throw_bad_alloc(void);


  void
  __throw_bad_cast(void);

  void
  __throw_bad_typeid(void);


  void
  __throw_logic_error(const char* __s);

  void
  __throw_domain_error(const char* __s);

  void
  __throw_invalid_argument(const char* __s);

  void
  __throw_length_error(const char* __s);

  void
  __throw_out_of_range(const char* __s);

  void
  __throw_runtime_error(const char* __s);

  void
  __throw_range_error(const char* __s);

  void
  __throw_overflow_error(const char* __s);

  void
  __throw_underflow_error(const char* __s);


  void
  __throw_ios_failure(const char* __s);
}
# 66 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_vector.h" 2 3


namespace std
{





  template<typename _Tp, typename _Alloc>
    struct _Vector_base
    {
      struct _Vector_impl
 : public _Alloc {
 _Tp* _M_start;
 _Tp* _M_finish;
 _Tp* _M_end_of_storage;
 _Vector_impl (_Alloc const& __a)
   : _Alloc(__a), _M_start(0), _M_finish(0), _M_end_of_storage(0)
 { }
      };

    public:
      typedef _Alloc allocator_type;

      allocator_type
      get_allocator() const { return *static_cast<const _Alloc*>(&this->_M_impl); }

      _Vector_base(const allocator_type& __a) : _M_impl(__a)
      { }

      _Vector_base(size_t __n, const allocator_type& __a)
 : _M_impl(__a)
      {
 this->_M_impl._M_start = this->_M_allocate(__n);
 this->_M_impl._M_finish = this->_M_impl._M_start;
 this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
      }

      ~_Vector_base()
      { _M_deallocate(this->_M_impl._M_start,
        this->_M_impl._M_end_of_storage - this->_M_impl._M_start); }

    public:
      _Vector_impl _M_impl;

      _Tp*
      _M_allocate(size_t __n) { return _M_impl.allocate(__n); }

      void
      _M_deallocate(_Tp* __p, size_t __n)
      { if (__p) _M_impl.deallocate(__p, __n); }
    };
# 140 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_vector.h" 3
  template<typename _Tp, typename _Alloc = allocator<_Tp> >
    class vector : protected _Vector_base<_Tp, _Alloc>
    {

     

      typedef _Vector_base<_Tp, _Alloc> _Base;
      typedef vector<_Tp, _Alloc> vector_type;

    public:
      typedef _Tp value_type;
      typedef typename _Alloc::pointer pointer;
      typedef typename _Alloc::const_pointer const_pointer;
      typedef typename _Alloc::reference reference;
      typedef typename _Alloc::const_reference const_reference;
      typedef __gnu_cxx::__normal_iterator<pointer, vector_type> iterator;
      typedef __gnu_cxx::__normal_iterator<const_pointer, vector_type>
      const_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
      typedef std::reverse_iterator<iterator> reverse_iterator;
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef typename _Base::allocator_type allocator_type;

    protected:





      using _Base::_M_allocate;
      using _Base::_M_deallocate;
      using _Base::_M_impl;

    public:





      explicit
      vector(const allocator_type& __a = allocator_type())
      : _Base(__a) { }
# 191 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_vector.h" 3
      vector(size_type __n, const value_type& __value,
      const allocator_type& __a = allocator_type())
      : _Base(__n, __a)
      { this->_M_impl._M_finish = std::uninitialized_fill_n(this->_M_impl._M_start,
          __n, __value); }
# 204 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_vector.h" 3
      explicit
      vector(size_type __n)
      : _Base(__n, allocator_type())
      { this->_M_impl._M_finish = std::uninitialized_fill_n(this->_M_impl._M_start,
          __n, value_type()); }
# 219 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_vector.h" 3
      vector(const vector& __x)
      : _Base(__x.size(), __x.get_allocator())
      { this->_M_impl._M_finish = std::uninitialized_copy(__x.begin(), __x.end(),
        this->_M_impl._M_start);
      }
# 240 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_vector.h" 3
      template<typename _InputIterator>
        vector(_InputIterator __first, _InputIterator __last,
        const allocator_type& __a = allocator_type())
 : _Base(__a)
        {

   typedef typename _Is_integer<_InputIterator>::_Integral _Integral;
   _M_initialize_dispatch(__first, __last, _Integral());
 }







      ~vector() { std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish); }
# 266 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_vector.h" 3
      vector&
      operator=(const vector& __x);
# 279 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_vector.h" 3
      void
      assign(size_type __n, const value_type& __val)
      { _M_fill_assign(__n, __val); }
# 295 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_vector.h" 3
      template<typename _InputIterator>
        void
        assign(_InputIterator __first, _InputIterator __last)
        {

   typedef typename _Is_integer<_InputIterator>::_Integral _Integral;
   _M_assign_dispatch(__first, __last, _Integral());
 }


      using _Base::get_allocator;







      iterator
      begin() { return iterator (this->_M_impl._M_start); }






      const_iterator
      begin() const { return const_iterator (this->_M_impl._M_start); }






      iterator
      end() { return iterator (this->_M_impl._M_finish); }






      const_iterator
      end() const { return const_iterator (this->_M_impl._M_finish); }






      reverse_iterator
      rbegin() { return reverse_iterator(end()); }






      const_reverse_iterator
      rbegin() const { return const_reverse_iterator(end()); }






      reverse_iterator
      rend() { return reverse_iterator(begin()); }






      const_reverse_iterator
      rend() const { return const_reverse_iterator(begin()); }



      size_type
      size() const { return size_type(end() - begin()); }


      size_type
      max_size() const { return size_type(-1) / sizeof(value_type); }
# 392 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_vector.h" 3
      void
      resize(size_type __new_size, const value_type& __x)
      {
 if (__new_size < size())
   erase(begin() + __new_size, end());
 else
   insert(end(), __new_size - size(), __x);
      }
# 411 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_vector.h" 3
      void
      resize(size_type __new_size) { resize(__new_size, value_type()); }





      size_type
      capacity() const
      { return size_type(const_iterator(this->_M_impl._M_end_of_storage) - begin()); }





      bool
      empty() const { return begin() == end(); }
# 446 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_vector.h" 3
      void
      reserve(size_type __n);
# 461 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_vector.h" 3
      reference
      operator[](size_type __n) { return *(begin() + __n); }
# 475 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_vector.h" 3
      const_reference
      operator[](size_type __n) const { return *(begin() + __n); }

    protected:

      void
      _M_range_check(size_type __n) const
      {
 if (__n >= this->size())
   __throw_out_of_range(("vector::_M_range_check"));
      }

    public:
# 499 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_vector.h" 3
      reference
      at(size_type __n) { _M_range_check(__n); return (*this)[__n]; }
# 513 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_vector.h" 3
      const_reference
      at(size_type __n) const { _M_range_check(__n); return (*this)[__n]; }





      reference
      front() { return *begin(); }





      const_reference
      front() const { return *begin(); }





      reference
      back() { return *(end() - 1); }





      const_reference
      back() const { return *(end() - 1); }
# 555 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_vector.h" 3
      void
      push_back(const value_type& __x)
      {
 if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
   {
     std::_Construct(this->_M_impl._M_finish, __x);
     ++this->_M_impl._M_finish;
   }
 else
   _M_insert_aux(end(), __x);
      }
# 576 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_vector.h" 3
      void
      pop_back()
      {
 --this->_M_impl._M_finish;
 std::_Destroy(this->_M_impl._M_finish);
      }
# 594 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_vector.h" 3
      iterator
      insert(iterator __position, const value_type& __x);
# 610 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_vector.h" 3
      void
      insert(iterator __position, size_type __n, const value_type& __x)
      { _M_fill_insert(__position, __n, __x); }
# 628 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_vector.h" 3
      template<typename _InputIterator>
        void
        insert(iterator __position, _InputIterator __first,
        _InputIterator __last)
        {

   typedef typename _Is_integer<_InputIterator>::_Integral _Integral;
   _M_insert_dispatch(__position, __first, __last, _Integral());
 }
# 653 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_vector.h" 3
      iterator
      erase(iterator __position);
# 674 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_vector.h" 3
      iterator
      erase(iterator __first, iterator __last);
# 686 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_vector.h" 3
      void
      swap(vector& __x)
      {
 std::swap(this->_M_impl._M_start, __x._M_impl._M_start);
 std::swap(this->_M_impl._M_finish, __x._M_impl._M_finish);
 std::swap(this->_M_impl._M_end_of_storage, __x._M_impl._M_end_of_storage);
      }







      void
      clear() { erase(begin(), end()); }

    protected:






      template<typename _ForwardIterator>
        pointer
        _M_allocate_and_copy(size_type __n,
        _ForwardIterator __first, _ForwardIterator __last)
        {
   pointer __result = this->_M_allocate(__n);
   try
     {
       std::uninitialized_copy(__first, __last, __result);
       return __result;
     }
   catch(...)
     {
       _M_deallocate(__result, __n);
       throw;
     }
 }





      template<typename _Integer>
        void
        _M_initialize_dispatch(_Integer __n, _Integer __value, __true_type)
        {
   this->_M_impl._M_start = _M_allocate(__n);
   this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
   this->_M_impl._M_finish = std::uninitialized_fill_n(this->_M_impl._M_start,
            __n, __value);
 }


      template<typename _InputIterator>
        void
        _M_initialize_dispatch(_InputIterator __first, _InputIterator __last,
          __false_type)
        {
   typedef typename iterator_traits<_InputIterator>::iterator_category
     _IterCategory;
   _M_range_initialize(__first, __last, _IterCategory());
 }


      template<typename _InputIterator>
        void
        _M_range_initialize(_InputIterator __first,
       _InputIterator __last, input_iterator_tag)
        {
   for ( ; __first != __last; ++__first)
     push_back(*__first);
 }


      template<typename _ForwardIterator>
        void
        _M_range_initialize(_ForwardIterator __first,
       _ForwardIterator __last, forward_iterator_tag)
        {
   size_type __n = std::distance(__first, __last);
   this->_M_impl._M_start = this->_M_allocate(__n);
   this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
   this->_M_impl._M_finish = std::uninitialized_copy(__first, __last,
          this->_M_impl._M_start);
 }






      template<typename _Integer>
        void
        _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)
        {
   _M_fill_assign(static_cast<size_type>(__n),
    static_cast<value_type>(__val));
 }


      template<typename _InputIterator>
        void
        _M_assign_dispatch(_InputIterator __first, _InputIterator __last,
      __false_type)
        {
   typedef typename iterator_traits<_InputIterator>::iterator_category
     _IterCategory;
   _M_assign_aux(__first, __last, _IterCategory());
 }


      template<typename _InputIterator>
        void
        _M_assign_aux(_InputIterator __first, _InputIterator __last,
        input_iterator_tag);


      template<typename _ForwardIterator>
        void
        _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
        forward_iterator_tag);



      void
      _M_fill_assign(size_type __n, const value_type& __val);





      template<typename _Integer>
        void
        _M_insert_dispatch(iterator __pos, _Integer __n, _Integer __val,
      __true_type)
        {
   _M_fill_insert(__pos, static_cast<size_type>(__n),
    static_cast<value_type>(__val));
 }


      template<typename _InputIterator>
        void
        _M_insert_dispatch(iterator __pos, _InputIterator __first,
      _InputIterator __last, __false_type)
        {
   typedef typename iterator_traits<_InputIterator>::iterator_category
     _IterCategory;
   _M_range_insert(__pos, __first, __last, _IterCategory());
 }


      template<typename _InputIterator>
        void
        _M_range_insert(iterator __pos, _InputIterator __first,
   _InputIterator __last, input_iterator_tag);


      template<typename _ForwardIterator>
        void
        _M_range_insert(iterator __pos, _ForwardIterator __first,
   _ForwardIterator __last, forward_iterator_tag);



      void
      _M_fill_insert(iterator __pos, size_type __n, const value_type& __x);


      void
      _M_insert_aux(iterator __position, const value_type& __x);
    };
# 874 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_vector.h" 3
  template<typename _Tp, typename _Alloc>
    inline bool
    operator==(const vector<_Tp,_Alloc>& __x, const vector<_Tp,_Alloc>& __y)
    {
      return __x.size() == __y.size() &&
             std::equal(__x.begin(), __x.end(), __y.begin());
    }
# 893 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_vector.h" 3
  template<typename _Tp, typename _Alloc>
    inline bool
    operator<(const vector<_Tp,_Alloc>& __x, const vector<_Tp,_Alloc>& __y)
    {
      return std::lexicographical_compare(__x.begin(), __x.end(),
       __y.begin(), __y.end());
    }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator!=(const vector<_Tp,_Alloc>& __x, const vector<_Tp,_Alloc>& __y)
    { return !(__x == __y); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator>(const vector<_Tp,_Alloc>& __x, const vector<_Tp,_Alloc>& __y)
    { return __y < __x; }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator<=(const vector<_Tp,_Alloc>& __x, const vector<_Tp,_Alloc>& __y)
    { return !(__y < __x); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator>=(const vector<_Tp,_Alloc>& __x, const vector<_Tp,_Alloc>& __y)
    { return !(__x < __y); }


  template<typename _Tp, typename _Alloc>
    inline void
    swap(vector<_Tp,_Alloc>& __x, vector<_Tp,_Alloc>& __y)
    { __x.swap(__y); }
}
# 72 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/vector" 2 3
# 1 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_bvector.h" 1 3
# 64 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_bvector.h" 3
namespace std
{
  typedef unsigned long _Bit_type;
  enum { _S_word_bit = int(8 * sizeof(_Bit_type)) };

  struct _Bit_reference
  {
    _Bit_type * _M_p;
    _Bit_type _M_mask;

    _Bit_reference(_Bit_type * __x, _Bit_type __y)
    : _M_p(__x), _M_mask(__y) { }

    _Bit_reference() : _M_p(0), _M_mask(0) { }

    operator bool() const { return !!(*_M_p & _M_mask); }

    _Bit_reference&
    operator=(bool __x)
    {
      if (__x)
 *_M_p |= _M_mask;
      else
 *_M_p &= ~_M_mask;
      return *this;
    }

    _Bit_reference&
    operator=(const _Bit_reference& __x)
    { return *this = bool(__x); }

    bool
    operator==(const _Bit_reference& __x) const
    { return bool(*this) == bool(__x); }

    bool
    operator<(const _Bit_reference& __x) const
    { return !bool(*this) && bool(__x); }

    void
    flip() { *_M_p ^= _M_mask; }
  };

  struct _Bit_iterator_base : public iterator<random_access_iterator_tag, bool>
  {
    _Bit_type * _M_p;
    unsigned int _M_offset;

    _Bit_iterator_base(_Bit_type * __x, unsigned int __y)
    : _M_p(__x), _M_offset(__y) { }

    void
    _M_bump_up()
    {
      if (_M_offset++ == _S_word_bit - 1)
 {
   _M_offset = 0;
   ++_M_p;
 }
    }

    void
    _M_bump_down()
    {
      if (_M_offset-- == 0)
 {
   _M_offset = _S_word_bit - 1;
   --_M_p;
 }
    }

    void
    _M_incr(ptrdiff_t __i)
    {
      difference_type __n = __i + _M_offset;
      _M_p += __n / _S_word_bit;
      __n = __n % _S_word_bit;
      if (__n < 0)
 {
   _M_offset = static_cast<unsigned int>(__n + _S_word_bit);
   --_M_p;
 }
      else
 _M_offset = static_cast<unsigned int>(__n);
    }

    bool
    operator==(const _Bit_iterator_base& __i) const
    { return _M_p == __i._M_p && _M_offset == __i._M_offset; }

    bool
    operator<(const _Bit_iterator_base& __i) const
    {
      return _M_p < __i._M_p
      || (_M_p == __i._M_p && _M_offset < __i._M_offset);
    }

    bool
    operator!=(const _Bit_iterator_base& __i) const
    { return !(*this == __i); }

    bool
    operator>(const _Bit_iterator_base& __i) const
    { return __i < *this; }

    bool
    operator<=(const _Bit_iterator_base& __i) const
    { return !(__i < *this); }

    bool
    operator>=(const _Bit_iterator_base& __i) const
    { return !(*this < __i); }
  };

  inline ptrdiff_t
  operator-(const _Bit_iterator_base& __x, const _Bit_iterator_base& __y)
  {
    return _S_word_bit * (__x._M_p - __y._M_p) + __x._M_offset - __y._M_offset;
  }

  struct _Bit_iterator : public _Bit_iterator_base
  {
    typedef _Bit_reference reference;
    typedef _Bit_reference* pointer;
    typedef _Bit_iterator iterator;

    _Bit_iterator() : _Bit_iterator_base(0, 0) { }
    _Bit_iterator(_Bit_type * __x, unsigned int __y)
    : _Bit_iterator_base(__x, __y) { }

    reference
    operator*() const { return reference(_M_p, 1UL << _M_offset); }

    iterator&
    operator++()
    {
      _M_bump_up();
      return *this;
    }

    iterator
    operator++(int)
    {
      iterator __tmp = *this;
      _M_bump_up();
      return __tmp;
    }

    iterator&
    operator--()
    {
      _M_bump_down();
      return *this;
    }

    iterator
    operator--(int)
    {
      iterator __tmp = *this;
      _M_bump_down();
      return __tmp;
    }

    iterator&
    operator+=(difference_type __i)
    {
      _M_incr(__i);
      return *this;
    }

    iterator&
    operator-=(difference_type __i)
    {
      *this += -__i;
      return *this;
    }

    iterator
    operator+(difference_type __i) const
    {
      iterator __tmp = *this;
      return __tmp += __i;
    }

    iterator
    operator-(difference_type __i) const
    {
      iterator __tmp = *this;
      return __tmp -= __i;
    }

    reference
    operator[](difference_type __i)
    { return *(*this + __i); }
  };

  inline _Bit_iterator
  operator+(ptrdiff_t __n, const _Bit_iterator& __x) { return __x + __n; }


  struct _Bit_const_iterator : public _Bit_iterator_base
  {
    typedef bool reference;
    typedef bool const_reference;
    typedef const bool* pointer;
    typedef _Bit_const_iterator const_iterator;

    _Bit_const_iterator() : _Bit_iterator_base(0, 0) { }
    _Bit_const_iterator(_Bit_type * __x, unsigned int __y)
    : _Bit_iterator_base(__x, __y) { }
    _Bit_const_iterator(const _Bit_iterator& __x)
    : _Bit_iterator_base(__x._M_p, __x._M_offset) { }

    const_reference
    operator*() const
    { return _Bit_reference(_M_p, 1UL << _M_offset); }

    const_iterator&
    operator++()
    {
      _M_bump_up();
      return *this;
    }

    const_iterator
    operator++(int)
    {
      const_iterator __tmp = *this;
      _M_bump_up();
      return __tmp;
    }

    const_iterator&
    operator--()
    {
      _M_bump_down();
      return *this;
    }

    const_iterator
    operator--(int)
    {
      const_iterator __tmp = *this;
      _M_bump_down();
      return __tmp;
    }

    const_iterator&
    operator+=(difference_type __i)
    {
      _M_incr(__i);
      return *this;
    }

    const_iterator&
    operator-=(difference_type __i)
    {
      *this += -__i;
      return *this;
    }

    const_iterator
    operator+(difference_type __i) const {
      const_iterator __tmp = *this;
      return __tmp += __i;
    }

    const_iterator
    operator-(difference_type __i) const
    {
      const_iterator __tmp = *this;
      return __tmp -= __i;
    }

    const_reference
    operator[](difference_type __i)
    { return *(*this + __i); }
  };

  inline _Bit_const_iterator
  operator+(ptrdiff_t __n, const _Bit_const_iterator& __x)
  { return __x + __n; }

  template<class _Alloc>
    class _Bvector_base
    {
      typedef typename _Alloc::template rebind<_Bit_type>::other
        _Bit_alloc_type;

      struct _Bvector_impl : public _Bit_alloc_type
      {
 _Bit_iterator _M_start;
 _Bit_iterator _M_finish;
 _Bit_type* _M_end_of_storage;
 _Bvector_impl(const _Bit_alloc_type& __a)
 : _Bit_alloc_type(__a), _M_start(), _M_finish(), _M_end_of_storage(0)
 { }
      };

    public:
      typedef _Alloc allocator_type;

      allocator_type
      get_allocator() const
      { return *static_cast<const _Bit_alloc_type*>(&this->_M_impl); }

      _Bvector_base(const allocator_type& __a) : _M_impl(__a) { }

      ~_Bvector_base() { this->_M_deallocate(); }

    protected:
      _Bvector_impl _M_impl;

      _Bit_type*
      _M_allocate(size_t __n)
      { return _M_impl.allocate((__n + _S_word_bit - 1) / _S_word_bit); }

      void
      _M_deallocate()
      {
 if (_M_impl._M_start._M_p)
   _M_impl.deallocate(_M_impl._M_start._M_p,
       _M_impl._M_end_of_storage - _M_impl._M_start._M_p);
      }
    };
}




namespace std
{
# 414 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/stl_bvector.h" 3
template<typename _Alloc>
  class vector<bool, _Alloc> : public _Bvector_base<_Alloc>
  {
  public:
    typedef bool value_type;
    typedef size_t size_type;
    typedef ptrdiff_t difference_type;
    typedef _Bit_reference reference;
    typedef bool const_reference;
    typedef _Bit_reference* pointer;
    typedef const bool* const_pointer;

    typedef _Bit_iterator iterator;
    typedef _Bit_const_iterator const_iterator;

    typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
    typedef std::reverse_iterator<iterator> reverse_iterator;

    typedef typename _Bvector_base<_Alloc>::allocator_type allocator_type;

    allocator_type get_allocator() const
    { return _Bvector_base<_Alloc>::get_allocator(); }

  protected:
    using _Bvector_base<_Alloc>::_M_allocate;
    using _Bvector_base<_Alloc>::_M_deallocate;

  protected:
    void _M_initialize(size_type __n)
    {
      _Bit_type* __q = this->_M_allocate(__n);
      this->_M_impl._M_end_of_storage = __q
                                + (__n + _S_word_bit - 1) / _S_word_bit;
      this->_M_impl._M_start = iterator(__q, 0);
      this->_M_impl._M_finish = this->_M_impl._M_start + difference_type(__n);
    }

    void _M_insert_aux(iterator __position, bool __x)
    {
      if (this->_M_impl._M_finish._M_p != this->_M_impl._M_end_of_storage)
 {
   std::copy_backward(__position, this->_M_impl._M_finish,
        this->_M_impl._M_finish + 1);
   *__position = __x;
   ++this->_M_impl._M_finish;
 }
      else
 {
   const size_type __len = size() ? 2 * size()
                                  : static_cast<size_type>(_S_word_bit);
   _Bit_type * __q = this->_M_allocate(__len);
   iterator __i = std::copy(begin(), __position, iterator(__q, 0));
   *__i++ = __x;
   this->_M_impl._M_finish = std::copy(__position, end(), __i);
   this->_M_deallocate();
   this->_M_impl._M_end_of_storage = __q + (__len + _S_word_bit - 1)
        / _S_word_bit;
   this->_M_impl._M_start = iterator(__q, 0);
 }
    }

    template<class _InputIterator>
    void _M_initialize_range(_InputIterator __first, _InputIterator __last,
                             input_iterator_tag)
    {
      this->_M_impl._M_start = iterator();
      this->_M_impl._M_finish = iterator();
      this->_M_impl._M_end_of_storage = 0;
      for ( ; __first != __last; ++__first)
        push_back(*__first);
    }

    template<class _ForwardIterator>
    void _M_initialize_range(_ForwardIterator __first, _ForwardIterator __last,
                             forward_iterator_tag)
    {
      const size_type __n = std::distance(__first, __last);
      _M_initialize(__n);
      std::copy(__first, __last, this->_M_impl._M_start);
    }

    template<class _InputIterator>
    void _M_insert_range(iterator __pos, _InputIterator __first,
    _InputIterator __last, input_iterator_tag)
    {
      for ( ; __first != __last; ++__first)
 {
   __pos = insert(__pos, *__first);
   ++__pos;
 }
    }

    template<class _ForwardIterator>
    void _M_insert_range(iterator __position, _ForwardIterator __first,
    _ForwardIterator __last, forward_iterator_tag)
    {
      if (__first != __last)
 {
   size_type __n = std::distance(__first, __last);
   if (capacity() - size() >= __n)
     {
       std::copy_backward(__position, end(),
          this->_M_impl._M_finish + difference_type(__n));
       std::copy(__first, __last, __position);
       this->_M_impl._M_finish += difference_type(__n);
     }
   else
     {
       const size_type __len = size() + std::max(size(), __n);
       _Bit_type * __q = this->_M_allocate(__len);
       iterator __i = std::copy(begin(), __position, iterator(__q, 0));
       __i = std::copy(__first, __last, __i);
       this->_M_impl._M_finish = std::copy(__position, end(), __i);
       this->_M_deallocate();
       this->_M_impl._M_end_of_storage = __q + (__len + _S_word_bit - 1)
                                  / _S_word_bit;
       this->_M_impl._M_start = iterator(__q, 0);
     }
 }
    }

  public:
    iterator begin()
    { return this->_M_impl._M_start; }

    const_iterator begin() const
    { return this->_M_impl._M_start; }

    iterator end()
    { return this->_M_impl._M_finish; }

    const_iterator end() const
    { return this->_M_impl._M_finish; }

    reverse_iterator rbegin()
    { return reverse_iterator(end()); }

    const_reverse_iterator rbegin() const
    { return const_reverse_iterator(end()); }

    reverse_iterator rend()
    { return reverse_iterator(begin()); }

    const_reverse_iterator rend() const
    { return const_reverse_iterator(begin()); }

    size_type size() const
    { return size_type(end() - begin()); }

    size_type max_size() const
    { return size_type(-1); }

    size_type capacity() const
    { return size_type(const_iterator(this->_M_impl._M_end_of_storage, 0)
         - begin()); }
    bool empty() const
    { return begin() == end(); }

    reference operator[](size_type __n)
    { return *(begin() + difference_type(__n)); }

    const_reference operator[](size_type __n) const
    { return *(begin() + difference_type(__n)); }

    void _M_range_check(size_type __n) const
    {
      if (__n >= this->size())
        __throw_out_of_range(("vector<bool>::_M_range_check"));
    }

    reference at(size_type __n)
    { _M_range_check(__n); return (*this)[__n]; }

    const_reference at(size_type __n) const
    { _M_range_check(__n); return (*this)[__n]; }

    explicit vector(const allocator_type& __a = allocator_type())
      : _Bvector_base<_Alloc>(__a) { }

    vector(size_type __n, bool __value,
    const allocator_type& __a = allocator_type())
    : _Bvector_base<_Alloc>(__a)
    {
      _M_initialize(__n);
      std::fill(this->_M_impl._M_start._M_p, this->_M_impl._M_end_of_storage,
  __value ? ~0 : 0);
    }

    explicit vector(size_type __n)
    : _Bvector_base<_Alloc>(allocator_type())
    {
      _M_initialize(__n);
      std::fill(this->_M_impl._M_start._M_p,
  this->_M_impl._M_end_of_storage, 0);
    }

    vector(const vector& __x) : _Bvector_base<_Alloc>(__x.get_allocator())
    {
      _M_initialize(__x.size());
      std::copy(__x.begin(), __x.end(), this->_M_impl._M_start);
    }


    template<class _Integer>
    void _M_initialize_dispatch(_Integer __n, _Integer __x, __true_type)
    {
      _M_initialize(__n);
      std::fill(this->_M_impl._M_start._M_p,
  this->_M_impl._M_end_of_storage, __x ? ~0 : 0);
    }

    template<class _InputIterator>
      void
      _M_initialize_dispatch(_InputIterator __first, _InputIterator __last,
        __false_type)
      { _M_initialize_range(__first, __last,
       std::__iterator_category(__first)); }

    template<class _InputIterator>
      vector(_InputIterator __first, _InputIterator __last,
      const allocator_type& __a = allocator_type())
    : _Bvector_base<_Alloc>(__a)
    {
      typedef typename _Is_integer<_InputIterator>::_Integral _Integral;
      _M_initialize_dispatch(__first, __last, _Integral());
    }

    ~vector() { }

    vector& operator=(const vector& __x)
    {
      if (&__x == this)
 return *this;
      if (__x.size() > capacity())
 {
   this->_M_deallocate();
   _M_initialize(__x.size());
 }
      std::copy(__x.begin(), __x.end(), begin());
      this->_M_impl._M_finish = begin() + difference_type(__x.size());
      return *this;
    }






    void _M_fill_assign(size_t __n, bool __x)
    {
      if (__n > size())
 {
   std::fill(this->_M_impl._M_start._M_p,
      this->_M_impl._M_end_of_storage, __x ? ~0 : 0);
   insert(end(), __n - size(), __x);
 }
      else
 {
   erase(begin() + __n, end());
   std::fill(this->_M_impl._M_start._M_p,
      this->_M_impl._M_end_of_storage, __x ? ~0 : 0);
 }
    }

    void assign(size_t __n, bool __x)
    { _M_fill_assign(__n, __x); }

    template<class _InputIterator>
    void assign(_InputIterator __first, _InputIterator __last)
    {
      typedef typename _Is_integer<_InputIterator>::_Integral _Integral;
      _M_assign_dispatch(__first, __last, _Integral());
    }

    template<class _Integer>
    void _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)
    { _M_fill_assign((size_t) __n, (bool) __val); }

    template<class _InputIterator>
    void _M_assign_dispatch(_InputIterator __first, _InputIterator __last,
       __false_type)
    { _M_assign_aux(__first, __last, std::__iterator_category(__first)); }

    template<class _InputIterator>
    void _M_assign_aux(_InputIterator __first, _InputIterator __last,
                       input_iterator_tag)
    {
      iterator __cur = begin();
      for ( ; __first != __last && __cur != end(); ++__cur, ++__first)
        *__cur = *__first;
      if (__first == __last)
        erase(__cur, end());
      else
        insert(end(), __first, __last);
    }

    template<class _ForwardIterator>
    void _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
                       forward_iterator_tag)
    {
      const size_type __len = std::distance(__first, __last);
      if (__len < size())
        erase(std::copy(__first, __last, begin()), end());
      else
 {
   _ForwardIterator __mid = __first;
   std::advance(__mid, size());
   std::copy(__first, __mid, begin());
   insert(end(), __mid, __last);
 }
    }

    void reserve(size_type __n)
    {
      if (__n > this->max_size())
 __throw_length_error(("vector::reserve"));
      if (this->capacity() < __n)
 {
   _Bit_type* __q = this->_M_allocate(__n);
   this->_M_impl._M_finish = std::copy(begin(), end(),
           iterator(__q, 0));
   this->_M_deallocate();
   this->_M_impl._M_start = iterator(__q, 0);
   this->_M_impl._M_end_of_storage = __q + (__n + _S_word_bit - 1) / _S_word_bit;
 }
    }

    reference front()
    { return *begin(); }

    const_reference front() const
    { return *begin(); }

    reference back()
    { return *(end() - 1); }

    const_reference back() const
    { return *(end() - 1); }

    void push_back(bool __x)
    {
      if (this->_M_impl._M_finish._M_p != this->_M_impl._M_end_of_storage)
        *this->_M_impl._M_finish++ = __x;
      else
        _M_insert_aux(end(), __x);
    }

    void swap(vector<bool, _Alloc>& __x)
    {
      std::swap(this->_M_impl._M_start, __x._M_impl._M_start);
      std::swap(this->_M_impl._M_finish, __x._M_impl._M_finish);
      std::swap(this->_M_impl._M_end_of_storage,
  __x._M_impl._M_end_of_storage);
    }


    static void swap(reference __x, reference __y)
    {
      bool __tmp = __x;
      __x = __y;
      __y = __tmp;
    }

    iterator insert(iterator __position, bool __x = bool())
    {
      const difference_type __n = __position - begin();
      if (this->_M_impl._M_finish._M_p != this->_M_impl._M_end_of_storage
   && __position == end())
        *this->_M_impl._M_finish++ = __x;
      else
        _M_insert_aux(__position, __x);
      return begin() + __n;
    }



    template<class _Integer>
    void _M_insert_dispatch(iterator __pos, _Integer __n, _Integer __x,
                            __true_type)
    { _M_fill_insert(__pos, __n, __x); }

    template<class _InputIterator>
    void _M_insert_dispatch(iterator __pos,
                            _InputIterator __first, _InputIterator __last,
                            __false_type)
    { _M_insert_range(__pos, __first, __last,
        std::__iterator_category(__first)); }

    template<class _InputIterator>
    void insert(iterator __position,
                _InputIterator __first, _InputIterator __last)
    {
      typedef typename _Is_integer<_InputIterator>::_Integral _Integral;
      _M_insert_dispatch(__position, __first, __last, _Integral());
    }

    void _M_fill_insert(iterator __position, size_type __n, bool __x)
    {
      if (__n == 0)
 return;
      if (capacity() - size() >= __n)
 {
   std::copy_backward(__position, end(),
        this->_M_impl._M_finish + difference_type(__n));
   std::fill(__position, __position + difference_type(__n), __x);
   this->_M_impl._M_finish += difference_type(__n);
 }
      else
 {
   const size_type __len = size() + std::max(size(), __n);
   _Bit_type * __q = this->_M_allocate(__len);
   iterator __i = std::copy(begin(), __position, iterator(__q, 0));
   std::fill_n(__i, __n, __x);
   this->_M_impl._M_finish = std::copy(__position, end(),
           __i + difference_type(__n));
   this->_M_deallocate();
   this->_M_impl._M_end_of_storage = __q + (__len + _S_word_bit - 1)
                                     / _S_word_bit;
   this->_M_impl._M_start = iterator(__q, 0);
 }
    }

    void insert(iterator __position, size_type __n, bool __x)
    { _M_fill_insert(__position, __n, __x); }

    void pop_back()
    { --this->_M_impl._M_finish; }

    iterator erase(iterator __position)
    {
      if (__position + 1 != end())
        std::copy(__position + 1, end(), __position);
      --this->_M_impl._M_finish;
      return __position;
    }

    iterator erase(iterator __first, iterator __last)
    {
      this->_M_impl._M_finish = std::copy(__last, end(), __first);
      return __first;
    }

    void resize(size_type __new_size, bool __x = bool())
    {
      if (__new_size < size())
        erase(begin() + difference_type(__new_size), end());
      else
        insert(end(), __new_size - size(), __x);
    }

    void flip()
    {
      for (_Bit_type * __p = this->_M_impl._M_start._M_p;
    __p != this->_M_impl._M_end_of_storage; ++__p)
        *__p = ~*__p;
    }

    void clear()
    { erase(begin(), end()); }
  };
}
# 73 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/vector" 2 3


# 1 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/vector.tcc" 1 3
# 64 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/vector.tcc" 3
namespace std
{
  template<typename _Tp, typename _Alloc>
    void
    vector<_Tp,_Alloc>::
    reserve(size_type __n)
    {
      if (__n > this->max_size())
 __throw_length_error(("vector::reserve"));
      if (this->capacity() < __n)
 {
   const size_type __old_size = size();
   pointer __tmp = _M_allocate_and_copy(__n,
            this->_M_impl._M_start,
            this->_M_impl._M_finish);
   std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish);
   _M_deallocate(this->_M_impl._M_start,
   this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
   this->_M_impl._M_start = __tmp;
   this->_M_impl._M_finish = __tmp + __old_size;
   this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
 }
    }

  template<typename _Tp, typename _Alloc>
    typename vector<_Tp,_Alloc>::iterator
    vector<_Tp,_Alloc>::
    insert(iterator __position, const value_type& __x)
    {
      size_type __n = __position - begin();
      if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage && __position == end())
      {
        std::_Construct(this->_M_impl._M_finish, __x);
        ++this->_M_impl._M_finish;
      }
      else
        _M_insert_aux(__position, __x);
      return begin() + __n;
    }

  template<typename _Tp, typename _Alloc>
    typename vector<_Tp,_Alloc>::iterator
    vector<_Tp,_Alloc>::
    erase(iterator __position)
    {
      if (__position + 1 != end())
        std::copy(__position + 1, end(), __position);
      --this->_M_impl._M_finish;
      std::_Destroy(this->_M_impl._M_finish);
      return __position;
    }

  template<typename _Tp, typename _Alloc>
    typename vector<_Tp,_Alloc>::iterator
    vector<_Tp,_Alloc>::
    erase(iterator __first, iterator __last)
    {
      iterator __i(copy(__last, end(), __first));
      std::_Destroy(__i, end());
      this->_M_impl._M_finish = this->_M_impl._M_finish - (__last - __first);
      return __first;
    }

  template<typename _Tp, typename _Alloc>
    vector<_Tp,_Alloc>&
    vector<_Tp,_Alloc>::
    operator=(const vector<_Tp,_Alloc>& __x)
    {
      if (&__x != this)
      {
        const size_type __xlen = __x.size();
        if (__xlen > capacity())
        {
          pointer __tmp = _M_allocate_and_copy(__xlen, __x.begin(), __x.end());
          std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish);
          _M_deallocate(this->_M_impl._M_start,
   this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
          this->_M_impl._M_start = __tmp;
          this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __xlen;
        }
        else if (size() >= __xlen)
        {
          iterator __i(copy(__x.begin(), __x.end(), begin()));
          std::_Destroy(__i, end());
        }
        else
        {
          std::copy(__x.begin(), __x.begin() + size(), this->_M_impl._M_start);
          std::uninitialized_copy(__x.begin() + size(), __x.end(), this->_M_impl._M_finish);
        }
        this->_M_impl._M_finish = this->_M_impl._M_start + __xlen;
      }
      return *this;
    }

  template<typename _Tp, typename _Alloc>
    void
    vector<_Tp,_Alloc>::
    _M_fill_assign(size_t __n, const value_type& __val)
    {
      if (__n > capacity())
      {
        vector __tmp(__n, __val, get_allocator());
        __tmp.swap(*this);
      }
      else if (__n > size())
      {
        std::fill(begin(), end(), __val);
        this->_M_impl._M_finish
   = std::uninitialized_fill_n(this->_M_impl._M_finish, __n - size(), __val);
      }
      else
        erase(fill_n(begin(), __n, __val), end());
    }

  template<typename _Tp, typename _Alloc> template<typename _InputIterator>
    void
    vector<_Tp,_Alloc>::
    _M_assign_aux(_InputIterator __first, _InputIterator __last, input_iterator_tag)
    {
      iterator __cur(begin());
      for ( ; __first != __last && __cur != end(); ++__cur, ++__first)
        *__cur = *__first;
      if (__first == __last)
        erase(__cur, end());
      else
        insert(end(), __first, __last);
    }

  template<typename _Tp, typename _Alloc> template<typename _ForwardIterator>
    void
    vector<_Tp,_Alloc>::
    _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
                  forward_iterator_tag)
    {
      size_type __len = std::distance(__first, __last);

      if (__len > capacity())
      {
        pointer __tmp(_M_allocate_and_copy(__len, __first, __last));
        std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish);
        _M_deallocate(this->_M_impl._M_start,
        this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
        this->_M_impl._M_start = __tmp;
        this->_M_impl._M_end_of_storage = this->_M_impl._M_finish = this->_M_impl._M_start + __len;
      }
      else if (size() >= __len)
      {
        iterator __new_finish(copy(__first, __last, this->_M_impl._M_start));
        std::_Destroy(__new_finish, end());
        this->_M_impl._M_finish = __new_finish.base();
      }
      else
      {
        _ForwardIterator __mid = __first;
        std::advance(__mid, size());
        std::copy(__first, __mid, this->_M_impl._M_start);
        this->_M_impl._M_finish = std::uninitialized_copy(__mid, __last, this->_M_impl._M_finish);
      }
    }

  template<typename _Tp, typename _Alloc>
    void
    vector<_Tp,_Alloc>::
    _M_insert_aux(iterator __position, const _Tp& __x)
    {
      if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
      {
        std::_Construct(this->_M_impl._M_finish, *(this->_M_impl._M_finish - 1));
        ++this->_M_impl._M_finish;
        _Tp __x_copy = __x;
        std::copy_backward(__position,
      iterator(this->_M_impl._M_finish-2),
      iterator(this->_M_impl._M_finish-1));
        *__position = __x_copy;
      }
      else
      {
        const size_type __old_size = size();
        const size_type __len = __old_size != 0 ? 2 * __old_size : 1;
        iterator __new_start(this->_M_allocate(__len));
        iterator __new_finish(__new_start);
        try
          {
            __new_finish = std::uninitialized_copy(iterator(this->_M_impl._M_start),
         __position,
         __new_start);
            std::_Construct(__new_finish.base(), __x);
            ++__new_finish;
            __new_finish = std::uninitialized_copy(__position,
         iterator(this->_M_impl._M_finish),
         __new_finish);
          }
        catch(...)
          {
            std::_Destroy(__new_start,__new_finish);
            _M_deallocate(__new_start.base(),__len);
            throw;
          }
        std::_Destroy(begin(), end());
        _M_deallocate(this->_M_impl._M_start,
        this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
        this->_M_impl._M_start = __new_start.base();
        this->_M_impl._M_finish = __new_finish.base();
        this->_M_impl._M_end_of_storage = __new_start.base() + __len;
      }
    }

  template<typename _Tp, typename _Alloc>
    void
    vector<_Tp,_Alloc>::
    _M_fill_insert(iterator __position, size_type __n, const value_type& __x)
    {
      if (__n != 0)
      {
        if (size_type(this->_M_impl._M_end_of_storage - this->_M_impl._M_finish) >= __n)
   {
           value_type __x_copy = __x;
    const size_type __elems_after = end() - __position;
    iterator __old_finish(this->_M_impl._M_finish);
    if (__elems_after > __n)
      {
        std::uninitialized_copy(this->_M_impl._M_finish - __n,
           this->_M_impl._M_finish,
           this->_M_impl._M_finish);
        this->_M_impl._M_finish += __n;
        std::copy_backward(__position, __old_finish - __n, __old_finish);
        std::fill(__position, __position + __n, __x_copy);
      }
    else
      {
        std::uninitialized_fill_n(this->_M_impl._M_finish,
      __n - __elems_after,
      __x_copy);
        this->_M_impl._M_finish += __n - __elems_after;
        std::uninitialized_copy(__position, __old_finish, this->_M_impl._M_finish);
        this->_M_impl._M_finish += __elems_after;
        std::fill(__position, __old_finish, __x_copy);
      }
   }
        else
   {
     const size_type __old_size = size();
     const size_type __len = __old_size + std::max(__old_size, __n);
     iterator __new_start(this->_M_allocate(__len));
     iterator __new_finish(__new_start);
     try
       {
  __new_finish = std::uninitialized_copy(begin(), __position,
             __new_start);
  __new_finish = std::uninitialized_fill_n(__new_finish, __n, __x);
  __new_finish = std::uninitialized_copy(__position, end(),
             __new_finish);
       }
     catch(...)
       {
  std::_Destroy(__new_start,__new_finish);
  _M_deallocate(__new_start.base(),__len);
  throw;
       }
     std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish);
     _M_deallocate(this->_M_impl._M_start,
     this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
     this->_M_impl._M_start = __new_start.base();
     this->_M_impl._M_finish = __new_finish.base();
     this->_M_impl._M_end_of_storage = __new_start.base() + __len;
   }
      }
    }

  template<typename _Tp, typename _Alloc> template<typename _InputIterator>
    void
    vector<_Tp,_Alloc>::
    _M_range_insert(iterator __pos,
                    _InputIterator __first, _InputIterator __last,
                    input_iterator_tag)
    {
      for ( ; __first != __last; ++__first)
      {
        __pos = insert(__pos, *__first);
        ++__pos;
      }
    }

  template<typename _Tp, typename _Alloc> template<typename _ForwardIterator>
    void
    vector<_Tp,_Alloc>::
    _M_range_insert(iterator __position,_ForwardIterator __first,
      _ForwardIterator __last, forward_iterator_tag)
    {
      if (__first != __last)
      {
        size_type __n = std::distance(__first, __last);
        if (size_type(this->_M_impl._M_end_of_storage - this->_M_impl._M_finish) >= __n)
        {
          const size_type __elems_after = end() - __position;
          iterator __old_finish(this->_M_impl._M_finish);
          if (__elems_after > __n)
          {
            std::uninitialized_copy(this->_M_impl._M_finish - __n,
        this->_M_impl._M_finish,
        this->_M_impl._M_finish);
            this->_M_impl._M_finish += __n;
            std::copy_backward(__position, __old_finish - __n, __old_finish);
            std::copy(__first, __last, __position);
          }
          else
          {
            _ForwardIterator __mid = __first;
            std::advance(__mid, __elems_after);
            std::uninitialized_copy(__mid, __last, this->_M_impl._M_finish);
            this->_M_impl._M_finish += __n - __elems_after;
            std::uninitialized_copy(__position, __old_finish, this->_M_impl._M_finish);
            this->_M_impl._M_finish += __elems_after;
            std::copy(__first, __mid, __position);
          }
        }
        else
        {
          const size_type __old_size = size();
          const size_type __len = __old_size + std::max(__old_size, __n);
          iterator __new_start(this->_M_allocate(__len));
          iterator __new_finish(__new_start);
          try
            {
              __new_finish = std::uninitialized_copy(iterator(this->_M_impl._M_start),
           __position, __new_start);
              __new_finish = std::uninitialized_copy(__first, __last,
           __new_finish);
              __new_finish = std::uninitialized_copy(__position,
           iterator(this->_M_impl._M_finish),
           __new_finish);
            }
          catch(...)
            {
              std::_Destroy(__new_start,__new_finish);
              _M_deallocate(__new_start.base(), __len);
              throw;
            }
          std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish);
          _M_deallocate(this->_M_impl._M_start,
   this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
          this->_M_impl._M_start = __new_start.base();
          this->_M_impl._M_finish = __new_finish.base();
          this->_M_impl._M_end_of_storage = __new_start.base() + __len;
        }
      }
    }
}
# 76 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/vector" 2 3
# 63 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/backward/vector.h" 2

using std::vector;
# 6 "gamespace.h" 2

class GameSpace;

# 1 "neobullet.h" 1



class NeoBullet;
# 1 "gameobject.h" 1



class GameObject;
# 1 "cwaypoint.h" 1



class CWayPoint;

# 1 "neoenemy.h" 1




# 1 "cwaypoint.h" 1
# 6 "neoenemy.h" 2





# 1 "gamespace.h" 1
# 12 "neoenemy.h" 2
# 1 "gameobject.h" 1
# 13 "neoenemy.h" 2

class NeoEnemy : public GameObject
{
   public:
   NeoEnemy(GameSpace* ngs);
   virtual ~NeoEnemy();
# 48 "neoenemy.h"
};
# 7 "cwaypoint.h" 2

# 1 "pather.h" 1



# 1 "twovector.h" 1



class TwoVector
{
    private:
    double x, y;

    public:
    TwoVector();
    TwoVector(double sx, double xy);
    ~TwoVector();
    double getLength();
    TwoVector normalize();
    TwoVector scale(double scaler);

    double getX();
    void setX(double newx);

    double getY();
    void setY(double newy);
};
# 5 "pather.h" 2


class PathPiece
{
   public:
   PathPiece();
   virtual ~PathPiece();

   virtual double getLength();
   virtual void getPoint(double x, double y, double n, TwoVector* tv);
   virtual void getStart(TwoVector* tv);
   virtual void getEnd(TwoVector* tv);
};

class LinePiece : public PathPiece
{
   public:
   LinePiece(double nx1, double ny1, double nx2, double ny2);
   virtual ~LinePiece();
   double getLength();
   void getPoint(double x, double y, double n, TwoVector* tv);
   void getStart(TwoVector* tv);
   void getEnd(TwoVector* tv);


   double x1, y1, x2, y2;
   double length;
};

class Pather
{
   public:
   Pather();
   ~Pather();

   vector<PathPiece*> path;
   vector<double> pathnend;

   double length;

   void calcPath();

   double getLength();
   void getPoint(double x, double y, double n, TwoVector* tv);

   void addLine(double xend, double yend);

};
# 9 "cwaypoint.h" 2

class CWayPoint
{
   public:
   CWayPoint();
   ~CWayPoint();

   void setInitAccel(double x, double y);

   void setInitVel(double x, double y);

   void setInitRadVel(double v);

   void setInitRotVel(double v);

   void setCenter(double x, double y);

   void setCycleInfo(int cycles, int next, bool nlast);

   void setDeathInfo(bool ndeathfinal, int ndeathnextwp);

   void setHP(int nhp);

   void addSpeedPath(int num, double speed, int nextstate, Pather* pa);
   void addTimedPath(int num, int cycles, int nextstate, Pather* pa);

   void setRotation(double newrotation);

   int enter(GameObject* ne, GameSpace* gs);
   int die(GameObject* ne);
   int update(GameObject* ne);

   private:
   bool initaccelon;
   double initaccelx;
   double initaccely;

   bool initvelon;
   double initvelx;
   double initvely;

   bool initradvelon;
   double initradvel;

   bool initrotvelon;
   double initrotvel;

   double centerx;
   double centery;

   int cyclesleft;
   int cyclenextwp;
   bool last;

   vector<int> barrages;
   vector<int> frequency;

   bool hpchange;
   int hp;

   bool deathfinal;
   int deathnextwp;

   bool rotationchange;
   double rotation;
   double sinetheta;
   double cosinetheta;

   bool onpath;
   int pathnum;
   int pathnextstate;
   double npercycle;

};
# 6 "gameobject.h" 2
# 14 "gameobject.h"
class GameObject
{
   public:
   GameObject();
   virtual ~GameObject();
   virtual void addWayPoint(CWayPoint* wp);
   virtual void copyFrom(GameObject* ne);

   virtual bool isVisible();
   virtual bool isHittable();

   vector<CWayPoint*> vwaypoints;

   double dir;
   double powerdropchance;
   double scoredropchance;
   double hp;
   double damage;

   GameSpace* gs;

   double rotation;
   double sinetheta;
   double cosinetheta;

   Pather* path;
   double npercycle;
   double pathlocation;

   double effvelx;
   double effvely;

   double score;
   double x, y;
   double xvel, yvel;
   double xaccel, yaccel;
   double rcenterx, rcentery;
   double rotaccel, rotvel;
   double radaccel, radvel;
   double radius;
   double wcyclesleft;
   bool active, dead, dissolve, initial;
   int sprite;
   int currentwaypoint;
   int activatecycles;



   virtual bool update(Player* p, GameSpace* gs);
};
# 6 "neobullet.h" 2







class NeoBullet : public GameObject
{
   public:
   NeoBullet(GameSpace* ngs);
   virtual ~NeoBullet();
};
# 10 "gamespace.h" 2


# 1 "item.h" 1





class Item
{
    public:
       Item();
       virtual ~Item();

       virtual void update();
       virtual void onPickup(Player* pl);

       virtual double getX();
       virtual void setX(double newx);

       virtual double getY();
       virtual void setY(double newy);

       virtual double getXVel();
       virtual void setXVel(double newxvel);

       virtual double getYVel();
       virtual void setYVel(double newyvel);

       virtual double getXAccel();
       virtual void setXAccel(double newxaccel);

       virtual double getYAccel();
       virtual void setYAccel(double newyaccel);

       virtual double getRadius();
       virtual void setRadius(double newradius);

       virtual int getSprite();
       virtual void setSprite(int newsprite);

    protected:
        double x, y;
        double xvel, yvel;
        double xaccel, yaccel;
        double radius;
        int sprite;


};
# 13 "gamespace.h" 2
# 1 "spritenote.h" 1



class SpriteNote

{
    private:

    public:
    int sprite;
    int x, y;
    float rotation;
    SpriteNote(int sx, int sy, int ssprite);
    SpriteNote(int sx, int sy, float srot, int ssprite);
    ~SpriteNote();

    int getX();
    void setX(int newx);

    int getY();
    void setY(int newy);

    float getRotation();
    void setRotation(float newrotation);

    int getSprite();
    void setSprite(int newsprite);
};
# 14 "gamespace.h" 2
# 1 "keystate.h" 1



class KeyState
{
    private:


    bool keyup;
    bool keydown;
    bool keyright;
    bool keyleft;
    bool keyz;
    bool keyx;
    bool keyesc;
    bool keyshift;

    public:
    KeyState();
    ~KeyState();

    bool isUp();
    bool isDown();
    bool isRight();
    bool isLeft();
    bool isZ();
    bool isX();
    bool isEsc();
    bool isShift();

    void setUp(bool newup);
    void setDown(bool newdown);
    void setLeft(bool newleft);
    void setRight(bool newright);
    void setZ(bool newz);
    void setX(bool newx);
    void setEsc(bool newesc);
    void setShift(bool newshift);

    void clearKeys();
    void updateKeys();
};
# 15 "gamespace.h" 2

# 1 "star.h" 1



class Star
{
    public:
       Star(double sx, double sy, double sz);
       ~Star();

       void update(double relvel);

       double getX();
       void setX(double newx);

       double getY();
       void setY(double newy);

       double getZ();
       void setZ(double newz);

       int getSprite();
       void setSprite(int newsprite);



    private:
        double x, y, z;
        int sprite;


};
# 17 "gamespace.h" 2
# 1 "random.h" 1
# 15 "random.h"
class Random
{
public:
   Random();
   Random(long long int init_seed);
   virtual void setSeed(long long int seed);
   virtual int nextBits(int bits);
   virtual double nextDouble(double range = 1.0);
   template <class T> T next(T range)
   { return (T) (range*nextDouble()); }
   virtual bool nextBoolean();
   virtual void nextBytes(char *buffer, int length);
   virtual float nextFloat(float range = 1.0f);
   virtual double nextGaussian();
   virtual int nextInt();
   virtual int nextInt(int max);

private:
   long long int seed;
   bool haveNextNextGaussian;
   double nextNextGaussian;

};
# 18 "gamespace.h" 2


# 1 "H:/CPP/lua51/include/lua.hpp" 1




extern "C" {



}
# 21 "gamespace.h" 2



using namespace std;

class GameSpace
{
    public:
    Player* thePlayer;
    int level;



    list<Bullet> lParticles;
    list<NeoEnemy*> lEnemies;
    vector<CWayPoint*> vWayPoints;
    vector<NeoEnemy*> vTempEnemies;
    vector<NeoEnemy*> vTempEnemies2;

    vector<Pather*> vPathers;

    list<NeoBullet> lEnemyBullets;
    list<NeoBullet> lFriendlyBullets;
    list<Item*> lItems;



    list<Star> lStars;
    double screenleft, screenright, screentop, screenbottom;
    private:
    bool isSim;



    public:

    int seed;
    int cycle;
    int lastcycle;
    Random gsran;
    GameSpace(int slevel, double left, double right, double top, double bottom, int seed, bool iSim, char* filename, char* charfile);
    ~GameSpace();

    int updateGameState(KeyState ks);






    void getSprites(vector<SpriteNote>* vsn, SpriteNote* BG, KeyState ks);







   void fx_explosion(double x, double y, int n, double force, int sprite);

    static int l_setCycleInfo( lua_State* luaVM );
    static int l_addWayPoint( lua_State* luaVM);
    static int l_setDeathInfo( lua_State* luaVM);
    static int l_setHP(lua_State *luaVM);
    static int l_setInitVel( lua_State* luaVM);
    static int l_setSpeedPath( lua_State* luaVM);
    static int l_setTimedPath( lua_State* luaVM);

    static int l_addEnemy( lua_State* luaVM);
    static int l_setRadius( lua_State* luaVM);
    static int l_setSprite( lua_State* luaVM);
    static int l_setEHP( lua_State* luaVM);
    static int l_insertWayPoint( lua_State* luaVM);

    static int l_addPath( lua_State* luaVM);
    static int l_insertLine( lua_State* luaVM);

    static int l_addToLevel( lua_State* luaVM);


};
# 9 "shooter.cpp" 2
# 1 "H:/CPP/irrlicht-1.3/include/irrlicht.h" 1
# 32 "H:/CPP/irrlicht-1.3/include/irrlicht.h"
# 1 "H:/CPP/irrlicht-1.3/include/IrrCompileConfig.h" 1
# 33 "H:/CPP/irrlicht-1.3/include/irrlicht.h" 2
# 1 "H:/CPP/irrlicht-1.3/include/aabbox3d.h" 1







# 1 "H:/CPP/irrlicht-1.3/include/irrMath.h" 1
# 9 "H:/CPP/irrlicht-1.3/include/irrMath.h"
# 1 "H:/CPP/irrlicht-1.3/include/irrTypes.h" 1
# 10 "H:/CPP/irrlicht-1.3/include/irrTypes.h"
namespace irr
{



typedef unsigned char u8;



typedef signed char s8;



typedef char c8;





typedef unsigned short u16;



typedef signed short s16;





typedef unsigned int u32;



typedef signed int s32;
# 57 "H:/CPP/irrlicht-1.3/include/irrTypes.h"
typedef float f32;



typedef double f64;


}
# 10 "H:/CPP/irrlicht-1.3/include/irrMath.h" 2
# 1 "H:/CPP/wxdevcpp6.10/include/math.h" 1
# 16 "H:/CPP/wxdevcpp6.10/include/math.h"
       
# 17 "H:/CPP/wxdevcpp6.10/include/math.h" 3
# 90 "H:/CPP/wxdevcpp6.10/include/math.h" 3
extern "C" {
# 118 "H:/CPP/wxdevcpp6.10/include/math.h" 3
extern __attribute__ ((dllimport)) double _HUGE;
# 128 "H:/CPP/wxdevcpp6.10/include/math.h" 3
struct _exception
{
 int type;
 char *name;
 double arg1;
 double arg2;
 double retval;
};

 double __attribute__((__cdecl__)) sin (double);
 double __attribute__((__cdecl__)) cos (double);
 double __attribute__((__cdecl__)) tan (double);
 double __attribute__((__cdecl__)) sinh (double);
 double __attribute__((__cdecl__)) cosh (double);
 double __attribute__((__cdecl__)) tanh (double);
 double __attribute__((__cdecl__)) asin (double);
 double __attribute__((__cdecl__)) acos (double);
 double __attribute__((__cdecl__)) atan (double);
 double __attribute__((__cdecl__)) atan2 (double, double);
 double __attribute__((__cdecl__)) exp (double);
 double __attribute__((__cdecl__)) log (double);
 double __attribute__((__cdecl__)) log10 (double);
 double __attribute__((__cdecl__)) pow (double, double);
 double __attribute__((__cdecl__)) sqrt (double);
 double __attribute__((__cdecl__)) ceil (double);
 double __attribute__((__cdecl__)) floor (double);
 double __attribute__((__cdecl__)) fabs (double);
 double __attribute__((__cdecl__)) ldexp (double, int);
 double __attribute__((__cdecl__)) frexp (double, int*);
 double __attribute__((__cdecl__)) modf (double, double*);
 double __attribute__((__cdecl__)) fmod (double, double);
# 204 "H:/CPP/wxdevcpp6.10/include/math.h" 3
struct _complex
{
 double x;
 double y;
};

 double __attribute__((__cdecl__)) _cabs (struct _complex);

 double __attribute__((__cdecl__)) _hypot (double, double);
 double __attribute__((__cdecl__)) _j0 (double);
 double __attribute__((__cdecl__)) _j1 (double);
 double __attribute__((__cdecl__)) _jn (int, double);
 double __attribute__((__cdecl__)) _y0 (double);
 double __attribute__((__cdecl__)) _y1 (double);
 double __attribute__((__cdecl__)) _yn (int, double);
 int __attribute__((__cdecl__)) _matherr (struct _exception *);
# 228 "H:/CPP/wxdevcpp6.10/include/math.h" 3
 double __attribute__((__cdecl__)) _chgsign (double);
 double __attribute__((__cdecl__)) _copysign (double, double);
 double __attribute__((__cdecl__)) _logb (double);
 double __attribute__((__cdecl__)) _nextafter (double, double);
 double __attribute__((__cdecl__)) _scalb (double, long);

 int __attribute__((__cdecl__)) _finite (double);
 int __attribute__((__cdecl__)) _fpclass (double);
 int __attribute__((__cdecl__)) _isnan (double);
# 248 "H:/CPP/wxdevcpp6.10/include/math.h" 3
 double __attribute__((__cdecl__)) j0 (double);
 double __attribute__((__cdecl__)) j1 (double);
 double __attribute__((__cdecl__)) jn (int, double);
 double __attribute__((__cdecl__)) y0 (double);
 double __attribute__((__cdecl__)) y1 (double);
 double __attribute__((__cdecl__)) yn (int, double);

 double __attribute__((__cdecl__)) chgsign (double);
 double __attribute__((__cdecl__)) scalb (double, long);
 int __attribute__((__cdecl__)) finite (double);
 int __attribute__((__cdecl__)) fpclass (double);
# 313 "H:/CPP/wxdevcpp6.10/include/math.h" 3
extern int __attribute__((__cdecl__)) __fpclassifyf (float);
extern int __attribute__((__cdecl__)) __fpclassify (double);

inline int __attribute__((__cdecl__)) __fpclassifyl (long double x){
  unsigned short sw;
  __asm__ ("fxam; fstsw %%ax;" : "=a" (sw): "t" (x));
  return sw & (0x0100 | 0x0400 | 0x4000 );
}
# 336 "H:/CPP/wxdevcpp6.10/include/math.h" 3
inline int __attribute__((__cdecl__)) __isnan (double _x)
{
  unsigned short sw;
  __asm__ ("fxam;"
    "fstsw %%ax": "=a" (sw) : "t" (_x));
  return (sw & (0x0100 | 0x0400 | (0x0100 | 0x0400) | 0x4000 | (0x0400 | 0x4000)))
    == 0x0100;
}

inline int __attribute__((__cdecl__)) __isnanf (float _x)
{
  unsigned short sw;
  __asm__ ("fxam;"
     "fstsw %%ax": "=a" (sw) : "t" (_x));
  return (sw & (0x0100 | 0x0400 | (0x0100 | 0x0400) | 0x4000 | (0x0400 | 0x4000)))
    == 0x0100;
}

inline int __attribute__((__cdecl__)) __isnanl (long double _x)
{
  unsigned short sw;
  __asm__ ("fxam;"
     "fstsw %%ax": "=a" (sw) : "t" (_x));
  return (sw & (0x0100 | 0x0400 | (0x0100 | 0x0400) | 0x4000 | (0x0400 | 0x4000)))
    == 0x0100;
}
# 372 "H:/CPP/wxdevcpp6.10/include/math.h" 3
inline int __attribute__((__cdecl__)) __signbit (double x) {
  unsigned short stw;
  __asm__ ( "fxam; fstsw %%ax;": "=a" (stw) : "t" (x));
  return (stw & 0x0200) != 0;
}

inline int __attribute__((__cdecl__)) __signbitf (float x) {
  unsigned short stw;
  __asm__ ("fxam; fstsw %%ax;": "=a" (stw) : "t" (x));
  return (stw & 0x0200) != 0;
}

inline int __attribute__((__cdecl__)) __signbitl (long double x) {
  unsigned short stw;
  __asm__ ("fxam; fstsw %%ax;": "=a" (stw) : "t" (x));
  return (stw & 0x0200) != 0;
}






extern float __attribute__((__cdecl__)) sinf (float);
extern long double __attribute__((__cdecl__)) sinl (long double);

extern float __attribute__((__cdecl__)) cosf (float);
extern long double __attribute__((__cdecl__)) cosl (long double);

extern float __attribute__((__cdecl__)) tanf (float);
extern long double __attribute__((__cdecl__)) tanl (long double);

extern float __attribute__((__cdecl__)) asinf (float);
extern long double __attribute__((__cdecl__)) asinl (long double);

extern float __attribute__((__cdecl__)) acosf (float);
extern long double __attribute__((__cdecl__)) acosl (long double);

extern float __attribute__((__cdecl__)) atanf (float);
extern long double __attribute__((__cdecl__)) atanl (long double);

extern float __attribute__((__cdecl__)) atan2f (float, float);
extern long double __attribute__((__cdecl__)) atan2l (long double, long double);


inline float __attribute__((__cdecl__)) sinhf (float x)
  {return (float) sinh (x);}
extern long double __attribute__((__cdecl__)) sinhl (long double);

inline float __attribute__((__cdecl__)) coshf (float x)
  {return (float) cosh (x);}
extern long double __attribute__((__cdecl__)) coshl (long double);

inline float __attribute__((__cdecl__)) tanhf (float x)
  {return (float) tanh (x);}
extern long double __attribute__((__cdecl__)) tanhl (long double);



extern double __attribute__((__cdecl__)) acosh (double);
extern float __attribute__((__cdecl__)) acoshf (float);
extern long double __attribute__((__cdecl__)) acoshl (long double);


extern double __attribute__((__cdecl__)) asinh (double);
extern float __attribute__((__cdecl__)) asinhf (float);
extern long double __attribute__((__cdecl__)) asinhl (long double);


extern double __attribute__((__cdecl__)) atanh (double);
extern float __attribute__((__cdecl__)) atanf (float);
extern long double __attribute__((__cdecl__)) atanhl (long double);



inline float __attribute__((__cdecl__)) expf (float x)
  {return (float) exp (x);}
extern long double __attribute__((__cdecl__)) expl (long double);


extern double __attribute__((__cdecl__)) exp2(double);
extern float __attribute__((__cdecl__)) exp2f(float);
extern long double __attribute__((__cdecl__)) exp2l(long double);



extern double __attribute__((__cdecl__)) expm1(double);
extern float __attribute__((__cdecl__)) expm1f(float);
extern long double __attribute__((__cdecl__)) expm1l(long double);


inline float __attribute__((__cdecl__)) frexpf (float x, int* expn)
  {return (float) frexp (x, expn);}
extern long double __attribute__((__cdecl__)) frexpl (long double, int*);




extern int __attribute__((__cdecl__)) ilogb (double);
extern int __attribute__((__cdecl__)) ilogbf (float);
extern int __attribute__((__cdecl__)) ilogbl (long double);


inline float __attribute__((__cdecl__)) ldexpf (float x, int expn)
  {return (float) ldexp (x, expn);}
extern long double __attribute__((__cdecl__)) ldexpl (long double, int);


extern float __attribute__((__cdecl__)) logf (float);
extern long double __attribute__((__cdecl__)) logl (long double);


extern float __attribute__((__cdecl__)) log10f (float);
extern long double __attribute__((__cdecl__)) log10l (long double);


extern double __attribute__((__cdecl__)) log1p(double);
extern float __attribute__((__cdecl__)) log1pf(float);
extern long double __attribute__((__cdecl__)) log1pl(long double);


extern double __attribute__((__cdecl__)) log2 (double);
extern float __attribute__((__cdecl__)) log2f (float);
extern long double __attribute__((__cdecl__)) log2l (long double);


extern double __attribute__((__cdecl__)) logb (double);
extern float __attribute__((__cdecl__)) logbf (float);
extern long double __attribute__((__cdecl__)) logbl (long double);




inline double __attribute__((__cdecl__)) logb (double x)
{
  double res;
  __asm__ ("fxtract\n\t"
       "fstp	%%st" : "=t" (res) : "0" (x));
  return res;
}

inline float __attribute__((__cdecl__)) logbf (float x)
{
  float res;
  __asm__ ("fxtract\n\t"
       "fstp	%%st" : "=t" (res) : "0" (x));
  return res;
}

inline long double __attribute__((__cdecl__)) logbl (long double x)
{
  long double res;
  __asm__ ("fxtract\n\t"
       "fstp	%%st" : "=t" (res) : "0" (x));
  return res;
}



extern float __attribute__((__cdecl__)) modff (float, float*);
extern long double __attribute__((__cdecl__)) modfl (long double, long double*);


extern double __attribute__((__cdecl__)) scalbn (double, int);
extern float __attribute__((__cdecl__)) scalbnf (float, int);
extern long double __attribute__((__cdecl__)) scalbnl (long double, int);

extern double __attribute__((__cdecl__)) scalbln (double, long);
extern float __attribute__((__cdecl__)) scalblnf (float, long);
extern long double __attribute__((__cdecl__)) scalblnl (long double, long);



extern double __attribute__((__cdecl__)) cbrt (double);
extern float __attribute__((__cdecl__)) cbrtf (float);
extern long double __attribute__((__cdecl__)) cbrtl (long double);


extern float __attribute__((__cdecl__)) fabsf (float x);
extern long double __attribute__((__cdecl__)) fabsl (long double x);


extern double __attribute__((__cdecl__)) hypot (double, double);
inline float __attribute__((__cdecl__)) hypotf (float x, float y)
  { return (float) hypot (x, y);}
extern long double __attribute__((__cdecl__)) hypotl (long double, long double);


inline float __attribute__((__cdecl__)) powf (float x, float y)
  {return (float) pow (x, y);}
extern long double __attribute__((__cdecl__)) powl (long double, long double);


extern float __attribute__((__cdecl__)) sqrtf (float);
extern long double __attribute__((__cdecl__)) sqrtl (long double);


extern double __attribute__((__cdecl__)) erf (double);
extern float __attribute__((__cdecl__)) erff (float);
extern long double __attribute__((__cdecl__)) erfl (long double);


extern double __attribute__((__cdecl__)) erfc (double);
extern float __attribute__((__cdecl__)) erfcf (float);
extern long double __attribute__((__cdecl__)) erfcl (long double);


extern double __attribute__((__cdecl__)) lgamma (double);
extern float __attribute__((__cdecl__)) lgammaf (float);
extern long double __attribute__((__cdecl__)) lgammal (long double);


extern double __attribute__((__cdecl__)) tgamma (double);
extern float __attribute__((__cdecl__)) tgammaf (float);
extern long double __attribute__((__cdecl__)) tgammal (long double);


extern float __attribute__((__cdecl__)) ceilf (float);
extern long double __attribute__((__cdecl__)) ceill (long double);


extern float __attribute__((__cdecl__)) floorf (float);
extern long double __attribute__((__cdecl__)) floorl (long double);


extern double __attribute__((__cdecl__)) nearbyint ( double);
extern float __attribute__((__cdecl__)) nearbyintf (float);
extern long double __attribute__((__cdecl__)) nearbyintl (long double);



extern double __attribute__((__cdecl__)) rint (double);
extern float __attribute__((__cdecl__)) rintf (float);
extern long double __attribute__((__cdecl__)) rintl (long double);


extern long __attribute__((__cdecl__)) lrint (double);
extern long __attribute__((__cdecl__)) lrintf (float);
extern long __attribute__((__cdecl__)) lrintl (long double);

extern long long __attribute__((__cdecl__)) llrint (double);
extern long long __attribute__((__cdecl__)) llrintf (float);
extern long long __attribute__((__cdecl__)) llrintl (long double);




inline double __attribute__((__cdecl__)) rint (double x)
{
  double retval;
  __asm__ ("frndint;": "=t" (retval) : "0" (x));
  return retval;
}

inline float __attribute__((__cdecl__)) rintf (float x)
{
  float retval;
  __asm__ ("frndint;" : "=t" (retval) : "0" (x) );
  return retval;
}

inline long double __attribute__((__cdecl__)) rintl (long double x)
{
  long double retval;
  __asm__ ("frndint;" : "=t" (retval) : "0" (x) );
  return retval;
}

inline long __attribute__((__cdecl__)) lrint (double x)
{
  long retval;
  __asm__ __volatile__
    ("fistpl %0" : "=m" (retval) : "t" (x) : "st");
  return retval;
}

inline long __attribute__((__cdecl__)) lrintf (float x)
{
  long retval;
  __asm__ __volatile__
    ("fistpl %0" : "=m" (retval) : "t" (x) : "st");
  return retval;
}

inline long __attribute__((__cdecl__)) lrintl (long double x)
{
  long retval;
  __asm__ __volatile__
    ("fistpl %0" : "=m" (retval) : "t" (x) : "st");
  return retval;
}

inline long long __attribute__((__cdecl__)) llrint (double x)
{
  long long retval;
  __asm__ __volatile__
    ("fistpll %0" : "=m" (retval) : "t" (x) : "st");
  return retval;
}

inline long long __attribute__((__cdecl__)) llrintf (float x)
{
  long long retval;
  __asm__ __volatile__
    ("fistpll %0" : "=m" (retval) : "t" (x) : "st");
  return retval;
}

inline long long __attribute__((__cdecl__)) llrintl (long double x)
{
  long long retval;
  __asm__ __volatile__
    ("fistpll %0" : "=m" (retval) : "t" (x) : "st");
  return retval;
}




extern double __attribute__((__cdecl__)) round (double);
extern float __attribute__((__cdecl__)) roundf (float);
extern long double __attribute__((__cdecl__)) roundl (long double);


extern long __attribute__((__cdecl__)) lround (double);
extern long __attribute__((__cdecl__)) lroundf (float);
extern long __attribute__((__cdecl__)) lroundl (long double);

extern long long __attribute__((__cdecl__)) llround (double);
extern long long __attribute__((__cdecl__)) llroundf (float);
extern long long __attribute__((__cdecl__)) llroundl (long double);



extern double __attribute__((__cdecl__)) trunc (double);
extern float __attribute__((__cdecl__)) truncf (float);
extern long double __attribute__((__cdecl__)) truncl (long double);


extern float __attribute__((__cdecl__)) fmodf (float, float);
extern long double __attribute__((__cdecl__)) fmodl (long double, long double);


extern double __attribute__((__cdecl__)) remainder (double, double);
extern float __attribute__((__cdecl__)) remainderf (float, float);
extern long double __attribute__((__cdecl__)) remainderl (long double, long double);


extern double __attribute__((__cdecl__)) remquo(double, double, int *);
extern float __attribute__((__cdecl__)) remquof(float, float, int *);
extern long double __attribute__((__cdecl__)) remquol(long double, long double, int *);


extern double __attribute__((__cdecl__)) copysign (double, double);
extern float __attribute__((__cdecl__)) copysignf (float, float);
extern long double __attribute__((__cdecl__)) copysignl (long double, long double);


extern double __attribute__((__cdecl__)) nan(const char *tagp);
extern float __attribute__((__cdecl__)) nanf(const char *tagp);
extern long double __attribute__((__cdecl__)) nanl(const char *tagp);
# 741 "H:/CPP/wxdevcpp6.10/include/math.h" 3
extern double __attribute__((__cdecl__)) nextafter (double, double);
extern float __attribute__((__cdecl__)) nextafterf (float, float);
extern long double __attribute__((__cdecl__)) nextafterl (long double, long double);


extern double __attribute__((__cdecl__)) nexttoward (double, long double);
extern float __attribute__((__cdecl__)) nexttowardf (float, long double);
extern long double __attribute__((__cdecl__)) nexttowardl (long double, long double);



extern double __attribute__((__cdecl__)) fdim (double x, double y);
extern float __attribute__((__cdecl__)) fdimf (float x, float y);
extern long double __attribute__((__cdecl__)) fdiml (long double x, long double y);







extern double __attribute__((__cdecl__)) fmax (double, double);
extern float __attribute__((__cdecl__)) fmaxf (float, float);
extern long double __attribute__((__cdecl__)) fmaxl (long double, long double);


extern double __attribute__((__cdecl__)) fmin (double, double);
extern float __attribute__((__cdecl__)) fminf (float, float);
extern long double __attribute__((__cdecl__)) fminl (long double, long double);



extern double __attribute__((__cdecl__)) fma (double, double, double);
extern float __attribute__((__cdecl__)) fmaf (float, float, float);
extern long double __attribute__((__cdecl__)) fmal (long double, long double, long double);
# 827 "H:/CPP/wxdevcpp6.10/include/math.h" 3
}
# 11 "H:/CPP/irrlicht-1.3/include/irrMath.h" 2
# 22 "H:/CPP/irrlicht-1.3/include/irrMath.h"
namespace irr
{
namespace core
{
# 34 "H:/CPP/irrlicht-1.3/include/irrMath.h"
 const f32 ROUNDING_ERROR_32 = 0.000001f;
 const f64 ROUNDING_ERROR_64 = 0.00000001f;



 const f32 PI = 3.14159265359f;


 const f64 PI64 = 3.1415926535897932384626433832795028841971693993751;


 const f32 DEGTORAD = PI / 180.0f;


 const f32 RADTODEG = 180.0f / PI;


 const f64 DEGTORAD64 = PI64 / 180.0;


 const f64 RADTODEG64 = 180.0 / PI64;


 template<class T>
 inline const T min_(const T a, const T b)
 {
  return a < b ? a : b;
 }


 template<class T>
 inline T max_(const T a, const T b)
 {
  return a < b ? b : a;
 }


 template<class T>
 inline T abs_(const T a)
 {
  return a < 0 ? -a : a;
 }



 template<class T>
 inline T lerp(const T a, const T b, const T t)
 {
  return (a*(1-t)) + (b*t);
 }


 template <class T>
 inline const T clamp (const T value, const T low, const T high)
 {
  return min_ (max_(value,low), high);
 }



 inline bool equals(const f32 a, const f32 b, const f32 tolerance = ROUNDING_ERROR_32)
 {
  return (a + tolerance > b) && (a - tolerance < b);
 }



 inline bool iszero(const f32 a, const f32 tolerance = ROUNDING_ERROR_32)
 {
  return fabs ( a ) < tolerance;
 }

 inline s32 s32_min ( s32 a, s32 b)
 {
  s32 mask = (a - b) >> 31;
  return (a & mask) | (b & ~mask);
 }

 inline s32 s32_max ( s32 a, s32 b)
 {
  s32 mask = (a - b) >> 31;
  return (b & mask) | (a & ~mask);
 }

 inline s32 s32_clamp (s32 value, s32 low, s32 high)
 {
  return s32_min (s32_max(value,low), high);
 }
# 181 "H:/CPP/irrlicht-1.3/include/irrMath.h"
 inline u32 if_c_a_else_b ( const s32 condition, const u32 a, const u32 b )
 {
  return ( ( -condition >> 31 ) & ( a ^ b ) ) ^ b;
 }


 inline u32 if_c_a_else_0 ( const s32 condition, const u32 a )
 {
  return ( -condition >> 31 ) & a;
 }




 inline void setbit ( u32 &state, s32 condition, u32 mask )
 {


  state ^= ( ( -condition >> 31 ) ^ state ) & mask;
 }
# 304 "H:/CPP/irrlicht-1.3/include/irrMath.h"
 inline void clearFPUException ()
 {
 }


 inline f32 reciprocal_squareroot(const f32 x)
 {
  return 1.f / sqrtf ( x );
 }


 inline f32 reciprocal ( const f32 x )
 {
  return 1.f / x;
 }

 inline f32 reciprocal_approxim ( const f32 x )
 {
  return 1.f / x;
 }


 inline s32 floor32 ( f32 x )
 {
  return (s32) floorf ( x );
 }

 inline s32 ceil32 ( f32 x )
 {
  return (s32) ceilf ( x );
 }

 inline s32 round32 ( f32 x )
 {
  return (s32) ( x + 0.5f );
 }


 inline f32 f32_max3(const f32 a, const f32 b, const f32 c)
 {
  return a > b ? (a > c ? a : c) : (b > c ? b : c);
 }

 inline f32 f32_min3(const f32 a, const f32 b, const f32 c)
 {
  return a < b ? (a < c ? a : c) : (b < c ? b : c);
 }



 inline f32 fract ( f32 x )
 {
  return x - floorf ( x );
 }

 inline f32 round ( f32 x )
 {
  return floorf ( x + 0.5f );
 }


}
}
# 9 "H:/CPP/irrlicht-1.3/include/aabbox3d.h" 2
# 1 "H:/CPP/irrlicht-1.3/include/plane3d.h" 1
# 9 "H:/CPP/irrlicht-1.3/include/plane3d.h"
# 1 "H:/CPP/irrlicht-1.3/include/vector3d.h" 1
# 10 "H:/CPP/irrlicht-1.3/include/vector3d.h"
namespace irr
{
namespace core
{


 template <class T>
 class vector3d
 {
 public:




  vector3d() : X(0), Y(0), Z(0) {};


  vector3d(T nx, T ny, T nz) : X(nx), Y(ny), Z(nz) {};
  vector3d(const vector3d<T>& other) : X(other.X), Y(other.Y), Z(other.Z) {};



  vector3d<T> operator-() const { return vector3d<T>(-X, -Y, -Z); }

  vector3d<T>& operator=(const vector3d<T>& other) { X = other.X; Y = other.Y; Z = other.Z; return *this; }

  vector3d<T> operator+(const vector3d<T>& other) const { return vector3d<T>(X + other.X, Y + other.Y, Z + other.Z); }
  vector3d<T>& operator+=(const vector3d<T>& other) { X+=other.X; Y+=other.Y; Z+=other.Z; return *this; }

  vector3d<T> operator-(const vector3d<T>& other) const { return vector3d<T>(X - other.X, Y - other.Y, Z - other.Z); }
  vector3d<T>& operator-=(const vector3d<T>& other) { X-=other.X; Y-=other.Y; Z-=other.Z; return *this; }

  vector3d<T> operator*(const vector3d<T>& other) const { return vector3d<T>(X * other.X, Y * other.Y, Z * other.Z); }
  vector3d<T>& operator*=(const vector3d<T>& other) { X*=other.X; Y*=other.Y; Z*=other.Z; return *this; }
  vector3d<T> operator*(const T v) const { return vector3d<T>(X * v, Y * v, Z * v); }
  vector3d<T>& operator*=(const T v) { X*=v; Y*=v; Z*=v; return *this; }

  vector3d<T> operator/(const vector3d<T>& other) const { return vector3d<T>(X / other.X, Y / other.Y, Z / other.Z); }
  vector3d<T>& operator/=(const vector3d<T>& other) { X/=other.X; Y/=other.Y; Z/=other.Z; return *this; }
  vector3d<T> operator/(const T v) const { T i=(T)1.0/v; return vector3d<T>(X * i, Y * i, Z * i); }
  vector3d<T>& operator/=(const T v) { T i=(T)1.0/v; X*=i; Y*=i; Z*=i; return *this; }

  bool operator<=(const vector3d<T>&other) const { return X<=other.X && Y<=other.Y && Z<=other.Z;};
  bool operator>=(const vector3d<T>&other) const { return X>=other.X && Y>=other.Y && Z>=other.Z;};
  bool operator<(const vector3d<T>&other) const { return X<other.X && Y<other.Y && Z<other.Z;};
  bool operator>(const vector3d<T>&other) const { return X>other.X && Y>other.Y && Z>other.Z;};





  bool operator==(const vector3d<T>& other) const
  {
   return core::equals(X, other.X) &&
       core::equals(Y, other.Y) &&
       core::equals(Z, other.Z);
  }

  bool operator!=(const vector3d<T>& other) const
  {
   return !core::equals(X, other.X) ||
       !core::equals(Y, other.Y) ||
       !core::equals(Z, other.Z);
  }




  bool equals(const vector3d<T>& other, const f32 tolerance = ROUNDING_ERROR_32 ) const
  {
   return core::equals(X, other.X, tolerance) &&
       core::equals(Y, other.Y, tolerance) &&
       core::equals(Z, other.Z, tolerance);
  }

  void set(const T nx, const T ny, const T nz) {X=nx; Y=ny; Z=nz; }
  void set(const vector3d<T>& p) { X=p.X; Y=p.Y; Z=p.Z;}


  T getLength() const { return (T) sqrt(X*X + Y*Y + Z*Z); }




  T getLengthSQ() const { return X*X + Y*Y + Z*Z; }


  T dotProduct(const vector3d<T>& other) const
  {
   return X*other.X + Y*other.Y + Z*other.Z;
  }



  f64 getDistanceFrom(const vector3d<T>& other) const
  {
   return vector3d<T>(X - other.X, Y - other.Y, Z - other.Z).getLength();
  }



  T getDistanceFromSQ(const vector3d<T>& other) const
  {
   return vector3d<T>(X - other.X, Y - other.Y, Z - other.Z).getLengthSQ();
  }




  vector3d<T> crossProduct(const vector3d<T>& p) const
  {
   return vector3d<T>(Y * p.Z - Z * p.Y, Z * p.X - X * p.Z, X * p.Y - Y * p.X);
  }






  bool isBetweenPoints(const vector3d<T>& begin, const vector3d<T>& end) const
  {
   T f = (end - begin).getLengthSQ();
   return getDistanceFromSQ(begin) < f &&
    getDistanceFromSQ(end) < f;
  }



  vector3d<T>& normalize()
  {
   T l = (T) reciprocal_squareroot ( f32(X*X + Y*Y + Z*Z) );

   X *= l;
   Y *= l;
   Z *= l;
   return *this;
# 158 "H:/CPP/irrlicht-1.3/include/vector3d.h"
  }


  void setLength(T newlength)
  {
   normalize();
   *this *= newlength;
  }


  void invert()
  {
   X *= -1.0f;
   Y *= -1.0f;
   Z *= -1.0f;
  }





  void rotateXZBy(f64 degrees, const vector3d<T>& center)
  {
   degrees *= DEGTORAD64;
   T cs = (T)cos(degrees);
   T sn = (T)sin(degrees);
   X -= center.X;
   Z -= center.Z;
   set(X*cs - Z*sn, Y, X*sn + Z*cs);
   X += center.X;
   Z += center.Z;
  }





  void rotateXYBy(f64 degrees, const vector3d<T>& center)
  {
   degrees *= DEGTORAD64;
   T cs = (T)cos(degrees);
   T sn = (T)sin(degrees);
   X -= center.X;
   Y -= center.Y;
   set(X*cs - Y*sn, X*sn + Y*cs, Z);
   X += center.X;
   Y += center.Y;
  }





  void rotateYZBy(f64 degrees, const vector3d<T>& center)
  {
   degrees *= DEGTORAD64;
   T cs = (T)cos(degrees);
   T sn = (T)sin(degrees);
   Z -= center.Z;
   Y -= center.Y;
   set(X, Y*cs - Z*sn, Y*sn + Z*cs);
   Z += center.Z;
   Y += center.Y;
  }




  vector3d<T> getInterpolated(const vector3d<T>& other, const T d) const
  {
   const T inv = (T) 1.0 - d;
   return vector3d<T>(other.X*inv + X*d, other.Y*inv + Y*d, other.Z*inv + Z*d);
  }





  vector3d<T> getInterpolated_quadratic(const vector3d<T>& v2, const vector3d<T>& v3, const T d) const
  {

   const T inv = (T) 1.0 - d;
   const T mul0 = inv * inv;
   const T mul1 = (T) 2.0 * d * inv;
   const T mul2 = d * d;

   return vector3d<T> ( X * mul0 + v2.X * mul1 + v3.X * mul2,
         Y * mul0 + v2.Y * mul1 + v3.Y * mul2,
         Z * mul0 + v2.Z * mul1 + v3.Z * mul2
        );
  }





  vector3d<T> getHorizontalAngle()
  {
   vector3d<T> angle;

   angle.Y = (T)atan2(X, Z);
   angle.Y *= (f32)RADTODEG64;

   if (angle.Y < 0.0f) angle.Y += 360.0f;
   if (angle.Y >= 360.0f) angle.Y -= 360.0f;

   f32 z1 = (f32)sqrt(X*X + Z*Z);

   angle.X = (T)atan2(z1, Y);
   angle.X *= (f32)RADTODEG64;
   angle.X -= 90.0f;

   if (angle.X < 0.0f) angle.X += 360.0f;
   if (angle.X >= 360.0f) angle.X -= 360.0f;

   return angle;
  }




  void getAs4Values(T* array) const
  {
   array[0] = X;
   array[1] = Y;
   array[2] = Z;
   array[3] = 0;
  }




  T X, Y, Z;
 };



 typedef vector3d<f32> vector3df;

 typedef vector3d<s32> vector3di;

 template<class S, class T> vector3d<T> operator*(const S scalar, const vector3d<T>& vector) { return vector*scalar; }

}
}
# 10 "H:/CPP/irrlicht-1.3/include/plane3d.h" 2

namespace irr
{
namespace core
{


enum EIntersectionRelation3D
{
 ISREL3D_FRONT = 0,
 ISREL3D_BACK,
 ISREL3D_PLANAR,
 ISREL3D_SPANNING,
 ISREL3D_CLIPPED
};


template <class T>
class plane3d
{
 public:



  plane3d(): Normal(0,1,0) { recalculateD(vector3d<T>(0,0,0)); };
  plane3d(const vector3d<T>& MPoint, const vector3d<T>& Normal) : Normal(Normal) { recalculateD(MPoint); };
  plane3d(T px, T py, T pz, T nx, T ny, T nz) : Normal(nx, ny, nz) { recalculateD(vector3d<T>(px, py, pz)); };
  plane3d(const plane3d<T>& other) : Normal(other.Normal), D(other.D) {};
  plane3d(const vector3d<T>& point1, const vector3d<T>& point2, const vector3d<T>& point3) { setPlane(point1, point2, point3); };



  inline bool operator==(const plane3d<T>& other) const { return (D==other.D && Normal==other.Normal);};
  inline bool operator!=(const plane3d<T>& other) const { return !(D==other.D && Normal==other.Normal);};



  void setPlane(const vector3d<T>& point, const vector3d<T>& nvector)
  {
   Normal = nvector;
   Normal.normalize();
   recalculateD(point);
  }

  void setPlane(const vector3d<T>& nvect, T d)
  {
   Normal = nvect;
   D = d;
  }

  void setPlane(const vector3d<T>& point1, const vector3d<T>& point2, const vector3d<T>& point3)
  {

   Normal = (point2 - point1).crossProduct(point3 - point1);
   Normal.normalize();

   recalculateD(point1);
  }







  bool getIntersectionWithLine(const vector3d<T>& linePoint, const vector3d<T>& lineVect,
     vector3d<T>& outIntersection) const
  {
   T t2 = Normal.dotProduct(lineVect);

   if (t2 == 0)
    return false;

   T t =- (Normal.dotProduct(linePoint) + D) / t2;
   outIntersection = linePoint + (lineVect * t);
   return true;
  }







  f32 getKnownIntersectionWithLine(const vector3d<T>& linePoint1,
   const vector3d<T>& linePoint2) const
  {
   vector3d<T> vect = linePoint2 - linePoint1;
   T t2 = (f32)Normal.dotProduct(vect);
   return (f32)-((Normal.dotProduct(linePoint1) + D) / t2);
  }






  bool getIntersectionWithLimitedLine(const vector3d<T>& linePoint1,
     const vector3d<T>& linePoint2, vector3d<T>& outIntersection) const
  {
   return ( getIntersectionWithLine(linePoint1, linePoint2 - linePoint1, outIntersection) &&
      outIntersection.isBetweenPoints(linePoint1, linePoint2));
  }






  EIntersectionRelation3D classifyPointRelation(const vector3d<T>& point) const
  {
   const T d = Normal.dotProduct(point) + D;

   if (d < -ROUNDING_ERROR_32)
    return ISREL3D_FRONT;

   if (d > ROUNDING_ERROR_32)
    return ISREL3D_BACK;

   return ISREL3D_PLANAR;
  }



  void recalculateD(const vector3d<T>& MPoint)
  {
   D = - MPoint.dotProduct(Normal);
  }


  vector3d<T> getMemberPoint() const
  {
   return Normal * -D;
  }



  bool existsInterSection(const plane3d<T>& other) const
  {
   vector3d<T> cross = other.Normal.crossProduct(Normal);
   return cross.getLength() > core::ROUNDING_ERROR_32;
  }



  bool getIntersectionWithPlane(const plane3d<T>& other, vector3d<T>& outLinePoint,
    vector3d<T>& outLineVect) const
  {
   f64 fn00 = Normal.getLength();
   f64 fn01 = Normal.dotProduct(other.Normal);
   f64 fn11 = other.Normal.getLength();
   f64 det = fn00*fn11 - fn01*fn01;

   if (fabs(det) < ROUNDING_ERROR_64 )
    return false;

   det = 1.0 / det;
   f64 fc0 = (fn11*-D + fn01*other.D) * det;
   f64 fc1 = (fn00*-other.D + fn01*D) * det;

   outLineVect = Normal.crossProduct(other.Normal);
   outLinePoint = Normal*(T)fc0 + other.Normal*(T)fc1;
   return true;
  }


  bool getIntersectionWithPlanes(const plane3d<T>& o1,
    const plane3d<T>& o2, vector3d<T>& outPoint) const
  {
   vector3d<T> linePoint, lineVect;
   if (getIntersectionWithPlane(o1, linePoint, lineVect))
    return o2.getIntersectionWithLine(linePoint, lineVect, outPoint);

   return false;
  }






  bool isFrontFacing(const vector3d<T>& lookDirection) const
  {
   const f32 d = Normal.dotProduct(lookDirection);
   return ((*((s32 *) &(d))) <= 0x00000000);
  }



  T getDistanceTo(const vector3d<T>& point) const
  {
   return point.dotProduct(Normal) + D;
  }



  vector3d<T> Normal;
  T D;
};



typedef plane3d<f32> plane3df;

typedef plane3d<s32> plane3di;

}
}
# 10 "H:/CPP/irrlicht-1.3/include/aabbox3d.h" 2
# 1 "H:/CPP/irrlicht-1.3/include/line3d.h" 1
# 11 "H:/CPP/irrlicht-1.3/include/line3d.h"
namespace irr
{
namespace core
{


template <class T>
class line3d
{
 public:



  line3d() : start(0,0,0), end(1,1,1) {};
  line3d(T xa, T ya, T za, T xb, T yb, T zb) : start(xa, ya, za), end(xb, yb, zb) {};
  line3d(const vector3d<T>& start, const vector3d<T>& end) : start(start), end(end) {};
  line3d(const line3d<T>& other) : start(other.start), end(other.end) {};



  line3d<T> operator+(const vector3d<T>& point) const { return line3d<T>(start + point, end + point); };
  line3d<T>& operator+=(const vector3d<T>& point) { start += point; end += point; return *this; };

  line3d<T> operator-(const vector3d<T>& point) const { return line3d<T>(start - point, end - point); };
  line3d<T>& operator-=(const vector3d<T>& point) { start -= point; end -= point; return *this; };

  bool operator==(const line3d<T>& other) const { return (start==other.start && end==other.end) || (end==other.start && start==other.end);};
  bool operator!=(const line3d<T>& other) const { return !(start==other.start && end==other.end) || (end==other.start && start==other.end);};



  void setLine(const T& xa, const T& ya, const T& za, const T& xb, const T& yb, const T& zb){start.set(xa, ya, za); end.set(xb, yb, zb);}
  void setLine(const vector3d<T>& nstart, const vector3d<T>& nend){start.set(nstart); end.set(nend);}
  void setLine(const line3d<T>& line){start.set(line.start); end.set(line.end);}



  f64 getLength() const { return start.getDistanceFrom(end); };



  T getLengthSQ() const { return start.getDistanceFromSQ(end); };


  vector3d<T> getMiddle() const
  {
   return (start + end) * (T)0.5;
  }


  vector3d<T> getVector() const
  {
   return end - start;
  }



  bool isPointBetweenStartAndEnd(const vector3d<T>& point) const
  {
   return point.isBetweenPoints(start, end);
  }


  vector3d<T> getClosestPoint(const vector3d<T>& point) const
  {
   vector3d<T> c = point - start;
   vector3d<T> v = end - start;
   T d = (T)v.getLength();
   v /= d;
   T t = v.dotProduct(c);

   if (t < (T)0.0) return start;
   if (t > d) return end;

   v *= t;
   return start + v;
  }
# 96 "H:/CPP/irrlicht-1.3/include/line3d.h"
  bool getIntersectionWithSphere(vector3d<T> sorigin, T sradius, f64& outdistance) const
  {
   vector3d<T> q = sorigin - start;
   f64 c = q.getLength();
   f64 v = q.dotProduct(getVector().normalize());
   f64 d = sradius * sradius - (c*c - v*v);

   if (d < 0.0)
    return false;

   outdistance = v - sqrt(d);
   return true;
  }



  vector3d<T> start;
  vector3d<T> end;
};


 typedef line3d<f32> line3df;

 typedef line3d<s32> line3di;

}
}
# 11 "H:/CPP/irrlicht-1.3/include/aabbox3d.h" 2

namespace irr
{
namespace core
{




template <class T>
class aabbox3d
{
 public:



  aabbox3d(): MinEdge(-1,-1,-1), MaxEdge(1,1,1) {};
  aabbox3d(const aabbox3d<T>& other): MinEdge(other.MinEdge), MaxEdge(other.MaxEdge) {};
  aabbox3d(const vector3d<T>& min, const vector3d<T>& max): MinEdge(min), MaxEdge(max) {};
  aabbox3d(const vector3d<T>& init): MinEdge(init), MaxEdge(init) {};
  aabbox3d(T minx, T miny, T minz, T maxx, T maxy, T maxz): MinEdge(minx, miny, minz), MaxEdge(maxx, maxy, maxz) {};



  inline bool operator==(const aabbox3d<T>& other) const { return (MinEdge == other.MinEdge && other.MaxEdge == MaxEdge);};
  inline bool operator!=(const aabbox3d<T>& other) const { return !(MinEdge == other.MinEdge && other.MaxEdge == MaxEdge);};






  void addInternalPoint(const vector3d<T>& p)
  {
   addInternalPoint(p.X, p.Y, p.Z);
  }




  void addInternalBox(const aabbox3d<T>& b)
  {
   addInternalPoint(b.MaxEdge);
   addInternalPoint(b.MinEdge);
  }


  void reset(T x, T y, T z)
  {
   MaxEdge.set(x,y,z);
   MinEdge = MaxEdge;
  }


  void reset(const aabbox3d<T>& initValue)
  {
   *this = initValue;
  }


  void reset(const vector3d<T>& initValue)
  {
   MaxEdge = initValue;
   MinEdge = initValue;
  }






  void addInternalPoint(T x, T y, T z)
  {
   if (x>MaxEdge.X) MaxEdge.X = x;
   if (y>MaxEdge.Y) MaxEdge.Y = y;
   if (z>MaxEdge.Z) MaxEdge.Z = z;

   if (x<MinEdge.X) MinEdge.X = x;
   if (y<MinEdge.Y) MinEdge.Y = y;
   if (z<MinEdge.Z) MinEdge.Z = z;
  }




  bool isPointInside(const vector3d<T>& p) const
  {
   return (p.X >= MinEdge.X && p.X <= MaxEdge.X &&
    p.Y >= MinEdge.Y && p.Y <= MaxEdge.Y &&
    p.Z >= MinEdge.Z && p.Z <= MaxEdge.Z);
  };




  bool isPointTotalInside(const vector3d<T>& p) const
  {
   return (p.X > MinEdge.X && p.X < MaxEdge.X &&
    p.Y > MinEdge.Y && p.Y < MaxEdge.Y &&
    p.Z > MinEdge.Z && p.Z < MaxEdge.Z);
  };





  bool intersectsWithBox(const aabbox3d<T>& other) const
  {
   return (MinEdge <= other.MaxEdge && MaxEdge >= other.MinEdge);
  }

  bool isFullInside(const aabbox3d<T>& other) const
  {
   return MinEdge >= other.MinEdge && MaxEdge <= other.MaxEdge;
  }




  bool intersectsWithLine(const line3d<T>& line) const
  {
   return intersectsWithLine(line.getMiddle(), line.getVector().normalize(),
     (T)(line.getLength() * 0.5));
  }



  bool intersectsWithLine(const vector3d<T>& linemiddle,
     const vector3d<T>& linevect,
     T halflength) const
  {
   const vector3d<T> e = getExtent() * (T)0.5;
   const vector3d<T> t = getCenter() - linemiddle;
   T r;

   if ((fabs(t.X) > e.X + halflength * fabs(linevect.X)) ||
    (fabs(t.Y) > e.Y + halflength * fabs(linevect.Y)) ||
    (fabs(t.Z) > e.Z + halflength * fabs(linevect.Z)) )
    return false;

   r = e.Y * (T)fabs(linevect.Z) + e.Z * (T)fabs(linevect.Y);
   if (fabs(t.Y*linevect.Z - t.Z*linevect.Y) > r )
    return false;

   r = e.X * (T)fabs(linevect.Z) + e.Z * (T)fabs(linevect.X);
   if (fabs(t.Z*linevect.X - t.X*linevect.Z) > r )
    return false;

   r = e.X * (T)fabs(linevect.Y) + e.Y * (T)fabs(linevect.X);
   if (fabs(t.X*linevect.Y - t.Y*linevect.X) > r)
    return false;

   return true;
  }






  EIntersectionRelation3D classifyPlaneRelation(const plane3d<T>& plane) const
  {
   vector3d<T> nearPoint(MaxEdge);
   vector3d<T> farPoint(MinEdge);

   if (plane.Normal.X > (T)0)
   {
    nearPoint.X = MinEdge.X;
    farPoint.X = MaxEdge.X;
   }

   if (plane.Normal.Y > (T)0)
   {
    nearPoint.Y = MinEdge.Y;
    farPoint.Y = MaxEdge.Y;
   }

   if (plane.Normal.Z > (T)0)
   {
    nearPoint.Z = MinEdge.Z;
    farPoint.Z = MaxEdge.Z;
   }

   if (plane.Normal.dotProduct(nearPoint) + plane.D > (T)0)
    return ISREL3D_FRONT;

   if (plane.Normal.dotProduct(farPoint) + plane.D > (T)0)
    return ISREL3D_CLIPPED;

   return ISREL3D_BACK;
  }



  vector3d<T> getCenter() const
  {
   return (MinEdge + MaxEdge) / 2;
  }


  vector3d<T> getExtent() const
  {
   return MaxEdge - MinEdge;
  }




  void getEdges(vector3d<T> *edges) const
  {
   const core::vector3d<T> middle = getCenter();
   const core::vector3d<T> diag = middle - MaxEdge;
# 237 "H:/CPP/irrlicht-1.3/include/aabbox3d.h"
   edges[0].set(middle.X + diag.X, middle.Y + diag.Y, middle.Z + diag.Z);
   edges[1].set(middle.X + diag.X, middle.Y - diag.Y, middle.Z + diag.Z);
   edges[2].set(middle.X + diag.X, middle.Y + diag.Y, middle.Z - diag.Z);
   edges[3].set(middle.X + diag.X, middle.Y - diag.Y, middle.Z - diag.Z);
   edges[4].set(middle.X - diag.X, middle.Y + diag.Y, middle.Z + diag.Z);
   edges[5].set(middle.X - diag.X, middle.Y - diag.Y, middle.Z + diag.Z);
   edges[6].set(middle.X - diag.X, middle.Y + diag.Y, middle.Z - diag.Z);
   edges[7].set(middle.X - diag.X, middle.Y - diag.Y, middle.Z - diag.Z);
  }




  bool isEmpty() const
  {
   return MinEdge.equals ( MaxEdge );
  }


  void repair()
  {
   T t;

   if (MinEdge.X > MaxEdge.X)
    { t=MinEdge.X; MinEdge.X = MaxEdge.X; MaxEdge.X=t; }
   if (MinEdge.Y > MaxEdge.Y)
    { t=MinEdge.Y; MinEdge.Y = MaxEdge.Y; MaxEdge.Y=t; }
   if (MinEdge.Z > MaxEdge.Z)
    { t=MinEdge.Z; MinEdge.Z = MaxEdge.Z; MaxEdge.Z=t; }
  }




  aabbox3d<T> getInterpolated(const aabbox3d<T>& other, f32 d) const
  {
   f32 inv = 1.0f - d;
   return aabbox3d<T>((other.MinEdge*inv) + (MinEdge*d),
    (other.MaxEdge*inv) + (MaxEdge*d));
  }



  vector3d<T> MinEdge;
  vector3d<T> MaxEdge;
};


 typedef aabbox3d<f32> aabbox3df;

 typedef aabbox3d<s32> aabbox3di;


}
}
# 34 "H:/CPP/irrlicht-1.3/include/irrlicht.h" 2
# 1 "H:/CPP/irrlicht-1.3/include/irrArray.h" 1
# 9 "H:/CPP/irrlicht-1.3/include/irrArray.h"
# 1 "H:/CPP/irrlicht-1.3/include/heapsort.h" 1
# 10 "H:/CPP/irrlicht-1.3/include/heapsort.h"
namespace irr
{
namespace core
{


template<class T>
inline void heapsink(T*array, s32 element, s32 max)
{
 while ((element<<1) < max)
 {
  s32 j = (element<<1);

  if (j+1 < max && array[j] < array[j+1])
   j = j+1;

  if (array[element] < array[j])
  {
   T t = array[j];
   array[j] = array[element];
   array[element] = t;
   element = j;
  }
  else
   return;
 }
}



template<class T>
inline void heapsort(T* array_, s32 size)
{




 T* virtualArray = array_ - 1;
 s32 virtualSize = size + 2;
 s32 i;



 for (i=((size-1)/2); i>=0; --i)
  heapsink(virtualArray, i+1, virtualSize-1);



 for (i=size-1; i>=0; --i)
 {
  T t = array_[0];
  array_[0] = array_[i];
  array_[i] = t;
  heapsink(virtualArray, 1, i + 1);
 }
}

}
}
# 10 "H:/CPP/irrlicht-1.3/include/irrArray.h" 2
# 1 "H:/CPP/irrlicht-1.3/include/irrAllocator.h" 1
# 10 "H:/CPP/irrlicht-1.3/include/irrAllocator.h"
# 1 "H:/CPP/wxdevcpp6.10/include/memory.h" 1
# 11 "H:/CPP/irrlicht-1.3/include/irrAllocator.h" 2

namespace irr
{
namespace core
{
# 24 "H:/CPP/irrlicht-1.3/include/irrAllocator.h"
template<typename T>
class irrAllocator
{
public:


 virtual ~irrAllocator() {}


 T* allocate(size_t cnt)
 {
  return (T*)internal_new(cnt* sizeof(T));
 }


 void deallocate(T* ptr)
 {
  internal_delete(ptr);
 }


 void construct(T* ptr, const T&e)
 {
  new ((void*)ptr) T(e);
 }


 void destruct(T* ptr)
 {
  ptr->~T();
 }

protected:

 virtual void* internal_new(size_t cnt)
 {
  return operator new(cnt);
 }

 virtual void internal_delete(void* ptr)
 {
  operator delete(ptr);
 }

};





template<typename T>
class irrAllocatorFast
{
public:


 T* allocate(size_t cnt)
 {
  return (T*)operator new(cnt* sizeof(T));
 }


 void deallocate(T* ptr)
 {
  operator delete(ptr);
 }


 void construct(T* ptr, const T&e)
 {
  new ((void*)ptr) T(e);
 }


 void destruct(T* ptr)
 {
  ptr->~T();
 }
};
# 112 "H:/CPP/irrlicht-1.3/include/irrAllocator.h"
}
}
# 11 "H:/CPP/irrlicht-1.3/include/irrArray.h" 2

namespace irr
{
namespace core
{




template <class T, typename TAlloc = irrAllocator<T> >
class array
{

public:

 array()
  : data(0), allocated(0), used(0),
   free_when_destroyed(true), is_sorted(true)
 {
 }



 array(u32 start_count)
  : data(0), allocated(0), used(0),
   free_when_destroyed(true), is_sorted(true)
 {
  reallocate(start_count);
 }



 array(const array<T>& other)
  : data(0)
 {
  *this = other;
 }





 ~array()
 {
  if (free_when_destroyed)
  {
   for (u32 i=0; i<used; ++i)
    allocator.destruct(&data[i]);

   allocator.deallocate(data);
  }
 }





 void reallocate(u32 new_size)
 {
  T* old_data = data;

  data = allocator.allocate(new_size);
  allocated = new_size;


  s32 end = used < new_size ? used : new_size;

  for (s32 i=0; i<end; ++i)
  {

   allocator.construct(&data[i], old_data[i]);
  }


  for (u32 j=0; j<used; ++j)
   allocator.destruct(&old_data[j]);

  if (allocated < used)
   used = allocated;

  allocator.deallocate(old_data);
 }




 void push_back(const T& element)
 {
  if (used + 1 > allocated)
  {





   T e(element);
   reallocate(used * 2 +1);

   allocator.construct(&data[used++], e);
  }
  else
  {


   allocator.construct(&data[used++], element);
  }

  is_sorted = false;
 }






 void push_front(const T& element)
 {
  if (used + 1 > allocated)
   reallocate(used +1);

  for (u32 i=used; i>0; --i)
  {

   allocator.construct(&data[i], data[i-1]);
  }


  allocator.construct(&data[0], element);

  is_sorted = false;
  ++used;
 }







 void insert(const T& element, u32 index=0)
 {
 

  if (used + 1 > allocated)
   reallocate(used +1);

  for (u32 i=used++; i>index; --i)
   allocator.construct(&data[i], data[i-1]);

  allocator.construct(&data[index], element);
  is_sorted = false;
 }





 void clear()
 {
  for (u32 i=0; i<used; ++i)
   allocator.destruct(&data[i]);

  allocator.deallocate(data);
  data = 0;
  used = 0;
  allocated = 0;
  is_sorted = true;
 }






 void set_pointer(T* newPointer, u32 size)
 {
  for (u32 i=0; i<used; ++i)
   allocator.destruct(&data[i]);

  allocator.deallocate(data);
  data = newPointer;
  allocated = size;
  used = size;
  is_sorted = false;
 }






 void set_free_when_destroyed(bool f)
 {
  free_when_destroyed = f;
 }







 void set_used(u32 usedNow)
 {
  if (allocated < usedNow)
   reallocate(usedNow);

  used = usedNow;
 }




 void operator=(const array<T>& other)
 {
  if (data)
  {
   for (u32 i=0; i<used; ++i)
    allocator.destruct(&data[i]);

   allocator.deallocate(data);
  }


  if (other.allocated == 0)
   data = 0;
  else
   data = allocator.allocate(other.allocated);

  used = other.used;
  free_when_destroyed = other.free_when_destroyed;
  is_sorted = other.is_sorted;
  allocated = other.allocated;

  for (u32 i=0; i<other.used; ++i)
   allocator.construct(&data[i], other.data[i]);
 }


 bool operator == (const array<T>& other) const
 {
  if (used != other.used)
   return false;

  for (u32 i=0; i<other.used; ++i)
   if (data[i] != other[i])
    return false;
  return true;
 }


 bool operator != (const array<T>& other) const
 {
  return !(*this==other);
 }


 T& operator [](u32 index)
 {
 

  return data[index];
 }




 const T& operator [](u32 index) const
 {
 

  return data[index];
 }


 T& getLast()
 {
 

  return data[used-1];
 }



 const T& getLast() const
 {
 

  return data[used-1];
 }



 T* pointer()
 {
  return data;
 }





 const T* const_pointer() const
 {
  return data;
 }





 u32 size() const
 {
  return used;
 }






 u32 allocated_size() const
 {
  return allocated;
 }





 bool empty() const
 {
  return used == 0;
 }





 void sort()
 {
  if (is_sorted || used<2)
   return;

  heapsort(data, used);
  is_sorted = true;
 }
# 367 "H:/CPP/irrlicht-1.3/include/irrArray.h"
 s32 binary_search(const T& element)
 {
  sort();
  return binary_search(element, 0, used-1);
 }






 s32 binary_search_const(const T& element) const
 {
  return binary_search(element, 0, used-1);
 }
# 391 "H:/CPP/irrlicht-1.3/include/irrArray.h"
 s32 binary_search(const T& element, s32 left, s32 right) const
 {
  if (!used)
   return -1;

  s32 m;

  do
  {
   m = (left+right)>>1;

   if (element < data[m])
    right = m - 1;
   else
    left = m + 1;

  } while((element < data[m] || data[m] < element) && left<=right);






  if (!(element < data[m]) && !(data[m] < element))
   return m;

  return -1;
 }







 s32 linear_search(const T& element) const
 {
  for (u32 i=0; i<used; ++i)
   if (!(element < data[i]) && !(data[i] < element))
    return (s32)i;

  return -1;
 }







 s32 linear_reverse_search(const T& element) const
 {
  for (s32 i=used-1; i>=0; --i)
   if (data[i] == element)
    return i;

  return -1;
 }






 void erase(u32 index)
 {
 

  for (u32 i=index+1; i<used; ++i)
  {
   allocator.destruct(&data[i-1]);
   allocator.construct(&data[i-1], data[i]);
  }

  allocator.destruct(&data[used-1]);

  --used;
 }






 void erase(u32 index, s32 count)
 {
 

  u32 i;
  for (i=index; i<index+count; ++i)
   allocator.destruct(&data[i]);

  for (i=index+count; i<used; ++i)
  {
   if (i > index+count)
    allocator.destruct(&data[i-count]);

   allocator.construct(&data[i-count], data[i]);

   if (i >= used-count)
    allocator.destruct(&data[i]);
  }

  used-= count;
 }



 void set_sorted(bool _is_sorted)
 {
  is_sorted = _is_sorted;
 }


 private:

  T* data;
  u32 allocated;
  u32 used;
  bool free_when_destroyed;
  bool is_sorted;
  TAlloc allocator;
};


}
}
# 35 "H:/CPP/irrlicht-1.3/include/irrlicht.h" 2
# 1 "H:/CPP/irrlicht-1.3/include/irrMap.h" 1
# 10 "H:/CPP/irrlicht-1.3/include/irrMap.h"
namespace irr
{
namespace core
{


template <class KeyType, class ValueType>
class map
{

 template <class KeyTypeRB, class ValueTypeRB>
 class RBTree
 {
 public:

  RBTree(const KeyTypeRB& k, const ValueTypeRB& v)
   : mLeftChild(0), mRightChild(0), mParent(0), mKey(k),
    mValue(v), mIsRed(true) {}

  virtual ~RBTree(){}

  void setLeftChild(RBTree* p) { mLeftChild=p; if (p) p->setParent(this); }
  void setRightChild(RBTree* p) { mRightChild=p;if (p) p->setParent(this); }
  void setParent(RBTree* p) { mParent=p; }

  void setValue(const ValueTypeRB& v) { mValue = v; }

  void setRed() { mIsRed = true; }
  void setBlack() { mIsRed = false; }

  RBTree* getLeftChild() const { return mLeftChild; }
  RBTree* getRightChild() const { return mRightChild; }
  RBTree* getParent() const { return mParent; }

  ValueTypeRB getValue() const
  {
   ;
   return mValue;
  }

  KeyTypeRB getKey() const
  {
   ;
   return mKey;
  }


  bool isRoot() const
  {
   ;
   return mParent==0;
  }

  bool isLeftChild() const
  {
   ;
   return mParent!=0 && mParent->getLeftChild()==this;
  }

  bool isRightChild() const
  {
   ;
   return mParent!=0 && mParent->getRightChild()==this;
  }

  bool isLeaf() const
  {
   ;
   return mLeftChild==0 && mRightChild==0;
  }

  unsigned int getLevel() const
  {
   if (isRoot())
    return 1;
   else
    return getParent()->getLevel() + 1;
  }


  bool isRed() const
  {
   ;
   return mIsRed;
  }

  bool isBlack() const
  {
   ;
   return !mIsRed;
  }

 private:
  RBTree();

  RBTree* mLeftChild;
  RBTree* mRightChild;

  RBTree* mParent;

  KeyTypeRB mKey;
  ValueTypeRB mValue;

  bool mIsRed;
 };

 public:

 typedef RBTree<KeyType,ValueType> Node;


 class Iterator
 {
 public:

  Iterator() : mRoot(0), mCur(0) {}


  Iterator(Node* root):mRoot(root)
  {
   reset();
  }


  Iterator(const Iterator& src) : mRoot(src.mRoot), mCur(src.mCur){}

  void reset(bool atLowest=true)
  {
   if (atLowest)
    mCur = getMin(mRoot);
   else
    mCur = getMax(mRoot);
  }

  bool atEnd() const
  {
   ;
   return mCur==0;
  }

  Node* getNode()
  {
   return mCur;
  }

  Iterator& operator=(const Iterator& src)
  {
   mRoot = src.mRoot;
   mCur = src.mCur;
   return (*this);
  }

  void operator++(int)
  {
   inc();
  }

  void operator--(int)
  {
   dec();
  }


  Node* operator -> ()
  {
   return getNode();
  }

  Node& operator* ()
  {
   if (atEnd())
    throw "Iterator at end";

   return *mCur;
  }

 private:

  Node* getMin(Node* n)
  {
   while(n && n->getLeftChild())
    n = n->getLeftChild();
   return n;
  }

  Node* getMax(Node* n)
  {
   while(n && n->getRightChild())
    n = n->getRightChild();
   return n;
  }

  void inc()
  {

   if (mCur==0)
    return;

   if (mCur->getRightChild())
   {


    mCur = getMin(mCur->getRightChild());
   }
   else if (mCur->isLeftChild())
   {


    mCur = mCur->getParent();
   }
   else
   {





    while(mCur->isRightChild())
     mCur = mCur->getParent();
    mCur = mCur->getParent();
   }
  }

  void dec()
  {

   if (mCur==0)
    return;

   if (mCur->getLeftChild())
   {


    mCur = getMax(mCur->getLeftChild());
   }
   else if (mCur->isRightChild())
   {


    mCur = mCur->getParent();
   }
   else
   {






    while(mCur->isLeftChild())
     mCur = mCur->getParent();
    mCur = mCur->getParent();
   }
  }

  Node* mRoot;
  Node* mCur;
 };
# 276 "H:/CPP/irrlicht-1.3/include/irrMap.h"
 class ParentFirstIterator
 {
 public:


 ParentFirstIterator():mRoot(0),mCur(0)
 {
 }


 explicit ParentFirstIterator(Node* root):mRoot(root),mCur(0)
 {
  reset();
 }

 void reset()
 {
  mCur = mRoot;
 }


 bool atEnd() const
 {
  ;
  return mCur==0;
 }

 Node* getNode()
 {
  return mCur;
 }


 ParentFirstIterator& operator=(const ParentFirstIterator& src)
 {
  mRoot = src.mRoot;
  mCur = src.mCur;
  return (*this);
 }


 void operator++(int)
 {
  inc();
 }


 Node* operator -> ()
 {
  return getNode();
 }

 Node& operator* ()
 {
  if (atEnd())
   throw "ParentFirstIterator at end";
  return *getNode();
 }

 private:

 void inc()
 {

  if (mCur==0)
   return;


  if (mCur->getLeftChild())
  {
   mCur = mCur->getLeftChild();
  }
  else if (mCur->getRightChild())
  {

   mCur = mCur->getRightChild();
  }
  else
  {



   while (mCur!=0)
   {



    if (mCur->isLeftChild() && mCur->getParent()->getRightChild())
    {
     mCur = mCur->getParent()->getRightChild();
     return;
    }
    mCur = mCur->getParent();
   }
  }
 }

 Node* mRoot;
 Node* mCur;

 };







 class ParentLastIterator
 {
 public:

  ParentLastIterator():mRoot(0),mCur(0){}

  explicit ParentLastIterator(Node* root) : mRoot(root), mCur(0)
  {
   reset();
  }

  void reset()
  {
   mCur = getMin(mRoot);
  }

  bool atEnd() const
  {
   ;
   return mCur==0;
  }

  Node* getNode()
  {
   return mCur;
  }

  ParentLastIterator& operator=(const ParentLastIterator& src)
  {
   mRoot = src.mRoot;
   mCur = src.mCur;
   return (*this);
  }

  void operator++(int)
  {
   inc();
  }

  Node* operator -> ()
  {
   return getNode();
  }

  Node& operator* ()
  {
   if (atEnd())
    throw "ParentLastIterator at end";
   return *getNode();
  }
 private:

  Node* getMin(Node* n)
  {
   while(n!=0 && (n->getLeftChild()!=0 || n->getRightChild()!=0))
   {
    if (n->getLeftChild())
     n = n->getLeftChild();
    else
     n = n->getRightChild();
   }
   return n;
  }

  void inc()
  {

   if (mCur==0)
    return;






   if (mCur->isLeftChild() && mCur->getParent()->getRightChild())
   {
    mCur = getMin(mCur->getParent()->getRightChild());
   }
   else
    mCur = mCur->getParent();
  }


  Node* mRoot;
  Node* mCur;
 };
# 480 "H:/CPP/irrlicht-1.3/include/irrMap.h"
 class AccessClass
 {

  friend class map<KeyType, ValueType>;

 public:


  void operator=(const ValueType& value)
  {

   mTree.set(mKey,value);
  }


  operator ValueType()
  {
   Node* node = mTree.find(mKey);


   if (node==0)
    throw "Item not found";

   ;
   return node->getValue();
  }

 private:

  AccessClass(map& tree, const KeyType& key):mTree(tree),mKey(key){}

  AccessClass();

  map& mTree;
  const KeyType& mKey;
 };



 map() : mRoot(0),mSize(0) {}


 ~map()
 {
  clear();
 }
# 536 "H:/CPP/irrlicht-1.3/include/irrMap.h"
 bool insert(const KeyType& keyNew, const ValueType& v)
 {

  Node* newNode = new Node(keyNew,v);
  if (!insert(newNode))
  {
   delete newNode;
   ;
   return false;
  }


  while (!newNode->isRoot() && (newNode->getParent()->isRed()))
  {
   if (newNode->getParent()->isLeftChild())
   {

    Node* newNodesUncle = newNode->getParent()->getParent()->getRightChild();
    if ( newNodesUncle!=0 && newNodesUncle->isRed())
    {

     newNode->getParent()->setBlack();
     newNodesUncle->setBlack();
     newNode->getParent()->getParent()->setRed();

     newNode = newNode->getParent()->getParent();
    }
    else
    {

     if ( newNode->isRightChild())
     {


      newNode = newNode->getParent();
      rotateLeft(newNode);
     }

     newNode->getParent()->setBlack();
     newNode->getParent()->getParent()->setRed();
     rotateRight(newNode->getParent()->getParent());
    }
   }
   else
   {

    Node* newNodesUncle = newNode->getParent()->getParent()->getLeftChild();
    if ( newNodesUncle!=0 && newNodesUncle->isRed())
    {

     newNode->getParent()->setBlack();
     newNodesUncle->setBlack();
     newNode->getParent()->getParent()->setRed();

     newNode = newNode->getParent()->getParent();
    }
    else
    {

     if (newNode->isLeftChild())
     {


      newNode = newNode->getParent();
      rotateRight(newNode);
     }

     newNode->getParent()->setBlack();
     newNode->getParent()->getParent()->setRed();
     rotateLeft(newNode->getParent()->getParent());
    }

   }
  }

  mRoot->setBlack();
  return true;
 }





 void set(const KeyType& k, const ValueType& v)
 {
  Node* p = find(k);
  if (p)
   p->setValue(v);
  else
   insert(k,v);
 }





 Node* delink(const KeyType& k)
 {
  Node* p = Find(k);
  if (p == 0)
   return 0;



  while(p->getRightChild())
  {

   rotateLeft(p);
  }

  Node* left = p->getLeftChild();


  if (p->isLeftChild())
   p->getParent()->setLeftChild(left);

  else if (p->isRightChild())
   p->getParent()->setRightChild(left);

  else
  {


   setRoot(left);
  }




  mSize--;
  return p;
 }



 bool remove(const KeyType& k)
 {
  Node* p = find(k);
  if (p == 0)
  {
   ;
   return false;
  }



  while(p->getRightChild())
  {

   rotateLeft(p);
  }

  Node* left = p->getLeftChild();


  if (p->isLeftChild())
   p->getParent()->setLeftChild(left);

  else if (p->isRightChild())
   p->getParent()->setRightChild(left);

  else
  {


   setRoot(left);
  }



  delete p;

  mSize--;
  return true;
 }


 void clear()
 {
  ParentLastIterator i(getParentLastIterator());

  while(!i.atEnd())
  {
   Node* p = i.getNode();
   i++;

   delete p;
  }
  mRoot = 0;
  mSize= 0;
 }



 bool isEmpty() const
 {
  ;
  return mRoot == 0;
 }




 Node* find(const KeyType& keyToFind) const
 {
  Node* pNode = mRoot;

  while(pNode!=0)
  {
   KeyType key(pNode->getKey());

   if (keyToFind == key)
    return pNode;
   else if (keyToFind < key)
    pNode = pNode->getLeftChild();
   else
    pNode = pNode->getRightChild();
  }

  return 0;
 }




 Node* getRoot() const
 {
  return mRoot;
 }


 u32 size() const
 {
  return mSize;
 }






 Iterator getIterator()
 {
  Iterator it(getRoot());
  return it;
 }





 ParentFirstIterator getParentFirstIterator()
 {
  ParentFirstIterator it(getRoot());
  return it;
 }





 ParentLastIterator getParentLastIterator()
 {
  ParentLastIterator it(getRoot());
  return it;
 }







 AccessClass operator[](const KeyType& k)
 {
  return AccessClass(*this, k);
 }
 private:







 explicit map(const map& src);
 map& operator = (const map& src);

 void setRoot(Node* newRoot)
 {
  mRoot = newRoot;
  if (mRoot!=0)
   mRoot->setParent(0);
 }



 bool insert(Node* newNode)
 {
  bool result=true;

  if (mRoot==0)
  {
   setRoot(newNode);
   mSize = 1;
  }
  else
  {
   Node* pNode = mRoot;
   KeyType keyNew = newNode->getKey();
   while (pNode)
   {
    KeyType key(pNode->getKey());

    if (keyNew == key)
    {
     result = false;
     pNode = 0;
    }
    else if (keyNew < key)
    {
     if (pNode->getLeftChild() == 0)
     {
      pNode->setLeftChild(newNode);
      pNode = 0;
     }
     else
      pNode = pNode->getLeftChild();
    }
    else
    {
     if (pNode->getRightChild()==0)
     {
      pNode->setRightChild(newNode);
      pNode = 0;
     }
     else
     {
      pNode = pNode->getRightChild();
     }
    }
   }

   if (result)
    mSize++;
  }

  ;
  return result;
 }



 void rotateLeft(Node* p)
 {
  Node* right = p->getRightChild();

  p->setRightChild(right->getLeftChild());

  if (p->isLeftChild())
   p->getParent()->setLeftChild(right);
  else if (p->isRightChild())
   p->getParent()->setRightChild(right);
  else
   setRoot(right);

  right->setLeftChild(p);
 }



 void rotateRight(Node* p)
 {

  Node* left = p->getLeftChild();

  p->setLeftChild(left->getRightChild());

  if (p->isLeftChild())
   p->getParent()->setLeftChild(left);
  else if (p->isRightChild())
   p->getParent()->setRightChild(left);
  else
   setRoot(left);

  left->setRightChild(p);
 }




 Node* mRoot;
 u32 mSize;

};

}
}
# 36 "H:/CPP/irrlicht-1.3/include/irrlicht.h" 2
# 1 "H:/CPP/irrlicht-1.3/include/SColor.h" 1
# 11 "H:/CPP/irrlicht-1.3/include/SColor.h"
namespace irr
{
namespace video
{

 inline u16 RGBA16(u32 r, u32 g, u32 b, u32 a)
 {
  return ((a & 0x80) << 8 |
   (r & 0xF8) << 7 |
   (g & 0xF8) << 2 |
   (b & 0xF8) >> 3);
 }



 inline u16 RGB16(u32 r, u32 g, u32 b)
 {
  return RGBA16(r,g,b,0xFF);
 }



 inline u16 RGB16from16(u16 r, u16 g, u16 b)
 {
  return (r & 0x1F) << 10 |
      (g & 0x1F) << 5 |
      (b & 0x1F);
 }



 inline u16 X8R8G8B8toA1R5G5B5(u32 color)
 {
  return ( 0x8000 |
   ( color & 0x00F80000) >> 9 |
   ( color & 0x0000F800) >> 6 |
   ( color & 0x000000F8) >> 3);
 }



 inline u16 A8R8G8B8toA1R5G5B5(u32 color)
 {
  return (( color & 0x80000000) >> 16|
   ( color & 0x00F80000) >> 9 |
   ( color & 0x0000F800) >> 6 |
   ( color & 0x000000F8) >> 3);
 }




 inline u32 A1R5G5B5toA8R8G8B8(u32 color)
 {
  return ( (( -( (s32) color & 0x00008000 ) >> (s32) 31 ) & 0xFF000000 ) |
    (( color & 0x00007C00 ) << 9) | (( color & 0x00007000 ) << 4) |
    (( color & 0x000003E0 ) << 6) | (( color & 0x00000380 ) << 1) |
    (( color & 0x0000001F ) << 3) | (( color & 0x0000001C ) >> 2)
    );
 }



 inline u32 R5G6B5toA8R8G8B8(u16 color)
 {
  return 0xFF000000 |
   ((color & 0xF800) << 8)|
   ((color & 0x07E0) << 5)|
   ((color & 0x001F) << 3);
 }



 inline u16 R5G6B5toA1R5G5B5(u16 color)
 {
  return 0x8000 | (((color & 0xFFC0) >> 1) | (color & 0x1F));
 }



 inline u16 A1R5G5B5toR5G6B5(u16 color)
 {
  return (((color & 0x7FE0) << 1) | (color & 0x1F));
 }




 inline u32 getAlpha(u16 color)
 {
  return ((color >> 15)&0x1);
 }




 inline u32 getRed(u16 color)
 {
  return ((color >> 10)&0x1F);
 }




 inline u32 getGreen(u16 color)
 {
  return ((color >> 5)&0x1F);
 }




 inline u32 getBlue(u16 color)
 {
  return (color & 0x1F);
 }



 inline s32 getRedSigned(u16 color)
 {
  return ((color >> 10)&0x1F);
 }




 inline s32 getGreenSigned(u16 color)
 {
  return ((color >> 5)&0x1F);
 }




 inline s32 getBlueSigned(u16 color)
 {
  return (color & 0x1F);
 }


 inline s32 getAverage(s16 color)
 {
  return ((getRed(color)<<3) + (getGreen(color)<<3) + (getBlue(color)<<3)) / 3;
 }
# 166 "H:/CPP/irrlicht-1.3/include/SColor.h"
 class SColor
 {
 public:



  inline SColor() {}



  inline SColor (u32 a, u32 r, u32 g, u32 b)
   : color(((a & 0xff)<<24) | ((r & 0xff)<<16) | ((g & 0xff)<<8) | (b & 0xff)) {}


  inline SColor(u32 clr)
   : color(clr) {}




  inline u32 getAlpha() const { return color>>24; }




  inline u32 getRed() const { return (color>>16) & 0xff; }




  inline u32 getGreen() const { return (color>>8) & 0xff; }




  inline u32 getBlue() const { return color & 0xff; }


  inline f32 getLuminance() const
  {
   return 0.3f*getRed() + 0.59f*getGreen() + 0.11f*getBlue();
  }


  inline u32 getAverage() const
  {
   return ( getRed() + getGreen() + getBlue() ) / 3;
  }





  inline void setAlpha(u32 a) { color = ((a & 0xff)<<24) | (color & 0x00ffffff); }




  inline void setRed(u32 r) { color = ((r & 0xff)<<16) | (color & 0xff00ffff); }




  inline void setGreen(u32 g) { color = ((g & 0xff)<<8) | (color & 0xffff00ff); }




  inline void setBlue(u32 b) { color = (b & 0xff) | (color & 0xffffff00); }



  inline u16 toA1R5G5B5() const { return A8R8G8B8toA1R5G5B5(color); };





  inline void toOpenGLColor(u8* dest) const
  {
   *dest = getRed();
   *++dest = getGreen();
   *++dest = getBlue();
   *++dest = getAlpha();
  };
# 268 "H:/CPP/irrlicht-1.3/include/SColor.h"
  inline void set(u32 a, u32 r, u32 g, u32 b) { color = (((a & 0xff)<<24) | ((r & 0xff)<<16) | ((g & 0xff)<<8) | (b & 0xff)); }
  inline void set(u32 col) { color = col; }



  inline bool operator==(const SColor& other) const { return other.color == color; }



  inline bool operator!=(const SColor& other) const { return other.color != color; }





  inline SColor getInterpolated(const SColor &other, f32 d) const
  {
   const f32 inv = 1.0f - d;
   return SColor((u32)(other.getAlpha()*inv + getAlpha()*d),
    (u32)(other.getRed()*inv + getRed()*d),
    (u32)(other.getGreen()*inv + getGreen()*d),
    (u32)(other.getBlue()*inv + getBlue()*d));
  }





  inline SColor getInterpolated_quadratic(const SColor& v2, const SColor& v3, const f32 d) const
  {

   const f32 inv = 1.f - d;
   const f32 mul0 = inv * inv;
   const f32 mul1 = 2.f * d * inv;
   const f32 mul2 = d * d;

   return SColor ( core::clamp ( core::floor32 ( getAlpha() * mul0 + v2.getAlpha() * mul1 + v3.getAlpha() * mul2 ), 0, 255 ),
       core::clamp ( core::floor32 ( getRed() * mul0 + v2.getRed() * mul1 + v3.getRed() * mul2 ), 0, 255 ),
       core::clamp ( core::floor32 ( getGreen() * mul0 + v2.getGreen() * mul1 + v3.getGreen() * mul2 ), 0, 255 ),
       core::clamp ( core::floor32 ( getBlue() * mul0 + v2.getBlue() * mul1 + v3.getBlue() * mul2 ), 0, 255 )
      );
  }



  u32 color;
 };
# 325 "H:/CPP/irrlicht-1.3/include/SColor.h"
 class SColorf
 {
 public:



  SColorf() : r(0.0f), g(0.0f), b(0.0f), a(0.0f) {};
# 340 "H:/CPP/irrlicht-1.3/include/SColor.h"
  SColorf(f32 r, f32 g, f32 b) : r(r), g(g), b(b), a(1.0f) {};
# 353 "H:/CPP/irrlicht-1.3/include/SColor.h"
  SColorf(f32 r, f32 g, f32 b, f32 a) : r(r), g(g), b(b), a(a) {};




  SColorf(SColor c) { const f32 inv = 1.0f / 255.0f; r = c.getRed() * inv; g = c.getGreen() * inv; b = c.getBlue() * inv; a = c.getAlpha() * inv; };


  SColor toSColor() const
  {
   return SColor((s32)(a*255.0f), (s32)(r*255.0f), (s32)(g*255.0f), (s32)(b*255.0f));
  }


  f32 r;


  f32 g;


  f32 b;


  f32 a;
# 385 "H:/CPP/irrlicht-1.3/include/SColor.h"
  void set(f32 rr, f32 gg, f32 bb) {r = rr; g =gg; b = bb; };
# 395 "H:/CPP/irrlicht-1.3/include/SColor.h"
  void set(f32 aa, f32 rr, f32 gg, f32 bb) {a = aa; r = rr; g =gg; b = bb; };





  inline SColorf getInterpolated(const SColorf &other, f32 d) const
  {
   const f32 inv = 1.0f - d;
   return SColorf(other.r*inv + r*d,
    other.g*inv + g*d, other.b*inv + b*d, other.a*inv + a*d);
  }





  inline SColorf getInterpolated_quadratic(const SColorf& v2, const SColorf& v3, const f32 d) const
  {

   const f32 inv = 1.f - d;
   const f32 mul0 = inv * inv;
   const f32 mul1 = 2.f * d * inv;
   const f32 mul2 = d * d;

   return SColorf ( r * mul0 + v2.r * mul1 + v3.r * mul2,
        g * mul0 + v2.g * mul1 + v3.g * mul2,
        g * mul0 + v2.b * mul1 + v3.b * mul2,
        a * mul0 + v2.a * mul1 + v3.a * mul2
       );
  }




  inline void setColorComponentValue(s32 index, f32 value)
  {
   switch(index)
   {
   case 0: r = value; break;
   case 1: g = value; break;
   case 2: b = value; break;
   case 3: a = value; break;
   }
  }
 };





 class SColorHSL
 {
 public:
  SColorHSL ( f32 h = 0.f, f32 s = 0.f, f32 l = 0.f )
   : Hue ( h ), Saturation ( s ), Luminance ( l ) {}

  void setfromRGB ( const SColor &color );
  void settoRGB ( SColor &color ) const;

  f32 Hue;
  f32 Saturation;
  f32 Luminance;

  private:
   inline u32 toRGB1(f32 rm1, f32 rm2, f32 rh) const;

 };

 inline void SColorHSL::settoRGB ( SColor &color ) const
 {
  if ( Saturation == 0.0f)
  {
   u8 c = (u8) ( Luminance * 255.0 );
   color.setRed ( c );
   color.setGreen ( c );
   color.setBlue ( c );
   return;
  }

  f32 rm1, rm2;

  if ( Luminance <= 0.5f )
  {
   rm2 = Luminance + Luminance * Saturation;
  }
  else
  {
   rm2 = Luminance + Saturation - Luminance * Saturation;
  }

  rm1 = 2.0f * Luminance - rm2;

  color.setRed ( toRGB1(rm1, rm2, Hue + (120.0f * core::DEGTORAD )) );
  color.setGreen ( toRGB1(rm1, rm2, Hue) );
  color.setBlue ( toRGB1(rm1, rm2, Hue - (120.0f * core::DEGTORAD) ) );
 }


 inline u32 SColorHSL::toRGB1(f32 rm1, f32 rm2, f32 rh) const
 {
  while ( rh > 2.f * core::PI )
   rh -= 2.f * core::PI;

  while ( rh < 0.f )
   rh += 2.f * core::PI;

  if (rh < 60.0f * core::DEGTORAD ) rm1 = rm1 + (rm2 - rm1) * rh / (60.0f * core::DEGTORAD);
  else if (rh < 180.0f * core::DEGTORAD ) rm1 = rm2;
  else if (rh < 240.0f * core::DEGTORAD ) rm1 = rm1 + (rm2 - rm1) * ( ( 240.0f * core::DEGTORAD ) - rh) / (60.0f * core::DEGTORAD);

  return (u32) (rm1 * 255.f);
 }

}
}
# 37 "H:/CPP/irrlicht-1.3/include/irrlicht.h" 2
# 1 "H:/CPP/irrlicht-1.3/include/SLight.h" 1
# 10 "H:/CPP/irrlicht-1.3/include/SLight.h"
namespace irr
{
namespace video
{


enum E_LIGHT_TYPE
{

 ELT_POINT,


 ELT_DIRECTIONAL
};


const c8* const LightTypeNames[] =
{
 "Point",
 "Directional",
 0
};





struct SLight
{
 SLight() : AmbientColor(0.0f,0.0f,0.0f), DiffuseColor(1.0f, 1.0f, 1.0f),
  SpecularColor(1.0f,1.0f,1.0f), Position(0.0f, 0.0f, 0.0f), Radius(100.0f),
  CastShadows(true), Type(ELT_POINT)
   {};


 SColorf AmbientColor;



 SColorf DiffuseColor;



 SColorf SpecularColor;


 core::vector3df Position;


 f32 Radius;


 bool CastShadows;


 E_LIGHT_TYPE Type;
};

}
}
# 38 "H:/CPP/irrlicht-1.3/include/irrlicht.h" 2
# 1 "H:/CPP/irrlicht-1.3/include/dimension2d.h" 1
# 10 "H:/CPP/irrlicht-1.3/include/dimension2d.h"
namespace irr
{
namespace core
{


 template <class T>
 class dimension2d
 {
  public:

   dimension2d()
    : Width(0), Height(0) {};

   dimension2d(T width, T height)
    : Width(width), Height(height) {};

   dimension2d(const dimension2d<T>& other)
    : Width(other.Width), Height(other.Height) {};


   bool operator == (const dimension2d<T>& other) const
   {
    return Width == other.Width && Height == other.Height;
   }


   bool operator != (const dimension2d<T>& other) const
   {
    return Width != other.Width || Height != other.Height;
   }

   const dimension2d<T>& operator=(const dimension2d<T>& other)
   {
    Width = other.Width;
    Height = other.Height;
    return *this;
   }

   dimension2d<T> operator/(T scale)
   {
    return dimension2d<T>(Width/scale, Height/scale);
   }

   dimension2d<T> operator*(T scale)
   {
    return dimension2d<T>(Width*scale, Height*scale);
   }

   T Width, Height;
 };


 typedef dimension2d<f32> dimension2df;

 typedef dimension2d<s32> dimension2di;

}
}
# 39 "H:/CPP/irrlicht-1.3/include/irrlicht.h" 2
# 1 "H:/CPP/irrlicht-1.3/include/EDriverTypes.h" 1







namespace irr
{
namespace video
{

 enum E_DRIVER_TYPE
 {



  EDT_NULL,






  EDT_SOFTWARE,
# 35 "H:/CPP/irrlicht-1.3/include/EDriverTypes.h"
  EDT_BURNINGSVIDEO,



  EDT_DIRECT3D8,



  EDT_DIRECT3D9,



  EDT_OPENGL
 };

}
}
# 40 "H:/CPP/irrlicht-1.3/include/irrlicht.h" 2

# 1 "H:/CPP/irrlicht-1.3/include/IAttributes.h" 1







# 1 "H:/CPP/irrlicht-1.3/include/IUnknown.h" 1
# 10 "H:/CPP/irrlicht-1.3/include/IUnknown.h"
namespace irr
{
# 41 "H:/CPP/irrlicht-1.3/include/IUnknown.h"
 class IUnknown
 {
 public:


  IUnknown()
   : ReferenceCounter(1), DebugName(0)
  {
  }


  virtual ~IUnknown()
  {
  }
# 84 "H:/CPP/irrlicht-1.3/include/IUnknown.h"
  void grab() { ++ReferenceCounter; }
# 112 "H:/CPP/irrlicht-1.3/include/IUnknown.h"
  bool drop()
  {
  

   --ReferenceCounter;
   if (!ReferenceCounter)
   {
    delete this;
    return true;
   }

   return false;
  }




  const c8* getDebugName() const
  {
   return DebugName;
  }

 protected:




  void setDebugName(const c8* newName)
  {
   DebugName = newName;
  }

 private:

  s32 ReferenceCounter;
  const c8* DebugName;
 };

}
# 9 "H:/CPP/irrlicht-1.3/include/IAttributes.h" 2


# 1 "H:/CPP/irrlicht-1.3/include/vector2d.h" 1
# 10 "H:/CPP/irrlicht-1.3/include/vector2d.h"
namespace irr
{
namespace core
{



template <class T>
class vector2d
{
public:

 vector2d() : X(0), Y(0) {};
 vector2d(T nx, T ny) : X(nx), Y(ny) {};
 vector2d(const vector2d<T>& other) : X(other.X), Y(other.Y) {};



 vector2d<T> operator-() const { return vector2d<T>(-X, -Y); }

 vector2d<T>& operator=(const vector2d<T>& other) { X = other.X; Y = other.Y; return *this; }

 vector2d<T> operator+(const vector2d<T>& other) const { return vector2d<T>(X + other.X, Y + other.Y); }
 vector2d<T>& operator+=(const vector2d<T>& other) { X+=other.X; Y+=other.Y; return *this; }

 vector2d<T> operator-(const vector2d<T>& other) const { return vector2d<T>(X - other.X, Y - other.Y); }
 vector2d<T>& operator-=(const vector2d<T>& other) { X-=other.X; Y-=other.Y; return *this; }

 vector2d<T> operator*(const vector2d<T>& other) const { return vector2d<T>(X * other.X, Y * other.Y); }
 vector2d<T>& operator*=(const vector2d<T>& other) { X*=other.X; Y*=other.Y; return *this; }
 vector2d<T> operator*(const T v) const { return vector2d<T>(X * v, Y * v); }
 vector2d<T>& operator*=(const T v) { X*=v; Y*=v; return *this; }

 vector2d<T> operator/(const vector2d<T>& other) const { return vector2d<T>(X / other.X, Y / other.Y); }
 vector2d<T>& operator/=(const vector2d<T>& other) { X/=other.X; Y/=other.Y; return *this; }
 vector2d<T> operator/(const T v) const { return vector2d<T>(X / v, Y / v); }
 vector2d<T>& operator/=(const T v) { X/=v; Y/=v; return *this; }

 bool operator<=(const vector2d<T>&other) const { return X<=other.X && Y<=other.Y; }
 bool operator>=(const vector2d<T>&other) const { return X>=other.X && Y>=other.Y; }

 bool operator<(const vector2d<T>&other) const { return X<other.X && Y<other.Y; }
 bool operator>(const vector2d<T>&other) const { return X>other.X && Y>other.Y; }

 bool operator==(const vector2d<T>& other) const { return other.X==X && other.Y==Y; }
 bool operator!=(const vector2d<T>& other) const { return other.X!=X || other.Y!=Y; }




 bool equals(const vector2d<T>& other) const
 {
  return core::equals(X, other.X) &&
      core::equals(Y, other.Y);
 }

 void set(T nx, T ny) {X=nx; Y=ny; }
 void set(const vector2d<T>& p) { X=p.X; Y=p.Y;}



 f64 getLength() const { return sqrt(X*X + Y*Y); }



 T getLengthSQ() const { return X*X + Y*Y; }


 T dotProduct(const vector2d<T>& other) const
 {
  return X*other.X + Y*other.Y;
 }



 f64 getDistanceFrom(const vector2d<T>& other) const
 {
  return vector2d<T>(X - other.X, Y - other.Y).getLength();
 }



 T getDistanceFromSQ(const vector2d<T>& other) const
 {
  return vector2d<T>(X - other.X, Y - other.Y).getLengthSQ();
 }


 void rotateBy(f64 degrees, const vector2d<T>& center)
 {
  degrees *= DEGTORAD64;
  T cs = (T)cos(degrees);
  T sn = (T)sin(degrees);

  X -= center.X;
  Y -= center.Y;

  set(X*cs - Y*sn, X*sn + Y*cs);

  X += center.X;
  Y += center.Y;
 }


 vector2d<T>& normalize()
 {
  T l = core::reciprocal_squareroot ( X*X + Y*Y );







  X *= l;
  Y *= l;
  return *this;
 }




 f64 getAngleTrig() const
 {
  if (X == 0.0)
   return Y < 0.0 ? 270.0 : 90.0;
  else
  if (Y == 0)
   return X < 0.0 ? 180.0 : 0.0;

  if ( Y > 0.0)
   if (X > 0.0)
    return atan(Y/X) * RADTODEG64;
   else
    return 180.0-atan(Y/-X) * RADTODEG64;
  else
   if (X > 0.0)
    return 360.0-atan(-Y/X) * RADTODEG64;
   else
    return 180.0+atan(-Y/-X) * RADTODEG64;
 }



 inline f64 getAngle() const
 {
  if (Y == 0.0)
   return X < 0.0 ? 180.0 : 0.0;
  else if (X == 0.0)
   return Y < 0.0 ? 90.0 : 270.0;

  f64 tmp = Y / getLength();
  tmp = atan(sqrt(1 - tmp*tmp) / tmp) * RADTODEG64;

  if (X>0.0 && Y>0.0)
   return tmp + 270;
  else
  if (X>0.0 && Y<0.0)
   return tmp + 90;
  else
  if (X<0.0 && Y<0.0)
   return 90 - tmp;
  else
  if (X<0.0 && Y>0.0)
   return 270 - tmp;

  return tmp;
 }



 inline f64 getAngleWith(const vector2d<T>& b) const
 {
  f64 tmp = X*b.X + Y*b.Y;

  if (tmp == 0.0)
   return 90.0;

  tmp = tmp / sqrt((X*X + Y*Y) * (b.X*b.X + b.Y*b.Y));
  if (tmp < 0.0) tmp = -tmp;

  return atan(sqrt(1 - tmp*tmp) / tmp) * RADTODEG64;
 }






 bool isBetweenPoints(const vector2d<T>& begin, const vector2d<T>& end) const
 {
  T f = (end - begin).getLengthSQ();
  return getDistanceFromSQ(begin) < f &&
   getDistanceFromSQ(end) < f;
 }




 vector2d<T> getInterpolated(const vector2d<T>& other, f32 d) const
 {
  T inv = (T) 1.0 - d;
  return vector2d<T>(other.X*inv + X*d, other.Y*inv + Y*d);
 }





 vector2d<T> getInterpolated_quadratic(const vector2d<T>& v2, const vector2d<T>& v3, const T d) const
 {

  const T inv = (T) 1.0 - d;
  const T mul0 = inv * inv;
  const T mul1 = (T) 2.0 * d * inv;
  const T mul2 = d * d;

  return vector2d<T> ( X * mul0 + v2.X * mul1 + v3.X * mul2,
        Y * mul0 + v2.Y * mul1 + v3.Y * mul2
       );
 }


 void interpolate(const vector2d<T>& a, const vector2d<T>& b, const f32 t)
 {
  X = b.X + ( ( a.X - b.X ) * t );
  Y = b.Y + ( ( a.Y - b.Y ) * t );
 }


 T X, Y;
};


 typedef vector2d<f32> vector2df;

 typedef vector2d<s32> vector2di;

 template<class S, class T> vector2d<T> operator*(const S scalar, const vector2d<T>& vector) { return vector*scalar; }

}
}
# 12 "H:/CPP/irrlicht-1.3/include/IAttributes.h" 2
# 1 "H:/CPP/irrlicht-1.3/include/line2d.h" 1
# 11 "H:/CPP/irrlicht-1.3/include/line2d.h"
namespace irr
{
namespace core
{


template <class T>
class line2d
{
 public:

  line2d() : start(0,0), end(1,1) {};
  line2d(T xa, T ya, T xb, T yb) : start(xa, ya), end(xb, yb) {};
  line2d(const vector2d<T>& start, const vector2d<T>& end) : start(start), end(end) {};
  line2d(const line2d<T>& other) : start(other.start), end(other.end) {};



  line2d<T> operator+(const vector2d<T>& point) const { return line2d<T>(start + point, end + point); };
  line2d<T>& operator+=(const vector2d<T>& point) { start += point; end += point; return *this; };

  line2d<T> operator-(const vector2d<T>& point) const { return line2d<T>(start - point, end - point); };
  line2d<T>& operator-=(const vector2d<T>& point) { start -= point; end -= point; return *this; };

  bool operator==(const line2d<T>& other) const { return (start==other.start && end==other.end) || (end==other.start && start==other.end);};
  bool operator!=(const line2d<T>& other) const { return !(start==other.start && end==other.end) || (end==other.start && start==other.end);};



  void setLine(const T& xa, const T& ya, const T& xb, const T& yb){start.set(xa, ya); end.set(xb, yb);}
  void setLine(const vector2d<T>& nstart, const vector2d<T>& nend){start.set(nstart); end.set(nend);}
  void setLine(const line2d<T>& line){start.set(line.start); end.set(line.end);}



  f64 getLength() const { return start.getDistanceFrom(end); };



  T getLengthSQ() const { return start.getDistanceFromSQ(end); };


  vector2d<T> getMiddle() const
  {
   return (start + end) * (T)0.5;
  }



  vector2d<T> getVector() const { return vector2d<T>(start.X - end.X, start.Y - end.Y); };






  bool intersectWith(const line2d<T>& l, vector2d<T>& out) const
  {
   bool found=false;

   f32 a1,a2,b1,b2;


   if (end.X-start.X == 0)
    b1 = (f32)1e+10;
   else
    b1 = (end.Y-start.Y)/(end.X-start.X);
   if (l.end.X-l.start.X == 0)
    b2 = (f32)1e+10;
   else
    b2 = (l.end.Y-l.start.Y)/(l.end.X-l.start.X);


   a1 = start.Y - b1 * start.X;
   a2 = l.start.Y - b2 * l.start.X;
   out.X = - (a1-a2)/(b1-b2);
   out.Y = a1 + b1*out.X;


   if ( (start.X-out.X) *(out.X-end.X) >= -ROUNDING_ERROR_32 &&
    (l.start.X-out.X)*(out.X-l.end.X)>= -ROUNDING_ERROR_32 &&
    (start.Y-out.Y) *(out.Y-end.Y) >= -ROUNDING_ERROR_32 &&
    (l.start.Y-out.Y)*(out.Y-l.end.Y)>= -ROUNDING_ERROR_32 )
   {
    found = true;
   }
   return found;
  }



  vector2d<T> getUnitVector()
  {
   T len = (T)(1.0 / getLength());
   return vector2d<T>((end.X - start.X) * len, (end.Y - start.Y) * len);
  }

  f64 getAngleWith(const line2d<T>& l)
  {
   vector2d<T> vect = getVector();
   vector2d<T> vect2 = l.getVector();
   return vect.getAngleWith(vect2);
  }





  T getPointOrientation(const vector2d<T>& point)
  {
   return ( (end.X - start.X) * (point.Y - start.Y) -
      (point.X - start.X) * (end.Y - start.Y) );
  }



  bool isPointOnLine(const vector2d<T>& point)
  {
   T d = getPointOrientation(point);
   return (d == 0 && point.isBetweenPoints(start, end));
  }



  bool isPointBetweenStartAndEnd(const vector2d<T>& point) const
  {
   return point.isBetweenPoints(start, end);
  }


  vector2d<T> getClosestPoint(const vector2d<T>& point) const
  {
   vector2d<T> c = point - start;
   vector2d<T> v = end - start;
   T d = (T)v.getLength();
   v /= d;
   T t = v.dotProduct(c);

   if (t < (T)0.0) return start;
   if (t > d) return end;

   v *= t;
   return start + v;
  }



  vector2d<T> start;
  vector2d<T> end;
};


 typedef line2d<f32> line2df;

 typedef line2d<s32> line2di;

}
}
# 13 "H:/CPP/irrlicht-1.3/include/IAttributes.h" 2

# 1 "H:/CPP/irrlicht-1.3/include/triangle3d.h" 1
# 13 "H:/CPP/irrlicht-1.3/include/triangle3d.h"
namespace irr
{
namespace core
{


 template <class T>
 class triangle3d
 {
 public:





  bool isTotalInsideBox(const aabbox3d<T>& box) const
  {
   return (box.isPointInside(pointA) &&
    box.isPointInside(pointB) &&
    box.isPointInside(pointC));
  }

  bool operator==(const triangle3d<T>& other) const { return other.pointA==pointA && other.pointB==pointB && other.pointC==pointC; }
  bool operator!=(const triangle3d<T>& other) const { return other.pointA!=pointA || other.pointB!=pointB || other.pointC!=pointC; }



  core::vector3d<T> closestPointOnTriangle(const core::vector3d<T>& p) const
  {
   core::vector3d<T> rab = line3d<T>(pointA, pointB).getClosestPoint(p);
   core::vector3d<T> rbc = line3d<T>(pointB, pointC).getClosestPoint(p);
   core::vector3d<T> rca = line3d<T>(pointC, pointA).getClosestPoint(p);

   T d1 = rab.getDistanceFrom(p);
   T d2 = rbc.getDistanceFrom(p);
   T d3 = rca.getDistanceFrom(p);

   if (d1 < d2)
    return d1 < d3 ? rab : rca;

   return d2 < d3 ? rbc : rca;
  }





  bool isPointInside(const vector3d<T>& p) const
  {
   return (isOnSameSide(p, pointA, pointB, pointC) &&
    isOnSameSide(p, pointB, pointA, pointC) &&
    isOnSameSide(p, pointC, pointA, pointB));
  }







  bool isPointInsideFast(const vector3d<T>& p) const
  {
   vector3d<T> f = pointB - pointA;
   vector3d<T> g = pointC - pointA;

   f32 a = f.dotProduct(f);
   f32 b = f.dotProduct(g);
   f32 c = g.dotProduct(g);

   f32 ac_bb = (a*c)-(b*b);
   vector3d<T> vp = p - pointA;

   f32 d = vp.dotProduct(f);
   f32 e = vp.dotProduct(g);
   f32 x = (d*c)-(e*b);
   f32 y = (e*a)-(d*b);
   f32 z = x+y-ac_bb;

   return (( ((u32&)z)& ~(((u32&)x)|((u32&)y))) & 0x80000000)!=0;
  }


  bool isOnSameSide(const vector3d<T>& p1, const vector3d<T>& p2,
   const vector3d<T>& a, const vector3d<T>& b) const
  {
   vector3d<T> bminusa = b - a;
   vector3d<T> cp1 = bminusa.crossProduct(p1 - a);
   vector3d<T> cp2 = bminusa.crossProduct(p2 - a);
   return (cp1.dotProduct(cp2) >= core::ROUNDING_ERROR_32);
  }






  bool getIntersectionWithLimitedLine(const line3d<T>& line,
   vector3d<T>& outIntersection) const
  {
   return getIntersectionWithLine(line.start,
    line.getVector(), outIntersection) &&
    outIntersection.isBetweenPoints(line.start, line.end);
  }
# 127 "H:/CPP/irrlicht-1.3/include/triangle3d.h"
  bool getIntersectionWithLine(const vector3d<T>& linePoint,
   const vector3d<T>& lineVect, vector3d<T>& outIntersection) const
  {
   if (getIntersectionOfPlaneWithLine(linePoint, lineVect, outIntersection))
    return isPointInside(outIntersection);

   return false;
  }
# 143 "H:/CPP/irrlicht-1.3/include/triangle3d.h"
  bool getIntersectionOfPlaneWithLine(const vector3d<T>& linePoint,
   const vector3d<T>& lineVect, vector3d<T>& outIntersection) const
  {
   const vector3d<T> normal = getNormal().normalize();
   T t2;

   if ( core::iszero ( t2 = normal.dotProduct(lineVect) ) )
    return false;

   T d = pointA.dotProduct(normal);
   T t = -(normal.dotProduct(linePoint) - d) / t2;
   outIntersection = linePoint + (lineVect * t);
   return true;
  }




  vector3d<T> getNormal() const
  {
   return (pointB - pointA).crossProduct(pointC - pointA);
  }





  bool isFrontFacing(const vector3d<T>& lookDirection) const
  {
   vector3d<T> n = getNormal();
   n.normalize();
   return n.dotProduct(lookDirection) <= 0.0f;
  }


  plane3d<T> getPlane() const
  {
   return plane3d<T>(pointA, pointB, pointC);
  }


  T getArea() const
  {
   return (pointB - pointA).crossProduct(pointC - pointA).getLength() * 0.5;

  }


  void set(const core::vector3d<T>& a, const core::vector3d<T>& b, const core::vector3d<T>& c)
  {
   pointA = a;
   pointB = b;
   pointC = c;
  }


  vector3d<T> pointA;
  vector3d<T> pointB;
  vector3d<T> pointC;
 };



 typedef triangle3d<f32> triangle3df;


 typedef triangle3d<s32> triangle3di;

}
}
# 15 "H:/CPP/irrlicht-1.3/include/IAttributes.h" 2
# 1 "H:/CPP/irrlicht-1.3/include/quaternion.h" 1
# 9 "H:/CPP/irrlicht-1.3/include/quaternion.h"
# 1 "H:/CPP/irrlicht-1.3/include/matrix4.h" 1
# 13 "H:/CPP/irrlicht-1.3/include/matrix4.h"
# 1 "H:/CPP/irrlicht-1.3/include/rect.h" 1
# 10 "H:/CPP/irrlicht-1.3/include/rect.h"
# 1 "H:/CPP/irrlicht-1.3/include/position2d.h" 1
# 11 "H:/CPP/irrlicht-1.3/include/position2d.h"
namespace irr
{
namespace core
{





 template <class T>
 class position2d
 {
  public:
   position2d(T x, T y)
    : X(x), Y(y) {};


   position2d()
    : X(0), Y(0) {};


   position2d(const position2d<T>& other)
    : X(other.X), Y(other.Y) {};


   bool operator == (const position2d<T>& other) const
   {
    return X == other.X && Y == other.Y;
   }


   bool operator != (const position2d<T>& other) const
   {
    return X != other.X || Y != other.Y;
   }

   const position2d<T>& operator+=(const position2d<T>& other)
   {
    X += other.X;
    Y += other.Y;
    return *this;
   }

   const position2d<T>& operator-=(const position2d<T>& other)
   {
    X -= other.X;
    Y -= other.Y;
    return *this;
   }

   const position2d<T>& operator+=(const dimension2d<T>& other)
   {
    X += other.Width;
    Y += other.Height;
    return *this;
   }

   const position2d<T>& operator-=(const dimension2d<T>& other)
   {
    X -= other.Width;
    Y -= other.Height;
    return *this;
   }

   position2d<T> operator-(const position2d<T>& other) const
   {
    return position2d<T>(X-other.X, Y-other.Y);
   }

   position2d<T> operator+(const position2d<T>& other) const
   {
    return position2d<T>(X+other.X, Y+other.Y);
   }

   position2d<T> operator*(const position2d<T>& other) const
   {
    return position2d<T>(X*other.X, Y*other.Y);
   }

   position2d<T> operator*(const T& scalar) const
   {
    return position2d<T>(X*scalar, Y*scalar);
   }

   position2d<T> operator+(const dimension2d<T>& other) const
   {
    return position2d<T>(X+other.Width, Y+other.Height);
   }

   position2d<T> operator-(const dimension2d<T>& other) const
   {
    return position2d<T>(X-other.Width, Y-other.Height);
   }

   const position2d<T>& operator=(const position2d<T>& other)
   {
    X = other.X;
    Y = other.Y;
    return *this;
   }

   T X, Y;
 };


 typedef position2d<f32> position2df;

 typedef position2d<s32> position2di;

}
}
# 11 "H:/CPP/irrlicht-1.3/include/rect.h" 2

namespace irr
{
namespace core
{






 template <class T>
 class rect
 {
 public:

  rect()
   : UpperLeftCorner(0,0), LowerRightCorner(0,0) {};


  rect(T x, T y, T x2, T y2)
   : UpperLeftCorner(x,y), LowerRightCorner(x2,y2) {};


  rect(const position2d<T>& upperLeft, const position2d<T>& lowerRight)
   : UpperLeftCorner(upperLeft), LowerRightCorner(lowerRight) {};

  rect(const rect<T>& other)
   : UpperLeftCorner(other.UpperLeftCorner), LowerRightCorner(other.LowerRightCorner) {};

  rect(const position2d<T>& pos, const dimension2d<T>& size)
   : UpperLeftCorner(pos), LowerRightCorner(pos.X + size.Width, pos.Y + size.Height) {};


  rect<T> operator+(const position2d<T>& pos) const
  {
   rect<T> ret(*this);
   ret.UpperLeftCorner += pos;
   ret.LowerRightCorner += pos;
   return ret;
  }

  const rect<T>& operator+=(const position2d<T>& pos)
  {
   UpperLeftCorner += pos;
   LowerRightCorner += pos;
   return *this;
  }

  rect<T> operator-(const position2d<T>& pos) const
  {
   rect<T> ret(*this);
   ret.UpperLeftCorner -= pos;
   ret.LowerRightCorner -= pos;
   return ret;
  }

  const rect<T>& operator-=(const position2d<T>& pos)
  {
   UpperLeftCorner -= pos;
   LowerRightCorner -= pos;
   return *this;
  }

  bool operator == (const rect<T>& other) const
  {
   return (UpperLeftCorner == other.UpperLeftCorner &&
    LowerRightCorner == other.LowerRightCorner);
  }


  bool operator != (const rect<T>& other) const
  {
   return (UpperLeftCorner != other.UpperLeftCorner ||
    LowerRightCorner != other.LowerRightCorner);
  }

  const rect<T>& operator = (const rect<T>& other)
  {
   UpperLeftCorner = other.UpperLeftCorner;
   LowerRightCorner = other.LowerRightCorner;
   return *this;
  }




  bool isPointInside(const position2d<T>& pos) const
  {
   return (UpperLeftCorner.X <= pos.X &&
    UpperLeftCorner.Y <= pos.Y &&
    LowerRightCorner.X >= pos.X &&
    LowerRightCorner.Y >= pos.Y);
  }


  bool isRectCollided(const rect<T>& other) const
  {
   return (LowerRightCorner.Y > other.UpperLeftCorner.Y &&
    UpperLeftCorner.Y < other.LowerRightCorner.Y &&
    LowerRightCorner.X > other.UpperLeftCorner.X &&
    UpperLeftCorner.X < other.LowerRightCorner.X);
  }


  void clipAgainst(const rect<T>& other)
  {
   if (other.LowerRightCorner.X < LowerRightCorner.X)
    LowerRightCorner.X = other.LowerRightCorner.X;
   if (other.LowerRightCorner.Y < LowerRightCorner.Y)
    LowerRightCorner.Y = other.LowerRightCorner.Y;

   if (other.UpperLeftCorner.X > UpperLeftCorner.X)
    UpperLeftCorner.X = other.UpperLeftCorner.X;
   if (other.UpperLeftCorner.Y > UpperLeftCorner.Y)
    UpperLeftCorner.Y = other.UpperLeftCorner.Y;


   if (UpperLeftCorner.Y > LowerRightCorner.Y)
    UpperLeftCorner.Y = LowerRightCorner.Y;
   if (UpperLeftCorner.X > LowerRightCorner.X)
    UpperLeftCorner.X = LowerRightCorner.X;
  }


  T getWidth() const
  {
   return LowerRightCorner.X - UpperLeftCorner.X;
  }


  T getHeight() const
  {
   return LowerRightCorner.Y - UpperLeftCorner.Y;
  }



  void repair()
  {
   if (LowerRightCorner.X < UpperLeftCorner.X)
   {
    T t = LowerRightCorner.X;
    LowerRightCorner.X = UpperLeftCorner.X;
    UpperLeftCorner.X = t;
   }

   if (LowerRightCorner.Y < UpperLeftCorner.Y)
   {
    T t = LowerRightCorner.Y;
    LowerRightCorner.Y = UpperLeftCorner.Y;
    UpperLeftCorner.Y = t;
   }
  }




  bool isValid() const
  {


   T xd = LowerRightCorner.X - UpperLeftCorner.X;
   T yd = LowerRightCorner.Y - UpperLeftCorner.Y;

   return !(xd < 0 || yd < 0 || (xd == 0 && yd == 0));
  }


  position2d<T> getCenter() const
  {
   return position2d<T>((UpperLeftCorner.X + LowerRightCorner.X) / 2,
    (UpperLeftCorner.Y + LowerRightCorner.Y) / 2);
  }


  dimension2d<T> getSize() const
  {
   return dimension2d<T>(getWidth(), getHeight());
  }





  void addInternalPoint(const position2d<T>& p)
  {
   addInternalPoint(p.X, p.Y);
  }





  void addInternalPoint(T x, T y)
  {
   if (x>LowerRightCorner.X) LowerRightCorner.X = x;
   if (y>LowerRightCorner.Y) LowerRightCorner.Y = y;

   if (x<UpperLeftCorner.X) UpperLeftCorner.X = x;
   if (y<UpperLeftCorner.Y) UpperLeftCorner.Y = y;
  }




  position2d<T> UpperLeftCorner;
  position2d<T> LowerRightCorner;
 };

}
}
# 14 "H:/CPP/irrlicht-1.3/include/matrix4.h" 2
# 1 "H:/CPP/irrlicht-1.3/include/irrString.h" 1
# 15 "H:/CPP/irrlicht-1.3/include/irrString.h"
namespace irr
{
namespace core
{
# 30 "H:/CPP/irrlicht-1.3/include/irrString.h"
template <typename T, typename TAlloc = irrAllocator<T> >
class string
{
public:


 string()
 : array(0), allocated(1), used(1)
 {
  array = allocator.allocate(1);
  array[0] = 0x0;
 }




 string(const string<T>& other)
 : array(0), allocated(0), used(0)
 {
  *this = other;
 }



 string(double number)
 : array(0), allocated(0), used(0)
 {
  c8 tmpbuf[255];
  sprintf(tmpbuf,"%0.6f",number);
  *this = tmpbuf;
 }




 string(int number)
 : array(0), allocated(0), used(0)
 {


  bool negative = false;
  if (number < 0)
  {
   number *= -1;
   negative = true;
  }



  c8 tmpbuf[16];
  tmpbuf[15] = 0;
  u32 idx = 15;



  if (!number)
  {
   tmpbuf[14] = '0';
   *this = &tmpbuf[14];
   return;
  }



  while(number && idx)
  {
   --idx;
   tmpbuf[idx] = (c8)('0' + (number % 10));
   number /= 10;
  }



  if (negative)
  {
   --idx;
   tmpbuf[idx] = '-';
  }

  *this = &tmpbuf[idx];
 }




 string(unsigned int number)
 : array(0), allocated(0), used(0)
 {


  c8 tmpbuf[16];
  tmpbuf[15] = 0;
  u32 idx = 15;



  if (!number)
  {
   tmpbuf[14] = '0';
   *this = &tmpbuf[14];
   return;
  }



  while(number && idx)
  {
   --idx;
   tmpbuf[idx] = (c8)('0' + (number % 10));
   number /= 10;
  }

  *this = &tmpbuf[idx];
 }




 template <class B>
 string(const B* const c, u32 length)
 : array(0), allocated(0), used(0)
 {
  if (!c)
  {

   *this="";
   return;
  }

  allocated = used = length+1;
  array = allocator.allocate(used);

  for (u32 l = 0; l<length; ++l)
   array[l] = (T)c[l];

  array[length] = 0;
 }




 template <class B>
 string(const B* const c)
 : array(0), allocated(0), used(0)
 {
  *this = c;
 }




 ~string()
 {
  allocator.deallocate(array);
 }




 string<T>& operator=(const string<T>& other)
 {
  if (this == &other)
   return *this;

  allocator.deallocate(array);
  allocated = used = other.size()+1;
  array = allocator.allocate(used);

  const T* p = other.c_str();
  for (u32 i=0; i<used; ++i, ++p)
   array[i] = *p;

  return *this;
 }




 template <class B>
 string<T>& operator=(const B* const c)
 {
  if (!c)
  {
   if (!array)
   {
    array = allocator.allocate(1);
    allocated = 1;
   }
   used = 1;
   array[0] = 0x0;
   return *this;
  }

  if ((void*)c == (void*)array)
   return *this;

  u32 len = 0;
  const B* p = c;
  while(*p)
  {
   ++len;
   ++p;
  }



  T* oldArray = array;

  ++len;
  allocated = used = len;
  array = allocator.allocate(used);

  for (u32 l = 0; l<len; ++l)
   array[l] = (T)c[l];

  allocator.deallocate(oldArray);
  return *this;
 }


 string<T> operator+(const string<T>& other) const
 {
  string<T> str(*this);
  str.append(other);

  return str;
 }


 template <class B>
 string<T> operator+(const B* const c) const
 {
  string<T> str(*this);
  str.append(c);

  return str;
 }




 T& operator [](const u32 index) const
 {
 

  return array[index];
 }



 bool operator ==(const T* const str) const
 {
  if (!str)
   return false;

  u32 i;
  for(i=0; array[i] && str[i]; ++i)
   if (array[i] != str[i])
    return false;

  return !array[i] && !str[i];
 }




 bool operator ==(const string<T>& other) const
 {
  for(u32 i=0; array[i] && other.array[i]; ++i)
   if (array[i] != other.array[i])
    return false;

  return used == other.used;
 }



 bool operator <(const string<T>& other) const
 {
  for(u32 i=0; array[i] && other.array[i]; ++i)
  {
   s32 diff = array[i] - other.array[i];
   if ( diff )
    return diff < 0;




  }

  return used < other.used;
 }




 bool operator !=(const T* const str) const
 {
  return !(*this == str);
 }




 bool operator !=(const string<T>& other) const
 {
  return !(*this == other);
 }





 u32 size() const
 {
  return used-1;
 }





 const T* c_str() const
 {
  return array;
 }




 void make_lower()
 {
  for (u32 i=0; i<used; ++i)
   array[i] = ansi_lower ( array[i] );
 }




 void make_upper()
 {
  const T a = (T)'a';
  const T z = (T)'z';
  const T diff = (T)'A' - a;

  for (u32 i=0; i<used; ++i)
  {
   if (array[i]>=a && array[i]<=z)
    array[i] += diff;
  }
 }






 bool equals_ignore_case(const string<T>& other) const
 {
  for(u32 i=0; array[i] && other[i]; ++i)
   if (ansi_lower(array[i]) != ansi_lower(other[i]))
    return false;

  return used == other.used;
 }




 bool lower_ignore_case(const string<T>& other) const
 {
  for(u32 i=0; array[i] && other.array[i]; ++i)
  {
   s32 diff = (s32) ansi_lower ( array[i] ) - (s32) ansi_lower ( other.array[i] );
   if ( diff )
    return diff < 0;
  }

  return used < other.used;
 }




 bool equalsn(const string<T>& other, int len) const
 {
  u32 i;
  for(i=0; array[i] && other[i] && i < len; ++i)
   if (array[i] != other[i])
    return false;



  return (i == len) || (used == other.used);
 }



 bool equalsn(const T* const str, int len) const
 {
  if (!str)
   return false;
  u32 i;
  for(i=0; array[i] && str[i] && i < len; ++i)
   if (array[i] != str[i])
    return false;



  return (i == len) || (array[i] == 0 && str[i] == 0);
 }




 void append(T character)
 {
  if (used + 1 > allocated)
   reallocate(used + 1);

  ++used;

  array[used-2] = character;
  array[used-1] = 0;
 }



 void append(const T* const other)
 {
  if (!other)
   return;

  u32 len = 0;
  const T* p = other;
  while(*p)
  {
   ++len;
   ++p;
  }

  if (used + len > allocated)
   reallocate(used + len);

  --used;
  ++len;

  for (u32 l=0; l<len; ++l)
   array[l+used] = *(other+l);

  used += len;
 }




 void append(const string<T>& other)
 {
  --used;
  u32 len = other.size()+1;

  if (used + len > allocated)
   reallocate(used + len);

  for (u32 l=0; l<len; ++l)
   array[used+l] = other[l];

  used += len;
 }





 void append(const string<T>& other, u32 length)
 {
  if (other.size() < length)
  {
   append(other);
   return;
  }

  if (used + length > allocated)
   reallocate(used + length);

  --used;

  for (u32 l=0; l<length; ++l)
   array[l+used] = other[l];
  used += length;


  array[used]=0;
  ++used;
 }




 void reserve(u32 count)
 {
  if (count < allocated)
   return;

  reallocate(count);
 }






 s32 findFirst(T c) const
 {
  for (u32 i=0; i<used; ++i)
   if (array[i] == c)
    return i;

  return -1;
 }
# 558 "H:/CPP/irrlicht-1.3/include/irrString.h"
 s32 findFirstChar(const T* const c, u32 count) const
 {
  if (!c)
   return -1;

  for (u32 i=0; i<used; ++i)
   for (u32 j=0; j<count; ++j)
    if (array[i] == c[j])
     return i;

  return -1;
 }
# 579 "H:/CPP/irrlicht-1.3/include/irrString.h"
 template <class B>
 s32 findFirstCharNotInList(const B* const c, u32 count) const
 {
  for (u32 i=0; i<used-1; ++i)
  {
   u32 j;
   for (j=0; j<count; ++j)
    if (array[i] == c[j])
     break;

   if (j==count)
    return i;
  }

  return -1;
 }
# 603 "H:/CPP/irrlicht-1.3/include/irrString.h"
 template <class B>
 s32 findLastCharNotInList(const B* const c, u32 count) const
 {
  for (s32 i=(s32)(used-2); i>=0; --i)
  {
   u32 j;
   for (j=0; j<count; ++j)
    if (array[i] == c[j])
     break;

   if (j==count)
    return i;
  }

  return -1;
 }






 s32 findNext(T c, u32 startPos) const
 {
  for (u32 i=startPos; i<used; ++i)
   if (array[i] == c)
    return i;

  return -1;
 }







 s32 findLast(T c, s32 start = -1) const
 {
  start = core::clamp ( start < 0 ? (s32)(used) - 1 : start, 0, (s32)(used) - 1 );
  for (s32 i=start; i>=0; --i)
   if (array[i] == c)
    return i;

  return -1;
 }





 template <class B>
 s32 find(const B* const str) const
 {
  if (str && *str)
  {
   u32 len = 0;

   while (str[len])
    ++len;

   if (len > used-1)
    return -1;

   for (u32 i=0; i<used-len; ++i)
   {
    u32 j=0;

    while(str[j] && array[i+j] == str[j])
     ++j;

    if (!str[j])
     return i;
   }
  }

  return -1;
 }





 string<T> subString(u32 begin, s32 length) const
 {
  if ((length+begin) > size())
   length = size()-begin;
  if (length <= 0)
   return string<T>("");

  string<T> o;
  o.reserve(length+1);

  for (s32 i=0; i<length; ++i)
   o.array[i] = array[i+begin];

  o.array[length] = 0;
  o.used = o.allocated;

  return o;
 }


 void operator += (T c)
 {
  append(c);
 }

 void operator += (const T* const c)
 {
  append(c);
 }

 void operator += (const string<T>& other)
 {
  append(other);
 }

 void operator += (int i)
 {
  append(string<T>(i));
 }

 void operator += (double i)
 {
  append(string<T>(i));
 }


 void replace(T toReplace, T replaceWith)
 {
  for (u32 i=0; i<used; ++i)
   if (array[i] == toReplace)
    array[i] = replaceWith;
 }



 void trim()
 {
  const c8 whitespace[] = " \t\n\r";
  const u32 whitespacecount = 4;


  s32 begin = findFirstCharNotInList(whitespace, whitespacecount);
  if (begin == -1)
  {
   *this="";
   return;
  }

  s32 end = findLastCharNotInList(whitespace, whitespacecount);

  *this = subString(begin, (end +1) - begin);
 }





 void erase(u32 index)
 {
 

  for (u32 i=index+1; i<used; ++i)
   array[i-1] = array[i];

  --used;
 }



private:
# 786 "H:/CPP/irrlicht-1.3/include/irrString.h"
 inline T ansi_lower ( u32 x ) const
 {
  return x >= 'A' && x <= 'Z' ? (T) x + 0x20 : (T) x;
 }



 void reallocate(u32 new_size)
 {
  T* old_array = array;

  array = allocator.allocate(new_size);
  allocated = new_size;

  u32 amount = used < new_size ? used : new_size;
  for (u32 i=0; i<amount; ++i)
   array[i] = old_array[i];

  if (allocated < used)
   used = allocated;

  allocator.deallocate(old_array);
 }




 T* array;
 u32 allocated;
 u32 used;
 TAlloc allocator;
};



typedef string<irr::c8> stringc;


typedef string<wchar_t> stringw;

}
}
# 15 "H:/CPP/irrlicht-1.3/include/matrix4.h" 2

namespace irr
{
namespace core
{





 class matrix4
 {
  public:


   enum eConstructor
   {
    EM4CONST_NOTHING = 0,
    EM4CONST_COPY,
    EM4CONST_IDENTITY,
    EM4CONST_TRANSPOSED,
    EM4CONST_INVERSE,
    EM4CONST_INVERSE_TRANSPOSED
   };

   matrix4( eConstructor constructor = EM4CONST_IDENTITY );
   matrix4( const matrix4& other,eConstructor constructor = EM4CONST_COPY);


   f32& operator()(const s32 row, const s32 col) { definitelyIdentityMatrix=false; return M[ row * 4 + col ]; }


   const f32& operator()(const s32 row, const s32 col) const { return M[row * 4 + col]; }


   f32& operator[](u32 index) { definitelyIdentityMatrix=false; return M[index]; }


   const f32& operator[](u32 index) const { return M[index]; }


   inline matrix4& operator=(const matrix4 &other);


   inline matrix4& operator=(const f32 scalar);


   const f32* pointer() const { return M; }
   f32* pointer() { definitelyIdentityMatrix=false; return M; }


   bool operator==(const matrix4 &other) const;


   bool operator!=(const matrix4 &other) const;


   matrix4 operator+(const matrix4& other) const;


   matrix4& operator+=(const matrix4& other);


   matrix4 operator-(const matrix4& other) const;


   matrix4& operator-=(const matrix4& other);


   inline void setbyproduct(const matrix4& other_a,const matrix4& other_b );



   void setbyproduct_nocheck(const matrix4& other_a,const matrix4& other_b );


   matrix4 operator*(const matrix4& other) const;


   matrix4& operator*=(const matrix4& other);


   matrix4 operator*(const f32 scalar) const;


   matrix4& operator*=(const f32 scalar);


   inline void makeIdentity();


   inline bool isIdentity() const;


   bool isIdentity_integer_base () const;


   void setTranslation( const vector3df& translation );


   vector3df getTranslation() const;


   void setInverseTranslation( const vector3df& translation );


   inline void setRotationRadians( const vector3df& rotation );


   void setRotationDegrees( const vector3df& rotation );


   core::vector3df getRotationDegrees() const;


   inline void setInverseRotationRadians( const vector3df& rotation );


   void setInverseRotationDegrees( const vector3df& rotation );


   void setScale( const vector3df& scale );


   core::vector3df getScale() const;


   void inverseTranslateVect( vector3df& vect ) const;


   void inverseRotateVect( vector3df& vect ) const;


   void rotateVect( vector3df& vect ) const;


   void transformVect( vector3df& vect) const;


   void transformVect( vector3df& out, const vector3df& in ) const;


   void transformVect(f32 *out,const core::vector3df &in) const;


   void rotateVect(f32 *out,const core::vector3df &in) const;


   void translateVect( vector3df& vect ) const;


   void transformPlane( core::plane3d<f32> &plane) const;


   void transformPlane_new( core::plane3d<f32> &plane) const;


   void transformPlane( const core::plane3d<f32> &in, core::plane3d<f32> &out) const;




   void transformBox(core::aabbox3d<f32>& box) const;




   void transformBoxEx(core::aabbox3d<f32>& box) const;


   void multiplyWith1x4Matrix(f32* matrix) const;



   bool makeInverse();




   bool getInversePrimitive ( matrix4& out ) const;




   bool getInverse(matrix4& out) const;


   void buildProjectionMatrixPerspectiveFovRH(f32 fieldOfViewRadians, f32 aspectRatio, f32 zNear, f32 zFar);


   void buildProjectionMatrixPerspectiveFovLH(f32 fieldOfViewRadians, f32 aspectRatio, f32 zNear, f32 zFar);


   void buildProjectionMatrixPerspectiveRH(f32 widthOfViewVolume, f32 heightOfViewVolume, f32 zNear, f32 zFar);


   void buildProjectionMatrixPerspectiveLH(f32 widthOfViewVolume, f32 heightOfViewVolume, f32 zNear, f32 zFar);


   void buildProjectionMatrixOrthoLH(f32 widthOfViewVolume, f32 heightOfViewVolume, f32 zNear, f32 zFar);


   void buildProjectionMatrixOrthoRH(f32 widthOfViewVolume, f32 heightOfViewVolume, f32 zNear, f32 zFar);


   void buildCameraLookAtMatrixLH(const vector3df& position, const vector3df& target, const vector3df& upVector);


   void buildCameraLookAtMatrixRH(const vector3df& position, const vector3df& target, const vector3df& upVector);






   void buildShadowMatrix(const core::vector3df& light, core::plane3df plane, f32 point=1.0f);



   void buildNDCToDCMatrix( const core::rect<s32>& area, f32 zScale);




   matrix4 interpolate(const core::matrix4& b, f32 time) const;


   matrix4 getTransposed() const;


   inline void getTransposed( matrix4& dest ) const;





   void setTextureScale ( f32 sx, f32 sy );

   void setTextureRotationCenter( f32 radAngle );
   void setTextureScaleCenter( f32 sx, f32 sy );

   void setTextureTranslate ( f32 x, f32 y );

   void buildTextureTransform( f32 rotateRad,
     const core::vector2df &rotatecenter,
     const core::vector2df &translate,
     const core::vector2df &scale);

  private:

   f32 M[16];
   bool definitelyIdentityMatrix;
 };

 inline matrix4::matrix4( matrix4::eConstructor constructor ) : definitelyIdentityMatrix(false)
 {
  switch ( constructor )
  {
   case EM4CONST_NOTHING:
   case EM4CONST_COPY:
    break;
   case EM4CONST_IDENTITY:
   case EM4CONST_INVERSE:
   default:
    makeIdentity();
    break;
  }
 }

 inline matrix4::matrix4( const matrix4& other,matrix4::eConstructor constructor) : definitelyIdentityMatrix(false)
 {
  switch ( constructor )
  {
   case EM4CONST_IDENTITY:
    makeIdentity();
    break;
   case EM4CONST_NOTHING:
    break;
   case EM4CONST_COPY:
    *this = other;
    break;
   case EM4CONST_TRANSPOSED:
    other.getTransposed(*this);
    break;
   case EM4CONST_INVERSE:
    if (!other.getInverse(*this))
     memset(M, 0, 16*sizeof(f32));
    break;
   case EM4CONST_INVERSE_TRANSPOSED:
    if (!other.getInverse(*this))
     memset(M, 0, 16*sizeof(f32));
    else
     *this=getTransposed();
    break;
  }
 }


 inline matrix4 matrix4::operator+(const matrix4& other) const
 {
  matrix4 temp ( EM4CONST_NOTHING );

  temp[0] = M[0]+other[0];
  temp[1] = M[1]+other[1];
  temp[2] = M[2]+other[2];
  temp[3] = M[3]+other[3];
  temp[4] = M[4]+other[4];
  temp[5] = M[5]+other[5];
  temp[6] = M[6]+other[6];
  temp[7] = M[7]+other[7];
  temp[8] = M[8]+other[8];
  temp[9] = M[9]+other[9];
  temp[10] = M[10]+other[10];
  temp[11] = M[11]+other[11];
  temp[12] = M[12]+other[12];
  temp[13] = M[13]+other[13];
  temp[14] = M[14]+other[14];
  temp[15] = M[15]+other[15];

  return temp;
 }


 inline matrix4& matrix4::operator+=(const matrix4& other)
 {
  M[0]+=other[0];
  M[1]+=other[1];
  M[2]+=other[2];
  M[3]+=other[3];
  M[4]+=other[4];
  M[5]+=other[5];
  M[6]+=other[6];
  M[7]+=other[7];
  M[8]+=other[8];
  M[9]+=other[9];
  M[10]+=other[10];
  M[11]+=other[11];
  M[12]+=other[12];
  M[13]+=other[13];
  M[14]+=other[14];
  M[15]+=other[15];

  return *this;
  matrix4 temp ( *this );
  setbyproduct ( temp, other );
  return *this;
 }


 inline matrix4 matrix4::operator-(const matrix4& other) const
 {
  matrix4 temp ( EM4CONST_NOTHING );

  temp[0] = M[0]-other[0];
  temp[1] = M[1]-other[1];
  temp[2] = M[2]-other[2];
  temp[3] = M[3]-other[3];
  temp[4] = M[4]-other[4];
  temp[5] = M[5]-other[5];
  temp[6] = M[6]-other[6];
  temp[7] = M[7]-other[7];
  temp[8] = M[8]-other[8];
  temp[9] = M[9]-other[9];
  temp[10] = M[10]-other[10];
  temp[11] = M[11]-other[11];
  temp[12] = M[12]-other[12];
  temp[13] = M[13]-other[13];
  temp[14] = M[14]-other[14];
  temp[15] = M[15]-other[15];

  return temp;
 }


 inline matrix4& matrix4::operator-=(const matrix4& other)
 {
  M[0]-=other[0];
  M[1]-=other[1];
  M[2]-=other[2];
  M[3]-=other[3];
  M[4]-=other[4];
  M[5]-=other[5];
  M[6]-=other[6];
  M[7]-=other[7];
  M[8]-=other[8];
  M[9]-=other[9];
  M[10]-=other[10];
  M[11]-=other[11];
  M[12]-=other[12];
  M[13]-=other[13];
  M[14]-=other[14];
  M[15]-=other[15];

  return *this;
 }


 inline matrix4 matrix4::operator*(const f32 scalar) const
 {
  matrix4 temp ( EM4CONST_NOTHING );

  temp[0] = M[0]*scalar;
  temp[1] = M[1]*scalar;
  temp[2] = M[2]*scalar;
  temp[3] = M[3]*scalar;
  temp[4] = M[4]*scalar;
  temp[5] = M[5]*scalar;
  temp[6] = M[6]*scalar;
  temp[7] = M[7]*scalar;
  temp[8] = M[8]*scalar;
  temp[9] = M[9]*scalar;
  temp[10] = M[10]*scalar;
  temp[11] = M[11]*scalar;
  temp[12] = M[12]*scalar;
  temp[13] = M[13]*scalar;
  temp[14] = M[14]*scalar;
  temp[15] = M[15]*scalar;

  return temp;
 }


 inline matrix4& matrix4::operator*=(const f32 scalar)
 {
  M[0]*=scalar;
  M[1]*=scalar;
  M[2]*=scalar;
  M[3]*=scalar;
  M[4]*=scalar;
  M[5]*=scalar;
  M[6]*=scalar;
  M[7]*=scalar;
  M[8]*=scalar;
  M[9]*=scalar;
  M[10]*=scalar;
  M[11]*=scalar;
  M[12]*=scalar;
  M[13]*=scalar;
  M[14]*=scalar;
  M[15]*=scalar;

  return *this;
 }


 inline matrix4& matrix4::operator*=(const matrix4& other)
 {
  matrix4 temp ( *this );
  setbyproduct ( temp, other );
  return *this;
 }




 inline void matrix4::setbyproduct_nocheck(const matrix4& other_a,const matrix4& other_b )
 {
  const f32 *m1 = other_a.M;
  const f32 *m2 = other_b.M;

  M[0] = m1[0]*m2[0] + m1[4]*m2[1] + m1[8]*m2[2] + m1[12]*m2[3];
  M[1] = m1[1]*m2[0] + m1[5]*m2[1] + m1[9]*m2[2] + m1[13]*m2[3];
  M[2] = m1[2]*m2[0] + m1[6]*m2[1] + m1[10]*m2[2] + m1[14]*m2[3];
  M[3] = m1[3]*m2[0] + m1[7]*m2[1] + m1[11]*m2[2] + m1[15]*m2[3];

  M[4] = m1[0]*m2[4] + m1[4]*m2[5] + m1[8]*m2[6] + m1[12]*m2[7];
  M[5] = m1[1]*m2[4] + m1[5]*m2[5] + m1[9]*m2[6] + m1[13]*m2[7];
  M[6] = m1[2]*m2[4] + m1[6]*m2[5] + m1[10]*m2[6] + m1[14]*m2[7];
  M[7] = m1[3]*m2[4] + m1[7]*m2[5] + m1[11]*m2[6] + m1[15]*m2[7];

  M[8] = m1[0]*m2[8] + m1[4]*m2[9] + m1[8]*m2[10] + m1[12]*m2[11];
  M[9] = m1[1]*m2[8] + m1[5]*m2[9] + m1[9]*m2[10] + m1[13]*m2[11];
  M[10] = m1[2]*m2[8] + m1[6]*m2[9] + m1[10]*m2[10] + m1[14]*m2[11];
  M[11] = m1[3]*m2[8] + m1[7]*m2[9] + m1[11]*m2[10] + m1[15]*m2[11];

  M[12] = m1[0]*m2[12] + m1[4]*m2[13] + m1[8]*m2[14] + m1[12]*m2[15];
  M[13] = m1[1]*m2[12] + m1[5]*m2[13] + m1[9]*m2[14] + m1[13]*m2[15];
  M[14] = m1[2]*m2[12] + m1[6]*m2[13] + m1[10]*m2[14] + m1[14]*m2[15];
  M[15] = m1[3]*m2[12] + m1[7]*m2[13] + m1[11]*m2[14] + m1[15]*m2[15];
  definitelyIdentityMatrix=false;
 }





 inline void matrix4::setbyproduct(const matrix4& other_a,const matrix4& other_b )
 {
  if ( other_a.isIdentity () )
  {
   *this = other_b;
   return;
  }
  else
  if ( other_b.isIdentity () )
  {
   *this = other_a;
   return;
  }
  setbyproduct_nocheck(other_a,other_b);
 }


 inline matrix4 matrix4::operator*(const matrix4& m2) const
 {

  if ( this->isIdentity() )
   return m2;
  if ( m2.isIdentity() )
   return *this;

  matrix4 m3 ( EM4CONST_NOTHING );

  const f32 *m1 = M;

  m3[0] = m1[0]*m2[0] + m1[4]*m2[1] + m1[8]*m2[2] + m1[12]*m2[3];
  m3[1] = m1[1]*m2[0] + m1[5]*m2[1] + m1[9]*m2[2] + m1[13]*m2[3];
  m3[2] = m1[2]*m2[0] + m1[6]*m2[1] + m1[10]*m2[2] + m1[14]*m2[3];
  m3[3] = m1[3]*m2[0] + m1[7]*m2[1] + m1[11]*m2[2] + m1[15]*m2[3];

  m3[4] = m1[0]*m2[4] + m1[4]*m2[5] + m1[8]*m2[6] + m1[12]*m2[7];
  m3[5] = m1[1]*m2[4] + m1[5]*m2[5] + m1[9]*m2[6] + m1[13]*m2[7];
  m3[6] = m1[2]*m2[4] + m1[6]*m2[5] + m1[10]*m2[6] + m1[14]*m2[7];
  m3[7] = m1[3]*m2[4] + m1[7]*m2[5] + m1[11]*m2[6] + m1[15]*m2[7];

  m3[8] = m1[0]*m2[8] + m1[4]*m2[9] + m1[8]*m2[10] + m1[12]*m2[11];
  m3[9] = m1[1]*m2[8] + m1[5]*m2[9] + m1[9]*m2[10] + m1[13]*m2[11];
  m3[10] = m1[2]*m2[8] + m1[6]*m2[9] + m1[10]*m2[10] + m1[14]*m2[11];
  m3[11] = m1[3]*m2[8] + m1[7]*m2[9] + m1[11]*m2[10] + m1[15]*m2[11];

  m3[12] = m1[0]*m2[12] + m1[4]*m2[13] + m1[8]*m2[14] + m1[12]*m2[15];
  m3[13] = m1[1]*m2[12] + m1[5]*m2[13] + m1[9]*m2[14] + m1[13]*m2[15];
  m3[14] = m1[2]*m2[12] + m1[6]*m2[13] + m1[10]*m2[14] + m1[14]*m2[15];
  m3[15] = m1[3]*m2[12] + m1[7]*m2[13] + m1[11]*m2[14] + m1[15]*m2[15];
  return m3;
 }



 inline vector3df matrix4::getTranslation() const
 {
  return vector3df(M[12], M[13], M[14]);
 }


 inline void matrix4::setTranslation( const vector3df& translation )
 {
  M[12] = translation.X;
  M[13] = translation.Y;
  M[14] = translation.Z;
  definitelyIdentityMatrix=false;
 }

 inline void matrix4::setInverseTranslation( const vector3df& translation )
 {
  M[12] = -translation.X;
  M[13] = -translation.Y;
  M[14] = -translation.Z;
  definitelyIdentityMatrix=false;
 }

 inline void matrix4::setScale( const vector3df& scale )
 {
  M[0] = scale.X;
  M[5] = scale.Y;
  M[10] = scale.Z;
  definitelyIdentityMatrix=false;
 }

 inline vector3df matrix4::getScale() const
 {
  return vector3df(M[0],M[5],M[10]);
 }

 inline void matrix4::setRotationDegrees( const vector3df& rotation )
 {
  setRotationRadians( rotation * core::DEGTORAD );
 }

 inline void matrix4::setInverseRotationDegrees( const vector3df& rotation )
 {
  setInverseRotationRadians( rotation * core::DEGTORAD );
 }

 inline void matrix4::setRotationRadians( const vector3df& rotation )
 {
  f64 cr = cos( rotation.X );
  f64 sr = sin( rotation.X );
  f64 cp = cos( rotation.Y );
  f64 sp = sin( rotation.Y );
  f64 cy = cos( rotation.Z );
  f64 sy = sin( rotation.Z );

  M[0] = (f32)( cp*cy );
  M[1] = (f32)( cp*sy );
  M[2] = (f32)( -sp );

  f64 srsp = sr*sp;
  f64 crsp = cr*sp;

  M[4] = (f32)( srsp*cy-cr*sy );
  M[5] = (f32)( srsp*sy+cr*cy );
  M[6] = (f32)( sr*cp );

  M[8] = (f32)( crsp*cy+sr*sy );
  M[9] = (f32)( crsp*sy-sr*cy );
  M[10] = (f32)( cr*cp );
  definitelyIdentityMatrix=false;
 }





 inline core::vector3df matrix4::getRotationDegrees() const
 {
  const matrix4 &mat = *this;

  f64 Y = -asin(mat(0,2));
  f64 C = cos(Y);
  Y *= RADTODEG64;

  f64 rotx, roty, X, Z;

  if (fabs(C)>0.0005f)
  {
   rotx = mat(2,2) / C;
   roty = mat(1,2) / C;
   X = atan2( roty, rotx ) * RADTODEG64;
   rotx = mat(0,0) / C;
   roty = mat(0,1) / C;
   Z = atan2( roty, rotx ) * RADTODEG64;
  }
  else
  {
   X = 0.0f;
   rotx = mat(1,1);
   roty = -mat(1,0);
   Z = atan2( roty, rotx ) * RADTODEG64;
  }




  if (X < 0.0) X += 360.0;
  if (Y < 0.0) Y += 360.0;
  if (Z < 0.0) Z += 360.0;

  return vector3df((f32)X,(f32)Y,(f32)Z);
 }

 inline void matrix4::setInverseRotationRadians( const vector3df& rotation )
 {
  f64 cr = cos( rotation.X );
  f64 sr = sin( rotation.X );
  f64 cp = cos( rotation.Y );
  f64 sp = sin( rotation.Y );
  f64 cy = cos( rotation.Z );
  f64 sy = sin( rotation.Z );

  M[0] = (f32)( cp*cy );
  M[4] = (f32)( cp*sy );
  M[8] = (f32)( -sp );

  f64 srsp = sr*sp;
  f64 crsp = cr*sp;

  M[1] = (f32)( srsp*cy-cr*sy );
  M[5] = (f32)( srsp*sy+cr*cy );
  M[9] = (f32)( sr*cp );

  M[2] = (f32)( crsp*cy+sr*sy );
  M[6] = (f32)( crsp*sy-sr*cy );
  M[10] = (f32)( cr*cp );
  definitelyIdentityMatrix=false;
 }




 inline void matrix4::makeIdentity()
 {
  memset(M, 0, 16*sizeof(f32));
  M[0] = M[5] = M[10] = M[15] = 1.0f;
  definitelyIdentityMatrix=true;
 }






 inline bool matrix4::isIdentity() const
 {
  if (definitelyIdentityMatrix)
   return true;
  if ( !equals ( M[ 0], 1.f ) ||
    !equals ( M[ 5], 1.f ) ||
    !equals ( M[10], 1.f ) ||
    !equals ( M[15], 1.f )
   )
   return false;

  for (s32 i=0; i<4; ++i)
   for (s32 j=0; j<4; ++j)
   if (j != i)
   {
    if ((*this)(i,j) < -ROUNDING_ERROR_32||
     (*this)(i,j) > ROUNDING_ERROR_32)
     return false;
   }
  return true;
 }







 inline bool matrix4::isIdentity_integer_base() const
 {
  if (definitelyIdentityMatrix)
   return true;
  if(((u32&)(M[0]))!=0x3f800000) return false;
  if(((u32&)(M[1]))!=0) return false;
  if(((u32&)(M[2]))!=0) return false;
  if(((u32&)(M[3]))!=0) return false;

  if(((u32&)(M[4]))!=0) return false;
  if(((u32&)(M[5]))!=0x3f800000) return false;
  if(((u32&)(M[6]))!=0) return false;
  if(((u32&)(M[7]))!=0) return false;

  if(((u32&)(M[8]))!=0) return false;
  if(((u32&)(M[9]))!=0) return false;
  if(((u32&)(M[10]))!=0x3f800000) return false;
  if(((u32&)(M[11]))!=0) return false;

  if(((u32&)(M[12]))!=0) return false;
  if(((u32&)(M[13]))!=0) return false;
  if(((u32&)(M[13]))!=0) return false;
  if(((u32&)(M[15]))!=0x3f800000) return false;
  return true;
 }



 inline void matrix4::rotateVect( vector3df& vect ) const
 {
  vector3df tmp = vect;
  vect.X = tmp.X*M[0] + tmp.Y*M[4] + tmp.Z*M[8];
  vect.Y = tmp.X*M[1] + tmp.Y*M[5] + tmp.Z*M[9];
  vect.Z = tmp.X*M[2] + tmp.Y*M[6] + tmp.Z*M[10];
 }


 inline void matrix4::rotateVect(f32 *out,const core::vector3df &in) const
 {
  out[0] = in.X*M[0] + in.Y*M[4] + in.Z*M[8];
  out[1] = in.X*M[1] + in.Y*M[5] + in.Z*M[9];
  out[2] = in.X*M[2] + in.Y*M[6] + in.Z*M[10];
 }

 inline void matrix4::inverseRotateVect( vector3df& vect ) const
 {
  vector3df tmp = vect;
  vect.X = tmp.X*M[0] + tmp.Y*M[1] + tmp.Z*M[2];
  vect.Y = tmp.X*M[4] + tmp.Y*M[5] + tmp.Z*M[6];
  vect.Z = tmp.X*M[8] + tmp.Y*M[9] + tmp.Z*M[10];
 }

 inline void matrix4::transformVect( vector3df& vect) const
 {
  f32 vector[3];

  vector[0] = vect.X*M[0] + vect.Y*M[4] + vect.Z*M[8] + M[12];
  vector[1] = vect.X*M[1] + vect.Y*M[5] + vect.Z*M[9] + M[13];
  vector[2] = vect.X*M[2] + vect.Y*M[6] + vect.Z*M[10] + M[14];

  vect.X = vector[0];
  vect.Y = vector[1];
  vect.Z = vector[2];
 }

 inline void matrix4::transformVect( vector3df& out, const vector3df& in) const
 {
  out.X = in.X*M[0] + in.Y*M[4] + in.Z*M[8] + M[12];
  out.Y = in.X*M[1] + in.Y*M[5] + in.Z*M[9] + M[13];
  out.Z = in.X*M[2] + in.Y*M[6] + in.Z*M[10] + M[14];
 }



 inline void matrix4::transformVect(f32 *out,const vector3df &in) const
 {
  out[0] = in.X*M[0] + in.Y*M[4] + in.Z*M[8] + M[12];
  out[1] = in.X*M[1] + in.Y*M[5] + in.Z*M[9] + M[13];
  out[2] = in.X*M[2] + in.Y*M[6] + in.Z*M[10] + M[14];
  out[3] = in.X*M[3] + in.Y*M[7] + in.Z*M[11] + M[15];
 }



 inline void matrix4::transformPlane( core::plane3d<f32> &plane) const
 {
  vector3df member;
  transformVect(member, plane.getMemberPoint());

  vector3df origin(0,0,0);
  transformVect(plane.Normal);
  transformVect(origin);

  plane.Normal -= origin;
  plane.D = - member.dotProduct(plane.Normal);
 }


 inline void matrix4::transformPlane_new( core::plane3d<f32> &plane) const
 {

  vector3df n;
  n.X = plane.Normal.X*M[0] + plane.Normal.Y*M[4] + plane.Normal.Z*M[8];
  n.Y = plane.Normal.X*M[1] + plane.Normal.Y*M[5] + plane.Normal.Z*M[9];
  n.Z = plane.Normal.X*M[2] + plane.Normal.Y*M[6] + plane.Normal.Z*M[10];


  plane.D -= M[12] * n.X + M[13] * n.Y + M[14] * n.Z;
  plane.Normal.X = n.X;
  plane.Normal.Y = n.Y;
  plane.Normal.Z = n.Z;
 }


 inline void matrix4::transformPlane( const core::plane3d<f32> &in, core::plane3d<f32> &out) const
 {
  out = in;
  transformPlane( out );
 }


 inline void matrix4::transformBox(core::aabbox3d<f32>& box) const
 {
  if (isIdentity() )
   return;

  transformVect(box.MinEdge);
  transformVect(box.MaxEdge);
  box.repair();
 }


 inline void matrix4::transformBoxEx(core::aabbox3d<f32>& box) const
 {
  f32 Amin[3];
  f32 Amax[3];
  f32 Bmin[3];
  f32 Bmax[3];

  Amin[0] = box.MinEdge.X;
  Amin[1] = box.MinEdge.Y;
  Amin[2] = box.MinEdge.Z;

  Amax[0] = box.MaxEdge.X;
  Amax[1] = box.MaxEdge.Y;
  Amax[2] = box.MaxEdge.Z;

  Bmin[0] = Bmax[0] = M[12];
  Bmin[1] = Bmax[1] = M[13];
  Bmin[2] = Bmax[2] = M[14];

  u32 i, j;
  const matrix4 &m = *this;

  for (i = 0; i < 3; ++i)
  {
   for (j = 0; j < 3; ++j)
   {
    f32 a = m(j,i) * Amin[j];
    f32 b = m(j,i) * Amax[j];

    if (a < b)
    {
     Bmin[i] += a;
     Bmax[i] += b;
    }
    else
    {
     Bmin[i] += b;
     Bmax[i] += a;
    }
   }
  }

  box.MinEdge.X = Bmin[0];
  box.MinEdge.Y = Bmin[1];
  box.MinEdge.Z = Bmin[2];

  box.MaxEdge.X = Bmax[0];
  box.MaxEdge.Y = Bmax[1];
  box.MaxEdge.Z = Bmax[2];
 }



 inline void matrix4::multiplyWith1x4Matrix(f32* matrix) const
 {







  f32 mat[4];
  mat[0] = matrix[0];
  mat[1] = matrix[1];
  mat[2] = matrix[2];
  mat[3] = matrix[3];

  matrix[0] = M[0]*mat[0] + M[4]*mat[1] + M[8]*mat[2] + M[12]*mat[3];
  matrix[1] = M[1]*mat[0] + M[5]*mat[1] + M[9]*mat[2] + M[13]*mat[3];
  matrix[2] = M[2]*mat[0] + M[6]*mat[1] + M[10]*mat[2] + M[14]*mat[3];
  matrix[3] = M[3]*mat[0] + M[7]*mat[1] + M[11]*mat[2] + M[15]*mat[3];
 }

 inline void matrix4::inverseTranslateVect( vector3df& vect ) const
 {
  vect.X = vect.X-M[12];
  vect.Y = vect.Y-M[13];
  vect.Z = vect.Z-M[14];
 }

 inline void matrix4::translateVect( vector3df& vect ) const
 {
  vect.X = vect.X+M[12];
  vect.Y = vect.Y+M[13];
  vect.Z = vect.Z+M[14];
 }


 inline bool matrix4::getInverse(matrix4& out) const
 {




  const matrix4 &m = *this;

  f32 d = (m(0, 0) * m(1, 1) - m(0, 1) * m(1, 0)) * (m(2, 2) * m(3, 3) - m(2, 3) * m(3, 2)) -
   (m(0, 0) * m(1, 2) - m(0, 2) * m(1, 0)) * (m(2, 1) * m(3, 3) - m(2, 3) * m(3, 1)) +
   (m(0, 0) * m(1, 3) - m(0, 3) * m(1, 0)) * (m(2, 1) * m(3, 2) - m(2, 2) * m(3, 1)) +
   (m(0, 1) * m(1, 2) - m(0, 2) * m(1, 1)) * (m(2, 0) * m(3, 3) - m(2, 3) * m(3, 0)) -
   (m(0, 1) * m(1, 3) - m(0, 3) * m(1, 1)) * (m(2, 0) * m(3, 2) - m(2, 2) * m(3, 0)) +
   (m(0, 2) * m(1, 3) - m(0, 3) * m(1, 2)) * (m(2, 0) * m(3, 1) - m(2, 1) * m(3, 0));

  if( core::iszero ( d ) )
   return false;

  d = core::reciprocal ( d );

  out(0, 0) = d * (m(1, 1) * (m(2, 2) * m(3, 3) - m(2, 3) * m(3, 2)) + m(1, 2) * (m(2, 3) * m(3, 1) - m(2, 1) * m(3, 3)) + m(1, 3) * (m(2, 1) * m(3, 2) - m(2, 2) * m(3, 1)));
  out(0, 1) = d * (m(2, 1) * (m(0, 2) * m(3, 3) - m(0, 3) * m(3, 2)) + m(2, 2) * (m(0, 3) * m(3, 1) - m(0, 1) * m(3, 3)) + m(2, 3) * (m(0, 1) * m(3, 2) - m(0, 2) * m(3, 1)));
  out(0, 2) = d * (m(3, 1) * (m(0, 2) * m(1, 3) - m(0, 3) * m(1, 2)) + m(3, 2) * (m(0, 3) * m(1, 1) - m(0, 1) * m(1, 3)) + m(3, 3) * (m(0, 1) * m(1, 2) - m(0, 2) * m(1, 1)));
  out(0, 3) = d * (m(0, 1) * (m(1, 3) * m(2, 2) - m(1, 2) * m(2, 3)) + m(0, 2) * (m(1, 1) * m(2, 3) - m(1, 3) * m(2, 1)) + m(0, 3) * (m(1, 2) * m(2, 1) - m(1, 1) * m(2, 2)));
  out(1, 0) = d * (m(1, 2) * (m(2, 0) * m(3, 3) - m(2, 3) * m(3, 0)) + m(1, 3) * (m(2, 2) * m(3, 0) - m(2, 0) * m(3, 2)) + m(1, 0) * (m(2, 3) * m(3, 2) - m(2, 2) * m(3, 3)));
  out(1, 1) = d * (m(2, 2) * (m(0, 0) * m(3, 3) - m(0, 3) * m(3, 0)) + m(2, 3) * (m(0, 2) * m(3, 0) - m(0, 0) * m(3, 2)) + m(2, 0) * (m(0, 3) * m(3, 2) - m(0, 2) * m(3, 3)));
  out(1, 2) = d * (m(3, 2) * (m(0, 0) * m(1, 3) - m(0, 3) * m(1, 0)) + m(3, 3) * (m(0, 2) * m(1, 0) - m(0, 0) * m(1, 2)) + m(3, 0) * (m(0, 3) * m(1, 2) - m(0, 2) * m(1, 3)));
  out(1, 3) = d * (m(0, 2) * (m(1, 3) * m(2, 0) - m(1, 0) * m(2, 3)) + m(0, 3) * (m(1, 0) * m(2, 2) - m(1, 2) * m(2, 0)) + m(0, 0) * (m(1, 2) * m(2, 3) - m(1, 3) * m(2, 2)));
  out(2, 0) = d * (m(1, 3) * (m(2, 0) * m(3, 1) - m(2, 1) * m(3, 0)) + m(1, 0) * (m(2, 1) * m(3, 3) - m(2, 3) * m(3, 1)) + m(1, 1) * (m(2, 3) * m(3, 0) - m(2, 0) * m(3, 3)));
  out(2, 1) = d * (m(2, 3) * (m(0, 0) * m(3, 1) - m(0, 1) * m(3, 0)) + m(2, 0) * (m(0, 1) * m(3, 3) - m(0, 3) * m(3, 1)) + m(2, 1) * (m(0, 3) * m(3, 0) - m(0, 0) * m(3, 3)));
  out(2, 2) = d * (m(3, 3) * (m(0, 0) * m(1, 1) - m(0, 1) * m(1, 0)) + m(3, 0) * (m(0, 1) * m(1, 3) - m(0, 3) * m(1, 1)) + m(3, 1) * (m(0, 3) * m(1, 0) - m(0, 0) * m(1, 3)));
  out(2, 3) = d * (m(0, 3) * (m(1, 1) * m(2, 0) - m(1, 0) * m(2, 1)) + m(0, 0) * (m(1, 3) * m(2, 1) - m(1, 1) * m(2, 3)) + m(0, 1) * (m(1, 0) * m(2, 3) - m(1, 3) * m(2, 0)));
  out(3, 0) = d * (m(1, 0) * (m(2, 2) * m(3, 1) - m(2, 1) * m(3, 2)) + m(1, 1) * (m(2, 0) * m(3, 2) - m(2, 2) * m(3, 0)) + m(1, 2) * (m(2, 1) * m(3, 0) - m(2, 0) * m(3, 1)));
  out(3, 1) = d * (m(2, 0) * (m(0, 2) * m(3, 1) - m(0, 1) * m(3, 2)) + m(2, 1) * (m(0, 0) * m(3, 2) - m(0, 2) * m(3, 0)) + m(2, 2) * (m(0, 1) * m(3, 0) - m(0, 0) * m(3, 1)));
  out(3, 2) = d * (m(3, 0) * (m(0, 2) * m(1, 1) - m(0, 1) * m(1, 2)) + m(3, 1) * (m(0, 0) * m(1, 2) - m(0, 2) * m(1, 0)) + m(3, 2) * (m(0, 1) * m(1, 0) - m(0, 0) * m(1, 1)));
  out(3, 3) = d * (m(0, 0) * (m(1, 1) * m(2, 2) - m(1, 2) * m(2, 1)) + m(0, 1) * (m(1, 2) * m(2, 0) - m(1, 0) * m(2, 2)) + m(0, 2) * (m(1, 0) * m(2, 1) - m(1, 1) * m(2, 0)));
  out.definitelyIdentityMatrix = definitelyIdentityMatrix;
  return true;
 }




 inline bool matrix4::getInversePrimitive ( matrix4& out ) const
 {
  out.M[0 ] = M[0];
  out.M[1 ] = M[4];
  out.M[2 ] = M[8];
  out.M[3 ] = 0.0f;

  out.M[4 ] = M[1];
  out.M[5 ] = M[5];
  out.M[6 ] = M[9];
  out.M[7 ] = 0.0f;

  out.M[8 ] = M[2];
  out.M[9 ] = M[6];
  out.M[10] = M[10];
  out.M[11] = 0.0f;

  out.M[12] = -(M[12]*M[0] + M[13]*M[1] + M[14]*M[2]);
  out.M[13] = -(M[12]*M[4] + M[13]*M[5] + M[14]*M[6]);
  out.M[14] = -(M[12]*M[8] + M[13]*M[9] + M[14]*M[10]);
  out.M[15] = 1.0f;
  out.definitelyIdentityMatrix = definitelyIdentityMatrix;
  return true;
 }



 inline bool matrix4::makeInverse()
 {
  matrix4 temp ( EM4CONST_NOTHING );

  if (getInverse(temp))
  {
   *this = temp;
   return true;
  }

  return false;
 }



 inline matrix4& matrix4::operator=(const matrix4 &other)
 {
  if (this==&other)
   return *this;
  memcpy(M, other.M, 16*sizeof(f32));
  definitelyIdentityMatrix=other.definitelyIdentityMatrix;
  return *this;
 }



 inline bool matrix4::operator==(const matrix4 &other) const
 {
  if (definitelyIdentityMatrix && other.definitelyIdentityMatrix)
   return true;
  for (s32 i = 0; i < 16; ++i)
   if (M[i] != other.M[i])
    return false;

  return true;
 }



 inline bool matrix4::operator!=(const matrix4 &other) const
 {
  return !(*this == other);
 }




 inline void matrix4::buildProjectionMatrixPerspectiveFovRH(f32 fieldOfViewRadians, f32 aspectRatio, f32 zNear, f32 zFar)
 {
  f32 h = (f32)(1.0/tan(fieldOfViewRadians/2.0));
  f32 w = h / aspectRatio;

  M[0] = w;
  M[1] = 0.0f;
  M[2] = 0.0f;
  M[3] = 0.0f;

  M[4] = 0.0f;
  M[5] = h;
  M[6] = 0.0f;
  M[7] = 0.0f;

  M[8] = 0.0f;
  M[9] = 0.0f;
  M[10] = zFar/(zNear-zFar);

  M[11] = -1.0f;

  M[12] = 0.0f;
  M[13] = 0.0f;
  M[14] = zNear*zFar/(zNear-zFar);

  M[15] = 0.0f;
  definitelyIdentityMatrix=false;
 }




 inline void matrix4::buildProjectionMatrixPerspectiveFovLH(f32 fieldOfViewRadians, f32 aspectRatio, f32 zNear, f32 zFar)
 {
  f32 h = (f32)(1.0/tan(fieldOfViewRadians/2.0));
  f32 w = h / aspectRatio;

  M[0] = w;
  M[1] = 0.0f;
  M[2] = 0.0f;
  M[3] = 0.0f;

  M[4] = 0.0f;
  M[5] = h;
  M[6] = 0.0f;
  M[7] = 0.0f;

  M[8] = 0.0f;
  M[9] = 0.0f;
  M[10] = zFar/(zFar-zNear);
  M[11] = 1.0f;

  M[12] = 0.0f;
  M[13] = 0.0f;
  M[14] = -zNear*zFar/(zFar-zNear);
  M[15] = 0.0f;
  definitelyIdentityMatrix=false;
 }




 inline void matrix4::buildProjectionMatrixOrthoLH(f32 widthOfViewVolume, f32 heightOfViewVolume, f32 zNear, f32 zFar)
 {
  M[0] = 2/widthOfViewVolume;
  M[1] = 0;
  M[2] = 0;
  M[3] = 0;

  M[4] = 0;
  M[5] = 2/heightOfViewVolume;
  M[6] = 0;
  M[7] = 0;

  M[8] = 0;
  M[9] = 0;
  M[10] = 1/(zFar-zNear);
  M[11] = 0;

  M[12] = 0;
  M[13] = 0;
  M[14] = zNear/(zNear-zFar);
  M[15] = 1;
  definitelyIdentityMatrix=false;
 }




 inline void matrix4::buildProjectionMatrixOrthoRH(f32 widthOfViewVolume, f32 heightOfViewVolume, f32 zNear, f32 zFar)
 {
  M[0] = 2/widthOfViewVolume;
  M[1] = 0;
  M[2] = 0;
  M[3] = 0;

  M[4] = 0;
  M[5] = 2/heightOfViewVolume;
  M[6] = 0;
  M[7] = 0;

  M[8] = 0;
  M[9] = 0;
  M[10] = 1/(zNear-zFar);
  M[11] = 0;

  M[12] = 0;
  M[13] = 0;
  M[14] = zNear/(zNear-zFar);
  M[15] = -1;
  definitelyIdentityMatrix=false;
 }



 inline void matrix4::buildProjectionMatrixPerspectiveRH(f32 widthOfViewVolume, f32 heightOfViewVolume, f32 zNear, f32 zFar)
 {
  M[0] = 2*zNear/widthOfViewVolume;
  M[1] = 0;
  M[2] = 0;
  M[3] = 0;

  M[4] = 0;
  M[5] = 2*zNear/heightOfViewVolume;
  M[6] = 0;
  M[7] = 0;

  M[8] = 0;
  M[9] = 0;
  M[10] = zFar/(zNear-zFar);
  M[11] = -1;

  M[12] = 0;
  M[13] = 0;
  M[14] = zNear*zFar/(zNear-zFar);
  M[15] = 0;
  definitelyIdentityMatrix=false;
 }



 inline void matrix4::buildProjectionMatrixPerspectiveLH(f32 widthOfViewVolume, f32 heightOfViewVolume, f32 zNear, f32 zFar)
 {
  M[0] = 2*zNear/widthOfViewVolume;
  M[1] = 0;
  M[2] = 0;
  M[3] = 0;

  M[4] = 0;
  M[5] = 2*zNear/heightOfViewVolume;
  M[6] = 0;
  M[7] = 0;

  M[8] = 0;
  M[9] = 0;
  M[10] = zFar/(zFar-zNear);
  M[11] = 1;

  M[12] = 0;
  M[13] = 0;
  M[14] = zNear*zFar/(zNear-zFar);
  M[15] = 0;
  definitelyIdentityMatrix=false;
 }



 inline void matrix4::buildShadowMatrix(const core::vector3df& light, core::plane3df plane, f32 point)
 {
  plane.Normal.normalize();
  f32 d = plane.Normal.dotProduct(light);

  M[ 0] = -plane.Normal.X * light.X + d;
  M[ 1] = -plane.Normal.X * light.Y;
  M[ 2] = -plane.Normal.X * light.Z;
  M[ 3] = -plane.Normal.X * point;

  M[ 4] = -plane.Normal.Y * light.X;
  M[ 5] = -plane.Normal.Y * light.Y + d;
  M[ 6] = -plane.Normal.Y * light.Z;
  M[ 7] = -plane.Normal.Y * point;

  M[ 8] = -plane.Normal.Z * light.X;
  M[ 9] = -plane.Normal.Z * light.Y;
  M[10] = -plane.Normal.Z * light.Z + d;
  M[11] = -plane.Normal.Z * point;

  M[12] = -plane.D * light.X;
  M[13] = -plane.D * light.Y;
  M[14] = -plane.D * light.Z;
  M[15] = -plane.D * point + d;
  definitelyIdentityMatrix=false;
 }


 inline void matrix4::buildCameraLookAtMatrixLH(
    const vector3df& position,
    const vector3df& target,
    const vector3df& upVector)
 {
  vector3df zaxis = target - position;
  zaxis.normalize();

  vector3df xaxis = upVector.crossProduct(zaxis);
  xaxis.normalize();

  vector3df yaxis = zaxis.crossProduct(xaxis);

  M[0] = xaxis.X;
  M[1] = yaxis.X;
  M[2] = zaxis.X;
  M[3] = 0;

  M[4] = xaxis.Y;
  M[5] = yaxis.Y;
  M[6] = zaxis.Y;
  M[7] = 0;

  M[8] = xaxis.Z;
  M[9] = yaxis.Z;
  M[10] = zaxis.Z;
  M[11] = 0;

  M[12] = -xaxis.dotProduct(position);
  M[13] = -yaxis.dotProduct(position);
  M[14] = -zaxis.dotProduct(position);
  M[15] = 1.0f;
  definitelyIdentityMatrix=false;
 }




 inline void matrix4::buildCameraLookAtMatrixRH(
    const vector3df& position,
    const vector3df& target,
    const vector3df& upVector)
 {
  vector3df zaxis = position - target;
  zaxis.normalize();

  vector3df xaxis = upVector.crossProduct(zaxis);
  xaxis.normalize();

  vector3df yaxis = zaxis.crossProduct(xaxis);

  M[0] = xaxis.X;
  M[1] = yaxis.X;
  M[2] = zaxis.X;
  M[3] = 0;

  M[4] = xaxis.Y;
  M[5] = yaxis.Y;
  M[6] = zaxis.Y;
  M[7] = 0;

  M[8] = xaxis.Z;
  M[9] = yaxis.Z;
  M[10] = zaxis.Z;
  M[11] = 0;

  M[12] = -xaxis.dotProduct(position);
  M[13] = -yaxis.dotProduct(position);
  M[14] = -zaxis.dotProduct(position);
  M[15] = 1.0f;
  definitelyIdentityMatrix=false;
 }




 inline matrix4 matrix4::interpolate(const core::matrix4& b, f32 time) const
 {
  matrix4 mat ( EM4CONST_NOTHING );

  for (s32 i=0; i < 16; i += 4)
  {
   mat.M[i+0] = M[i+0] + ( b.M[i+0] - M[i+0] ) * time;
   mat.M[i+1] = M[i+1] + ( b.M[i+1] - M[i+1] ) * time;
   mat.M[i+2] = M[i+2] + ( b.M[i+2] - M[i+2] ) * time;
   mat.M[i+3] = M[i+3] + ( b.M[i+3] - M[i+3] ) * time;
  }
  return mat;
 }


 inline matrix4 matrix4::getTransposed() const
 {
  matrix4 t ( EM4CONST_NOTHING );
  getTransposed ( t );
  return t;
 }


 inline void matrix4::getTransposed( matrix4& o ) const
 {
  o[ 0] = M[ 0];
  o[ 1] = M[ 4];
  o[ 2] = M[ 8];
  o[ 3] = M[12];

  o[ 4] = M[ 1];
  o[ 5] = M[ 5];
  o[ 6] = M[ 9];
  o[ 7] = M[13];

  o[ 8] = M[ 2];
  o[ 9] = M[ 6];
  o[10] = M[10];
  o[11] = M[14];

  o[12] = M[ 3];
  o[13] = M[ 7];
  o[14] = M[11];
  o[15] = M[15];
  o.definitelyIdentityMatrix=definitelyIdentityMatrix;
 }



 inline void matrix4::buildNDCToDCMatrix( const core::rect<s32>& viewport, f32 zScale)
 {
  f32 scaleX = (viewport.getWidth() - 0.75f ) / 2.f;
  f32 scaleY = -(viewport.getHeight() - 0.75f ) / 2.f;

  f32 dx = -0.5f + ( (viewport.UpperLeftCorner.X + viewport.LowerRightCorner.X ) / 2.f );
  f32 dy = -0.5f + ( (viewport.UpperLeftCorner.Y + viewport.LowerRightCorner.Y ) / 2.f );

  makeIdentity();
  M[0] = scaleX;
  M[5] = scaleY;
  M[10] = zScale;
  M[12] = dx;
  M[13] = dy;
  definitelyIdentityMatrix=false;
 }
# 1421 "H:/CPP/irrlicht-1.3/include/matrix4.h"
 inline void matrix4::buildTextureTransform( f32 rotateRad,
     const core::vector2df &rotatecenter,
     const core::vector2df &translate,
     const core::vector2df &scale)
 {
  f32 c = cosf(rotateRad);
  f32 s = sinf(rotateRad);

  M[0] = c * scale.X;
  M[1] = s * scale.Y;
  M[2] = 0.f;
  M[3] = 0.f;

  M[4] = -s * scale.X;
  M[5] = c * scale.Y;
  M[6] = 0.f;
  M[7] = 0.f;

  M[8] = c * scale.X * rotatecenter.X + -s * rotatecenter.Y + translate.X;
  M[9] = s * scale.Y * rotatecenter.X + c * rotatecenter.Y + translate.Y;
  M[10] = 1.f;
  M[11] = 0.f;

  M[12] = 0.f;
  M[13] = 0.f;
  M[14] = 0.f;
  M[15] = 1.f;
  definitelyIdentityMatrix=false;
 }


 inline void matrix4::setTextureRotationCenter( f32 rotateRad )
 {
  f32 c = cosf(rotateRad);
  f32 s = sinf(rotateRad);
  M[0] = c;
  M[1] = s;
  M[2] = -0.5f * ( c + s) + 0.5f;

  M[4] = -s;
  M[5] = c;
  M[6] = -0.5f * (-s + c) + 0.5f;
  definitelyIdentityMatrix=false;
 }

 inline void matrix4::setTextureTranslate ( f32 x, f32 y )
 {
  M[2] = x;
  M[6] = y;
  definitelyIdentityMatrix=false;
 }

 inline void matrix4::setTextureScale ( f32 sx, f32 sy )
 {
  M[0] = sx;
  M[5] = sy;
  definitelyIdentityMatrix=false;
 }

 inline void matrix4::setTextureScaleCenter( f32 sx, f32 sy )
 {
  M[0] = sx;
  M[2] = -0.5f * sx + 0.5f;
  M[5] = sy;
  M[6] = -0.5f * sy + 0.5f;
  definitelyIdentityMatrix=false;
 }


 inline matrix4 operator*(const f32 scalar, const matrix4& mat)
 {
  return mat*scalar;
 }

 const matrix4 IdentityMatrix(matrix4::EM4CONST_IDENTITY);
}
}
# 10 "H:/CPP/irrlicht-1.3/include/quaternion.h" 2


namespace irr
{
namespace core
{


class quaternion
{
 public:


  quaternion();


  quaternion(f32 X, f32 Y, f32 Z, f32 W);


  quaternion(f32 x, f32 y, f32 z);


  quaternion(const matrix4& mat);


  bool operator==(const quaternion& other) const;


  inline quaternion& operator=(const quaternion& other);


  inline quaternion& operator=(const matrix4& other);


  quaternion operator+(const quaternion& other) const;


  quaternion operator*(const quaternion& other) const;


  quaternion operator*(f32 s) const;


  quaternion& operator*=(f32 s);


  vector3df operator* (const vector3df& v) const;


  quaternion& operator*=(const quaternion& other);


  inline f32 getDotProduct(const quaternion& other) const;


  inline void set(f32 x, f32 y, f32 z, f32 w);


  inline void set(f32 x, f32 y, f32 z);


  inline quaternion& normalize();


  matrix4 getMatrix() const;


  void getMatrix( matrix4 &dest ) const;


  void getMatrix_transposed( matrix4 &dest ) const;


  void makeInverse();


  void slerp( quaternion q1, const quaternion q2, f32 interpolate );




  void fromAngleAxis (f32 angle, const vector3df& axis);

  void toEuler(vector3df& euler) const;


  void makeIdentity();

  f32 X, Y, Z, W;
};



inline quaternion::quaternion()
: X(0.0f), Y(0.0f), Z(0.0f), W(1.0f)
{
}


inline quaternion::quaternion(f32 x, f32 y, f32 z, f32 w)
: X(x), Y(y), Z(z), W(w)
{
}


inline quaternion::quaternion(f32 x, f32 y, f32 z)
{
 set(x,y,z);
}



inline quaternion::quaternion(const matrix4& mat)
{
 (*this) = mat;
}



inline bool quaternion::operator==(const quaternion& other) const
{
 if(X != other.X)
  return false;
 if(Y != other.Y)
  return false;
 if(Z != other.Z)
  return false;
 if(W != other.W)
  return false;

 return true;
}



inline quaternion& quaternion::operator=(const quaternion& other)
{
 X = other.X;
 Y = other.Y;
 Z = other.Z;
 W = other.W;
 return *this;
}



inline quaternion& quaternion::operator=(const matrix4& m)
{
 f32 diag = m(0,0) + m(1,1) + m(2,2) + 1;
 f32 scale = 0.0f;

 if( diag > 0.0f )
 {
  scale = sqrtf(diag) * 2.0f;


  X = ( m(2,1) - m(1,2)) / scale;
  Y = ( m(0,2) - m(2,0)) / scale;
  Z = ( m(1,0) - m(0,1)) / scale;
  W = 0.25f * scale;
 }
 else
 {
  if ( m(0,0) > m(1,1) && m(0,0) > m(2,2))
  {


   scale = sqrtf( 1.0f + m(0,0) - m(1,1) - m(2,2)) * 2.0f;


   X = 0.25f * scale;
   Y = (m(0,1) + m(1,0)) / scale;
   Z = (m(2,0) + m(0,2)) / scale;
   W = (m(2,1) - m(1,2)) / scale;
  }
  else if ( m(1,1) > m(2,2))
  {


   scale = sqrtf( 1.0f + m(1,1) - m(0,0) - m(2,2)) * 2.0f;


   X = (m(0,1) + m(1,0) ) / scale;
   Y = 0.25f * scale;
   Z = (m(1,2) + m(2,1) ) / scale;
   W = (m(0,2) - m(2,0) ) / scale;
  }
  else
  {


   scale = sqrtf( 1.0f + m(2,2) - m(0,0) - m(1,1)) * 2.0f;


   X = (m(0,2) + m(2,0)) / scale;
   Y = (m(1,2) + m(2,1)) / scale;
   Z = 0.25f * scale;
   W = (m(1,0) - m(0,1)) / scale;
  }
 }

 normalize();
 return *this;
}



inline quaternion quaternion::operator*(const quaternion& other) const
{
 quaternion tmp;

 tmp.W = (other.W * W) - (other.X * X) - (other.Y * Y) - (other.Z * Z);
 tmp.X = (other.W * X) + (other.X * W) + (other.Y * Z) - (other.Z * Y);
 tmp.Y = (other.W * Y) + (other.Y * W) + (other.Z * X) - (other.X * Z);
 tmp.Z = (other.W * Z) + (other.Z * W) + (other.X * Y) - (other.Y * X);

 return tmp;
}



inline quaternion quaternion::operator*(f32 s) const
{
 return quaternion(s*X, s*Y, s*Z, s*W);
}


inline quaternion& quaternion::operator*=(f32 s)
{
 X *= s; Y*=s; Z*=s; W*=s;
 return *this;
}


inline quaternion& quaternion::operator*=(const quaternion& other)
{
 *this = other * (*this);
 return *this;
}


inline quaternion quaternion::operator+(const quaternion& b) const
{
 return quaternion(X+b.X, Y+b.Y, Z+b.Z, W+b.W);
}



inline matrix4 quaternion::getMatrix() const
{
 core::matrix4 m;

 m(0,0) = 1.0f - 2.0f*Y*Y - 2.0f*Z*Z;
 m(1,0) = 2.0f*X*Y + 2.0f*Z*W;
 m(2,0) = 2.0f*X*Z - 2.0f*Y*W;
 m(3,0) = 0.0f;

 m(0,1) = 2.0f*X*Y - 2.0f*Z*W;
 m(1,1) = 1.0f - 2.0f*X*X - 2.0f*Z*Z;
 m(2,1) = 2.0f*Z*Y + 2.0f*X*W;
 m(3,1) = 0.0f;

 m(0,2) = 2.0f*X*Z + 2.0f*Y*W;
 m(1,2) = 2.0f*Z*Y - 2.0f*X*W;
 m(2,2) = 1.0f - 2.0f*X*X - 2.0f*Y*Y;
 m(3,2) = 0.0f;

 m(0,3) = 0.0f;
 m(1,3) = 0.0f;
 m(2,3) = 0.0f;
 m(3,3) = 1.0f;

 return m;
}



inline void quaternion::getMatrix( matrix4 &dest ) const
{
 dest[0] = 1.0f - 2.0f*Y*Y - 2.0f*Z*Z;
 dest[1] = 2.0f*X*Y + 2.0f*Z*W;
 dest[2] = 2.0f*X*Z - 2.0f*Y*W;
 dest[3] = 0.0f;

 dest[4] = 2.0f*X*Y - 2.0f*Z*W;
 dest[5] = 1.0f - 2.0f*X*X - 2.0f*Z*Z;
 dest[6] = 2.0f*Z*Y + 2.0f*X*W;
 dest[7] = 0.0f;

 dest[8] = 2.0f*X*Z + 2.0f*Y*W;
 dest[9] = 2.0f*Z*Y - 2.0f*X*W;
 dest[10] = 1.0f - 2.0f*X*X - 2.0f*Y*Y;
 dest[11] = 0.0f;

 dest[12] = 0.f;
 dest[13] = 0.f;
 dest[14] = 0.f;
 dest[15] = 1.f;
}


inline void quaternion::getMatrix_transposed( matrix4 &dest ) const
{
 dest[0] = 1.0f - 2.0f*Y*Y - 2.0f*Z*Z;
 dest[4] = 2.0f*X*Y + 2.0f*Z*W;
 dest[8] = 2.0f*X*Z - 2.0f*Y*W;
 dest[12] = 0.0f;

 dest[1] = 2.0f*X*Y - 2.0f*Z*W;
 dest[5] = 1.0f - 2.0f*X*X - 2.0f*Z*Z;
 dest[9] = 2.0f*Z*Y + 2.0f*X*W;
 dest[13] = 0.0f;

 dest[2] = 2.0f*X*Z + 2.0f*Y*W;
 dest[6] = 2.0f*Z*Y - 2.0f*X*W;
 dest[10] = 1.0f - 2.0f*X*X - 2.0f*Y*Y;
 dest[14] = 0.0f;

 dest[3] = 0.f;
 dest[7] = 0.f;
 dest[11] = 0.f;
 dest[15] = 1.f;
}




inline void quaternion::makeInverse()
{
 X = -X; Y = -Y; Z = -Z;
}


inline void quaternion::set(f32 x, f32 y, f32 z, f32 w)
{
 X = x;
 Y = y;
 Z = z;
 W = w;
}



inline void quaternion::set(f32 x, f32 y, f32 z)
{
 f64 angle;

 angle = x * 0.5;
 f64 sr = (f32)sin(angle);
 f64 cr = (f32)cos(angle);

 angle = y * 0.5;
 f64 sp = (f32)sin(angle);
 f64 cp = (f32)cos(angle);

 angle = z * 0.5;
 f64 sy = (f32)sin(angle);
 f64 cy = (f32)cos(angle);

 f64 cpcy = cp * cy;
 f64 spcy = sp * cy;
 f64 cpsy = cp * sy;
 f64 spsy = sp * sy;

 X = (f32)(sr * cpcy - cr * spsy);
 Y = (f32)(cr * spcy + sr * cpsy);
 Z = (f32)(cr * cpsy - sr * spcy);
 W = (f32)(cr * cpcy + sr * spsy);

 normalize();
}


inline quaternion& quaternion::normalize()
{
 f32 n = X*X + Y*Y + Z*Z + W*W;

 if (n == 1)
  return *this;


 n = reciprocal_squareroot ( n );
 X *= n;
 Y *= n;
 Z *= n;
 W *= n;

 return *this;
}



inline void quaternion::slerp( quaternion q1, quaternion q2, f32 time)
{
 f32 angle = q1.getDotProduct(q2);

 if (angle < 0.0f)
 {
  q1 *= -1.0f;
  angle *= -1.0f;
 }

 f32 scale;
 f32 invscale;

 if ((angle + 1.0f) > 0.05f)
 {
  if ((1.0f - angle) >= 0.05f)
  {
   f32 theta = (f32)acos(angle);
   f32 invsintheta = 1.0f / (f32)sin(theta);
   scale = (f32)sin(theta * (1.0f-time)) * invsintheta;
   invscale = (f32)sin(theta * time) * invsintheta;
  }
  else
  {
   scale = 1.0f - time;
   invscale = time;
  }
 }
 else
 {
  q2 = quaternion(-q1.Y, q1.X, -q1.W, q1.Z);
  scale = (f32)sin(PI * (0.5f - time));
  invscale = (f32)sin(PI * time);
 }

 *this = (q1*scale) + (q2*invscale);
}



inline f32 quaternion::getDotProduct(const quaternion& q2) const
{
 return (X * q2.X) + (Y * q2.Y) + (Z * q2.Z) + (W * q2.W);
}


inline void quaternion::fromAngleAxis(f32 angle, const vector3df& axis)
{
 f32 fHalfAngle = 0.5f*angle;
 f32 fSin = (f32)sin(fHalfAngle);
 W = (f32)cos(fHalfAngle);
 X = fSin*axis.X;
 Y = fSin*axis.Y;
 Z = fSin*axis.Z;
}

inline void quaternion::toEuler(vector3df& euler) const
{
 double sqw = W*W;
 double sqx = X*X;
 double sqy = Y*Y;
 double sqz = Z*Z;


 euler.Z = (f32) (atan2(2.0 * (X*Y +Z*W),(sqx - sqy - sqz + sqw)));


 euler.X = (f32) (atan2(2.0 * (Y*Z +X*W),(-sqx - sqy + sqz + sqw)));


 euler.Y = (f32) (asin(-2.0 * (X*Z - Y*W)));
}

inline vector3df quaternion::operator* (const vector3df& v) const
{


 vector3df uv, uuv;
 vector3df qvec(X, Y, Z);
 uv = qvec.crossProduct(v);
 uuv = qvec.crossProduct(uv);
 uv *= (2.0f * W);
 uuv *= 2.0f;

 return v + uv + uuv;
}


inline void quaternion::makeIdentity()
{
 W = 1.f;
 X = 0.f;
 Y = 0.f;
 Z = 0.f;
}


}
}
# 16 "H:/CPP/irrlicht-1.3/include/IAttributes.h" 2
# 26 "H:/CPP/irrlicht-1.3/include/IAttributes.h"
# 1 "H:/CPP/irrlicht-1.3/include/IXMLReader.h" 1
# 9 "H:/CPP/irrlicht-1.3/include/IXMLReader.h"
# 1 "H:/CPP/irrlicht-1.3/include/irrXML.h" 1
# 152 "H:/CPP/irrlicht-1.3/include/irrXML.h"
namespace irr
{
namespace io
{

 enum ETEXT_FORMAT
 {

  ETF_ASCII,


  ETF_UTF8,


  ETF_UTF16_BE,


  ETF_UTF16_LE,


  ETF_UTF32_BE,


  ETF_UTF32_LE
 };



 enum EXML_NODE
 {

  EXN_NONE,


  EXN_ELEMENT,


  EXN_ELEMENT_END,


  EXN_TEXT,


  EXN_COMMENT,


  EXN_CDATA,


  EXN_UNKNOWN
 };
# 212 "H:/CPP/irrlicht-1.3/include/irrXML.h"
 class IFileReadCallBack
 {
 public:


  virtual ~IFileReadCallBack() {};





  virtual int read(void* buffer, int sizeToRead) = 0;


  virtual int getSize() = 0;
 };







 class IXMLBase
 {
 };
# 272 "H:/CPP/irrlicht-1.3/include/irrXML.h"
 template<class char_type, class super_class>
 class IIrrXMLReader : public super_class
 {
 public:


  virtual ~IIrrXMLReader() {};



  virtual bool read() = 0;


  virtual EXML_NODE getNodeType() const = 0;





  virtual int getAttributeCount() const = 0;




  virtual const char_type* getAttributeName(int idx) const = 0;




  virtual const char_type* getAttributeValue(int idx) const = 0;




  virtual const char_type* getAttributeValue(const char_type* name) const = 0;






  virtual const char_type* getAttributeValueSafe(const char_type* name) const = 0;





  virtual int getAttributeValueAsInt(const char_type* name) const = 0;





  virtual int getAttributeValueAsInt(int idx) const = 0;





  virtual float getAttributeValueAsFloat(const char_type* name) const = 0;





  virtual float getAttributeValueAsFloat(int idx) const = 0;




  virtual const char_type* getNodeName() const = 0;




  virtual const char_type* getNodeData() const = 0;


  virtual bool isEmptyElement() const = 0;






  virtual ETEXT_FORMAT getSourceFormat() const = 0;






  virtual ETEXT_FORMAT getParserFormat() const = 0;
 };





 typedef unsigned short char16;




 typedef unsigned long char32;







 typedef IIrrXMLReader<char, IXMLBase> IrrXMLReader;







 typedef IIrrXMLReader<char16, IXMLBase> IrrXMLReaderUTF16;







 typedef IIrrXMLReader<char32, IXMLBase> IrrXMLReaderUTF32;
# 412 "H:/CPP/irrlicht-1.3/include/irrXML.h"
 IrrXMLReader* createIrrXMLReader(const char* filename);
# 424 "H:/CPP/irrlicht-1.3/include/irrXML.h"
 IrrXMLReader* createIrrXMLReader(FILE* file);
# 437 "H:/CPP/irrlicht-1.3/include/irrXML.h"
 IrrXMLReader* createIrrXMLReader(IFileReadCallBack* callback);
# 449 "H:/CPP/irrlicht-1.3/include/irrXML.h"
 IrrXMLReaderUTF16* createIrrXMLReaderUTF16(const char* filename);
# 461 "H:/CPP/irrlicht-1.3/include/irrXML.h"
 IrrXMLReaderUTF16* createIrrXMLReaderUTF16(FILE* file);
# 474 "H:/CPP/irrlicht-1.3/include/irrXML.h"
 IrrXMLReaderUTF16* createIrrXMLReaderUTF16(IFileReadCallBack* callback);
# 486 "H:/CPP/irrlicht-1.3/include/irrXML.h"
 IrrXMLReaderUTF32* createIrrXMLReaderUTF32(const char* filename);
# 498 "H:/CPP/irrlicht-1.3/include/irrXML.h"
 IrrXMLReaderUTF32* createIrrXMLReaderUTF32(FILE* file);
# 512 "H:/CPP/irrlicht-1.3/include/irrXML.h"
 IrrXMLReaderUTF32* createIrrXMLReaderUTF32(IFileReadCallBack* callback);
# 536 "H:/CPP/irrlicht-1.3/include/irrXML.h"
}
}
# 10 "H:/CPP/irrlicht-1.3/include/IXMLReader.h" 2

namespace irr
{
namespace io
{




 typedef IIrrXMLReader<wchar_t, IUnknown> IXMLReader;





 typedef IIrrXMLReader<c8, IUnknown> IXMLReaderUTF8;

}
}
# 27 "H:/CPP/irrlicht-1.3/include/IAttributes.h" 2

namespace irr
{
namespace video
{
 class ITexture;
}
namespace io
{
 class IXMLWriter;


enum E_ATTRIBUTE_TYPE
{

 EAT_INT = 0,


 EAT_FLOAT,


 EAT_STRING,


 EAT_BOOL,


 EAT_ENUM,


 EAT_COLOR,


 EAT_COLORF,


 EAT_VECTOR3D,


 EAT_POSITION2D,


 EAT_VECTOR2D,


 EAT_RECT,


 EAT_MATRIX,


 EAT_QUATERNION,


 EAT_BBOX,


 EAT_PLANE,


 EAT_TRIANGLE3D,


 EAT_LINE2D,


 EAT_LINE3D,


 EAT_STRINGWARRAY,


 EAT_FLOATARRAY,


 EAT_INTARRAY,


 EAT_BINARY,


 EAT_TEXTURE,


 EAT_COUNT,


 EAT_UNKNOWN
};


class IAttributes : public virtual IUnknown
{
public:


 virtual s32 getAttributeCount() = 0;



 virtual const c8* getAttributeName(s32 index) = 0;



 virtual E_ATTRIBUTE_TYPE getAttributeType(const c8* attributeName) = 0;



 virtual E_ATTRIBUTE_TYPE getAttributeType(s32 index) = 0;



 virtual const wchar_t* getAttributeTypeString(const c8* attributeName) = 0;



 virtual const wchar_t* getAttributeTypeString(s32 index) = 0;


 virtual bool existsAttribute(const c8* attributeName) = 0;


 virtual s32 findAttribute(const c8* attributeName) = 0;


 virtual void clear() = 0;




 virtual bool read(irr::io::IXMLReader* reader, bool readCurrentElementOnly=false) = 0;





 virtual bool write(io::IXMLWriter* writer, bool writeXMLHeader=false) = 0;
# 173 "H:/CPP/irrlicht-1.3/include/IAttributes.h"
 virtual void addInt(const c8* attributeName, s32 value) = 0;


 virtual void setAttribute(const c8* attributeName, s32 value) = 0;




 virtual s32 getAttributeAsInt(const c8* attributeName) = 0;



 virtual s32 getAttributeAsInt(s32 index) = 0;


 virtual void setAttribute(s32 index, s32 value) = 0;
# 197 "H:/CPP/irrlicht-1.3/include/IAttributes.h"
 virtual void addFloat(const c8* attributeName, f32 value) = 0;


 virtual void setAttribute(const c8* attributeName, f32 value) = 0;




 virtual f32 getAttributeAsFloat(const c8* attributeName) = 0;



 virtual f32 getAttributeAsFloat(s32 index) = 0;


 virtual void setAttribute(s32 index, f32 value) = 0;
# 221 "H:/CPP/irrlicht-1.3/include/IAttributes.h"
 virtual void addString(const c8* attributeName, const c8* value) = 0;




 virtual void setAttribute(const c8* attributeName, const c8* value) = 0;





 virtual core::stringc getAttributeAsString(const c8* attributeName) = 0;




 virtual void getAttributeAsString(const c8* attributeName, c8* target) = 0;



 virtual core::stringc getAttributeAsString(s32 index) = 0;



 virtual void setAttribute(s32 index, const c8* value) = 0;




 virtual void addString(const c8* attributeName, const wchar_t* value) = 0;




 virtual void setAttribute(const c8* attributeName, const wchar_t* value) = 0;





 virtual core::stringw getAttributeAsStringW(const c8* attributeName) = 0;




 virtual void getAttributeAsStringW(const c8* attributeName, wchar_t* target) = 0;



 virtual core::stringw getAttributeAsStringW(s32 index) = 0;



 virtual void setAttribute(s32 index, const wchar_t* value) = 0;
# 283 "H:/CPP/irrlicht-1.3/include/IAttributes.h"
 virtual void addBinary(const c8* attributeName, void* data, s32 dataSizeInBytes) = 0;


 virtual void setAttribute(const c8* attributeName, void* data, s32 dataSizeInBytes ) = 0;



 virtual void getAttributeAsBinaryData(const c8* attributeName, void* outData, s32 maxSizeInBytes) = 0;



 virtual void getAttributeAsBinaryData(s32 index, void* outData, s32 maxSizeInBytes) = 0;


 virtual void setAttribute(s32 index, void* data, s32 dataSizeInBytes ) = 0;
# 307 "H:/CPP/irrlicht-1.3/include/IAttributes.h"
 virtual void addArray(const c8* attributeName, core::array<core::stringw> value) = 0;




 virtual void setAttribute(const c8* attributeName, const core::array<core::stringw> value) = 0;





 virtual core::array<core::stringw> getAttributeAsArray(const c8* attributeName) = 0;



 virtual core::array<core::stringw> getAttributeAsArray(s32 index) = 0;


 virtual void setAttribute(s32 index, core::array<core::stringw> value) = 0;
# 335 "H:/CPP/irrlicht-1.3/include/IAttributes.h"
 virtual void addBool(const c8* attributeName, bool value) = 0;


 virtual void setAttribute(const c8* attributeName, bool value) = 0;




 virtual bool getAttributeAsBool(const c8* attributeName) = 0;



 virtual bool getAttributeAsBool(s32 index) = 0;


 virtual void setAttribute(s32 index, bool value) = 0;
# 359 "H:/CPP/irrlicht-1.3/include/IAttributes.h"
 virtual void addEnum(const c8* attributeName, const c8* enumValue, const c8* const* enumerationLiterals) = 0;


 virtual void addEnum(const c8* attributeName, s32 enumValue, const c8* const* enumerationLiterals) = 0;


 virtual void setAttribute(const c8* attributeName, const c8* enumValue, const c8* const* enumerationLiterals) = 0;




 virtual const c8* getAttributeAsEnumeration(const c8* attributeName) = 0;







 virtual s32 getAttributeAsEnumeration(const c8* attributeName, const c8* const* enumerationLiteralsToUse) = 0;



 virtual s32 getAttributeAsEnumeration(s32 index, const c8* const* enumerationLiteralsToUse) = 0;



 virtual const c8* getAttributeAsEnumeration(s32 index) = 0;



 virtual void getAttributeEnumerationLiteralsOfEnumeration(const c8* attributeName, core::array<core::stringc>& outLiterals) = 0;



 virtual void getAttributeEnumerationLiteralsOfEnumeration(s32 index, core::array<core::stringc>& outLiterals) = 0;


 virtual void setAttribute(s32 index, const c8* enumValue, const c8* const* enumerationLiterals) = 0;
# 407 "H:/CPP/irrlicht-1.3/include/IAttributes.h"
 virtual void addColor(const c8* attributeName, video::SColor value) = 0;



 virtual void setAttribute(const c8* attributeName, video::SColor color) = 0;




 virtual video::SColor getAttributeAsColor(const c8* attributeName) = 0;



 virtual video::SColor getAttributeAsColor(s32 index) = 0;


 virtual void setAttribute(s32 index, video::SColor color) = 0;
# 432 "H:/CPP/irrlicht-1.3/include/IAttributes.h"
 virtual void addColorf(const c8* attributeName, video::SColorf value) = 0;


 virtual void setAttribute(const c8* attributeName, video::SColorf color) = 0;




 virtual video::SColorf getAttributeAsColorf(const c8* attributeName) = 0;



 virtual video::SColorf getAttributeAsColorf(s32 index) = 0;


 virtual void setAttribute(s32 index, video::SColorf color) = 0;
# 457 "H:/CPP/irrlicht-1.3/include/IAttributes.h"
 virtual void addVector3d(const c8* attributeName, core::vector3df value) = 0;


 virtual void setAttribute(const c8* attributeName, core::vector3df v) = 0;




 virtual core::vector3df getAttributeAsVector3d(const c8* attributeName) = 0;



 virtual core::vector3df getAttributeAsVector3d(s32 index) = 0;


 virtual void setAttribute(s32 index, core::vector3df v) = 0;
# 481 "H:/CPP/irrlicht-1.3/include/IAttributes.h"
 virtual void addPosition2d(const c8* attributeName, core::position2di value) = 0;


 virtual void setAttribute(const c8* attributeName, core::position2di v) = 0;




 virtual core::position2di getAttributeAsPosition2d(const c8* attributeName) = 0;



 virtual core::position2di getAttributeAsPosition2d(s32 index) = 0;


 virtual void setAttribute(s32 index, core::position2di v) = 0;
# 505 "H:/CPP/irrlicht-1.3/include/IAttributes.h"
 virtual void addRect(const c8* attributeName, core::rect<s32> value) = 0;


 virtual void setAttribute(const c8* attributeName, core::rect<s32> v) = 0;




 virtual core::rect<s32> getAttributeAsRect(const c8* attributeName) = 0;



 virtual core::rect<s32> getAttributeAsRect(s32 index) = 0;


 virtual void setAttribute(s32 index, core::rect<s32> v) = 0;
# 530 "H:/CPP/irrlicht-1.3/include/IAttributes.h"
 virtual void addMatrix(const c8* attributeName, core::matrix4 v) = 0;


 virtual void setAttribute(const c8* attributeName, core::matrix4 v) = 0;




 virtual core::matrix4 getAttributeAsMatrix(const c8* attributeName) = 0;



 virtual core::matrix4 getAttributeAsMatrix(s32 index) = 0;


 virtual void setAttribute(s32 index, core::matrix4 v) = 0;







 virtual void addQuaternion(const c8* attributeName, core::quaternion v) = 0;


 virtual void setAttribute(const c8* attributeName, core::quaternion v) = 0;




 virtual core::quaternion getAttributeAsQuaternion(const c8* attributeName) = 0;



 virtual core::quaternion getAttributeAsQuaternion(s32 index) = 0;


 virtual void setAttribute(s32 index, core::quaternion v) = 0;
# 577 "H:/CPP/irrlicht-1.3/include/IAttributes.h"
 virtual void addBox3d(const c8* attributeName, core::aabbox3df v) = 0;


 virtual void setAttribute(const c8* attributeName, core::aabbox3df v) = 0;




 virtual core::aabbox3df getAttributeAsBox3d(const c8* attributeName) = 0;



 virtual core::aabbox3df getAttributeAsBox3d(s32 index) = 0;


 virtual void setAttribute(s32 index, core::aabbox3df v) = 0;
# 601 "H:/CPP/irrlicht-1.3/include/IAttributes.h"
 virtual void addPlane3d(const c8* attributeName, core::plane3df v) = 0;


 virtual void setAttribute(const c8* attributeName, core::plane3df v) = 0;




 virtual core::plane3df getAttributeAsPlane3d(const c8* attributeName) = 0;



 virtual core::plane3df getAttributeAsPlane3d(s32 index) = 0;


 virtual void setAttribute(s32 index, core::plane3df v) = 0;
# 626 "H:/CPP/irrlicht-1.3/include/IAttributes.h"
 virtual void addTriangle3d(const c8* attributeName, core::triangle3df v) = 0;


 virtual void setAttribute(const c8* attributeName, core::triangle3df v) = 0;




 virtual core::triangle3df getAttributeAsTriangle3d(const c8* attributeName) = 0;



 virtual core::triangle3df getAttributeAsTriangle3d(s32 index) = 0;


 virtual void setAttribute(s32 index, core::triangle3df v) = 0;
# 651 "H:/CPP/irrlicht-1.3/include/IAttributes.h"
 virtual void addLine2d(const c8* attributeName, core::line2df v) = 0;


 virtual void setAttribute(const c8* attributeName, core::line2df v) = 0;




 virtual core::line2df getAttributeAsLine2d(const c8* attributeName) = 0;



 virtual core::line2df getAttributeAsLine2d(s32 index) = 0;


 virtual void setAttribute(s32 index, core::line2df v) = 0;
# 676 "H:/CPP/irrlicht-1.3/include/IAttributes.h"
 virtual void addLine3d(const c8* attributeName, core::line3df v) = 0;


 virtual void setAttribute(const c8* attributeName, core::line3df v) = 0;




 virtual core::line3df getAttributeAsLine3d(const c8* attributeName) = 0;



 virtual core::line3df getAttributeAsLine3d(s32 index) = 0;


 virtual void setAttribute(s32 index, core::line3df v) = 0;
# 701 "H:/CPP/irrlicht-1.3/include/IAttributes.h"
 virtual void addTexture(const c8* attributeName, video::ITexture* texture) = 0;


 virtual void setAttribute(const c8* attributeName, video::ITexture* texture ) = 0;



 virtual video::ITexture* getAttributeAsTexture(const c8* attributeName) = 0;



 virtual video::ITexture* getAttributeAsTexture(s32 index) = 0;


 virtual void setAttribute(s32 index, video::ITexture* texture) = 0;

};

}
}
# 42 "H:/CPP/irrlicht-1.3/include/irrlicht.h" 2
# 1 "H:/CPP/irrlicht-1.3/include/IAttributeExchangingObject.h" 1
# 11 "H:/CPP/irrlicht-1.3/include/IAttributeExchangingObject.h"
namespace irr
{

namespace io
{

class IAttributes;


enum E_ATTRIBUTE_READ_WRITE_FLAGS
{

 EARWF_FOR_FILE = 0x00000001,


 EARWF_FOR_EDITOR = 0x00000002,


 EARWF_USE_RELATIVE_PATHS = 0x00000004
};



struct SAttributeReadWriteOptions
{

 SAttributeReadWriteOptions()
  : Flags(0), Filename(0)
 {
 }


 s32 Flags;


 const c8* Filename;
};



class IAttributeExchangingObject : public virtual IUnknown
{
public:




 virtual void serializeAttributes(io::IAttributes* out, io::SAttributeReadWriteOptions* options=0) {}




 virtual void deserializeAttributes(io::IAttributes* in, io::SAttributeReadWriteOptions* options=0) {}

};

}
}
# 43 "H:/CPP/irrlicht-1.3/include/irrlicht.h" 2
# 1 "H:/CPP/irrlicht-1.3/include/IAnimatedMesh.h" 1
# 9 "H:/CPP/irrlicht-1.3/include/IAnimatedMesh.h"
# 1 "H:/CPP/irrlicht-1.3/include/IMesh.h" 1
# 9 "H:/CPP/irrlicht-1.3/include/IMesh.h"
# 1 "H:/CPP/irrlicht-1.3/include/IMeshBuffer.h" 1
# 9 "H:/CPP/irrlicht-1.3/include/IMeshBuffer.h"
# 1 "H:/CPP/irrlicht-1.3/include/SMaterial.h" 1
# 9 "H:/CPP/irrlicht-1.3/include/SMaterial.h"
# 1 "H:/CPP/irrlicht-1.3/include/ITexture.h" 1
# 9 "H:/CPP/irrlicht-1.3/include/ITexture.h"
# 1 "H:/CPP/irrlicht-1.3/include/IImage.h" 1
# 12 "H:/CPP/irrlicht-1.3/include/IImage.h"
namespace irr
{
namespace video
{



enum ECOLOR_FORMAT
{



 ECF_A1R5G5B5 = 0,


 ECF_R5G6B5,


 ECF_R8G8B8,



 ECF_A8R8G8B8
};






class IImage : public virtual IUnknown
{
public:


 virtual ~IImage() {};







 virtual void* lock() = 0;




 virtual void unlock() = 0;


 virtual const core::dimension2d<s32>& getDimension() = 0;


 virtual s32 getBitsPerPixel() = 0;


 virtual s32 getBytesPerPixel() = 0;


 virtual s32 getImageDataSizeInBytes() = 0;


 virtual s32 getImageDataSizeInPixels() = 0;


 virtual SColor getPixel(s32 x, s32 y) = 0;


 virtual ECOLOR_FORMAT getColorFormat() const = 0;


 virtual u32 getRedMask() = 0;


 virtual u32 getGreenMask() = 0;


 virtual u32 getBlueMask() = 0;


 virtual u32 getAlphaMask() = 0;


 virtual u32 getPitch() const = 0;

};

}
}
# 10 "H:/CPP/irrlicht-1.3/include/ITexture.h" 2





namespace irr
{
namespace video
{




enum E_TEXTURE_CREATION_FLAG
{
# 33 "H:/CPP/irrlicht-1.3/include/ITexture.h"
 ETCF_ALWAYS_16_BIT = 0x00000001,
# 42 "H:/CPP/irrlicht-1.3/include/ITexture.h"
 ETCF_ALWAYS_32_BIT = 0x00000002,







 ETCF_OPTIMIZED_FOR_QUALITY = 0x00000004,






 ETCF_OPTIMIZED_FOR_SPEED = 0x00000008,


 ETCF_CREATE_MIP_MAPS = 0x00000010,



 ETCF_FORCE_32_BIT_DO_NOT_USE = 0x7fffffff
};





inline E_TEXTURE_CREATION_FLAG getTextureFormatFromFlags(u32 flags)
{
 if (flags & ETCF_OPTIMIZED_FOR_SPEED)
  return ETCF_OPTIMIZED_FOR_SPEED;
 if (flags & ETCF_ALWAYS_16_BIT)
  return ETCF_ALWAYS_16_BIT;
 if (flags & ETCF_ALWAYS_32_BIT)
  return ETCF_ALWAYS_32_BIT;
 if (flags & ETCF_OPTIMIZED_FOR_QUALITY)
  return ETCF_OPTIMIZED_FOR_QUALITY;
 return ETCF_OPTIMIZED_FOR_SPEED;
}
# 94 "H:/CPP/irrlicht-1.3/include/ITexture.h"
class ITexture : public virtual IUnknown
{
public:


 ITexture(const c8* name) : Name(name)
 {
  Name.make_lower();
 }


 virtual ~ITexture() {};
# 114 "H:/CPP/irrlicht-1.3/include/ITexture.h"
 virtual void* lock() = 0;


 virtual void unlock() = 0;
# 128 "H:/CPP/irrlicht-1.3/include/ITexture.h"
 virtual const core::dimension2d<s32>& getOriginalSize() = 0;



 virtual const core::dimension2d<s32>& getSize() = 0;







 virtual E_DRIVER_TYPE getDriverType() = 0;



 virtual ECOLOR_FORMAT getColorFormat() const = 0;





 virtual u32 getPitch() const = 0;



 virtual bool hasMipMaps() { return false; }



 virtual void regenerateMipMapLevels() = 0;


 const core::stringc& getName() { return Name; }

protected:

 core::stringc Name;
};


}
}
# 10 "H:/CPP/irrlicht-1.3/include/SMaterial.h" 2



namespace irr
{
namespace video
{

 enum E_MATERIAL_TYPE
 {


  EMT_SOLID = 0,





  EMT_SOLID_2_LAYER,




  EMT_LIGHTMAP,



  EMT_LIGHTMAP_ADD,






  EMT_LIGHTMAP_M2,






  EMT_LIGHTMAP_M4,


  EMT_LIGHTMAP_LIGHTING,


  EMT_LIGHTMAP_LIGHTING_M2,


  EMT_LIGHTMAP_LIGHTING_M4,
# 69 "H:/CPP/irrlicht-1.3/include/SMaterial.h"
  EMT_DETAIL_MAP,




  EMT_SPHERE_MAP,




  EMT_REFLECTION_2_LAYER,
# 88 "H:/CPP/irrlicht-1.3/include/SMaterial.h"
  EMT_TRANSPARENT_ADD_COLOR,
# 101 "H:/CPP/irrlicht-1.3/include/SMaterial.h"
  EMT_TRANSPARENT_ALPHA_CHANNEL,
# 112 "H:/CPP/irrlicht-1.3/include/SMaterial.h"
  EMT_TRANSPARENT_ALPHA_CHANNEL_REF,


  EMT_TRANSPARENT_VERTEX_ALPHA,
# 124 "H:/CPP/irrlicht-1.3/include/SMaterial.h"
  EMT_TRANSPARENT_REFLECTION_2_LAYER,
# 135 "H:/CPP/irrlicht-1.3/include/SMaterial.h"
  EMT_NORMAL_MAP_SOLID,
# 146 "H:/CPP/irrlicht-1.3/include/SMaterial.h"
  EMT_NORMAL_MAP_TRANSPARENT_ADD_COLOR,
# 158 "H:/CPP/irrlicht-1.3/include/SMaterial.h"
  EMT_NORMAL_MAP_TRANSPARENT_VERTEX_ALPHA,
# 174 "H:/CPP/irrlicht-1.3/include/SMaterial.h"
  EMT_PARALLAX_MAP_SOLID,



  EMT_PARALLAX_MAP_TRANSPARENT_ADD_COLOR,



  EMT_PARALLAX_MAP_TRANSPARENT_VERTEX_ALPHA,



  EMT_ONETEXTURE_BLEND,


  EMT_FORCE_32BIT = 0x7fffffff
 };



 enum E_BLEND_FACTOR
 {
  EBF_ZERO = 0,
  EBF_ONE,
  EBF_DST_COLOR,
  EBF_ONE_MINUS_DST_COLOR,
  EBF_SRC_COLOR,
  EBF_ONE_MINUS_SRC_COLOR,
  EBF_SRC_ALPHA,
  EBF_ONE_MINUS_SRC_ALPHA,
  EBF_DST_ALPHA,
  EBF_ONE_MINUS_DST_ALPHA,
  EBF_SRC_ALPHA_SATURATE
 };


 enum E_TEXTURE_CLAMP
 {
  ETC_REPEAT = 0,
  ETC_CLAMP,
  ETC_CLAMP_TO_EDGE,
  ETC_CLAMP_TO_BORDER,
  ETC_MIRROR
 };
 static const char* const aTextureClampNames[] = {
   "texture_clamp_repeat",
   "texture_clamp_clamp",
   "texture_clamp_clamp_to_edge",
   "texture_clamp_clamp_to_border",
   "texture_clamp_mirror", 0};


 enum E_MODULATE_FUNC
 {
  EMFN_MODULATE_1X = 1,
  EMFN_MODULATE_2X = 2,
  EMFN_MODULATE_4X = 4
 };


 inline f32 pack_texureBlendFunc ( const E_BLEND_FACTOR srcFact, const E_BLEND_FACTOR dstFact, const E_MODULATE_FUNC modulate )
 {
  u32 state = modulate << 16 | srcFact << 8 | dstFact;
  return (f32&) state;
 }


 inline void unpack_texureBlendFunc ( E_BLEND_FACTOR &srcFact, E_BLEND_FACTOR &dstFact, E_MODULATE_FUNC &modulo, const f32 param )
 {
  u32 state = (u32&)(param);
  modulo = E_MODULATE_FUNC ( ( state & 0x00FF0000 ) >> 16 );
  srcFact = E_BLEND_FACTOR ( ( state & 0x0000FF00 ) >> 8 );
  dstFact = E_BLEND_FACTOR ( ( state & 0x000000FF ) );
 }


 enum E_MATERIAL_FLAG
 {

  EMF_WIREFRAME = 0,


  EMF_POINTCLOUD,


  EMF_GOURAUD_SHADING,


  EMF_LIGHTING,


  EMF_ZBUFFER,



  EMF_ZWRITE_ENABLE,


  EMF_BACK_FACE_CULLING,


  EMF_BILINEAR_FILTER,




  EMF_TRILINEAR_FILTER,






  EMF_ANISOTROPIC_FILTER,


  EMF_FOG_ENABLE,





  EMF_NORMALIZE_NORMALS,


  EMF_TEXTURE_WRAP,


  EMF_MATERIAL_FLAG_COUNT
 };


 const u32 MATERIAL_MAX_TEXTURES = 4;



 class SMaterial
 {
 public:

  SMaterial()
  : MaterialType(EMT_SOLID), AmbientColor(255,255,255,255), DiffuseColor(255,255,255,255),
   EmissiveColor(0,0,0,0), SpecularColor(255,255,255,255),
   Shininess(0.0f), MaterialTypeParam(0.0f), MaterialTypeParam2(0.0f), Thickness(1.0f),
   Wireframe(false), PointCloud(false), GouraudShading(true), Lighting(true),
   ZBuffer(true), ZWriteEnable(true), BackfaceCulling(true),
   BilinearFilter(true), TrilinearFilter(false), AnisotropicFilter(false),
   FogEnable(false), NormalizeNormals(false)
  {
   for (u32 i=0; i<MATERIAL_MAX_TEXTURES; ++i)
   {
    Textures[i] = 0;
    TextureMatrix[i] = 0;
    TextureWrap[i] = ETC_REPEAT;
   }
  }

  SMaterial(const SMaterial& other)
  {

   for (u32 i=0; i<MATERIAL_MAX_TEXTURES; ++i)
   {
    TextureMatrix[i] = 0;
   }
   *this = other;
  }

  ~SMaterial()
  {
   for (u32 i=0; i<MATERIAL_MAX_TEXTURES; ++i)
    if (TextureMatrix[i])
     delete TextureMatrix[i];
  }

  SMaterial& operator=(const SMaterial& other)
  {
   MaterialType = other.MaterialType;

   AmbientColor = other.AmbientColor;
   DiffuseColor = other.DiffuseColor;
   EmissiveColor = other.EmissiveColor;
   SpecularColor = other.SpecularColor;
   Shininess = other.Shininess;
   MaterialTypeParam = other.MaterialTypeParam;
   MaterialTypeParam2 = other.MaterialTypeParam2;
   Thickness = other.Thickness;
   for (u32 i=0; i<MATERIAL_MAX_TEXTURES; ++i)
   {
    Textures[i] = other.Textures[i];
    if (TextureMatrix[i])
    {
     if (other.TextureMatrix[i])
      *TextureMatrix[i] = *other.TextureMatrix[i];
     else
     {
      delete TextureMatrix[i];
      TextureMatrix[i] = 0;
     }
    }
    else
    {
     if (other.TextureMatrix[i])
      TextureMatrix[i] = new core::matrix4(*other.TextureMatrix[i]);
     else
      TextureMatrix[i] = 0;
    }
    TextureWrap[i] = other.TextureWrap[i];
   }

   Wireframe = other.Wireframe;
   PointCloud = other.PointCloud;
   GouraudShading = other.GouraudShading;
   Lighting = other.Lighting;
   ZBuffer = other.ZBuffer;
   ZWriteEnable = other.ZWriteEnable;
   BackfaceCulling = other.BackfaceCulling;
   BilinearFilter = other.BilinearFilter;
   TrilinearFilter = other.TrilinearFilter;
   AnisotropicFilter = other.AnisotropicFilter;
   FogEnable = other.FogEnable;
   NormalizeNormals = other.NormalizeNormals;

   return *this;
  }


  E_MATERIAL_TYPE MaterialType;




  SColor AmbientColor;



  SColor DiffuseColor;


  SColor EmissiveColor;




  SColor SpecularColor;
# 448 "H:/CPP/irrlicht-1.3/include/SMaterial.h"
  f32 Shininess;




  f32 MaterialTypeParam;



  f32 MaterialTypeParam2;


  f32 Thickness;


  ITexture* Textures[MATERIAL_MAX_TEXTURES];




  core::matrix4* TextureMatrix[MATERIAL_MAX_TEXTURES];


  E_TEXTURE_CLAMP TextureWrap[MATERIAL_MAX_TEXTURES];





  struct
  {

   bool Wireframe;


   bool PointCloud;


   bool GouraudShading;


   bool Lighting;




   u32 ZBuffer;




   bool ZWriteEnable;


   bool BackfaceCulling;


   bool BilinearFilter;




   bool TrilinearFilter;






   bool AnisotropicFilter;


   bool FogEnable;


   bool NormalizeNormals;
  };

  core::matrix4& getTextureMatrix(u32 i)
  {
   if (i<MATERIAL_MAX_TEXTURES && !TextureMatrix[i])
    TextureMatrix[i] = new core::matrix4(core::matrix4::EM4CONST_IDENTITY);
   return *TextureMatrix[i];
  }

  const core::matrix4& getTextureMatrix(u32 i) const
  {
   if (i<MATERIAL_MAX_TEXTURES && TextureMatrix[i])
    return *TextureMatrix[i];
   else
    return core::IdentityMatrix;
  }

  void setTextureMatrix(u32 i, const core::matrix4& mat)
  {
   if (i>=MATERIAL_MAX_TEXTURES)
    return;
   if (!TextureMatrix[i])
    TextureMatrix[i] = new core::matrix4(mat);
   else
    *TextureMatrix[i] = mat;
  }

  void setFlag(E_MATERIAL_FLAG flag, bool value)
  {
   switch (flag)
   {
    case EMF_WIREFRAME:
     Wireframe = value; break;
    case EMF_POINTCLOUD:
     PointCloud = value; break;
    case EMF_GOURAUD_SHADING:
     GouraudShading = value; break;
    case EMF_LIGHTING:
     Lighting = value; break;
    case EMF_ZBUFFER:
     ZBuffer = value; break;
    case EMF_ZWRITE_ENABLE:
     ZWriteEnable = value; break;
    case EMF_BACK_FACE_CULLING:
     BackfaceCulling = value; break;
    case EMF_BILINEAR_FILTER:
     BilinearFilter = value; break;
    case EMF_TRILINEAR_FILTER:
     TrilinearFilter = value; break;
    case EMF_ANISOTROPIC_FILTER:
     AnisotropicFilter = value; break;
    case EMF_FOG_ENABLE:
     FogEnable = value; break;
    case EMF_NORMALIZE_NORMALS:
     NormalizeNormals = value; break;
    case EMF_TEXTURE_WRAP:
     TextureWrap[0] = TextureWrap[1] = TextureWrap[2] = TextureWrap[3] = (E_TEXTURE_CLAMP)value;
     break;
    default:
     break;
   }
  }

  bool getFlag(E_MATERIAL_FLAG flag) const
  {
   switch (flag)
   {
    case EMF_WIREFRAME:
     return Wireframe; break;
    case EMF_POINTCLOUD:
     return PointCloud; break;
    case EMF_GOURAUD_SHADING:
     return GouraudShading; break;
    case EMF_LIGHTING:
     return Lighting; break;
    case EMF_ZBUFFER:
     return ZBuffer!=0; break;
    case EMF_ZWRITE_ENABLE:
     return ZWriteEnable; break;
    case EMF_BACK_FACE_CULLING:
     return BackfaceCulling; break;
    case EMF_BILINEAR_FILTER:
     return BilinearFilter; break;
    case EMF_TRILINEAR_FILTER:
     return TrilinearFilter; break;
    case EMF_ANISOTROPIC_FILTER:
     return AnisotropicFilter; break;
    case EMF_FOG_ENABLE:
     return FogEnable; break;
    case EMF_NORMALIZE_NORMALS:
     return NormalizeNormals; break;
    case EMF_TEXTURE_WRAP:
     return !(TextureWrap[0] || TextureWrap[1] || TextureWrap[2] || TextureWrap[3]);
    case EMF_MATERIAL_FLAG_COUNT:
     break;
   }

   return false;
  }


  inline bool operator!=(const SMaterial& b) const
  {
   return
    Textures[0] != b.Textures[0] ||
    Textures[1] != b.Textures[1] ||
    Textures[2] != b.Textures[2] ||
    Textures[3] != b.Textures[3] ||
    MaterialType != b.MaterialType ||
    AmbientColor != b.AmbientColor ||
    DiffuseColor != b.DiffuseColor ||
    EmissiveColor != b.EmissiveColor ||
    SpecularColor != b.SpecularColor ||
    Shininess != b.Shininess ||
    MaterialTypeParam != b.MaterialTypeParam ||
    MaterialTypeParam2 != b.MaterialTypeParam2 ||
    Thickness != b.Thickness ||
    Wireframe != b.Wireframe ||
    PointCloud != b.PointCloud ||
    GouraudShading != b.GouraudShading ||
    Lighting != b.Lighting ||
    ZBuffer != b.ZBuffer ||
    ZWriteEnable != b.ZWriteEnable ||
    BackfaceCulling != b.BackfaceCulling ||
    BilinearFilter != b.BilinearFilter ||
    TrilinearFilter != b.TrilinearFilter ||
    AnisotropicFilter != b.AnisotropicFilter ||
    FogEnable != b.FogEnable ||
    NormalizeNormals != b.NormalizeNormals ||
    TextureWrap[0] != b.TextureWrap[0] ||
    TextureWrap[1] != b.TextureWrap[1] ||
    TextureWrap[2] != b.TextureWrap[2] ||
    TextureWrap[3] != b.TextureWrap[3] ||
    TextureMatrix[0] != b.TextureMatrix[0] ||
    TextureMatrix[1] != b.TextureMatrix[1] ||
    TextureMatrix[2] != b.TextureMatrix[2] ||
    TextureMatrix[3] != b.TextureMatrix[3];
  }
  inline bool operator==(const SMaterial& b) const
  { return !(b!=*this); }
 };

}
}
# 10 "H:/CPP/irrlicht-1.3/include/IMeshBuffer.h" 2

# 1 "H:/CPP/irrlicht-1.3/include/S3DVertex.h" 1
# 12 "H:/CPP/irrlicht-1.3/include/S3DVertex.h"
namespace irr
{
namespace video
{


enum E_VERTEX_TYPE
{

 EVT_STANDARD = 0,



 EVT_2TCOORDS,



 EVT_TANGENTS
};


struct S3DVertex
{

 S3DVertex() {};


 S3DVertex(f32 x, f32 y, f32 z, f32 nx, f32 ny, f32 nz, SColor c, f32 tu, f32 tv)
  : Pos(x,y,z), Normal(nx,ny,nz), Color(c), TCoords(tu,tv) {}


 S3DVertex(const core::vector3df& pos, const core::vector3df& normal,
  SColor color, const core::vector2d<f32>& tcoords)
  : Pos(pos), Normal(normal), Color(color), TCoords(tcoords) {}


 core::vector3df Pos;


 core::vector3df Normal;


 SColor Color;


 core::vector2d<f32> TCoords;

 bool operator == (const S3DVertex& other) const
 {
  return (Pos == other.Pos && Normal == other.Normal &&
   Color == other.Color && TCoords == other.TCoords);
 }

 bool operator != (const S3DVertex& other) const
 {
  return (Pos != other.Pos || Normal != other.Normal ||
   Color != other.Color || TCoords != other.TCoords);
 }
};






struct S3DVertex2TCoords
{

 S3DVertex2TCoords() {};


 S3DVertex2TCoords(f32 x, f32 y, f32 z, SColor c, f32 tu, f32 tv, f32 tu2, f32 tv2)
  : Pos(x,y,z), Color(c), TCoords(tu,tv), TCoords2(tu2,tv2) {}


 S3DVertex2TCoords(const core::vector3df& pos, SColor color,
  const core::vector2d<f32>& tcoords, const core::vector2d<f32>& tcoords2)
  : Pos(pos), Color(color), TCoords(tcoords), TCoords2(tcoords2) {}


 S3DVertex2TCoords(const core::vector3df& pos, const core::vector3df& normal, const SColor& color,
  const core::vector2d<f32>& tcoords, const core::vector2d<f32>& tcoords2)
  : Pos(pos), Normal(normal), Color(color), TCoords(tcoords), TCoords2(tcoords2) {}


 S3DVertex2TCoords(f32 x, f32 y, f32 z, f32 nx, f32 ny, f32 nz, SColor c, f32 tu, f32 tv)
  : Pos(x,y,z), Normal(nx,ny,nz), Color(c), TCoords(tu,tv), TCoords2(tu,tv) {}


 S3DVertex2TCoords(const core::vector3df& pos, const core::vector3df& normal,
  SColor color, const core::vector2d<f32>& tcoords)
  : Pos(pos), Normal(normal), Color(color), TCoords(tcoords), TCoords2(tcoords) {}


 core::vector3df Pos;


 core::vector3df Normal;


 SColor Color;


 core::vector2d<f32> TCoords;


 core::vector2d<f32> TCoords2;

 bool operator == (const S3DVertex2TCoords& other) const
 {
  return (Pos == other.Pos && Normal == other.Normal &&
   Color == other.Color && TCoords == other.TCoords &&
   TCoords2 == other.TCoords2);
 }

 bool operator != (const S3DVertex2TCoords& other) const
 {
  return (Pos != other.Pos || Normal != other.Normal ||
   Color != other.Color || TCoords != other.TCoords ||
   TCoords2 != other.TCoords2);
 }

};





struct S3DVertexTangents
{

 S3DVertexTangents() { };


 S3DVertexTangents(f32 x, f32 y, f32 z)
 : Pos(x,y,z) { }


 S3DVertexTangents(const core::vector3df& pos,
  const core::vector2df& tcoords, SColor c)
  : Pos(pos), Color(c), TCoords(tcoords) { }


 core::vector3df Pos;


 core::vector3df Normal;


 SColor Color;


 core::vector2d<f32> TCoords;


 core::vector3df Tangent;


 core::vector3df Binormal;

 bool operator == (const S3DVertexTangents& other) const
 {
  return (Pos == other.Pos && Normal == other.Normal &&
   Color == other.Color && TCoords == other.TCoords &&
   Tangent == other.Tangent && Binormal == other.Binormal);
 }

 bool operator != (const S3DVertexTangents& other) const
 {
  return (Pos != other.Pos || Normal != other.Normal ||
   Color != other.Color || TCoords != other.TCoords ||
   Tangent != other.Tangent || Binormal != other.Binormal);
 }
};



}
}
# 12 "H:/CPP/irrlicht-1.3/include/IMeshBuffer.h" 2

namespace irr
{
namespace scene
{

enum E_PRIMITIVE_TYPE
{

 EPT_POINTS=0,


 EPT_LINE_STRIP,


 EPT_LINE_LOOP,


 EPT_LINES,



 EPT_TRIANGLE_STRIP,



 EPT_TRIANGLE_FAN,


 EPT_TRIANGLES,


 EPT_QUAD_STRIP,


 EPT_QUADS,


 EPT_POLYGON
};



 class IMeshBuffer : public virtual IUnknown
 {
 public:


  virtual ~IMeshBuffer() {};


  virtual video::SMaterial& getMaterial() = 0;


  virtual const video::SMaterial& getMaterial() const = 0;


  virtual video::E_VERTEX_TYPE getVertexType() const = 0;


  virtual u32 getVertexPitch() const = 0;



  virtual const void* getVertices() const = 0;



  virtual void* getVertices() = 0;


  virtual u32 getVertexCount() const = 0;


  virtual const u16* getIndices() const = 0;


  virtual u16* getIndices() = 0;


  virtual u32 getIndexCount() const = 0;


  virtual const core::aabbox3df& getBoundingBox() const = 0;


  virtual void setBoundingBox( const core::aabbox3df& box) = 0;

 };

}
}
# 10 "H:/CPP/irrlicht-1.3/include/IMesh.h" 2

namespace irr
{
namespace scene
{




 class IMesh : public virtual IUnknown
 {
 public:


  virtual ~IMesh(){};



  virtual u32 getMeshBufferCount() const = 0;






  virtual IMeshBuffer* getMeshBuffer(u32 nr) const = 0;





  virtual IMeshBuffer* getMeshBuffer( const video::SMaterial &material) const { return 0; }



  virtual const core::aabbox3d<f32>& getBoundingBox() const = 0;


  virtual void setBoundingBox( const core::aabbox3df& box) = 0;




  virtual void setMaterialFlag(video::E_MATERIAL_FLAG flag, bool newvalue) = 0;

 };

}
}
# 10 "H:/CPP/irrlicht-1.3/include/IAnimatedMesh.h" 2


namespace irr
{
namespace scene
{
 enum E_ANIMATED_MESH_TYPE
 {

  EAMT_UNKNOWN = 0,


  EAMT_MD2,


  EAMT_MD3,


  EAMT_MS3D,


  EAMT_OBJ,


  EAMT_BSP,


  EAMT_3DS,




  EAMT_X,


  EAMT_MY3D,



  EAMT_LMTS,


  EAMT_CSM,




  EAMT_OCT,


  EAMT_B3D

 };






 class IAnimatedMesh : public virtual IUnknown
 {
 public:


  virtual ~IAnimatedMesh() {};




  virtual s32 getFrameCount() = 0;
# 93 "H:/CPP/irrlicht-1.3/include/IAnimatedMesh.h"
  virtual IMesh* getMesh(s32 frame, s32 detailLevel=255, s32 startFrameLoop=-1, s32 endFrameLoop=-1) = 0;



  virtual const core::aabbox3d<f32>& getBoundingBox() const = 0;







  virtual E_ANIMATED_MESH_TYPE getMeshType() const
  {
   return EAMT_UNKNOWN;
  }
 };

}
}
# 44 "H:/CPP/irrlicht-1.3/include/irrlicht.h" 2
# 1 "H:/CPP/irrlicht-1.3/include/IAnimatedMeshMD2.h" 1
# 10 "H:/CPP/irrlicht-1.3/include/IAnimatedMeshMD2.h"
namespace irr
{
namespace scene
{


 enum EMD2_ANIMATION_TYPE
 {
  EMAT_STAND = 0,
  EMAT_RUN,
  EMAT_ATTACK,
  EMAT_PAIN_A,
  EMAT_PAIN_B,
  EMAT_PAIN_C,
  EMAT_JUMP,
  EMAT_FLIP,
  EMAT_SALUTE,
  EMAT_FALLBACK,
  EMAT_WAVE,
  EMAT_POINT,
  EMAT_CROUCH_STAND,
  EMAT_CROUCH_WALK,
  EMAT_CROUCH_ATTACK,
  EMAT_CROUCH_PAIN,
  EMAT_CROUCH_DEATH,
  EMAT_DEATH_FALLBACK,
  EMAT_DEATH_FALLFORWARD,
  EMAT_DEATH_FALLBACKSLOW,
  EMAT_BOOM,


  EMAT_COUNT
 };


 class IAnimatedMeshMD2 : public IAnimatedMesh
 {
 public:






  virtual void getFrameLoop(EMD2_ANIMATION_TYPE l, s32& outBegin,
   s32& outEnd, s32& outFPS) const = 0;






  virtual bool getFrameLoop(const c8* name,
   s32& outBegin, s32& outEnd, s32& outFPS) const = 0;


  virtual s32 getAnimationCount() const = 0;



  virtual const c8* getAnimationName(s32 nr) const = 0;

 };

}
}
# 45 "H:/CPP/irrlicht-1.3/include/irrlicht.h" 2
# 1 "H:/CPP/irrlicht-1.3/include/IAnimatedMeshMD3.h" 1
# 9 "H:/CPP/irrlicht-1.3/include/IAnimatedMeshMD3.h"
# 1 "H:/CPP/irrlicht-1.3/include/IQ3Shader.h" 1
# 9 "H:/CPP/irrlicht-1.3/include/IQ3Shader.h"
# 1 "H:/CPP/irrlicht-1.3/include/fast_atof.h" 1
# 11 "H:/CPP/irrlicht-1.3/include/fast_atof.h"
namespace irr
{
namespace core
{

const float fast_atof_table[] = {
          0.f,
          0.1f,
          0.01f,
          0.001f,
          0.0001f,
          0.00001f,
          0.000001f,
          0.0000001f,
          0.00000001f,
          0.000000001f,
          0.0000000001f,
          0.00000000001f,
          0.000000000001f,
          0.0000000000001f,
          0.00000000000001f,
          0.000000000000001f
         };

inline u32 strtol10( const char* in, const char* &out)
{
 u32 value = 0;
 c8 symbol;

 while ( 1 )
 {
  symbol = *in;
  if ( symbol < '0' || symbol > '9' )
   break;

  value = ( value * 10 ) + ( symbol - '0' );
  in += 1;
 }
 out = in;
 return value;
}




inline const char* fast_atof_move( const char* c, float& out)
{
 bool inv = false;
 const char *t;
 float f;

 if (*c=='-')
 {
  c++;
  inv = true;
 }


 f = (float) strtol10 ( c, t );

 c = t;

 if (*c == '.')
 {
  c++;


  float pl = (float) strtol10 ( c, t );
  pl *= fast_atof_table[t-c];

  f += pl;

  c = t;

  if (*c == 'e')
  {
   ++c;

   float exp = (float)strtol10(c, t);

   f *= (float)pow(10.0f, exp);
   c = t;
  }
 }

 if (inv)
  f *= -1.0f;

 out = f;
 return c;
}

inline float fast_atof(const char* c)
{
 float ret;
 fast_atof_move(c, ret);
 return ret;
}

}
}
# 10 "H:/CPP/irrlicht-1.3/include/IQ3Shader.h" 2
# 1 "H:/CPP/irrlicht-1.3/include/IFileSystem.h" 1
# 12 "H:/CPP/irrlicht-1.3/include/IFileSystem.h"
namespace irr
{
namespace video
{
 class IVideoDriver;
}
namespace io
{

class IReadFile;
class IWriteFile;
class IFileList;
class IXMLWriter;
class IAttributes;
# 34 "H:/CPP/irrlicht-1.3/include/IFileSystem.h"
class IFileSystem : public virtual IUnknown
{
public:


 virtual ~IFileSystem() {};






 virtual IReadFile* createAndOpenFile(const c8* filename) = 0;
# 59 "H:/CPP/irrlicht-1.3/include/IFileSystem.h"
 virtual IReadFile* createMemoryReadFile(void* memory, s32 len, const c8* fileName, bool deleteMemoryWhenDropped=false) = 0;
# 69 "H:/CPP/irrlicht-1.3/include/IFileSystem.h"
 virtual IWriteFile* createAndWriteFile(const c8* filename, bool append=false) = 0;
# 81 "H:/CPP/irrlicht-1.3/include/IFileSystem.h"
 virtual bool addZipFileArchive(const c8* filename, bool ignoreCase = true, bool ignorePaths = true) = 0;
# 91 "H:/CPP/irrlicht-1.3/include/IFileSystem.h"
 virtual bool addFolderFileArchive(const c8* filename, bool ignoreCase = true, bool ignorePaths = true) = 0;
# 103 "H:/CPP/irrlicht-1.3/include/IFileSystem.h"
 virtual bool addPakFileArchive(const c8* filename, bool ignoreCase = true, bool ignorePaths = true) = 0;


 virtual const c8* getWorkingDirectory() = 0;






 virtual bool changeWorkingDirectoryTo(const c8* newDirectory) = 0;


 virtual irr::core::stringc getAbsolutePath(irr::core::stringc &filename) = 0;





 virtual IFileList* createFileList() = 0;




 virtual bool existFile(const c8* filename) = 0;
# 136 "H:/CPP/irrlicht-1.3/include/IFileSystem.h"
 virtual IXMLReader* createXMLReader(const c8* filename) = 0;
# 145 "H:/CPP/irrlicht-1.3/include/IFileSystem.h"
 virtual IXMLReader* createXMLReader(IReadFile* file) = 0;
# 154 "H:/CPP/irrlicht-1.3/include/IFileSystem.h"
 virtual IXMLReaderUTF8* createXMLReaderUTF8(const c8* filename) = 0;
# 163 "H:/CPP/irrlicht-1.3/include/IFileSystem.h"
 virtual IXMLReaderUTF8* createXMLReaderUTF8(IReadFile* file) = 0;






 virtual IXMLWriter* createXMLWriter(const c8* filename) = 0;






 virtual IXMLWriter* createXMLWriter(IWriteFile* file) = 0;







 virtual IAttributes* createEmptyAttributes(video::IVideoDriver* driver=0) = 0;
};

}
}
# 11 "H:/CPP/irrlicht-1.3/include/IQ3Shader.h" 2
# 1 "H:/CPP/irrlicht-1.3/include/IVideoDriver.h" 1
# 15 "H:/CPP/irrlicht-1.3/include/IVideoDriver.h"
# 1 "H:/CPP/irrlicht-1.3/include/IReadFile.h" 1
# 10 "H:/CPP/irrlicht-1.3/include/IReadFile.h"
namespace irr
{
namespace io
{


 class IReadFile : public virtual IUnknown
 {
 public:

  virtual ~IReadFile() {};





  virtual s32 read(void* buffer, u32 sizeToRead) = 0;







  virtual bool seek(s32 finalPos, bool relativeMovement = false) = 0;



  virtual s32 getSize() = 0;



  virtual s32 getPos() = 0;



  virtual const c8* getFileName() = 0;
 };


 IReadFile* createReadFile(const c8* fileName);

 IReadFile* createLimitReadFile(const c8* fileName, IReadFile* alreadyOpenedFile, s32 areaSize);

 IReadFile* createMemoryReadFile(void* memory, s32 size, const c8* fileName, bool deleteMemoryWhenDropped);

}
}
# 16 "H:/CPP/irrlicht-1.3/include/IVideoDriver.h" 2

# 1 "H:/CPP/irrlicht-1.3/include/IImageLoader.h" 1
# 12 "H:/CPP/irrlicht-1.3/include/IImageLoader.h"
namespace irr
{
namespace video
{






class IImageLoader : public virtual IUnknown
{
public:


 virtual ~IImageLoader() {};



 virtual bool isALoadableFileExtension(const c8* fileName) = 0;


 virtual bool isALoadableFileFormat(irr::io::IReadFile* file) = 0;


 virtual IImage* loadImage(irr::io::IReadFile* file) = 0;
};


}
}
# 18 "H:/CPP/irrlicht-1.3/include/IVideoDriver.h" 2
# 1 "H:/CPP/irrlicht-1.3/include/IImageWriter.h" 1






namespace irr
{
namespace io
{
 class IWriteFile;
}

namespace video
{
 class IImage;



class IImageWriter : public IUnknown
{
public:

 IImageWriter()
 {
 }


 virtual ~IImageWriter()
 {
 };


 virtual bool isAWriteableFileExtension(const c8* fileName) = 0;


 virtual bool writeImage(io::IWriteFile *file, IImage *image, u32 param = 0) = 0;
};

}
}
# 19 "H:/CPP/irrlicht-1.3/include/IVideoDriver.h" 2


# 1 "H:/CPP/irrlicht-1.3/include/SExposedVideoData.h" 1
# 9 "H:/CPP/irrlicht-1.3/include/SExposedVideoData.h"
struct IDirect3D9;
struct IDirect3DDevice9;
struct IDirect3D8;
struct IDirect3DDevice8;

namespace irr
{
namespace video
{







struct SExposedVideoData
{
 union
 {
  struct
  {

   IDirect3D9* D3D9;


   IDirect3DDevice9* D3DDev9;



   s32 HWnd;

  } D3D9;

  struct
  {

   IDirect3D8* D3D8;


   IDirect3DDevice8* D3DDev8;



   s32 HWnd;

  } D3D8;

  struct
  {


   s32 HDc;



   s32 HRc;



   s32 HWnd;

  } OpenGLWin32;

  struct
  {

   u32 Window;
  } OpenGLLinux;
 };
};

}
}
# 22 "H:/CPP/irrlicht-1.3/include/IVideoDriver.h" 2
# 1 "H:/CPP/irrlicht-1.3/include/IMaterialRenderer.h" 1
# 12 "H:/CPP/irrlicht-1.3/include/IMaterialRenderer.h"
namespace irr
{
namespace video
{

class IVideoDriver;
class IMaterialRendererServices;





class IMaterialRenderer : public virtual IUnknown
{
public:


 virtual ~IMaterialRenderer() {};
# 49 "H:/CPP/irrlicht-1.3/include/IMaterialRenderer.h"
 virtual void OnSetMaterial(SMaterial& material, const SMaterial& lastMaterial,
  bool resetAllRenderstates, IMaterialRendererServices* services) {};
# 66 "H:/CPP/irrlicht-1.3/include/IMaterialRenderer.h"
 virtual bool OnRender(IMaterialRendererServices* service, E_VERTEX_TYPE vtxtype) { return true; };





 virtual void OnUnsetMaterial() {};




 virtual bool isTransparent() { return false; }
# 89 "H:/CPP/irrlicht-1.3/include/IMaterialRenderer.h"
 virtual s32 getRenderCapability() { return 0; }
};


}
}
# 23 "H:/CPP/irrlicht-1.3/include/IVideoDriver.h" 2

# 1 "H:/CPP/irrlicht-1.3/include/IGPUProgrammingServices.h" 1
# 11 "H:/CPP/irrlicht-1.3/include/IGPUProgrammingServices.h"
namespace irr
{

namespace io
{
 class IReadFile;
}

namespace video
{

class IVideoDriver;
class IShaderConstantSetCallBack;


enum E_VERTEX_SHADER_TYPE
{
 EVST_VS_1_1 = 0,
 EVST_VS_2_0,
 EVST_VS_2_a,
 EVST_VS_3_0,


 EVST_COUNT
};


const c8* const VERTEX_SHADER_TYPE_NAMES[] = {
 "vs_1_1",
 "vs_2_0",
 "vs_2_a",
 "vs_3_0",
 0 };


enum E_PIXEL_SHADER_TYPE
{
 EPST_PS_1_1 = 0,
 EPST_PS_1_2,
 EPST_PS_1_3,
 EPST_PS_1_4,
 EPST_PS_2_0,
 EPST_PS_2_a,
 EPST_PS_2_b,
 EPST_PS_3_0,


 EPST_COUNT
};


const c8* const PIXEL_SHADER_TYPE_NAMES[] = {
 "ps_1_1",
 "ps_1_2",
 "ps_1_3",
 "ps_1_4",
 "ps_2_0",
 "ps_2_a",
 "ps_2_b",
 "ps_3_0",
 0 };


class IGPUProgrammingServices
{
public:


 virtual ~IGPUProgrammingServices() {}
# 104 "H:/CPP/irrlicht-1.3/include/IGPUProgrammingServices.h"
    virtual s32 addHighLevelShaderMaterial(
  const c8* vertexShaderProgram,
  const c8* vertexShaderEntryPointName = "main",
  E_VERTEX_SHADER_TYPE vsCompileTarget = EVST_VS_1_1,
  const c8* pixelShaderProgram = 0,
  const c8* pixelShaderEntryPointName = "main",
  E_PIXEL_SHADER_TYPE psCompileTarget = EPST_PS_1_1,
  IShaderConstantSetCallBack* callback = 0,
  E_MATERIAL_TYPE baseMaterial = video::EMT_SOLID,
  s32 userData = 0 ) = 0;







 virtual s32 addHighLevelShaderMaterialFromFiles(
  const c8* vertexShaderProgram,
  const c8* vertexShaderEntryPointName = "main",
  E_VERTEX_SHADER_TYPE vsCompileTarget = EVST_VS_1_1,
  const c8* pixelShaderProgram = 0,
  const c8* pixelShaderEntryPointName = "main",
  E_PIXEL_SHADER_TYPE psCompileTarget = EPST_PS_1_1,
  IShaderConstantSetCallBack* callback = 0,
  E_MATERIAL_TYPE baseMaterial = video::EMT_SOLID,
  s32 userData = 0) = 0;
# 139 "H:/CPP/irrlicht-1.3/include/IGPUProgrammingServices.h"
 virtual s32 addHighLevelShaderMaterialFromFiles(
  io::IReadFile* vertexShaderProgram,
  const c8* vertexShaderEntryPointName = "main",
  E_VERTEX_SHADER_TYPE vsCompileTarget = EVST_VS_1_1,
  io::IReadFile* pixelShaderProgram = 0,
  const c8* pixelShaderEntryPointName = "main",
  E_PIXEL_SHADER_TYPE psCompileTarget = EPST_PS_1_1,
  IShaderConstantSetCallBack* callback = 0,
  E_MATERIAL_TYPE baseMaterial = video::EMT_SOLID,
  s32 userData = 0) = 0;
# 176 "H:/CPP/irrlicht-1.3/include/IGPUProgrammingServices.h"
 virtual s32 addShaderMaterial(const c8* vertexShaderProgram = 0,
  const c8* pixelShaderProgram = 0,
  IShaderConstantSetCallBack* callback = 0,
  E_MATERIAL_TYPE baseMaterial = video::EMT_SOLID,
  s32 userData = 0) = 0;
# 191 "H:/CPP/irrlicht-1.3/include/IGPUProgrammingServices.h"
 virtual s32 addShaderMaterialFromFiles(io::IReadFile* vertexShaderProgram,
  io::IReadFile* pixelShaderProgram,
  IShaderConstantSetCallBack* callback = 0,
  E_MATERIAL_TYPE baseMaterial = video::EMT_SOLID,
  s32 userData = 0) = 0;
# 207 "H:/CPP/irrlicht-1.3/include/IGPUProgrammingServices.h"
 virtual s32 addShaderMaterialFromFiles(const c8* vertexShaderProgramFileName,
  const c8* pixelShaderProgramFileName,
  IShaderConstantSetCallBack* callback = 0,
  E_MATERIAL_TYPE baseMaterial = video::EMT_SOLID,
  s32 userData = 0) = 0;
};


}
}
# 25 "H:/CPP/irrlicht-1.3/include/IVideoDriver.h" 2

namespace irr
{
namespace io
{
 class IAttributes;
}
namespace scene
{
 class IMeshBuffer;
}

namespace video
{
 struct S3DVertex;
 struct S3DVertex2TCoords;
 struct S3DVertexTangents;
 struct SLight;


 enum E_VIDEO_DRIVER_FEATURE
 {

  EVDF_RENDER_TO_TARGET = 0,


  EVDF_HARDWARE_TL,


  EVDF_MULTITEXTURE,


  EVDF_BILINEAR_FILTER,


  EVDF_MIP_MAP,


  EVDF_MIP_MAP_AUTO_UPDATE,


  EVDF_STENCIL_BUFFER,


  EVDF_VERTEX_SHADER_1_1,


  EVDF_VERTEX_SHADER_2_0,


  EVDF_VERTEX_SHADER_3_0,


  EVDF_PIXEL_SHADER_1_1,


  EVDF_PIXEL_SHADER_1_2,


  EVDF_PIXEL_SHADER_1_3,


  EVDF_PIXEL_SHADER_1_4,


  EVDF_PIXEL_SHADER_2_0,


  EVDF_PIXEL_SHADER_3_0,


  EVDF_ARB_VERTEX_PROGRAM_1,


  EVDF_ARB_FRAGMENT_PROGRAM_1,


  EVDF_ARB_GLSL,


  EVDF_HLSL,


  EVDF_TEXTURE_NPOT,


  EVDF_FRAMEBUFFER_OBJECT
 };


 enum E_TRANSFORMATION_STATE
 {

  ETS_VIEW = 0,

  ETS_WORLD,

  ETS_PROJECTION,

  ETS_TEXTURE_0,

  ETS_TEXTURE_1,

  ETS_TEXTURE_2,

  ETS_TEXTURE_3,

  ETS_COUNT
 };
# 144 "H:/CPP/irrlicht-1.3/include/IVideoDriver.h"
 class IVideoDriver : public virtual IUnknown
 {
 public:


  virtual ~IVideoDriver() {}
# 159 "H:/CPP/irrlicht-1.3/include/IVideoDriver.h"
  virtual bool beginScene(bool backBuffer, bool zBuffer, SColor color) = 0;
# 170 "H:/CPP/irrlicht-1.3/include/IVideoDriver.h"
  virtual bool endScene( s32 windowId = 0, core::rect<s32>* sourceRect=0 ) = 0;





  virtual bool queryFeature(E_VIDEO_DRIVER_FEATURE feature) = 0;




  virtual void setTransform(E_TRANSFORMATION_STATE state, const core::matrix4& mat) = 0;


  virtual const core::matrix4& getTransform(E_TRANSFORMATION_STATE state) = 0;





  virtual void setMaterial(const SMaterial& material) = 0;
# 209 "H:/CPP/irrlicht-1.3/include/IVideoDriver.h"
  virtual ITexture* getTexture(const c8* filename) = 0;
# 228 "H:/CPP/irrlicht-1.3/include/IVideoDriver.h"
  virtual ITexture* getTexture(io::IReadFile* file) = 0;





  virtual ITexture* getTextureByIndex(u32 index) = 0;


  virtual s32 getTextureCount() = 0;
# 248 "H:/CPP/irrlicht-1.3/include/IVideoDriver.h"
  virtual ITexture* addTexture(const core::dimension2d<s32>& size,
   const c8* name, ECOLOR_FORMAT format = ECF_A8R8G8B8) = 0;
# 258 "H:/CPP/irrlicht-1.3/include/IVideoDriver.h"
  virtual ITexture* addTexture(const c8* name, IImage* image) = 0;
# 268 "H:/CPP/irrlicht-1.3/include/IVideoDriver.h"
  virtual ITexture* createRenderTargetTexture(const core::dimension2d<s32>& size) = 0;







  virtual void removeTexture(ITexture* texture) = 0;






  virtual void removeAllTextures() = 0;
# 296 "H:/CPP/irrlicht-1.3/include/IVideoDriver.h"
  virtual void makeColorKeyTexture(video::ITexture* texture, video::SColor color) = 0;
# 306 "H:/CPP/irrlicht-1.3/include/IVideoDriver.h"
  virtual void makeColorKeyTexture(video::ITexture* texture,
   core::position2d<s32> colorKeyPixelPos) = 0;
# 316 "H:/CPP/irrlicht-1.3/include/IVideoDriver.h"
  virtual void makeNormalMapTexture(video::ITexture* texture, f32 amplitude=1.0f) = 0;
# 347 "H:/CPP/irrlicht-1.3/include/IVideoDriver.h"
  virtual bool setRenderTarget(video::ITexture* texture,
   bool clearBackBuffer=true, bool clearZBuffer=true,
   SColor color=video::SColor(0,0,0,0)) = 0;




  virtual void setViewPort(const core::rect<s32>& area) = 0;



  virtual const core::rect<s32>& getViewPort() const = 0;
# 371 "H:/CPP/irrlicht-1.3/include/IVideoDriver.h"
  virtual void drawVertexPrimitiveList(const void* vertices, u32 vertexCount, const u16* indexList, u32 triangleCount, E_VERTEX_TYPE vType, scene::E_PRIMITIVE_TYPE pType) = 0;
# 382 "H:/CPP/irrlicht-1.3/include/IVideoDriver.h"
  virtual void drawIndexedTriangleList(const S3DVertex* vertices,
   u32 vertexCount, const u16* indexList, u32 triangleCount) = 0;
# 394 "H:/CPP/irrlicht-1.3/include/IVideoDriver.h"
  virtual void drawIndexedTriangleList(const S3DVertex2TCoords* vertices,
   u32 vertexCount, const u16* indexList, u32 triangleCount) = 0;
# 406 "H:/CPP/irrlicht-1.3/include/IVideoDriver.h"
  virtual void drawIndexedTriangleList(const S3DVertexTangents* vertices,
   u32 vertexCount, const u16* indexList, u32 triangleCount) = 0;
# 420 "H:/CPP/irrlicht-1.3/include/IVideoDriver.h"
  virtual void drawIndexedTriangleFan(const S3DVertex* vertices,
   u32 vertexCount, const u16* indexList, u32 triangleCount) = 0;
# 434 "H:/CPP/irrlicht-1.3/include/IVideoDriver.h"
  virtual void drawIndexedTriangleFan(const S3DVertex2TCoords* vertices,
   u32 vertexCount, const u16* indexList, u32 triangleCount) = 0;
# 450 "H:/CPP/irrlicht-1.3/include/IVideoDriver.h"
  virtual void draw3DLine(const core::vector3df& start,
   const core::vector3df& end, SColor color = SColor(255,255,255,255)) = 0;
# 462 "H:/CPP/irrlicht-1.3/include/IVideoDriver.h"
  virtual void draw3DTriangle(const core::triangle3df& triangle,
   SColor color = SColor(255,255,255,255)) = 0;
# 474 "H:/CPP/irrlicht-1.3/include/IVideoDriver.h"
  virtual void draw3DBox(const core::aabbox3d<f32> box,
   SColor color = SColor(255,255,255,255)) = 0;




  virtual void draw2DImage(video::ITexture* texture,
   const core::position2d<s32>& destPos) = 0;
# 496 "H:/CPP/irrlicht-1.3/include/IVideoDriver.h"
  virtual void draw2DImage(video::ITexture* texture, const core::position2d<s32>& destPos,
   const core::rect<s32>& sourceRect, const core::rect<s32>* clipRect = 0,
   SColor color=SColor(255,255,255,255), bool useAlphaChannelOfTexture=false) = 0;
# 517 "H:/CPP/irrlicht-1.3/include/IVideoDriver.h"
  virtual void draw2DImage(video::ITexture* texture,
    const core::position2d<s32>& pos,
    const core::array<core::rect<s32> >& sourceRects,
    const core::array<s32>& indices,
    s32 kerningWidth,
    const core::rect<s32>* clipRect, SColor color,
    bool useAlphaChannelOfTexture) = 0;
# 533 "H:/CPP/irrlicht-1.3/include/IVideoDriver.h"
  virtual void draw2DImage(video::ITexture* texture, const core::rect<s32>& destRect,
   const core::rect<s32>& sourceRect, const core::rect<s32>* clipRect = 0,
   video::SColor* colors=0, bool useAlphaChannelOfTexture=false) = 0;







  virtual void draw2DRectangle(SColor color, const core::rect<s32>& pos,
   const core::rect<s32>* clip = 0) = 0;
# 558 "H:/CPP/irrlicht-1.3/include/IVideoDriver.h"
  virtual void draw2DRectangle(const core::rect<s32>& pos,
   SColor colorLeftUp, SColor colorRightUp, SColor colorLeftDown, SColor colorRightDown,
   const core::rect<s32>* clip = 0) = 0;





  virtual void draw2DLine(const core::position2d<s32>& start,
     const core::position2d<s32>& end,
     SColor color=SColor(255,255,255,255)) = 0;
# 581 "H:/CPP/irrlicht-1.3/include/IVideoDriver.h"
  virtual void draw2DPolygon(core::position2d<s32> center,
   f32 radius, video::SColor color=SColor(100,255,255,255), s32 vertexCount=10) = 0;
# 593 "H:/CPP/irrlicht-1.3/include/IVideoDriver.h"
  virtual void drawStencilShadowVolume(const core::vector3df* triangles, s32 count, bool zfail=true) = 0;
# 609 "H:/CPP/irrlicht-1.3/include/IVideoDriver.h"
  virtual void drawStencilShadow(bool clearStencilBuffer=false,
   video::SColor leftUpEdge = video::SColor(255,0,0,0),
   video::SColor rightUpEdge = video::SColor(255,0,0,0),
   video::SColor leftDownEdge = video::SColor(255,0,0,0),
   video::SColor rightDownEdge = video::SColor(255,0,0,0)) = 0;



  virtual void drawMeshBuffer( const scene::IMeshBuffer* mb) = 0;
# 631 "H:/CPP/irrlicht-1.3/include/IVideoDriver.h"
  virtual void setFog(SColor color=SColor(0,255,255,255), bool linearFog=true, f32 start=50.0f, f32 end=100.0f,
   f32 density=0.01f, bool pixelFog=false, bool rangeFog=false) = 0;



  virtual core::dimension2d<s32> getScreenSize() = 0;




  virtual core::dimension2d<s32> getCurrentRenderTargetSize() = 0;




  virtual s32 getFPS() = 0;




  virtual u32 getPrimitiveCountDrawn( u32 param = 0 ) = 0;


  virtual void deleteAllDynamicLights() = 0;



  virtual void addDynamicLight(const SLight& light) = 0;





  virtual void setAmbientLight(const SColorf& color) = 0;



  virtual u32 getMaximalDynamicLightAmount() = 0;



  virtual u32 getDynamicLightCount() = 0;





  virtual const SLight& getDynamicLight(u32 idx) = 0;




  virtual const wchar_t* getName() = 0;
# 692 "H:/CPP/irrlicht-1.3/include/IVideoDriver.h"
  virtual void addExternalImageLoader(IImageLoader* loader) = 0;
# 701 "H:/CPP/irrlicht-1.3/include/IVideoDriver.h"
  virtual void addExternalImageWriter(IImageWriter* writer) = 0;





  virtual u32 getMaximalPrimitiveCount() = 0;
# 718 "H:/CPP/irrlicht-1.3/include/IVideoDriver.h"
  virtual void setTextureCreationFlag(E_TEXTURE_CREATION_FLAG flag, bool enabled) = 0;





  virtual bool getTextureCreationFlag(E_TEXTURE_CREATION_FLAG flag) = 0;
# 734 "H:/CPP/irrlicht-1.3/include/IVideoDriver.h"
  virtual IImage* createImageFromFile(const c8* filename) = 0;
# 744 "H:/CPP/irrlicht-1.3/include/IVideoDriver.h"
  virtual IImage* createImageFromFile(io::IReadFile* file) = 0;
# 753 "H:/CPP/irrlicht-1.3/include/IVideoDriver.h"
  virtual bool writeImageToFile(IImage* image, const c8* filename, u32 param = 0) = 0;
# 769 "H:/CPP/irrlicht-1.3/include/IVideoDriver.h"
  virtual IImage* createImageFromData(ECOLOR_FORMAT format,
   const core::dimension2d<s32>& size, void *data,
   bool ownForeignMemory=false,
   bool deleteMemory = true) = 0;




  virtual void OnResize(const core::dimension2d<s32>& size) = 0;
# 797 "H:/CPP/irrlicht-1.3/include/IVideoDriver.h"
  virtual s32 addMaterialRenderer(IMaterialRenderer* renderer, const c8* name = 0) = 0;




  virtual IMaterialRenderer* getMaterialRenderer(u32 idx) = 0;


  virtual u32 getMaterialRendererCount() = 0;







  virtual const c8* getMaterialRendererName(u32 idx) = 0;





  virtual void setMaterialRendererName(s32 idx, const c8* name) = 0;




  virtual io::IAttributes* createAttributesFromMaterial(const video::SMaterial& material) = 0;





  virtual void fillMaterialStructureFromAttributes(video::SMaterial& outMaterial, io::IAttributes* attributes) = 0;




  virtual SExposedVideoData getExposedVideoData() = 0;


  virtual E_DRIVER_TYPE getDriverType() = 0;





  virtual IGPUProgrammingServices* getGPUProgrammingServices() = 0;







  virtual void clearZBuffer() = 0;


  virtual IImage* createScreenShot() = 0;
 };

}
}
# 12 "H:/CPP/irrlicht-1.3/include/IQ3Shader.h" 2
# 1 "H:/CPP/irrlicht-1.3/include/coreutil.h" 1
# 10 "H:/CPP/irrlicht-1.3/include/coreutil.h"
namespace irr
{
namespace core
{







static const stringc irrEmtpyStringc = "";


inline stringc& cutFilenameExtension ( stringc &dest, const stringc &source )
{
 s32 endPos = source.findLast ( '.' );
 dest = source.subString ( 0, endPos < 0 ? source.size () : endPos );
 return dest;
}


inline stringc& getFileNameExtension ( stringc &dest, const stringc &source )
{
 s32 endPos = source.findLast ( '.' );
 if ( endPos < 0 )
  dest = "";
 else
  dest = source.subString ( endPos, source.size () );
 return dest;
}





inline s32 isdigit(s32 c) { return c >= '0' && c <= '9'; }
inline s32 isspace(s32 c) { return c == ' ' || c == '\f' || c == '\n' || c == '\r' || c == '\t' || c == '\v'; }
inline s32 isupper(s32 c) { return c >= 'A' && c <= 'Z'; }


}
}
# 13 "H:/CPP/irrlicht-1.3/include/IQ3Shader.h" 2

namespace irr
{
namespace scene
{
namespace quake3
{


 enum eQ3MeshIndex
 {
  E_Q3_MESH_GEOMETRY = 0,
  E_Q3_MESH_ITEMS,
  E_Q3_MESH_BILLBOARD,
  E_Q3_MESH_SIZE
 };



 const video::E_MATERIAL_TYPE defaultLightMap = video::EMT_LIGHTMAP_M2;
 const video::E_MODULATE_FUNC defaultModulate = video::EMFN_MODULATE_2X;


 typedef core::array< core::stringc > tStringList;
 typedef core::array< video::ITexture* > tTexArray;


 struct SVariable
 {
  core::stringc name;
  core::stringc content;

  void clear ()
  {
   name = core::irrEmtpyStringc;
   content = core::irrEmtpyStringc;
  }

  s32 isValid () const
  {
   return name.size();
  }

  bool operator < ( const SVariable &other ) const
  {
   return name < other.name;
  }
 };


 inline s32 isEqual ( const core::stringc &string, u32 &pos, const c8 *list[], u32 listSize )
 {
  const char * in = string.c_str () + pos;

  for ( u32 i = 0; i != listSize; ++i )
  {
   if (string.size() < pos)
    return -2;
   u32 len = (u32) strlen ( list[i] );
   if (string.size() < pos+len)
    continue;
   if ( in [len] != 0 && in [len] != ' ' )
    continue;
   if ( strncmp ( in, list[i], len ) )
    continue;

   pos += len + 1;
   return (s32) i;
  }
  return -2;
 }

 inline f32 getAsFloat ( const core::stringc &string, u32 &pos )
 {
  const char * in = string.c_str () + pos;

  f32 value = 0.f;
  pos += (u32) ( core::fast_atof_move ( in, value ) - in ) + 1;
  return value;
 }

 inline core::vector3df getAsVector3df ( const core::stringc &string, u32 &pos )
 {
  core::vector3df v;

  v.X = getAsFloat ( string, pos );
  v.Z = getAsFloat ( string, pos );
  v.Y = getAsFloat ( string, pos );

  return v;
 }




 inline void getAsStringList ( tStringList &list, s32 max, const core::stringc &string, u32 &startPos )
 {
  list.clear ();

  s32 finish = 0;
  s32 endPos;
  do
  {
   endPos = string.findNext ( ' ', startPos );
   if ( endPos == -1 )
   {
    finish = 1;
    endPos = string.size();
   }

   list.push_back ( string.subString ( startPos, endPos - startPos ) );
   startPos = endPos + 1;

   if ( list.size() >= (u32) max )
    finish = 1;

  } while ( !finish );

 }

 struct SBlendFunc
 {
  SBlendFunc () : type ( video::EMT_SOLID ), param ( 0.f ) {}

  video::E_MATERIAL_TYPE type;
  f32 param;
 };


 inline bool getBackfaceCulling ( const core::stringc &string )
 {
  if ( string.size() == 0 )
   return true;

  bool ret = true;
  static const c8 * funclist[] = { "none", "disable" };

  u32 pos = 0;
  switch ( isEqual ( string, pos, funclist, 2 ) )
  {
   case 0:
   case 1:
    ret = false;
    break;
  }
  return ret;
 }



 inline u32 getDepthFunction ( const core::stringc &string )
 {
  if ( string.size() == 0 )
   return 1;

  u32 ret = 1;
  static const c8 * funclist[] = { "lequal","equal" };

  u32 pos = 0;
  switch ( isEqual ( string, pos, funclist, 2 ) )
  {
   case 0:
    ret = 1;
   case 1:
    ret = 2;
    break;
  }
  return ret;
 }




 inline static void getBlendFunc ( const core::stringc &string, SBlendFunc &blendfunc )
 {
  if ( string.size() == 0 )
   return;


  static const c8 * funclist[] =
  {
   "gl_zero",
   "gl_one",
   "gl_dst_color",
   "gl_one_minus_dst_color",
   "gl_src_color",
   "gl_one_minus_src_color",
   "gl_src_alpha",
   "gl_one_minus_src_alpha",
   "gl_dst_alpha",
   "gl_one_minus_dst_alpha",
   "gl_src_alpha_sat",

   "add",
   "filter",
   "blend",

   "ge128",
   "gt0"
  };


  u32 pos = 0;
  s32 srcFact = isEqual ( string, pos, funclist, 16 );

  if ( srcFact < 0 )
   return;

  u32 resolved = 0;
  s32 dstFact = isEqual ( string, pos, funclist, 16 );

  switch ( srcFact )
  {
   case video::EBF_ONE:
    switch ( dstFact )
    {

     case video::EBF_ZERO:
      blendfunc.type = video::EMT_SOLID;
      resolved = 1;
      break;


     case video::EBF_ONE:
      blendfunc.type = video::EMT_TRANSPARENT_ADD_COLOR;
      resolved = 1;
      break;
    } break;

   case video::EBF_SRC_ALPHA:
    switch ( dstFact )
    {

     case video::EBF_ONE_MINUS_SRC_ALPHA:
      blendfunc.type = video::EMT_TRANSPARENT_ALPHA_CHANNEL;
      blendfunc.param = 1.f / 255.f;
      resolved = 1;
      break;
    } break;

   case 11:

    blendfunc.type = video::EMT_TRANSPARENT_ADD_COLOR;
    resolved = 1;
    break;
   case 12:

    blendfunc.type = video::EMT_ONETEXTURE_BLEND;
    blendfunc.param = video::pack_texureBlendFunc ( video::EBF_DST_COLOR, video::EBF_ZERO, defaultModulate );
    resolved = 1;
    break;
   case 13:

    blendfunc.type = video::EMT_TRANSPARENT_ALPHA_CHANNEL;
    blendfunc.param = 1.f / 255.f;
    resolved = 1;
    break;
   case 14:

    blendfunc.type = video::EMT_TRANSPARENT_ALPHA_CHANNEL_REF;
    blendfunc.param = 0.5f;
    resolved = 1;
    break;
   case 15:

    blendfunc.type = video::EMT_TRANSPARENT_ALPHA_CHANNEL_REF;
    blendfunc.param = 1.f / 255.f;
    resolved = 1;
    break;
  }


  if ( 0 == resolved )
  {
   blendfunc.type = video::EMT_ONETEXTURE_BLEND;
   blendfunc.param = video::pack_texureBlendFunc (
     (video::E_BLEND_FACTOR) srcFact,
     (video::E_BLEND_FACTOR) dstFact,
     defaultModulate);
  }
 }

 struct SModifierFunction
 {
  SModifierFunction ()
   : masterfunc0 ( 0 ), masterfunc1(0), func ( 0 ),
   tcgen( 8 ), base ( 0 ), amp ( 1 ), phase ( 0 ), freq ( 1 ), wave(1) {}


  s32 masterfunc0;

  s32 masterfunc1;

  s32 func;

  s32 tcgen;

  union
  {
   f32 base;
   f32 bulgewidth;
  };

  union
  {
   f32 amp;
   f32 bulgeheight;
  };

  f32 phase;

  union
  {
   f32 freq;
   f32 bulgespeed;
  };

  f32 wave;

  f32 evaluate ( f32 dt ) const
  {

   f32 x = core::fract( (dt + phase ) * freq );
   f32 y = 0.f;

   switch ( func )
   {

    case 0:
     y = (f32) sin ( x * core::PI64 * 2.0 );
     break;

    case 1:
     y = (f32) cos ( x * core::PI64 * 2.0 );
     break;

    case 2:
     y = x < 0.5f ? 1.f : -1.f;
     break;

    case 3:
     y = x < 0.5f ? ( 2.f * x ) - 1.f : ( -2.f * x ) + 2.f;
     break;

    case 4:
     y = x;
     break;

    case 5:
     y = 1.f - x;
     break;
   }

   return base + ( y * amp );
  }


 };


 inline void getModifierFunc ( SModifierFunction& fill, const core::stringc &string, u32 &pos )
 {
  if ( string.size() == 0 )
   return;

  static const c8 * funclist[] =
  {
   "sin","cos","square", "triangle", "sawtooth","inversesawtooth"
  };

  fill.func = quake3::isEqual ( string,pos, funclist,6 );
  if ( fill.func == -2 )
   fill.func = 0;

  fill.base = quake3::getAsFloat ( string, pos );
  fill.amp = quake3::getAsFloat ( string, pos );
  fill.phase = quake3::getAsFloat ( string, pos );
  fill.freq = quake3::getAsFloat ( string, pos );
 }



 struct SVarGroup
 {

  s32 getIndex( const c8 * name ) const
  {
   SVariable search;
   search.name = name;

   return Variable.linear_search ( search );
  }



  const core::stringc &get( const c8 * name ) const
  {
   s32 index = getIndex ( name );
   if ( index < 0 )
    return core::irrEmtpyStringc;

   return Variable [ index ].content;
  }

  bool isDefined ( const c8 * name, const c8 * content = 0 ) const
  {
   for ( u32 i = 0; i != Variable.size (); ++i )
   {
    if ( 0 == strcmp ( Variable[i].name.c_str(), name ) )
    {
     if ( 0 == content )
      return true;
     if ( 0 == strcmp ( Variable[i].content.c_str(), content ) )
      return true;
    }
   }
   return false;
  }

  core::array < SVariable > Variable;
 };

 struct SVarGroupList: public IUnknown
 {
  SVarGroupList () {}
  virtual ~SVarGroupList () {}

  core::array < SVarGroup > VariableGroup;
 };


 class SShader
 {
  public:
   bool operator < (const SShader &other ) const
   {
    return name < other.name;
   }

   const SVarGroup * getGroup ( u32 stage ) const
   {
    if ( 0 == VarGroup || stage >= VarGroup->VariableGroup.size () )
     return 0;

    return &VarGroup->VariableGroup [ stage ];
   }


   s32 id;



   core::stringc name;
   SVarGroupList *VarGroup;
 };

 typedef SShader SEntity;

 typedef core::array < SEntity > tQ3EntityList;





 inline void dumpVarGroup ( core::stringc &dest, const SVarGroup * group, s32 stack )
 {
  core::stringc buf;
  s32 i;


  if ( stack > 0 )
  {
   buf = "";
   for ( i = 0; i < stack - 1; ++i )
    buf += '\t';

   buf += "{\n";
   dest.append ( buf );
  }

  for ( u32 g = 0; g != group->Variable.size(); ++g )
  {
   buf = "";
   for ( i = 0; i < stack; ++i )
    buf += '\t';

   buf += group->Variable[g].name;
   buf += " ";
   buf += group->Variable[g].content;
   buf += "\n";
   dest.append ( buf );
  }

  if ( stack > 1 )
  {
   buf = "";
   for ( i = 0; i < stack - 1; ++i )
    buf += '\t';

   buf += "}\n";
   dest.append ( buf );
  }

 }

 inline core::stringc & dumpShader ( core::stringc &dest, const SShader * shader )
 {
  dest = "";
  if ( 0 == shader )
   return dest;

  const SVarGroup * group;

  const u32 size = shader->VarGroup->VariableGroup.size ();

  for ( u32 i = 0; i != size; ++i )
  {
   group = &shader->VarGroup->VariableGroup[ i ];
   dumpVarGroup ( dest, group, core::clamp ( (s32) i, 0, 2 ) );
  }

  if ( size <= 1 )
  {
   dest.append ( "{\n" );
  }

  dest.append ( "}\n" );
  return dest;
 }
# 550 "H:/CPP/irrlicht-1.3/include/IQ3Shader.h"
 inline void getTextures ( tTexArray &textures ,
      const core::stringc &name, u32 &startPos,
      io::IFileSystem *fileSystem,
      video::IVideoDriver* driver
     )
 {
  static const char * extension[2] =
  {
   ".jpg",
   ".tga"
  };

  tStringList stringList;
  getAsStringList ( stringList, -1, name, startPos );

  textures.clear();

  core::stringc loadFile;
  for ( u32 i = 0; i!= stringList.size (); ++i )
  {
   video::ITexture* texture = 0;
   for ( u32 g = 0; g != 2 ; ++g )
   {
    irr::core::cutFilenameExtension ( loadFile, stringList[i] ).append ( extension[g] );

    if ( fileSystem->existFile ( loadFile.c_str() ) )
    {
     texture = driver->getTexture( loadFile.c_str () );
     if ( texture )
     {
      break;
     }
    }
   }

   textures.push_back(texture);
  }
 }





 class IShaderManager : public irr::IUnknown
 {
 };

}
}
}
# 10 "H:/CPP/irrlicht-1.3/include/IAnimatedMeshMD3.h" 2


namespace irr
{
namespace scene
{

 enum eMD3Models
 {
  EMD3_HEAD = 0,
  EMD3_UPPER,
  EMD3_LOWER,
  EMD3_WEAPON,
  EMD3_NUMMODELS
 };



 enum EMD3_ANIMATION_TYPE
 {

  EMD3_BOTH_DEATH_1 = 0,
  EMD3_BOTH_DEAD_1,
  EMD3_BOTH_DEATH_2,
  EMD3_BOTH_DEAD_2,
  EMD3_BOTH_DEATH_3,
  EMD3_BOTH_DEAD_3,


  EMD3_TORSO_GESTURE,
  EMD3_TORSO_ATTACK_1,
  EMD3_TORSO_ATTACK_2,
  EMD3_TORSO_DROP,
  EMD3_TORSO_RAISE,
  EMD3_TORSO_STAND_1,
  EMD3_TORSO_STAND_2,


  EMD3_LEGS_WALK_CROUCH,
  EMD3_LEGS_WALK,
  EMD3_LEGS_RUN,
  EMD3_LEGS_BACK,
  EMD3_LEGS_SWIM,
  EMD3_LEGS_JUMP_1,
  EMD3_LEGS_LAND_1,
  EMD3_LEGS_JUMP_2,
  EMD3_LEGS_LAND_2,
  EMD3_LEGS_IDLE,
  EMD3_LEGS_IDLE_CROUCH,
  EMD3_LEGS_TURN,


  EMD3_ANIMATION_COUNT
 };

 struct SMD3AnimationInfo
 {
  s32 first;
  s32 num;
  s32 looping;
  s32 fps;
 };
# 86 "H:/CPP/irrlicht-1.3/include/IAnimatedMeshMD3.h"
 struct SMD3Header
 {
  c8 headerID[4];
  s32 Version;
  s8 fileName[68];
  s32 numFrames;
  s32 numTags;
  s32 numMeshes;
  s32 numMaxSkins;
  s32 headerSize;
  s32 tagStart;
  s32 tagEnd;
  s32 fileSize;
 };

 struct SMD3MeshHeader
 {
  c8 meshID[4];
  c8 meshName[68];

  s32 numFrames;
  s32 numShader;
  s32 numVertices;
  s32 numTriangles;

  s32 offset_triangles;
  s32 offset_shaders;
  s32 offset_st;
  s32 vertexStart;
  s32 offset_end;
 };



 struct SMD3Vertex
 {
  s16 position[3];
  u8 normal[2];
 };


 struct SMD3TexCoord
 {
  f32 u;
  f32 v;
 };


 struct SMD3Face
 {
  s32 Index[3];
 };
# 148 "H:/CPP/irrlicht-1.3/include/IAnimatedMeshMD3.h"
 struct SMD3MeshBuffer : public IUnknown
 {
  virtual ~ SMD3MeshBuffer () {}

  SMD3MeshHeader MeshHeader;

  core::array < core::stringc > Shader;
  core::array < s32 > Indices;
  core::array < SMD3Vertex > Vertices;
  core::array < SMD3TexCoord > Tex;
 };



 struct SMD3QuaterionTag
 {
  SMD3QuaterionTag() {}

  SMD3QuaterionTag( const core::stringc& name )
   : Name ( name ) {}


  SMD3QuaterionTag ( const core::stringc& name, const core::matrix4 &m )
  {
   Name = name;
   position = m.getTranslation ();
   rotation = m;
  }


  void setto ( core::matrix4 &m )
  {
   rotation.getMatrix ( m );
   m.setTranslation ( position );
  }


  SMD3QuaterionTag ( const core::vector3df&pos, const core::vector3df &angle )
  {
   position = pos;
   rotation.set ( angle.X * core::DEGTORAD, angle.Y * core::DEGTORAD, angle.Z * core::DEGTORAD );
  }

  virtual ~SMD3QuaterionTag() {}

  core::stringc Name;
  core::vector3df position;
  core::quaternion rotation;

  bool operator < ( const SMD3QuaterionTag &other ) const
  {
   return Name < other.Name;
  }
 };


 struct SMD3QuaterionTagList : public virtual IUnknown
 {
  SMD3QuaterionTagList () {}
  virtual ~SMD3QuaterionTagList () {}

  SMD3QuaterionTag* get ( const core::stringc& name )
  {
   SMD3QuaterionTag search ( name );
   s32 index = Container.linear_search ( search );
   if ( index >= 0 )
    return &Container[index];
   return 0;
  }

  u32 size () const
  {
   return Container.size();
  }

  SMD3QuaterionTag& operator[] (u32 index )
  {
   return Container[index];
  }


  core::array < SMD3QuaterionTag > Container;
 };




 struct SMD3Mesh: public IUnknown
 {
  virtual ~SMD3Mesh()
  {
   for (u32 i=0; i<Buffer.size(); ++i)
    Buffer[i]->drop();
  };

  SMD3Header MD3Header;
  core::stringc Name;
  core::array < SMD3MeshBuffer * > Buffer;
  SMD3QuaterionTagList TagList;
 };




 class IAnimatedMeshMD3 : public IAnimatedMesh
 {
 public:


  virtual void setInterpolationShift ( u32 shift, u32 loopMode ) = 0;

  virtual SMD3QuaterionTagList *getTagList(s32 frame, s32 detailLevel, s32 startFrameLoop, s32 endFrameLoop) = 0;

  virtual SMD3Mesh * getOriginalMesh () = 0;

 };

}
}
# 46 "H:/CPP/irrlicht-1.3/include/irrlicht.h" 2
# 1 "H:/CPP/irrlicht-1.3/include/IAnimatedMeshMS3D.h" 1
# 10 "H:/CPP/irrlicht-1.3/include/IAnimatedMeshMS3D.h"
namespace irr
{
namespace scene
{

 class IAnimatedMeshMS3D : public IAnimatedMesh
 {
 public:
# 28 "H:/CPP/irrlicht-1.3/include/IAnimatedMeshMS3D.h"
  virtual core::matrix4* getMatrixOfJoint(s32 jointNumber, s32 frame) = 0;



  virtual s32 getJointCount() const = 0;





  virtual const c8* getJointName(s32 number) const = 0;




  virtual s32 getJointNumber(const c8* name) const = 0;

 };

}
}
# 47 "H:/CPP/irrlicht-1.3/include/irrlicht.h" 2

# 1 "H:/CPP/irrlicht-1.3/include/IQ3LevelMesh.h" 1
# 11 "H:/CPP/irrlicht-1.3/include/IQ3LevelMesh.h"
namespace irr
{
namespace scene
{




 class IQ3LevelMesh : public IAnimatedMesh
 {
 public:


  virtual ~IQ3LevelMesh() {};


  virtual void releaseMesh ( s32 index ) = 0;



  virtual const quake3::SShader * getShader ( const c8 * filename, s32 fileNameIsValid ) = 0;


  virtual const quake3::SShader * getShader ( u32 index ) const = 0;


  virtual const quake3::tQ3EntityList & getEntityList () = 0;

 };

}
}
# 49 "H:/CPP/irrlicht-1.3/include/irrlicht.h" 2
# 1 "H:/CPP/irrlicht-1.3/include/IAnimatedMeshX.h" 1
# 11 "H:/CPP/irrlicht-1.3/include/IAnimatedMeshX.h"
namespace irr
{
namespace scene
{

 class IAnimatedMeshX : public IAnimatedMesh
 {
 public:
# 29 "H:/CPP/irrlicht-1.3/include/IAnimatedMeshX.h"
  virtual core::matrix4* getMatrixOfJoint(s32 jointNumber, s32 frame) = 0;



  virtual s32 getJointCount() const = 0;





  virtual const c8* getJointName(s32 number) const = 0;




  virtual s32 getJointNumber(const c8* name) const = 0;







  virtual const core::array<core::vector3df>* getDrawableSkeleton(s32 frame) = 0;


  virtual s32 getAnimationCount() const = 0;






  virtual const c8* getAnimationName(s32 idx) const = 0;




  virtual void setCurrentAnimation(s32 idx) = 0;





  virtual bool setCurrentAnimation(const c8* name) = 0;
 };

}
}
# 50 "H:/CPP/irrlicht-1.3/include/irrlicht.h" 2
# 1 "H:/CPP/irrlicht-1.3/include/IAnimatedMeshB3d.h" 1







# 1 "H:/CPP/irrlicht-1.3/include/ISceneNode.h" 1
# 9 "H:/CPP/irrlicht-1.3/include/ISceneNode.h"
# 1 "H:/CPP/irrlicht-1.3/include/ESceneNodeTypes.h" 1







namespace irr
{
namespace scene
{

 enum ESCENE_NODE_TYPE
 {

  ESNT_CUBE = 0,


  ESNT_SPHERE,


  ESNT_TEXT,


  ESNT_WATER_SURFACE,


  ESNT_TERRAIN,


  ESNT_SKY_BOX,


  ESNT_SHADOW_VOLUME,


  ESNT_OCT_TREE,


  ESNT_MESH,


  ESNT_LIGHT,


  ESNT_EMPTY,


  ESNT_DUMMY_TRANSFORMATION,


  ESNT_CAMERA,


  ESNT_CAMERA_MAYA,


  ESNT_CAMERA_FPS,


  ESNT_BILLBOARD,


  ESNT_ANIMATED_MESH,


  ESNT_PARTICLE_SYSTEM,


  ESNT_MD3_SCENE_NODE,


  ESNT_COUNT,


  ESNT_UNKNOWN,



  ESNT_FORCE_32_BIT = 0x7fffffff
 };



 enum E_CULLING_TYPE
 {
  EAC_OFF = 0,
  EAC_BOX,
  EAC_FRUSTUM_BOX,
  EAC_FRUSTUM_SPHERE
 };


 const c8* const AutomaticCullingNames[] =
 {
  "false",
  "box",
  "frustum_box",
  "frustum_sphere",
  0
 };


 enum E_DEBUG_SCENE_TYPE
 {

  EDS_OFF = 0,

  EDS_BBOX = 1,

  EDS_NORMALS = 2,

  EDS_SKELETON = 4,

  EDS_MESH_WIRE_OVERLAY = 8,

  EDS_HALF_TRANSPARENCY = 16,

  EDS_BBOX_BUFFERS = 32,
  EDS_FULL = EDS_BBOX | EDS_NORMALS | EDS_SKELETON | EDS_MESH_WIRE_OVERLAY
 };



}
}
# 10 "H:/CPP/irrlicht-1.3/include/ISceneNode.h" 2
# 1 "H:/CPP/irrlicht-1.3/include/ISceneManager.h" 1
# 14 "H:/CPP/irrlicht-1.3/include/ISceneManager.h"
# 1 "H:/CPP/irrlicht-1.3/include/IEventReceiver.h" 1







# 1 "H:/CPP/irrlicht-1.3/include/ILogger.h" 1
# 10 "H:/CPP/irrlicht-1.3/include/ILogger.h"
namespace irr
{

enum ELOG_LEVEL
{


 ELL_INFORMATION = 0,


 ELL_WARNING,


 ELL_ERROR,


 ELL_NONE
};



class ILogger : public virtual IUnknown
{
public:


 virtual ~ILogger() {}


 virtual ELOG_LEVEL getLogLevel() = 0;
# 48 "H:/CPP/irrlicht-1.3/include/ILogger.h"
 virtual void setLogLevel(ELOG_LEVEL ll) = 0;
# 57 "H:/CPP/irrlicht-1.3/include/ILogger.h"
 virtual void log(const c8* text, ELOG_LEVEL ll=ELL_INFORMATION) = 0;
# 68 "H:/CPP/irrlicht-1.3/include/ILogger.h"
 virtual void log(const c8* text, const c8* hint, ELOG_LEVEL ll=ELL_INFORMATION) = 0;
# 79 "H:/CPP/irrlicht-1.3/include/ILogger.h"
 virtual void log(const wchar_t* text, const wchar_t* hint, ELOG_LEVEL ll=ELL_INFORMATION) = 0;
# 89 "H:/CPP/irrlicht-1.3/include/ILogger.h"
 virtual void log(const wchar_t* text, ELOG_LEVEL ll=ELL_INFORMATION) = 0;
};

}
# 9 "H:/CPP/irrlicht-1.3/include/IEventReceiver.h" 2

# 1 "H:/CPP/irrlicht-1.3/include/Keycodes.h" 1







namespace irr
{

 enum EKEY_CODE
 {
  KEY_LBUTTON = 0x01,
  KEY_RBUTTON = 0x02,
  KEY_CANCEL = 0x03,
  KEY_MBUTTON = 0x04,
  KEY_XBUTTON1 = 0x05,
  KEY_XBUTTON2 = 0x06,
  KEY_BACK = 0x08,
  KEY_TAB = 0x09,
  KEY_CLEAR = 0x0C,
  KEY_RETURN = 0x0D,
  KEY_SHIFT = 0x10,
  KEY_CONTROL = 0x11,
  KEY_MENU = 0x12,
  KEY_PAUSE = 0x13,
  KEY_CAPITAL = 0x14,
  KEY_KANA = 0x15,
  KEY_HANGUEL = 0x15,
  KEY_HANGUL = 0x15,
  KEY_JUNJA = 0x17,
  KEY_FINAL = 0x18,
  KEY_HANJA = 0x19,
  KEY_KANJI = 0x19,
  KEY_ESCAPE = 0x1B,
  KEY_CONVERT = 0x1C,
  KEY_NONCONVERT = 0x1D,
  KEY_ACCEPT = 0x1E,
  KEY_MODECHANGE = 0x1F,
  KEY_SPACE = 0x20,
  KEY_PRIOR = 0x21,
  KEY_NEXT = 0x22,
  KEY_END = 0x23,
  KEY_HOME = 0x24,
  KEY_LEFT = 0x25,
  KEY_UP = 0x26,
  KEY_RIGHT = 0x27,
  KEY_DOWN = 0x28,
  KEY_SELECT = 0x29,
  KEY_PRINT = 0x2A,
  KEY_EXECUT = 0x2B,
  KEY_SNAPSHOT = 0x2C,
  KEY_INSERT = 0x2D,
  KEY_DELETE = 0x2E,
  KEY_HELP = 0x2F,
  KEY_KEY_0 = 0x30,
  KEY_KEY_1 = 0x31,
  KEY_KEY_2 = 0x32,
  KEY_KEY_3 = 0x33,
  KEY_KEY_4 = 0x34,
  KEY_KEY_5 = 0x35,
  KEY_KEY_6 = 0x36,
  KEY_KEY_7 = 0x37,
  KEY_KEY_8 = 0x38,
  KEY_KEY_9 = 0x39,
  KEY_KEY_A = 0x41,
  KEY_KEY_B = 0x42,
  KEY_KEY_C = 0x43,
  KEY_KEY_D = 0x44,
  KEY_KEY_E = 0x45,
  KEY_KEY_F = 0x46,
  KEY_KEY_G = 0x47,
  KEY_KEY_H = 0x48,
  KEY_KEY_I = 0x49,
  KEY_KEY_J = 0x4A,
  KEY_KEY_K = 0x4B,
  KEY_KEY_L = 0x4C,
  KEY_KEY_M = 0x4D,
  KEY_KEY_N = 0x4E,
  KEY_KEY_O = 0x4F,
  KEY_KEY_P = 0x50,
  KEY_KEY_Q = 0x51,
  KEY_KEY_R = 0x52,
  KEY_KEY_S = 0x53,
  KEY_KEY_T = 0x54,
  KEY_KEY_U = 0x55,
  KEY_KEY_V = 0x56,
  KEY_KEY_W = 0x57,
  KEY_KEY_X = 0x58,
  KEY_KEY_Y = 0x59,
  KEY_KEY_Z = 0x5A,
  KEY_LWIN = 0x5B,
  KEY_RWIN = 0x5C,
  KEY_APPS = 0x5D,
  KEY_SLEEP = 0x5F,
  KEY_NUMPAD0 = 0x60,
  KEY_NUMPAD1 = 0x61,
  KEY_NUMPAD2 = 0x62,
  KEY_NUMPAD3 = 0x63,
  KEY_NUMPAD4 = 0x64,
  KEY_NUMPAD5 = 0x65,
  KEY_NUMPAD6 = 0x66,
  KEY_NUMPAD7 = 0x67,
  KEY_NUMPAD8 = 0x68,
  KEY_NUMPAD9 = 0x69,
  KEY_MULTIPLY = 0x6A,
  KEY_ADD = 0x6B,
  KEY_SEPARATOR = 0x6C,
  KEY_SUBTRACT = 0x6D,
  KEY_DECIMAL = 0x6E,
  KEY_DIVIDE = 0x6F,
  KEY_F1 = 0x70,
  KEY_F2 = 0x71,
  KEY_F3 = 0x72,
  KEY_F4 = 0x73,
  KEY_F5 = 0x74,
  KEY_F6 = 0x75,
  KEY_F7 = 0x76,
  KEY_F8 = 0x77,
  KEY_F9 = 0x78,
  KEY_F10 = 0x79,
  KEY_F11 = 0x7A,
  KEY_F12 = 0x7B,
  KEY_F13 = 0x7C,
  KEY_F14 = 0x7D,
  KEY_F15 = 0x7E,
  KEY_F16 = 0x7F,
  KEY_F17 = 0x80,
  KEY_F18 = 0x81,
  KEY_F19 = 0x82,
  KEY_F20 = 0x83,
  KEY_F21 = 0x84,
  KEY_F22 = 0x85,
  KEY_F23 = 0x86,
  KEY_F24 = 0x87,
  KEY_NUMLOCK = 0x90,
  KEY_SCROLL = 0x91,
  KEY_LSHIFT = 0xA0,
  KEY_RSHIFT = 0xA1,
  KEY_LCONTROL = 0xA2,
  KEY_RCONTROL = 0xA3,
  KEY_LMENU = 0xA4,
  KEY_RMENU = 0xA5,
  KEY_PLUS = 0xBB,
  KEY_COMMA = 0xBC,
  KEY_MINUS = 0xBD,
  KEY_PERIOD = 0xBE,
  KEY_ATTN = 0xF6,
  KEY_CRSEL = 0xF7,
  KEY_EXSEL = 0xF8,
  KEY_EREOF = 0xF9,
  KEY_PLAY = 0xFA,
  KEY_ZOOM = 0xFB,
  KEY_PA1 = 0xFD,
  KEY_OEM_CLEAR = 0xFE,

  KEY_KEY_CODES_COUNT = 0xFF
 };

}
# 11 "H:/CPP/irrlicht-1.3/include/IEventReceiver.h" 2

namespace irr
{

 enum EEVENT_TYPE
 {

  EET_GUI_EVENT = 0,


  EET_MOUSE_INPUT_EVENT,


  EET_KEY_INPUT_EVENT,


  EET_LOG_TEXT_EVENT,



  EET_USER_EVENT
 };


 enum EMOUSE_INPUT_EVENT
 {

  EMIE_LMOUSE_PRESSED_DOWN = 0,


  EMIE_RMOUSE_PRESSED_DOWN,


  EMIE_MMOUSE_PRESSED_DOWN,


  EMIE_LMOUSE_LEFT_UP,


  EMIE_RMOUSE_LEFT_UP,


  EMIE_MMOUSE_LEFT_UP,


  EMIE_MOUSE_MOVED,



  EMIE_MOUSE_WHEEL,


  EMIE_COUNT
 };

 namespace gui
 {

  class IGUIElement;


  enum EGUI_EVENT_TYPE
  {

   EGET_ELEMENT_FOCUS_LOST = 0,


   EGET_ELEMENT_FOCUSED,


   EGET_ELEMENT_HOVERED,


   EGET_ELEMENT_LEFT,


   EGET_BUTTON_CLICKED,


   EGET_SCROLL_BAR_CHANGED,


   EGET_CHECKBOX_CHANGED,


   EGET_LISTBOX_CHANGED,


   EGET_LISTBOX_SELECTED_AGAIN,


   EGET_FILE_SELECTED,


   EGET_FILE_CHOOSE_DIALOG_CANCELLED,


   EGET_MESSAGEBOX_YES,


   EGET_MESSAGEBOX_NO,


   EGET_MESSAGEBOX_OK,


   EGET_MESSAGEBOX_CANCEL,


   EGET_EDITBOX_ENTER,


   EGET_TAB_CHANGED,


   EGET_MENU_ITEM_SELECTED,


   EGET_COMBO_BOX_CHANGED
  };
 }



struct SEvent
{
 EEVENT_TYPE EventType;

 union
 {
  struct
  {

   gui::IGUIElement* Caller;


   gui::EGUI_EVENT_TYPE EventType;

  } GUIEvent;

  struct
  {

   s32 X;


   s32 Y;



   f32 Wheel;


   EMOUSE_INPUT_EVENT Event;
  } MouseInput;

  struct
  {

   wchar_t Char;


   EKEY_CODE Key;


   bool PressedDown;


   bool Shift;


   bool Control;
  } KeyInput;

  struct
  {

   const c8* Text;


   ELOG_LEVEL Level;
  } LogEvent;

  struct
  {

   s32 UserData1;


   s32 UserData2;


   f32 UserData3;
  } UserEvent;

 };

};


class IEventReceiver
{
public:

 virtual ~IEventReceiver() {};


 virtual bool OnEvent(SEvent event) = 0;
};


}
# 15 "H:/CPP/irrlicht-1.3/include/ISceneManager.h" 2
# 1 "H:/CPP/irrlicht-1.3/include/ETerrainElements.h" 1







namespace irr
{
namespace scene
{

 enum E_TERRAIN_PATCH_SIZE
 {

  ETPS_9 = 9,


  ETPS_17 = 17,


  ETPS_33 = 33,


  ETPS_65 = 65,


  ETPS_129 = 129
 };

}
}
# 16 "H:/CPP/irrlicht-1.3/include/ISceneManager.h" 2

# 1 "H:/CPP/irrlicht-1.3/include/SceneParameters.h" 1
# 15 "H:/CPP/irrlicht-1.3/include/SceneParameters.h"
namespace irr
{
namespace scene
{







 const c8* const CSM_TEXTURE_PATH = "CSM_TexturePath";
# 35 "H:/CPP/irrlicht-1.3/include/SceneParameters.h"
 const c8* const LMTS_TEXTURE_PATH = "LMTS_TexturePath";
# 44 "H:/CPP/irrlicht-1.3/include/SceneParameters.h"
 const c8* const MY3D_TEXTURE_PATH = "MY3D_TexturePath";
# 58 "H:/CPP/irrlicht-1.3/include/SceneParameters.h"
 const c8* const COLLADA_CREATE_SCENE_INSTANCES = "COLLADA_CreateSceneInstances";
# 67 "H:/CPP/irrlicht-1.3/include/SceneParameters.h"
 const c8* const DMF_TEXTURE_PATH = "DMF_TexturePath";
# 82 "H:/CPP/irrlicht-1.3/include/SceneParameters.h"
 const c8* const DMF_USE_MATERIALS_DIRS = "DMF_MaterialsDir";
# 92 "H:/CPP/irrlicht-1.3/include/SceneParameters.h"
 const c8* const DMF_ALPHA_CHANNEL_REF = "DMF_AlphaRef";
# 102 "H:/CPP/irrlicht-1.3/include/SceneParameters.h"
 const c8* const DMF_FLIP_ALPHA_TEXTURES = "DMF_FlipAlpha";





 const c8* const IRR_SCENE_MANAGER_IS_EDITOR = "IRR_Editor";

}
}
# 18 "H:/CPP/irrlicht-1.3/include/ISceneManager.h" 2
# 1 "H:/CPP/irrlicht-1.3/include/IGUIEnvironment.h" 1
# 12 "H:/CPP/irrlicht-1.3/include/IGUIEnvironment.h"
# 1 "H:/CPP/irrlicht-1.3/include/IGUIWindow.h" 1







# 1 "H:/CPP/irrlicht-1.3/include/IGUIButton.h" 1







# 1 "H:/CPP/irrlicht-1.3/include/IGUIElement.h" 1
# 9 "H:/CPP/irrlicht-1.3/include/IGUIElement.h"
# 1 "H:/CPP/irrlicht-1.3/include/irrList.h" 1
# 10 "H:/CPP/irrlicht-1.3/include/irrList.h"
namespace irr
{
namespace core
{


template <class T>
class list
{
private:


 struct SKListNode
 {
  SKListNode() : next(0), prev(0) {};

  SKListNode* next;
  SKListNode* prev;
  T element;
 };

public:


 class Iterator
 {
 public:

  Iterator() : current(0) {};

  Iterator& operator ++() { current = current->next; return *this; };
  Iterator& operator --() { current = current->prev; return *this; };
  Iterator operator ++(s32) { Iterator tmp = *this; current = current->next; return tmp; };
  Iterator operator --(s32) { Iterator tmp = *this; current = current->prev; return tmp; };

  Iterator operator+(s32 num) const
  {
   Iterator tmp = *this;

   if (num >= 0)
    while (num-- && tmp.current != 0) ++tmp;
   else
    while (num++ && tmp.current != 0) --tmp;

   return tmp;
  }

  Iterator& operator+=(s32 num)
  {
   if (num >= 0)
    while (num-- && this->current != 0) ++(*this);
   else
    while (num++ && this->current != 0) --(*this);

   return *this;
  }

  Iterator operator-(s32 num) const { return (*this)+(-num); }
  Iterator operator-=(s32 num) const { (*this)+=(-num); return *this; }

  bool operator ==(const Iterator& other) const { return current == other.current; };
  bool operator !=(const Iterator& other) const { return current != other.current; };

  T& operator *() { return current->element; };

 private:

  Iterator(SKListNode* begin) : current(begin) {};

  friend class list<T>;

  SKListNode* current;
 };



 list()
  : root(0), last(0), size(0) {}



 list(const list<T>& other) : root(0), last(0), size(0)
 {
  *this = other;
 }



 ~list()
 {
  clear();
 }




 void operator=(const list<T>& other)
 {
  clear();

  SKListNode* node = other.root;
  while(node)
  {
   push_back(node->element);
   node = node->next;
  }
 }





 u32 getSize() const
 {
  return size;
 }





 void clear()
 {
  SKListNode* node = root;
  while(node)
  {
   SKListNode* next = node->next;
   delete node;
   node = next;
  }

  root = 0;
  last = 0;
  size = 0;
 }





 bool empty() const
 {
  return root == 0;
 }





 void push_back(const T& element)
 {
  SKListNode* node = new SKListNode;
  node->element = element;

  ++size;

  if (root == 0)
   root = node;

  node->prev = last;

  if (last != 0)
   last->next = node;

  last = node;
 }




 void push_front(const T& element)
 {
  SKListNode* node = new SKListNode;
  node->element = element;

  ++size;

  if (root == 0)
  {
   last = node;
   root = node;
  }
  else
  {
   node->next = root;
   root->prev = node;
   root = node;
  }
 }




 Iterator begin() const
 {
  return Iterator(root);
 }




 Iterator end() const
 {
  return Iterator(0);
 }




 Iterator getLast() const
 {
  return Iterator(last);
 }






 void insert_after(Iterator& it, const T& element)
 {
  SKListNode* node = new SKListNode;
  node->element = element;

  node->next = it.current->next;

  if (it.current->next)
   it.current->next->prev = node;

  node->prev = it.current;
  it.current->next = node;
  ++size;

  if (it.current == last)
   last = node;
 }






 void insert_before(Iterator& it, const T& element)
 {
  SKListNode* node = new SKListNode;
  node->element = element;

  node->prev = it.current->prev;

  if (it.current->prev)
   it.current->prev->next = node;

  node->next = it.current;
  it.current->prev = node;
  ++size;

  if (it.current == root)
   root = node;
 }





 Iterator erase(Iterator& it)
 {
  Iterator returnIterator(it);
  ++returnIterator;

  if (it.current == root)
   root = it.current->next;

  if (it.current == last)
   last = it.current->prev;

  if (it.current->next)
   it.current->next->prev = it.current->prev;

  if (it.current->prev)
   it.current->prev->next = it.current->next;

  delete it.current;
  it.current = 0;
  --size;

  return returnIterator;
 }

private:

 SKListNode* root;
 SKListNode* last;
 u32 size;

};


}
}
# 10 "H:/CPP/irrlicht-1.3/include/IGUIElement.h" 2



# 1 "H:/CPP/irrlicht-1.3/include/EGUIElementTypes.h" 1







namespace irr
{
namespace gui
{



enum EGUI_ELEMENT_TYPE
{

 EGUIET_BUTTON = 0,


 EGUIET_CHECK_BOX,


 EGUIET_COMBO_BOX,


 EGUIET_CONTEXT_MENU,


 EGUIET_MENU,


 EGUIET_EDIT_BOX,


 EGUIET_FILE_OPEN_DIALOG,


 EGUIET_COLOR_SELECT_DIALOG,


 EGUIET_IN_OUT_FADER,


 EGUIET_IMAGE,


 EGUIET_LIST_BOX,


 EGUIET_MESH_VIEWER,


 EGUIET_MESSAGE_BOX,


 EGUIET_MODAL_SCREEN,


 EGUIET_SCROLL_BAR,


 EGUIET_STATIC_TEXT,


 EGUIET_TAB,


 EGUIET_TAB_CONTROL,


 EGUIET_TOOL_BAR,


 EGUIET_WINDOW,


 EGUIET_COUNT,


 EGUIET_ELEMENT,



 EGUIET_FORCE_32_BIT = 0x7fffffff

};


const c8* const GUIElementTypeNames[] =
{
 "button",
 "checkBox",
 "comboBox",
 "contextMenu",
 "menu",
 "editBox",
 "fileOpenDialog",
 "colorSelectDialog",
 "inOutFader",
 "image",
 "listBox",
 "meshViewer",
 "messageBox",
 "modalScreen",
 "scrollBar",
 "staticText",
 "tab",
 "tabControl",
 "toolBar",
 "window",
 0
};

}
}
# 14 "H:/CPP/irrlicht-1.3/include/IGUIElement.h" 2



namespace irr
{
namespace gui
{
class IGUIEnvironment;

enum EGUI_ALIGNMENT
{

 EGUIA_UPPERLEFT=0,

 EGUIA_LOWERRIGHT,

 EGUIA_CENTER,

 EGUIA_SCALE
};


const c8* const GUIAlignmentNames[] =
{
 "upperLeft",
 "lowerRight",
 "center",
 "scale",
 0
};


class IGUIElement : public virtual io::IAttributeExchangingObject, public IEventReceiver
{
public:


 IGUIElement(EGUI_ELEMENT_TYPE type, IGUIEnvironment* environment, IGUIElement* parent,
  s32 id, core::rect<s32> rectangle)
  : Parent(0), RelativeRect(rectangle), AbsoluteRect(rectangle),
  AbsoluteClippingRect(rectangle), DesiredRect(rectangle),
  MaxSize(0,0), MinSize(1,1), IsVisible(true), IsEnabled(true),
  IsSubElement(false), NoClip(false), ID(id),
  AlignLeft(EGUIA_UPPERLEFT), AlignRight(EGUIA_UPPERLEFT), AlignTop(EGUIA_UPPERLEFT), AlignBottom(EGUIA_UPPERLEFT),
  Environment(environment), Type(type)
 {

  if (parent)
   parent->addChild(this);


  if (Parent)
  {
   LastParentRect = Parent->getAbsolutePosition();
   AbsoluteRect += LastParentRect.UpperLeftCorner;
   AbsoluteClippingRect = AbsoluteRect;
   AbsoluteClippingRect.clipAgainst(Parent->AbsoluteClippingRect);
  }
 }



 virtual ~IGUIElement()
 {

  core::list<IGUIElement*>::Iterator it = Children.begin();
  for (; it != Children.end(); ++it)
  {
   (*it)->Parent = 0;
   (*it)->drop();
  }
 };



 IGUIElement* getParent() const
 {
  return Parent;
 }



 core::rect<s32> getRelativePosition() const
 {
  return RelativeRect;
 }



 void setRelativePosition(const core::rect<s32>& r)
 {
  if (Parent)
  {
   core::rect<s32> r2(Parent->getAbsolutePosition());

   core::dimension2df d((f32)r2.getSize().Width, (f32)r2.getSize().Height);

   if (AlignLeft == EGUIA_SCALE)
    ScaleRect.UpperLeftCorner.X = (f32)r.UpperLeftCorner.X / d.Width;
   if (AlignRight == EGUIA_SCALE)
    ScaleRect.LowerRightCorner.X = (f32)r.LowerRightCorner.X / d.Width;
   if (AlignTop == EGUIA_SCALE)
    ScaleRect.UpperLeftCorner.Y = (f32)r.UpperLeftCorner.Y / d.Height;
   if (AlignBottom == EGUIA_SCALE)
    ScaleRect.LowerRightCorner.Y = (f32)r.LowerRightCorner.Y / d.Height;
  }

  DesiredRect = r;
  updateAbsolutePosition();
 }


 void setRelativePosition(const core::rect<f32>& r)
 {
  if (!Parent)
   return;

  core::rect<s32> r2(Parent->getAbsolutePosition());

  core::dimension2di d(r2.getSize());

  DesiredRect = core::rect<s32>(
      (s32)((f32)d.Width * r.UpperLeftCorner.X),
      (s32)((f32)d.Height * r.UpperLeftCorner.Y),
      (s32)((f32)d.Width * r.LowerRightCorner.X),
      (s32)((f32)d.Height * r.LowerRightCorner.Y));

  ScaleRect = r;

  updateAbsolutePosition();
 }



 core::rect<s32> getAbsolutePosition() const
 {
  return AbsoluteRect;
 }


 void setNotClipped(bool noClip)
 {
  NoClip = noClip;
 }


 bool isNotClipped()
 {
  return NoClip;
 }



 void setMaxSize(core::dimension2di size)
 {
  MaxSize = size;
  updateAbsolutePosition();
 }


 void setMinSize(core::dimension2di size)
 {
  MinSize = size;
  if (MinSize.Width < 1)
   MinSize.Width = 1;
  if (MinSize.Height < 1)
   MinSize.Height = 1;
  updateAbsolutePosition();
 }

 void setAlignment(EGUI_ALIGNMENT left, EGUI_ALIGNMENT right, EGUI_ALIGNMENT top, EGUI_ALIGNMENT bottom)
 {
  AlignLeft = left;
  AlignRight = right;
  AlignTop = top;
  AlignBottom = bottom;

  if (Parent)
  {
   core::rect<s32> r(Parent->getAbsolutePosition());

   core::dimension2df d((f32)r.getSize().Width, (f32)r.getSize().Height);

   if (AlignLeft == EGUIA_SCALE)
    ScaleRect.UpperLeftCorner.X = (f32)DesiredRect.UpperLeftCorner.X / d.Width;
   if (AlignRight == EGUIA_SCALE)
    ScaleRect.LowerRightCorner.X = (f32)DesiredRect.LowerRightCorner.X / d.Width;
   if (AlignTop == EGUIA_SCALE)
    ScaleRect.UpperLeftCorner.Y = (f32)DesiredRect.UpperLeftCorner.Y / d.Height;
   if (AlignBottom == EGUIA_SCALE)
    ScaleRect.LowerRightCorner.Y = (f32)DesiredRect.LowerRightCorner.Y / d.Height;
  }
 }


 virtual void updateAbsolutePosition()
 {
  core::rect<s32> parentAbsolute(0,0,0,0);
  core::rect<s32> parentAbsoluteClip;
  s32 diffx, diffy;
  f32 fw=0.f, fh=0.f;

  if (Parent)
  {
   parentAbsolute = Parent->AbsoluteRect;

   if (NoClip)
   {
    IGUIElement* p=this;
    while (p && p->NoClip && p->Parent)
      p = p->Parent;
    if (p->Parent)
     parentAbsoluteClip = p->Parent->AbsoluteClippingRect;
    else
     parentAbsoluteClip = p->AbsoluteClippingRect;
   }
   else
    parentAbsoluteClip = Parent->AbsoluteClippingRect;
  }


  diffx = parentAbsolute.getWidth() - LastParentRect.getWidth();
  diffy = parentAbsolute.getHeight() - LastParentRect.getHeight();

  if (AlignLeft == EGUIA_SCALE || AlignRight == EGUIA_SCALE)
   fw = (f32)parentAbsolute.getWidth();

  if (AlignTop == EGUIA_SCALE || AlignBottom == EGUIA_SCALE)
   fh = (f32)parentAbsolute.getHeight();


  switch (AlignLeft)
  {
   case EGUIA_UPPERLEFT:
    break;
   case EGUIA_LOWERRIGHT:
    DesiredRect.UpperLeftCorner.X += diffx;
    break;
   case EGUIA_CENTER:
    DesiredRect.UpperLeftCorner.X += diffx/2;
    break;
   case EGUIA_SCALE:
    DesiredRect.UpperLeftCorner.X = (s32)(ScaleRect.UpperLeftCorner.X * fw);
    break;
  }

  switch (AlignRight)
  {
   case EGUIA_UPPERLEFT:
    break;
   case EGUIA_LOWERRIGHT:
    DesiredRect.LowerRightCorner.X += diffx;
    break;
   case EGUIA_CENTER:
    DesiredRect.LowerRightCorner.X += diffx/2;
    break;
   case EGUIA_SCALE:
    DesiredRect.LowerRightCorner.X = (s32)(ScaleRect.LowerRightCorner.X * fw);
    break;
  }

  switch (AlignTop)
  {
   case EGUIA_UPPERLEFT:
    break;
   case EGUIA_LOWERRIGHT:
    DesiredRect.UpperLeftCorner.Y += diffy;
    break;
   case EGUIA_CENTER:
    DesiredRect.UpperLeftCorner.Y += diffy/2;
    break;
   case EGUIA_SCALE:
    DesiredRect.UpperLeftCorner.Y = (s32)(ScaleRect.UpperLeftCorner.Y * fh);
    break;
  }

  switch (AlignBottom)
  {
   case EGUIA_UPPERLEFT:
    break;
   case EGUIA_LOWERRIGHT:
    DesiredRect.LowerRightCorner.Y += diffy;
    break;
   case EGUIA_CENTER:
    DesiredRect.LowerRightCorner.Y += diffy/2;
    break;
   case EGUIA_SCALE:
    DesiredRect.LowerRightCorner.Y = (s32)(ScaleRect.LowerRightCorner.Y * fh);
    break;
  }

  RelativeRect = DesiredRect;

  s32 w = RelativeRect.getWidth();
  s32 h = RelativeRect.getHeight();


  if (w < MinSize.Width)
   RelativeRect.LowerRightCorner.X = RelativeRect.UpperLeftCorner.X + MinSize.Width;
  if (h < MinSize.Height)
   RelativeRect.LowerRightCorner.Y = RelativeRect.UpperLeftCorner.Y + MinSize.Height;
  if (MaxSize.Width && w > MaxSize.Width)
   RelativeRect.LowerRightCorner.X = RelativeRect.UpperLeftCorner.X + MaxSize.Width;
  if (MaxSize.Height && h > MaxSize.Height)
   RelativeRect.LowerRightCorner.Y = RelativeRect.UpperLeftCorner.Y + MaxSize.Height;

  RelativeRect.repair();

  AbsoluteRect = RelativeRect + parentAbsolute.UpperLeftCorner;

  if (!Parent)
   parentAbsoluteClip = AbsoluteRect;

  AbsoluteClippingRect = AbsoluteRect;
  AbsoluteClippingRect.clipAgainst(parentAbsoluteClip);

  LastParentRect = parentAbsolute;


  core::list<IGUIElement*>::Iterator it = Children.begin();
  for (; it != Children.end(); ++it)
  {
   (*it)->updateAbsolutePosition();
  }
 }



 IGUIElement* getElementFromPoint(const core::position2d<s32>& point)
 {
  IGUIElement* target = 0;



  core::list<IGUIElement*>::Iterator it = Children.getLast();

  if (IsVisible)
   while(it != Children.end())
   {
    target = (*it)->getElementFromPoint(point);
    if (target)
     return target;

    --it;
   }

  if (AbsoluteClippingRect.isPointInside(point) && IsVisible)
   target = this;

  return target;
 }



 virtual void addChild(IGUIElement* child)
 {
  if (child)
  {
   child->grab();
   child->remove();
   child->Parent = this;
   Children.push_back(child);
  }
 }



 virtual void removeChild(IGUIElement* child)
 {
  core::list<IGUIElement*>::Iterator it = Children.begin();
  for (; it != Children.end(); ++it)
   if ((*it) == child)
   {
    (*it)->Parent = 0;
    (*it)->drop();
    Children.erase(it);
    return;
   }
 }



 virtual void remove()
 {
  if (Parent)
   Parent->removeChild(this);
 }



 virtual void draw()
 {
  if (!IsVisible)
   return;

  core::list<IGUIElement*>::Iterator it = Children.begin();
  for (; it != Children.end(); ++it)
   (*it)->draw();
 }


 virtual void OnPostRender(u32 timeMs)
 {
  if (!IsVisible)
   return;

  core::list<IGUIElement*>::Iterator it = Children.begin();
  for (; it != Children.end(); ++it)
   (*it)->OnPostRender( timeMs );
 }



 virtual void move(core::position2d<s32> absoluteMovement)
 {
  setRelativePosition(DesiredRect + absoluteMovement);
 }



 virtual bool isVisible()
 {
  ;
  return IsVisible;
 }



 virtual void setVisible(bool visible)
 {
  IsVisible = visible;
 }



 virtual bool isSubElement()
 {
  ;
  return IsSubElement;
 }




 virtual void setSubElement(bool subElement)
 {
  IsSubElement = subElement;
 }


 virtual bool isEnabled()
 {
  ;
  return IsEnabled;
 }



 virtual void setEnabled(bool enabled)
 {
  IsEnabled = enabled;
 }



 virtual void setText(const wchar_t* text)
 {
  Text = text;
 }



 virtual const wchar_t* getText()
 {
  return Text.c_str();
 }


 virtual void setToolTipText(const wchar_t* text)
 {
  ToolTipText = text;
 }



 virtual core::stringw &getToolTipText()
 {
  return ToolTipText;
 }



 virtual s32 getID()
 {
  return ID;
 }


 virtual void setID(s32 id)
 {
  ID = id;
 }



 virtual bool OnEvent(SEvent event)
 {
  if (Parent)
   Parent->OnEvent(event);

  return true;
 }




 virtual bool bringToFront(IGUIElement* element)
 {
  core::list<IGUIElement*>::Iterator it = Children.begin();
  for (; it != Children.end(); ++it)
  {
   if (element == (*it))
   {
    Children.erase(it);
    Children.push_back(element);
    return true;
   }
  }

  ;
  return false;
 }


 virtual const core::list<IGUIElement*>& getChildren() const
 {
  return Children;
 }
# 560 "H:/CPP/irrlicht-1.3/include/IGUIElement.h"
 virtual IGUIElement* getElementFromId(s32 id, bool searchchildren=false) const
 {
  IGUIElement* e = 0;

  core::list<IGUIElement*>::Iterator it = Children.begin();
  for (; it != Children.end(); ++it)
  {
   if ((*it)->getID() == id)
    return (*it);

   if (searchchildren)
    e = (*it)->getElementFromId(id, true);

   if (e)
    return e;
  }

  return e;
 }






 EGUI_ELEMENT_TYPE getType()
 {
  return Type;
 }




 virtual const c8* getTypeName()
 {
  return GUIElementTypeNames[Type];
 }




 virtual void serializeAttributes(io::IAttributes* out, io::SAttributeReadWriteOptions* options=0)
 {
  out->addInt("Id", ID );
  out->addString("Caption", Text.c_str());
  out->addRect("Rect", DesiredRect);
  out->addPosition2d("MinSize", core::position2di(MinSize.Width, MinSize.Height));
  out->addPosition2d("MaxSize", core::position2di(MaxSize.Width, MaxSize.Height));
  out->addBool("NoClip", NoClip);
  out->addEnum("LeftAlign", AlignLeft, GUIAlignmentNames);
  out->addEnum("RightAlign", AlignRight, GUIAlignmentNames);
  out->addEnum("TopAlign", AlignTop, GUIAlignmentNames);
  out->addEnum("BottomAlign", AlignBottom, GUIAlignmentNames);
  out->addBool("Visible", IsVisible );
  out->addBool("Enabled", IsEnabled );
 }




 virtual void deserializeAttributes(io::IAttributes* in, io::SAttributeReadWriteOptions* options=0)
 {

  ID = in->getAttributeAsInt("Id");
  Text = in->getAttributeAsStringW("Caption").c_str();
  IsVisible = in->getAttributeAsBool("Visible");
  IsEnabled = in->getAttributeAsBool("Enabled");
  core::position2di p = in->getAttributeAsPosition2d("MaxSize");
  MaxSize = core::dimension2di(p.X,p.Y);
  p = in->getAttributeAsPosition2d("MinSize");
  MinSize = core::dimension2di(p.X,p.Y);
  NoClip = in->getAttributeAsBool("NoClip");
  AlignLeft = (EGUI_ALIGNMENT) in->getAttributeAsEnumeration("LeftAlign", GUIAlignmentNames);
  AlignRight = (EGUI_ALIGNMENT)in->getAttributeAsEnumeration("RightAlign", GUIAlignmentNames);
  AlignTop = (EGUI_ALIGNMENT)in->getAttributeAsEnumeration("TopAlign", GUIAlignmentNames);
  AlignBottom = (EGUI_ALIGNMENT)in->getAttributeAsEnumeration("BottomAlign", GUIAlignmentNames);

  setRelativePosition(in->getAttributeAsRect("Rect"));
 }

protected:


 core::list<IGUIElement*> Children;


 IGUIElement* Parent;


 core::rect<s32> RelativeRect;


 core::rect<s32> AbsoluteRect;


 core::rect<s32> AbsoluteClippingRect;



 core::rect<s32> DesiredRect;


 core::rect<s32> LastParentRect;


 core::rect<f32> ScaleRect;


 core::dimension2di MaxSize, MinSize;


 bool IsVisible;


 bool IsEnabled;


 bool IsSubElement;


 bool NoClip;


 core::stringw Text;


 core::stringw ToolTipText;


 s32 ID;


 EGUI_ALIGNMENT AlignLeft, AlignRight, AlignTop, AlignBottom;


 IGUIEnvironment* Environment;


 EGUI_ELEMENT_TYPE Type;
};


}
}
# 9 "H:/CPP/irrlicht-1.3/include/IGUIButton.h" 2

namespace irr
{

namespace video
{
 class ITexture;
}

namespace gui
{
 class IGUIFont;
 class IGUISpriteBank;

 enum EGUI_BUTTON_STATE
 {

  EGBS_BUTTON_UP=0,

  EGBS_BUTTON_DOWN,

  EGBS_BUTTON_MOUSE_OVER,

  EGBS_BUTTON_MOUSE_OFF,

  EGBS_BUTTON_FOCUSED,

  EGBS_BUTTON_NOT_FOCUSED,

  EGBS_COUNT
 };


 const c8* const GUIButtonStateNames[] =
 {
  "buttonUp",
  "buttonDown",
  "buttonMouseOver",
  "buttonMouseOff",
  "buttonFocused",
  "buttonNotFocused",
  0,
  0,
 };


 class IGUIButton : public IGUIElement
 {
 public:


  IGUIButton(IGUIEnvironment* environment, IGUIElement* parent, s32 id, core::rect<s32> rectangle)
   : IGUIElement(EGUIET_BUTTON, environment, parent, id, rectangle) {}


  ~IGUIButton() {};




  virtual void setOverrideFont(IGUIFont* font=0) = 0;



  virtual void setImage(video::ITexture* image) = 0;




  virtual void setImage(video::ITexture* image, const core::rect<s32>& pos) = 0;





  virtual void setPressedImage(video::ITexture* image) = 0;




  virtual void setPressedImage(video::ITexture* image, const core::rect<s32>& pos) = 0;


  virtual void setSpriteBank(IGUISpriteBank* bank) = 0;
# 101 "H:/CPP/irrlicht-1.3/include/IGUIButton.h"
  virtual void setSprite(EGUI_BUTTON_STATE state, s32 index,
    video::SColor color=video::SColor(255,255,255,255), bool loop=false) = 0;




  virtual void setIsPushButton(bool isPushButton) = 0;


  virtual void setPressed(bool pressed) = 0;


  virtual bool isPressed() = 0;


  virtual void setUseAlphaChannel(bool useAlphaChannel) = 0;


  virtual bool getUseAlphaChannel() = 0;


  virtual void setDrawBorder(bool border) = 0;
 };


}
}
# 9 "H:/CPP/irrlicht-1.3/include/IGUIWindow.h" 2

namespace irr
{
namespace gui
{

 enum EMESSAGE_BOX_FLAG
 {

  EMBF_OK = 0x1,


  EMBF_CANCEL = 0x2,


  EMBF_YES = 0x4,


  EMBF_NO = 0x8,


  EMBF_FORCE_32BIT = 0x7fffffff
 };


 class IGUIWindow : public IGUIElement
 {
 public:


  IGUIWindow(IGUIEnvironment* environment, IGUIElement* parent, s32 id, core::rect<s32> rectangle)
   : IGUIElement(EGUIET_WINDOW, environment, parent, id, rectangle) {}


  virtual ~IGUIWindow() {};


  virtual IGUIButton* getCloseButton() = 0;


  virtual IGUIButton* getMinimizeButton() = 0;


  virtual IGUIButton* getMaximizeButton() = 0;
 };


}
}
# 13 "H:/CPP/irrlicht-1.3/include/IGUIEnvironment.h" 2
# 1 "H:/CPP/irrlicht-1.3/include/IGUISkin.h" 1
# 10 "H:/CPP/irrlicht-1.3/include/IGUISkin.h"
# 1 "H:/CPP/irrlicht-1.3/include/IGUISkin.h" 1
# 11 "H:/CPP/irrlicht-1.3/include/IGUISkin.h" 2


namespace irr
{
namespace gui
{
 class IGUIFont;
 class IGUISpriteBank;
 class IGUIElement;
# 30 "H:/CPP/irrlicht-1.3/include/IGUISkin.h"
 enum EGUI_SKIN_TYPE
 {

  EGST_WINDOWS_CLASSIC=0,

  EGST_WINDOWS_METALLIC,

  EGST_BURNING_SKIN,


  EGST_UNKNOWN
 };


 const c8* const GUISkinTypeNames[] =
 {
  "windowsClassic",
  "windowsMetallic",
  "burning",
  "unknown",
  0,
 };



 enum EGUI_DEFAULT_COLOR
 {

  EGDC_3D_DARK_SHADOW = 0,

  EGDC_3D_SHADOW,

  EGDC_3D_FACE,

  EGDC_3D_HIGH_LIGHT,

  EGDC_3D_LIGHT,

  EGDC_ACTIVE_BORDER,

  EGDC_ACTIVE_CAPTION,

  EGDC_APP_WORKSPACE,

  EGDC_BUTTON_TEXT,

  EGDC_GRAY_TEXT,

  EGDC_HIGH_LIGHT,

  EGDC_HIGH_LIGHT_TEXT,

  EGDC_INACTIVE_BORDER,

  EGDC_INACTIVE_CAPTION,

  EGDC_TOOLTIP,

  EGDC_SCROLLBAR,

  EGDC_WINDOW,

  EGDC_WINDOW_SYMBOL,

  EGDC_ICON,

  EGDC_ICON_HIGH_LIGHT,


  EGDC_COUNT
 };


 const c8* const GUISkinColorNames[] =
 {
  "3DDarkShadow",
  "3DShadow",
  "3DFace",
  "3DHighlight",
  "3DLight",
  "ActiveBorder",
  "ActiveCaption",
  "AppWorkspace",
  "ButtonText",
  "GrayText",
  "Highlight",
  "HighlightText",
  "InactiveBorder",
  "InactiveCaption",
  "ToolTip",
  "ScrollBar",
  "Window",
  "WindowSymbol",
  "Icon",
  "IconHighlight",
  0,
 };


 enum EGUI_DEFAULT_SIZE
 {

  EGDS_SCROLLBAR_SIZE = 0,

  EGDS_MENU_HEIGHT,

  EGDS_WINDOW_BUTTON_WIDTH,

  EGDS_CHECK_BOX_WIDTH,

  EGDS_MESSAGE_BOX_WIDTH,

  EGDS_MESSAGE_BOX_HEIGHT,

  EGDS_BUTTON_WIDTH,

  EGDS_BUTTON_HEIGHT,

  EGDS_TEXT_DISTANCE_X,

  EGDS_TEXT_DISTANCE_Y,


  EGDS_COUNT
 };



 const c8* const GUISkinSizeNames[] =
 {
  "ScrollBarSize",
  "MenuHeight",
  "WindowButtonWidth",
  "CheckBoxWidth",
  "MessageBoxWidth",
  "MessageBoxHeight",
  "ButtonWidth",
  "ButtonHeight",
  "TextDistanceX",
  "TextDistanceY",
  0,
 };


 enum EGUI_DEFAULT_TEXT
 {

  EGDT_MSG_BOX_OK = 0,

  EGDT_MSG_BOX_CANCEL,

  EGDT_MSG_BOX_YES,

  EGDT_MSG_BOX_NO,

  EGDT_WINDOW_CLOSE,

  EGDT_WINDOW_MAXIMIZE,

  EGDT_WINDOW_MINIMIZE,

  EGDT_WINDOW_RESTORE,


  EGDT_COUNT
 };


 const c8* const GUISkinTextNames[] =
 {
  "MessageBoxOkay",
  "MessageBoxCancel",
  "MessageBoxYes",
  "MessageBoxNo",
  "WindowButtonClose",
  "WindowButtonMaximize",
  "WindowButtonMinimize",
  "WindowButtonRestore",
  0,
 };


 enum EGUI_DEFAULT_ICON
 {

  EGDI_WINDOW_MAXIMIZE = 0,

  EGDI_WINDOW_RESTORE,

  EGDI_WINDOW_CLOSE,

  EGDI_WINDOW_MINIMIZE,

  EGDI_CURSOR_UP,

  EGDI_CURSOR_DOWN,

  EGDI_CURSOR_LEFT,

  EGDI_CURSOR_RIGHT,

  EGDI_MENU_MORE,

  EGDI_CHECK_BOX_CHECKED,

  EGDI_DROP_DOWN,

  EGDI_SMALL_CURSOR_UP,

  EGDI_SMALL_CURSOR_DOWN,

  EGDI_RADIO_BUTTON_CHECKED,

  EGDI_FILE,

  EGDI_DIRECTORY,


  EGDI_COUNT
 };

 const c8* const GUISkinIconNames[] =
 {
  "windowMaximize",
  "windowRestore",
  "windowClose",
  "windowMinimize",
  "cursorUp",
  "cursorDown",
  "cursorLeft",
  "cursorRight",
  "menuMore",
  "checkBoxChecked",
  "dropDown",
  "smallCursorUp",
  "smallCursorDown",
  "radioButtonChecked",
  "file",
  "directory",
  0
 };


 class IGUISkin : public virtual io::IAttributeExchangingObject
 {
 public:


  ~IGUISkin() {};


  virtual video::SColor getColor(EGUI_DEFAULT_COLOR color) = 0;


  virtual void setColor(EGUI_DEFAULT_COLOR which, video::SColor newColor) = 0;


  virtual s32 getSize(EGUI_DEFAULT_SIZE size) = 0;




  virtual const wchar_t* getDefaultText(EGUI_DEFAULT_TEXT text) = 0;




  virtual void setDefaultText(EGUI_DEFAULT_TEXT which, const wchar_t* newText) = 0;


  virtual void setSize(EGUI_DEFAULT_SIZE which, s32 size) = 0;


  virtual IGUIFont* getFont() = 0;


  virtual void setFont(IGUIFont* font) = 0;


  virtual IGUISpriteBank* getSpriteBank() = 0;


  virtual void setSpriteBank(IGUISpriteBank* bank) = 0;



  virtual u32 getIcon(EGUI_DEFAULT_ICON icon) = 0;






  virtual void setIcon(EGUI_DEFAULT_ICON icon, u32 index) = 0;
# 334 "H:/CPP/irrlicht-1.3/include/IGUISkin.h"
  virtual void draw3DButtonPaneStandard(IGUIElement* element,
   const core::rect<s32>& rect,
   const core::rect<s32>* clip=0) = 0;
# 347 "H:/CPP/irrlicht-1.3/include/IGUISkin.h"
  virtual void draw3DButtonPanePressed(IGUIElement* element,
   const core::rect<s32>& rect,
   const core::rect<s32>* clip=0) = 0;
# 363 "H:/CPP/irrlicht-1.3/include/IGUISkin.h"
  virtual void draw3DSunkenPane(IGUIElement* element,
   video::SColor bgcolor, bool flat, bool fillBackGround,
   const core::rect<s32>& rect,
   const core::rect<s32>* clip=0) = 0;
# 378 "H:/CPP/irrlicht-1.3/include/IGUISkin.h"
  virtual core::rect<s32> draw3DWindowBackground(IGUIElement* element,
   bool drawTitleBar, video::SColor titleBarColor,
   const core::rect<s32>& rect,
   const core::rect<s32>* clip=0) = 0;
# 392 "H:/CPP/irrlicht-1.3/include/IGUISkin.h"
  virtual void draw3DMenuPane(IGUIElement* element,
   const core::rect<s32>& rect,
   const core::rect<s32>* clip=0) = 0;
# 403 "H:/CPP/irrlicht-1.3/include/IGUISkin.h"
  virtual void draw3DToolBar(IGUIElement* element,
   const core::rect<s32>& rect,
   const core::rect<s32>* clip=0) = 0;
# 415 "H:/CPP/irrlicht-1.3/include/IGUISkin.h"
  virtual void draw3DTabButton(IGUIElement* element, bool active,
   const core::rect<s32>& rect, const core::rect<s32>* clip=0) = 0;
# 426 "H:/CPP/irrlicht-1.3/include/IGUISkin.h"
  virtual void draw3DTabBody(IGUIElement* element, bool border, bool background,
   const core::rect<s32>& rect, const core::rect<s32>* clip=0) = 0;
# 439 "H:/CPP/irrlicht-1.3/include/IGUISkin.h"
  virtual void drawIcon(IGUIElement* element, EGUI_DEFAULT_ICON icon,
   const core::position2di position, u32 starttime=0, u32 currenttime=0,
   bool loop=false, const core::rect<s32>* clip=0) = 0;


  virtual EGUI_SKIN_TYPE getType() { return EGST_UNKNOWN; };

 };


}
}
# 14 "H:/CPP/irrlicht-1.3/include/IGUIEnvironment.h" 2


namespace irr
{
 namespace io
 {
  class IXMLWriter;
  class IReadFile;
  class IWriteFile;
 }
 namespace video
 {
  class IVideoDriver;
  class ITexture;
 }

namespace gui
{

class IGUIElement;
class IGUIFont;
class IGUISpriteBank;
class IGUIScrollBar;
class IGUIImage;
class IGUIMeshViewer;
class IGUICheckBox;
class IGUIListBox;
class IGUIFileOpenDialog;
class IGUIColorSelectDialog;
class IGUIInOutFader;
class IGUIStaticText;
class IGUIEditBox;
class IGUITabControl;
class IGUITab;
class IGUIContextMenu;
class IGUIComboBox;
class IGUIToolBar;
class IGUIElementFactory;


class IGUIEnvironment : public virtual IUnknown
{
public:


 virtual ~IGUIEnvironment() {};


 virtual void drawAll() = 0;


 virtual void setFocus(IGUIElement* element) = 0;


 virtual IGUIElement* getFocus() = 0;


 virtual void removeFocus(IGUIElement* element) = 0;


 virtual bool hasFocus(IGUIElement* element) = 0;


 virtual video::IVideoDriver* getVideoDriver() = 0;


 virtual io::IFileSystem* getFileSystem() = 0;


 virtual void clear() = 0;




 virtual bool postEventFromUser(SEvent event) = 0;




 virtual void setUserEventReceiver(IEventReceiver* evr) = 0;


 virtual IGUISkin* getSkin() = 0;
# 109 "H:/CPP/irrlicht-1.3/include/IGUIEnvironment.h"
 virtual void setSkin(IGUISkin* skin) = 0;






 virtual IGUISkin* createSkin(EGUI_SKIN_TYPE type) = 0;






 virtual IGUIFont* getFont(const c8* filename) = 0;


 virtual IGUIFont* getBuiltInFont() = 0;






 virtual IGUISpriteBank* getSpriteBank(const c8* filename) = 0;


 virtual IGUISpriteBank* addEmptySpriteBank(const c8 *name) = 0;






 virtual IGUIElement* getRootGUIElement() = 0;





 virtual IGUIButton* addButton(const core::rect<s32>& rectangle,
  IGUIElement* parent=0, s32 id=-1, const wchar_t* text=0, const wchar_t* tooltiptext = 0) = 0;
# 159 "H:/CPP/irrlicht-1.3/include/IGUIEnvironment.h"
 virtual IGUIWindow* addWindow(const core::rect<s32>& rectangle, bool modal = false,
  const wchar_t* text=0, IGUIElement* parent=0, s32 id=-1) = 0;






 virtual IGUIElement* addModalScreen(IGUIElement* parent) = 0;
# 183 "H:/CPP/irrlicht-1.3/include/IGUIEnvironment.h"
 virtual IGUIWindow* addMessageBox(const wchar_t* caption, const wchar_t* text=0,
  bool modal = true, s32 flags = EMBF_OK, IGUIElement* parent=0, s32 id=-1) = 0;





 virtual IGUIScrollBar* addScrollBar(bool horizontal, const core::rect<s32>& rectangle,
  IGUIElement* parent=0, s32 id=-1) = 0;
# 202 "H:/CPP/irrlicht-1.3/include/IGUIEnvironment.h"
 virtual IGUIImage* addImage(video::ITexture* image, core::position2d<s32> pos,
  bool useAlphaChannel=true, IGUIElement* parent=0, s32 id=-1, const wchar_t* text=0) = 0;






 virtual IGUIImage* addImage(const core::rect<s32>& rectangle,
  IGUIElement* parent=0, s32 id=-1, const wchar_t* text=0) = 0;





 virtual IGUICheckBox* addCheckBox(bool checked, const core::rect<s32>& rectangle,
  IGUIElement* parent=0, s32 id=-1, const wchar_t* text=0) = 0;





 virtual IGUIListBox* addListBox(const core::rect<s32>& rectangle,
  IGUIElement* parent=0, s32 id=-1, bool drawBackground=false) = 0;





 virtual IGUIMeshViewer* addMeshViewer(const core::rect<s32>& rectangle, IGUIElement* parent=0, s32 id=-1, const wchar_t* text=0) = 0;
# 240 "H:/CPP/irrlicht-1.3/include/IGUIEnvironment.h"
 virtual IGUIFileOpenDialog* addFileOpenDialog(const wchar_t* title = 0,
  bool modal=true, IGUIElement* parent=0, s32 id=-1) = 0;
# 250 "H:/CPP/irrlicht-1.3/include/IGUIEnvironment.h"
 virtual IGUIColorSelectDialog* addColorSelectDialog(const wchar_t* title = 0,
  bool modal=true, IGUIElement* parent=0, s32 id=-1) = 0;
# 265 "H:/CPP/irrlicht-1.3/include/IGUIEnvironment.h"
 virtual IGUIStaticText* addStaticText(const wchar_t* text, const core::rect<s32>& rectangle,
  bool border=false, bool wordWrap=true, IGUIElement* parent=0, s32 id=-1,
  bool fillBackground = false) = 0;
# 282 "H:/CPP/irrlicht-1.3/include/IGUIEnvironment.h"
 virtual IGUIEditBox* addEditBox(const wchar_t* text, const core::rect<s32>& rectangle,
  bool border=true, IGUIElement* parent=0, s32 id=-1) = 0;
# 293 "H:/CPP/irrlicht-1.3/include/IGUIEnvironment.h"
 virtual IGUIInOutFader* addInOutFader(const core::rect<s32>* rectangle=0, IGUIElement* parent=0, s32 id=-1) = 0;
# 305 "H:/CPP/irrlicht-1.3/include/IGUIEnvironment.h"
 virtual IGUITabControl* addTabControl(const core::rect<s32>& rectangle,
  IGUIElement* parent=0, bool fillbackground=false,
  bool border=true, s32 id=-1) = 0;







 virtual IGUITab* addTab(const core::rect<s32>& rectangle,
  IGUIElement* parent=0, s32 id=-1) = 0;






 virtual IGUIContextMenu* addContextMenu(const core::rect<s32>& rectangle,
  IGUIElement* parent=0, s32 id=-1) = 0;





 virtual IGUIContextMenu* addMenu(IGUIElement* parent=0, s32 id=-1) = 0;






 virtual IGUIToolBar* addToolBar(IGUIElement* parent=0, s32 id=-1) = 0;




 virtual IGUIComboBox* addComboBox(const core::rect<s32>& rectangle,
  IGUIElement* parent=0, s32 id=-1) = 0;


 virtual IGUIElementFactory* getDefaultGUIElementFactory() = 0;




 virtual void registerGUIElementFactory(IGUIElementFactory* factoryToAdd) = 0;


 virtual s32 getRegisteredGUIElementFactoryCount() = 0;


 virtual IGUIElementFactory* getGUIElementFactory(s32 index) = 0;


 virtual IGUIElement* addGUIElement(const c8* elementName, IGUIElement* parent=0) = 0;



 virtual bool saveGUI(const c8* filename)=0;


 virtual bool saveGUI(io::IWriteFile* file)=0;



 virtual bool loadGUI(const c8* filename)=0;


 virtual bool loadGUI(io::IReadFile* file)=0;


 virtual void serializeAttributes(io::IAttributes* out, io::SAttributeReadWriteOptions* options=0)=0;


 virtual void deserializeAttributes(io::IAttributes* in, io::SAttributeReadWriteOptions* options=0)=0;


 virtual void writeGUIElement(io::IXMLWriter* writer, IGUIElement* node) =0;


 virtual void readGUIElement(io::IXMLReader* reader, IGUIElement* parent) =0;

};


}
}
# 19 "H:/CPP/irrlicht-1.3/include/ISceneManager.h" 2

namespace irr
{
 struct SKeyMap;

namespace io
{
 class IFileSystem;
 class IReadFile;
 class IAttributes;
 class IWriteFile;
}

namespace gui
{
 class IGUIFont;
 class IGUIFontBitmap;
}

namespace video
{
 class IVideoDriver;
}

namespace scene
{



 enum E_SCENE_NODE_RENDER_PASS
 {


  ESNRP_CAMERA,


  ESNRP_LIGHT,


  ESNRP_SKY_BOX,
# 70 "H:/CPP/irrlicht-1.3/include/ISceneManager.h"
  ESNRP_AUTOMATIC,


  ESNRP_SOLID,


  ESNRP_SHADOW,



  ESNRP_TRANSPARENT,


  ESNRP_SHADER_0,
  ESNRP_SHADER_1,
  ESNRP_SHADER_2,
  ESNRP_SHADER_3,
  ESNRP_SHADER_4,
  ESNRP_SHADER_5,
  ESNRP_SHADER_6,
  ESNRP_SHADER_7,
  ESNRP_SHADER_8,
  ESNRP_SHADER_9,
  ESNRP_SHADER_10,


  ESNRP_COUNT
 };

 class IMesh;
 class IMeshBuffer;
 class IAnimatedMesh;
 class IMeshCache;
 class ISceneNode;
 class ICameraSceneNode;
 class IAnimatedMeshSceneNode;
 class ISceneNodeAnimator;
 class ISceneNodeAnimatorCollisionResponse;
 class ILightSceneNode;
 class IBillboardSceneNode;
 class ITerrainSceneNode;
 class IMeshSceneNode;
 class IMeshLoader;
 class ISceneCollisionManager;
 class IParticleSystemSceneNode;
 class IDummyTransformationSceneNode;
 class ITriangleSelector;
 class IMetaTriangleSelector;
 class IMeshManipulator;
 class ITextSceneNode;
 class ISceneNodeFactory;
 class ISceneNodeAnimatorFactory;
 class ISceneUserDataSerializer;

 namespace quake3
 {
  class SShader;
 }
# 145 "H:/CPP/irrlicht-1.3/include/ISceneManager.h"
 class ISceneManager : public virtual IUnknown
 {
 public:


  virtual ~ISceneManager() {};
# 300 "H:/CPP/irrlicht-1.3/include/ISceneManager.h"
  virtual IAnimatedMesh* getMesh(const c8* filename) = 0;





  virtual IMeshCache* getMeshCache() = 0;




  virtual video::IVideoDriver* getVideoDriver() = 0;




  virtual gui::IGUIEnvironment* getGUIEnvironment() = 0;
# 329 "H:/CPP/irrlicht-1.3/include/ISceneManager.h"
  virtual ISceneNode* addCubeSceneNode(f32 size=10.0f, ISceneNode* parent=0, s32 id=-1,
   const core::vector3df& position = core::vector3df(0,0,0),
   const core::vector3df& rotation = core::vector3df(0,0,0),
   const core::vector3df& scale = core::vector3df(1.0f, 1.0f, 1.0f)) = 0;
# 346 "H:/CPP/irrlicht-1.3/include/ISceneManager.h"
  virtual ISceneNode* addSphereSceneNode(f32 radius=5.0f, s32 polyCount=16, ISceneNode* parent=0, s32 id=-1,
   const core::vector3df& position = core::vector3df(0,0,0),
   const core::vector3df& rotation = core::vector3df(0,0,0),
   const core::vector3df& scale = core::vector3df(1.0f, 1.0f, 1.0f)) = 0;
# 361 "H:/CPP/irrlicht-1.3/include/ISceneManager.h"
  virtual IAnimatedMeshSceneNode* addAnimatedMeshSceneNode(IAnimatedMesh* mesh, ISceneNode* parent=0, s32 id=-1,
   const core::vector3df& position = core::vector3df(0,0,0),
   const core::vector3df& rotation = core::vector3df(0,0,0),
   const core::vector3df& scale = core::vector3df(1.0f, 1.0f, 1.0f),
   bool alsoAddIfMeshPointerZero=false) = 0;
# 377 "H:/CPP/irrlicht-1.3/include/ISceneManager.h"
  virtual IMeshSceneNode* addMeshSceneNode(IMesh* mesh, ISceneNode* parent=0, s32 id=-1,
   const core::vector3df& position = core::vector3df(0,0,0),
   const core::vector3df& rotation = core::vector3df(0,0,0),
   const core::vector3df& scale = core::vector3df(1.0f, 1.0f, 1.0f),
   bool alsoAddIfMeshPointerZero=false) = 0;
# 398 "H:/CPP/irrlicht-1.3/include/ISceneManager.h"
  virtual ISceneNode* addWaterSurfaceSceneNode(IMesh* mesh,
   f32 waveHeight=2.0f, f32 waveSpeed=300.0f, f32 waveLength=10.0f,
   ISceneNode* parent=0, s32 id=-1,
   const core::vector3df& position = core::vector3df(0,0,0),
   const core::vector3df& rotation = core::vector3df(0,0,0),
   const core::vector3df& scale = core::vector3df(1.0f, 1.0f, 1.0f)) = 0;
# 418 "H:/CPP/irrlicht-1.3/include/ISceneManager.h"
  virtual ISceneNode* addOctTreeSceneNode(IAnimatedMesh* mesh, ISceneNode* parent=0,
   s32 id=-1, s32 minimalPolysPerNode=256, bool alsoAddIfMeshPointerZero=false) = 0;
# 433 "H:/CPP/irrlicht-1.3/include/ISceneManager.h"
  virtual ISceneNode* addOctTreeSceneNode(IMesh* mesh, ISceneNode* parent=0,
   s32 id=-1, s32 minimalPolysPerNode=256, bool alsoAddIfMeshPointerZero=false) = 0;
# 447 "H:/CPP/irrlicht-1.3/include/ISceneManager.h"
  virtual ICameraSceneNode* addCameraSceneNode(ISceneNode* parent = 0,
   const core::vector3df& position = core::vector3df(0,0,0),
   const core::vector3df& lookat = core::vector3df(0,0,100), s32 id=-1) = 0;
# 461 "H:/CPP/irrlicht-1.3/include/ISceneManager.h"
  virtual ICameraSceneNode* addCameraSceneNodeMaya(ISceneNode* parent = 0,
   f32 rotateSpeed = -1500.0f, f32 zoomSpeed = 200.0f, f32 translationSpeed = 1500.0f, s32 id=-1) = 0;
# 509 "H:/CPP/irrlicht-1.3/include/ISceneManager.h"
  virtual ICameraSceneNode* addCameraSceneNodeFPS(ISceneNode* parent = 0,
   f32 rotateSpeed = 100.0f, f32 moveSpeed = 500.0f, s32 id=-1,
   SKeyMap* keyMapArray=0, s32 keyMapSize=0, bool noVerticalMovement=false,
   f32 jumpSpeed = 0.f) = 0;
# 527 "H:/CPP/irrlicht-1.3/include/ISceneManager.h"
  virtual ILightSceneNode* addLightSceneNode(ISceneNode* parent = 0,
   const core::vector3df& position = core::vector3df(0,0,0),
   video::SColorf color = video::SColorf(1.0f, 1.0f, 1.0f),
   f32 radius=100.0f, s32 id=-1) = 0;
# 546 "H:/CPP/irrlicht-1.3/include/ISceneManager.h"
  virtual IBillboardSceneNode* addBillboardSceneNode(ISceneNode* parent = 0,
   const core::dimension2d<f32>& size = core::dimension2d<f32>(10.0f, 10.0f),
   const core::vector3df& position = core::vector3df(0,0,0), s32 id=-1,
   video::SColor shade_top = 0xFFFFFFFF, video::SColor shade_down = 0xFFFFFFFF) = 0;
# 566 "H:/CPP/irrlicht-1.3/include/ISceneManager.h"
  virtual ISceneNode* addSkyBoxSceneNode(video::ITexture* top, video::ITexture* bottom,
   video::ITexture* left, video::ITexture* right, video::ITexture* front,
   video::ITexture* back, ISceneNode* parent = 0, s32 id=-1) = 0;
# 584 "H:/CPP/irrlicht-1.3/include/ISceneManager.h"
  virtual ISceneNode* addSkyDomeSceneNode(video::ITexture* texture,
   u32 horiRes, u32 vertRes, f64 texturePercentage, f64 spherePercentage,
   ISceneNode* parent = 0, s32 id=-1) = 0;
# 601 "H:/CPP/irrlicht-1.3/include/ISceneManager.h"
  virtual IParticleSystemSceneNode* addParticleSystemSceneNode(
   bool withDefaultEmitter=true, ISceneNode* parent=0, s32 id=-1,
   const core::vector3df& position = core::vector3df(0,0,0),
   const core::vector3df& rotation = core::vector3df(0,0,0),
   const core::vector3df& scale = core::vector3df(1.0f, 1.0f, 1.0f)) = 0;
# 647 "H:/CPP/irrlicht-1.3/include/ISceneManager.h"
  virtual ITerrainSceneNode* addTerrainSceneNode(
    const c8* heightMapFileName,
    ISceneNode* parent=0, s32 id=-1,
   const core::vector3df& position = core::vector3df(0.0f,0.0f,0.0f),
   const core::vector3df& rotation = core::vector3df(0.0f,0.0f,0.0f),
   const core::vector3df& scale = core::vector3df(1.0f,1.0f,1.0f),
   video::SColor vertexColor = video::SColor(255,255,255,255),
   s32 maxLOD=5, E_TERRAIN_PATCH_SIZE patchSize=ETPS_17, s32 smoothFactor=0) = 0;





  virtual ITerrainSceneNode* addTerrainSceneNode(
   io::IReadFile* heightMapFile,
   ISceneNode* parent=0, s32 id=-1,
   const core::vector3df& position = core::vector3df(0.0f,0.0f,0.0f),
   const core::vector3df& rotation = core::vector3df(0.0f,0.0f,0.0f),
   const core::vector3df& scale = core::vector3df(1.0f,1.0f,1.0f),
   video::SColor vertexColor = video::SColor(255,255,255,255),
   s32 maxLOD=5, E_TERRAIN_PATCH_SIZE patchSize=ETPS_17, s32 smoothFactor=0) = 0;





  virtual ISceneNode* addQuake3SceneNode(IMeshBuffer* meshBuffer, const quake3::SShader * shader,
            ISceneNode* parent=0, s32 id=-1
            ) = 0;







  virtual ISceneNode* addEmptySceneNode(ISceneNode* parent=0, s32 id=-1) = 0;
# 692 "H:/CPP/irrlicht-1.3/include/ISceneManager.h"
  virtual IDummyTransformationSceneNode* addDummyTransformationSceneNode(
   ISceneNode* parent=0, s32 id=-1) = 0;


  virtual ITextSceneNode* addTextSceneNode(gui::IGUIFont* font, const wchar_t* text,
   video::SColor color=video::SColor(100,255,255,255),
   ISceneNode* parent = 0, const core::vector3df& position = core::vector3df(0,0,0),
   s32 id=-1) = 0;


  virtual ITextSceneNode* addBillboardTextSceneNode( gui::IGUIFont* font, const wchar_t* text,
   ISceneNode* parent = 0,
   const core::dimension2d<f32>& size = core::dimension2d<f32>(10.0f, 10.0f),
   const core::vector3df& position = core::vector3df(0,0,0), s32 id=-1,
   video::SColor shade_top = 0xFFFFFFFF, video::SColor shade_down = 0xFFFFFFFF) = 0;
# 735 "H:/CPP/irrlicht-1.3/include/ISceneManager.h"
  virtual IAnimatedMesh* addHillPlaneMesh(const c8* name,
   const core::dimension2d<f32>& tileSize, const core::dimension2d<s32>& tileCount,
   video::SMaterial* material = 0, f32 hillHeight = 0.0f,
   const core::dimension2d<f32>& countHills = core::dimension2d<f32>(0.0f, 0.0f),
   const core::dimension2d<f32>& textureRepeatCount = core::dimension2d<f32>(1.0f, 1.0f)) = 0;
# 763 "H:/CPP/irrlicht-1.3/include/ISceneManager.h"
  virtual IAnimatedMesh* addTerrainMesh(const c8* meshname,
   video::IImage* texture, video::IImage* heightmap,
   const core::dimension2d<f32>& stretchSize = core::dimension2d<f32>(10.0f,10.0f),
   f32 maxHeight=200.0f,
   const core::dimension2d<s32>& defaultVertexBlockSize = core::dimension2d<s32>(64,64)) = 0;




  virtual IAnimatedMesh* addArrowMesh(const c8* name, u32 tesselationCylinder, u32 tesselationCone, f32 height,
           f32 cylinderHeight, f32 width0,f32 width1,
           video::SColor vtxColor0, video::SColor vtxColor1) = 0;







  virtual ISceneNode* getRootSceneNode() = 0;
# 791 "H:/CPP/irrlicht-1.3/include/ISceneManager.h"
  virtual ISceneNode* getSceneNodeFromId(s32 id, ISceneNode* start=0) = 0;







  virtual ISceneNode* getSceneNodeFromName(const c8* name, ISceneNode* start=0) = 0;




  virtual ICameraSceneNode* getActiveCamera() = 0;




  virtual void setActiveCamera(ICameraSceneNode* camera) = 0;


  virtual void setShadowColor(video::SColor color = video::SColor(150,0,0,0)) = 0;


  virtual video::SColor getShadowColor() const = 0;
# 826 "H:/CPP/irrlicht-1.3/include/ISceneManager.h"
  virtual u32 registerNodeForRendering(ISceneNode* node,
   E_SCENE_NODE_RENDER_PASS pass = ESNRP_AUTOMATIC) = 0;






  virtual void drawAll() = 0;







  virtual ISceneNodeAnimator* createRotationAnimator(const core::vector3df& rotationPerSecond) = 0;
# 852 "H:/CPP/irrlicht-1.3/include/ISceneManager.h"
  virtual ISceneNodeAnimator* createFlyCircleAnimator(const core::vector3df& center,
   f32 radius, f32 speed=0.001f, const core::vector3df& direction= core::vector3df ( 0.f, 1.f, 0.f ) ) = 0;
# 866 "H:/CPP/irrlicht-1.3/include/ISceneManager.h"
  virtual ISceneNodeAnimator* createFlyStraightAnimator(const core::vector3df& startPoint,
   const core::vector3df& endPoint, u32 timeForWay, bool loop=false) = 0;
# 879 "H:/CPP/irrlicht-1.3/include/ISceneManager.h"
  virtual ISceneNodeAnimator* createTextureAnimator(const core::array<video::ITexture*>& textures,
   s32 timePerFrame, bool loop=true) = 0;







  virtual ISceneNodeAnimator* createDeleteAnimator(u32 timeMs) = 0;
# 919 "H:/CPP/irrlicht-1.3/include/ISceneManager.h"
  virtual ISceneNodeAnimatorCollisionResponse* createCollisionResponseAnimator(
   ITriangleSelector* world, ISceneNode* sceneNode,
   const core::vector3df& ellipsoidRadius = core::vector3df(30,60,30),
   const core::vector3df& gravityPerSecond = core::vector3df(0,-100.0f,0),
   const core::vector3df& ellipsoidTranslation = core::vector3df(0,0,0),
   f32 slidingValue = 0.0005f) = 0;
# 934 "H:/CPP/irrlicht-1.3/include/ISceneManager.h"
  virtual ISceneNodeAnimator* createFollowSplineAnimator(s32 startTime,
   const core::array< core::vector3df >& points,
   f32 speed = 1.0f, f32 tightness = 0.5f) = 0;
# 957 "H:/CPP/irrlicht-1.3/include/ISceneManager.h"
  virtual ITriangleSelector* createTriangleSelector(IMesh* mesh, ISceneNode* node) = 0;
# 968 "H:/CPP/irrlicht-1.3/include/ISceneManager.h"
  virtual ITriangleSelector* createTriangleSelectorFromBoundingBox(ISceneNode* node) = 0;
# 993 "H:/CPP/irrlicht-1.3/include/ISceneManager.h"
  virtual ITriangleSelector* createOctTreeTriangleSelector(IMesh* mesh,
   ISceneNode* node, s32 minimalPolysPerNode=32) = 0;
# 1004 "H:/CPP/irrlicht-1.3/include/ISceneManager.h"
  virtual IMetaTriangleSelector* createMetaTriangleSelector() = 0;




  virtual ITriangleSelector* createTerrainTriangleSelector(
   ITerrainSceneNode* node, s32 LOD=0) = 0;
# 1019 "H:/CPP/irrlicht-1.3/include/ISceneManager.h"
  virtual void addExternalMeshLoader(IMeshLoader* externalLoader) = 0;


  virtual ISceneCollisionManager* getSceneCollisionManager() = 0;


  virtual IMeshManipulator* getMeshManipulator() = 0;
# 1036 "H:/CPP/irrlicht-1.3/include/ISceneManager.h"
  virtual void addToDeletionQueue(ISceneNode* node) = 0;




  virtual bool postEventFromUser(SEvent event) = 0;



  virtual void clear() = 0;







  virtual io::IAttributes* getParameters() = 0;
# 1062 "H:/CPP/irrlicht-1.3/include/ISceneManager.h"
  virtual E_SCENE_NODE_RENDER_PASS getSceneNodeRenderPass() = 0;


  virtual ISceneNodeFactory* getDefaultSceneNodeFactory() = 0;




  virtual void registerSceneNodeFactory(ISceneNodeFactory* factoryToAdd) = 0;


  virtual s32 getRegisteredSceneNodeFactoryCount() = 0;


  virtual ISceneNodeFactory* getSceneNodeFactory(s32 index) = 0;


  virtual ISceneNodeAnimatorFactory* getDefaultSceneNodeAnimatorFactory() = 0;




  virtual void registerSceneNodeAnimatorFactory(ISceneNodeAnimatorFactory* factoryToAdd) = 0;


  virtual s32 getRegisteredSceneNodeAnimatorFactoryCount() = 0;


  virtual ISceneNodeAnimatorFactory* getSceneNodeAnimatorFactory(s32 index) = 0;


  virtual const c8* getSceneNodeTypeName(ESCENE_NODE_TYPE type) = 0;
# 1107 "H:/CPP/irrlicht-1.3/include/ISceneManager.h"
  virtual ISceneManager* createNewSceneManager() = 0;
# 1119 "H:/CPP/irrlicht-1.3/include/ISceneManager.h"
  virtual bool saveScene(const c8* filename, ISceneUserDataSerializer* userDataSerializer=0) = 0;
# 1131 "H:/CPP/irrlicht-1.3/include/ISceneManager.h"
  virtual bool saveScene(io::IWriteFile* file, ISceneUserDataSerializer* userDataSerializer=0) = 0;
# 1142 "H:/CPP/irrlicht-1.3/include/ISceneManager.h"
  virtual bool loadScene(const c8* filename, ISceneUserDataSerializer* userDataSerializer=0) = 0;
# 1153 "H:/CPP/irrlicht-1.3/include/ISceneManager.h"
  virtual bool loadScene(io::IReadFile* file, ISceneUserDataSerializer* userDataSerializer=0) = 0;


  virtual void setAmbientLight(const video::SColorf &ambientColor) = 0;


  virtual video::SColorf getAmbientLight() = 0;

 };


}
}
# 11 "H:/CPP/irrlicht-1.3/include/ISceneNode.h" 2
# 1 "H:/CPP/irrlicht-1.3/include/ISceneNodeAnimator.h" 1
# 10 "H:/CPP/irrlicht-1.3/include/ISceneNodeAnimator.h"
# 1 "H:/CPP/irrlicht-1.3/include/ESceneNodeAnimatorTypes.h" 1







namespace irr
{
namespace scene
{

 enum ESCENE_NODE_ANIMATOR_TYPE
 {

  ESNAT_FLY_CIRCLE = 0,


  ESNAT_FLY_STRAIGHT,


  ESNAT_FOLLOW_SPLINE,


  ESNAT_ROTATION,


  ESNAT_TEXTURE,


  ESNAT_DELETION,


  ESNAT_COLLISION_RESPONSE,


  ESNAT_COUNT,


  ESNAT_UNKNOWN,



  ESNAT_FORCE_32_BIT = 0x7fffffff
 };

}
}
# 11 "H:/CPP/irrlicht-1.3/include/ISceneNodeAnimator.h" 2


namespace irr
{
namespace io
{
 class IAttributes;
}
namespace scene
{
 class ISceneNode;






 class ISceneNodeAnimator : public io::IAttributeExchangingObject
 {
 public:


  virtual ~ISceneNodeAnimator() {}






  virtual void animateNode(ISceneNode* node, u32 timeMs) = 0;


  virtual ESCENE_NODE_ANIMATOR_TYPE getType()
  {
   return ESNAT_UNKNOWN;
  }
 };
}
}
# 12 "H:/CPP/irrlicht-1.3/include/ISceneNode.h" 2
# 1 "H:/CPP/irrlicht-1.3/include/ITriangleSelector.h" 1
# 14 "H:/CPP/irrlicht-1.3/include/ITriangleSelector.h"
namespace irr
{
namespace scene
{
# 26 "H:/CPP/irrlicht-1.3/include/ITriangleSelector.h"
class ITriangleSelector : public virtual IUnknown
{
public:


 virtual ~ITriangleSelector() {};


 virtual s32 getTriangleCount() const = 0;
# 44 "H:/CPP/irrlicht-1.3/include/ITriangleSelector.h"
 virtual void getTriangles(core::triangle3df* triangles, s32 arraySize,
  s32& outTriangleCount, const core::matrix4* transform=0) = 0;
# 59 "H:/CPP/irrlicht-1.3/include/ITriangleSelector.h"
 virtual void getTriangles(core::triangle3df* triangles, s32 arraySize,
  s32& outTriangleCount, const core::aabbox3d<f32>& box,
  const core::matrix4* transform=0) = 0;
# 75 "H:/CPP/irrlicht-1.3/include/ITriangleSelector.h"
 virtual void getTriangles(core::triangle3df* triangles, s32 arraySize,
  s32& outTriangleCount, const core::line3d<f32>& line,
  const core::matrix4* transform=0) = 0;
};

}
}
# 13 "H:/CPP/irrlicht-1.3/include/ISceneNode.h" 2
# 21 "H:/CPP/irrlicht-1.3/include/ISceneNode.h"
namespace irr
{
namespace scene
{






 class ISceneNode : public io::IAttributeExchangingObject
 {
 public:


  ISceneNode( ISceneNode* parent, ISceneManager* mgr, s32 id=-1,
     const core::vector3df& position = core::vector3df(0,0,0),
     const core::vector3df& rotation = core::vector3df(0,0,0),
     const core::vector3df& scale = core::vector3df(1.0f, 1.0f, 1.0f))
   : RelativeTranslation(position), RelativeRotation(rotation), RelativeScale(scale),
    Parent(parent), ID(id), SceneManager(mgr), TriangleSelector(0),
    AutomaticCullingState(EAC_BOX), IsVisible(true),
    DebugDataVisible(EDS_OFF), IsDebugObject(false)
  {
   if (Parent)
    Parent->addChild(this);

   updateAbsolutePosition();
  }




  virtual ~ISceneNode()
  {

   removeAll();


   core::list<ISceneNodeAnimator*>::Iterator ait = Animators.begin();
   for (; ait != Animators.end(); ++ait)
    (*ait)->drop();

   if (TriangleSelector)
    TriangleSelector->drop();
  }
# 83 "H:/CPP/irrlicht-1.3/include/ISceneNode.h"
  virtual void OnRegisterSceneNode()
  {
   if (IsVisible)
   {
    core::list<ISceneNode*>::Iterator it = Children.begin();
    for (; it != Children.end(); ++it)
     (*it)->OnRegisterSceneNode();
   }
  }
# 100 "H:/CPP/irrlicht-1.3/include/ISceneNode.h"
  virtual void OnAnimate(u32 timeMs)
  {
   if (IsVisible)
   {


    core::list<ISceneNodeAnimator*>::Iterator ait = Animators.begin();
    for (; ait != Animators.end(); ++ait)
     (*ait)->animateNode(this, timeMs);


    updateAbsolutePosition();



    core::list<ISceneNode*>::Iterator it = Children.begin();
    for (; it != Children.end(); ++it)
     (*it)->OnAnimate(timeMs);
   }
  }



  virtual void render() = 0;




  virtual const c8* getName() const
  {
   return Name.c_str();
  }




  virtual void setName(const c8* name)
  {
   Name = name;
  }
# 148 "H:/CPP/irrlicht-1.3/include/ISceneNode.h"
  virtual const core::aabbox3d<f32>& getBoundingBox() const = 0;




  virtual const core::aabbox3d<f32> getTransformedBoundingBox() const
  {
   core::aabbox3d<f32> box = getBoundingBox();
   AbsoluteTransformation.transformBox(box);
   return box;
  }



  const core::matrix4& getAbsoluteTransformation() const
  {
   return AbsoluteTransformation;
  }







  virtual core::matrix4 getRelativeTransformation() const
  {
   core::matrix4 mat;
   mat.setRotationDegrees(RelativeRotation);
   mat.setTranslation(RelativeTranslation);

   if (RelativeScale != core::vector3df(1,1,1))
   {
    core::matrix4 smat;
    smat.setScale(RelativeScale);
    mat *= smat;
   }

   return mat;
  }




  virtual bool isVisible() const
  {
   ;
   return IsVisible;
  }



  virtual void setVisible(bool isVisible)
  {
   IsVisible = isVisible;
  }



  virtual s32 getID() const
  {
   return ID;
  }



  virtual void setID(s32 id)
  {
   ID = id;
  }




  virtual void addChild(ISceneNode* child)
  {
   if (child)
   {
    child->grab();
    child->remove();
    Children.push_back(child);
    child->Parent = this;
   }
  }




  virtual bool removeChild(ISceneNode* child)
  {
   core::list<ISceneNode*>::Iterator it = Children.begin();
   for (; it != Children.end(); ++it)
    if ((*it) == child)
    {
     (*it)->Parent = 0;
     (*it)->drop();
     Children.erase(it);
     return true;
    }

   ;
   return false;
  }



  virtual void removeAll()
  {
   core::list<ISceneNode*>::Iterator it = Children.begin();
   for (; it != Children.end(); ++it)
   {
    (*it)->Parent = 0;
    (*it)->drop();
   }

   Children.clear();
  }



  virtual void remove()
  {
   if (Parent)
    Parent->removeChild(this);
  }



  virtual void addAnimator(ISceneNodeAnimator* animator)
  {
   if (animator)
   {
    Animators.push_back(animator);
    animator->grab();
   }
  }



  const core::list<ISceneNodeAnimator*>& getAnimators() const
  {
   return Animators;
  }



  virtual void removeAnimator(ISceneNodeAnimator* animator)
  {
   core::list<ISceneNodeAnimator*>::Iterator it = Animators.begin();
   for (; it != Animators.end(); ++it)
    if ((*it) == animator)
    {
     (*it)->drop();
     Animators.erase(it);
     return;
    }
  }



  virtual void removeAnimators()
  {
   core::list<ISceneNodeAnimator*>::Iterator it = Animators.begin();
   for (; it != Animators.end(); ++it)
    (*it)->drop();

   Animators.clear();
  }
# 325 "H:/CPP/irrlicht-1.3/include/ISceneNode.h"
  virtual video::SMaterial& getMaterial(u32 num)
  {
   return *((video::SMaterial*)0);
  }




  virtual u32 getMaterialCount()
  {
   return 0;
  }






  void setMaterialFlag(video::E_MATERIAL_FLAG flag, bool newvalue)
  {
   for (u32 i=0; i<getMaterialCount(); ++i)
    getMaterial(i).setFlag(flag, newvalue);
  }







  void setMaterialTexture(u32 textureLayer, video::ITexture* texture)
  {
   if (textureLayer>= video::MATERIAL_MAX_TEXTURES)
    return;

   for (u32 i=0; i<getMaterialCount(); ++i)
    getMaterial(i).Textures[textureLayer] = texture;
  }





  void setMaterialType(video::E_MATERIAL_TYPE newType)
  {
   for (u32 i=0; i<getMaterialCount(); ++i)
    getMaterial(i).MaterialType = newType;
  }




  virtual core::vector3df getScale() const
  {
   return RelativeScale;
  }




  virtual void setScale(const core::vector3df& scale)
  {
   RelativeScale = scale;
  }





  virtual const core::vector3df& getRotation() const
  {
   return RelativeRotation;
  }





  virtual void setRotation(const core::vector3df& rotation)
  {
   RelativeRotation = rotation;
  }





  virtual const core::vector3df getPosition() const
  {
   return RelativeTranslation;
  }





  virtual void setPosition(const core::vector3df& newpos)
  {
   RelativeTranslation = newpos;
  }





  virtual core::vector3df getAbsolutePosition() const
  {
   return AbsoluteTransformation.getTranslation();
  }
# 443 "H:/CPP/irrlicht-1.3/include/ISceneNode.h"
  void setAutomaticCulling( E_CULLING_TYPE state)
  {
   AutomaticCullingState = state;
  }





  E_CULLING_TYPE getAutomaticCulling() const
  {
   ;
   return AutomaticCullingState;
  }




  virtual void setDebugDataVisible(E_DEBUG_SCENE_TYPE visible)
  {
   DebugDataVisible = visible;
  }


  E_DEBUG_SCENE_TYPE isDebugDataVisible() const
  {
   ;
   return DebugDataVisible;
  }





  void setIsDebugObject(bool debugObject)
  {
   IsDebugObject = debugObject;
  }




  bool isDebugObject()
  {
   ;
   return IsDebugObject;
  }



  const core::list<ISceneNode*>& getChildren() const
  {
   return Children;
  }



  virtual void setParent(ISceneNode* newParent)
  {
   grab();
   remove();

   Parent = newParent;

   if (Parent)
    Parent->addChild(this);

   drop();
  }
# 524 "H:/CPP/irrlicht-1.3/include/ISceneNode.h"
  virtual ITriangleSelector* getTriangleSelector() const
  {
   return TriangleSelector;
  }
# 538 "H:/CPP/irrlicht-1.3/include/ISceneNode.h"
  virtual void setTriangleSelector(ITriangleSelector* selector)
  {
   if (TriangleSelector)
    TriangleSelector->drop();

   TriangleSelector = selector;
   if (TriangleSelector)
    TriangleSelector->grab();
  }


  virtual void updateAbsolutePosition()
  {
   if (Parent )
   {
    AbsoluteTransformation =
     Parent->getAbsoluteTransformation() * getRelativeTransformation();
   }
   else
    AbsoluteTransformation = getRelativeTransformation();
  }


  scene::ISceneNode* getParent() const
  {
   return Parent;
  }


  virtual ESCENE_NODE_TYPE getType() const
  {
   return ESNT_UNKNOWN;
  }




  virtual void serializeAttributes(io::IAttributes* out, io::SAttributeReadWriteOptions* options=0)
  {
   out->addString ("Name", Name.c_str());
   out->addInt ("Id", ID );
   out->addVector3d("Position", RelativeTranslation );
   out->addVector3d("Rotation", RelativeRotation );
   out->addVector3d("Scale", RelativeScale );
   out->addBool ("Visible", IsVisible );
   out->addEnum ("AutomaticCulling", AutomaticCullingState, AutomaticCullingNames);
   out->addInt ("DebugDataVisible", DebugDataVisible );
   out->addBool ("IsDebugObject", IsDebugObject );
  }




  virtual void deserializeAttributes(io::IAttributes* in, io::SAttributeReadWriteOptions* options=0)
  {
   Name = in->getAttributeAsString("Name");
   ID = in->getAttributeAsInt("Id");
   RelativeTranslation = in->getAttributeAsVector3d("Position");
   RelativeRotation = in->getAttributeAsVector3d("Rotation");
   RelativeScale = in->getAttributeAsVector3d("Scale");
   IsVisible = in->getAttributeAsBool("Visible");
   AutomaticCullingState = (scene::E_CULLING_TYPE ) in->getAttributeAsEnumeration("AutomaticCulling", scene::AutomaticCullingNames);

   DebugDataVisible = (scene::E_DEBUG_SCENE_TYPE ) in->getAttributeAsInt("DebugDataVisible");
   IsDebugObject = in->getAttributeAsBool("IsDebugObject");

   updateAbsolutePosition();
  }

 protected:


  core::stringc Name;


  core::matrix4 AbsoluteTransformation;


  core::vector3df RelativeTranslation;


  core::vector3df RelativeRotation;


  core::vector3df RelativeScale;


  ISceneNode* Parent;


  core::list<ISceneNode*> Children;


  core::list<ISceneNodeAnimator*> Animators;


  s32 ID;


  ISceneManager* SceneManager;


  ITriangleSelector* TriangleSelector;


  E_CULLING_TYPE AutomaticCullingState;


  bool IsVisible;


  E_DEBUG_SCENE_TYPE DebugDataVisible;


  bool IsDebugObject;
 };

}
}
# 9 "H:/CPP/irrlicht-1.3/include/IAnimatedMeshB3d.h" 2


namespace irr
{
namespace scene
{


 class IAnimatedMeshB3d : public IAnimatedMesh
 {
 public:
# 30 "H:/CPP/irrlicht-1.3/include/IAnimatedMeshB3d.h"
  virtual core::matrix4* getMatrixOfJoint(s32 jointNumber, s32 frame) = 0;



  virtual core::matrix4* getLocalMatrixOfJoint(s32 jointNumber) = 0;


  virtual core::matrix4* getMatrixOfJointUnanimated(s32 jointNumber) = 0;







  virtual void setJointAnimation(s32 jointNumber, bool On) = 0;




  virtual s32 getJointCount() const = 0;





  virtual const c8* getJointName(s32 number) const = 0;




  virtual s32 getJointNumber(const c8* name) const = 0;




  virtual void updateNormalsWhenAnimating(bool on) = 0;





  virtual void setInterpolationMode(s32 mode) = 0;






  virtual void setAnimateMode(s32 mode) = 0;


  virtual void convertToTangents() =0;


  virtual void recoverJointsFromMesh(core::array<ISceneNode*> &JointChildSceneNodes)=0;
  virtual void tranferJointsToMesh(core::array<ISceneNode*> &JointChildSceneNodes)=0;
  virtual void createJoints(core::array<ISceneNode*> &JointChildSceneNodes, ISceneNode* AnimatedMeshSceneNode, ISceneManager* SceneManager)=0;

 };

}
}
# 51 "H:/CPP/irrlicht-1.3/include/irrlicht.h" 2
# 1 "H:/CPP/irrlicht-1.3/include/IAnimatedMeshSceneNode.h" 1
# 11 "H:/CPP/irrlicht-1.3/include/IAnimatedMeshSceneNode.h"
# 1 "H:/CPP/irrlicht-1.3/include/IShadowVolumeSceneNode.h" 1
# 11 "H:/CPP/irrlicht-1.3/include/IShadowVolumeSceneNode.h"
namespace irr
{
namespace scene
{


 class IShadowVolumeSceneNode : public ISceneNode
 {
 public:


  IShadowVolumeSceneNode(ISceneNode* parent, ISceneManager* mgr, s32 id)
   : ISceneNode(parent, mgr, id) {}


  virtual void setMeshToRenderFrom(IMesh* mesh) = 0;
 };

}
}
# 12 "H:/CPP/irrlicht-1.3/include/IAnimatedMeshSceneNode.h" 2

namespace irr
{
namespace scene
{
 class IAnimatedMeshSceneNode;






 class IAnimationEndCallBack : public virtual IUnknown
 {
 public:





  virtual void OnAnimationEnd(IAnimatedMeshSceneNode* node) = 0;
 };




 class IAnimatedMeshSceneNode : public ISceneNode
 {
 public:


  IAnimatedMeshSceneNode(ISceneNode* parent, ISceneManager* mgr, s32 id,
   const core::vector3df& position = core::vector3df(0,0,0),
   const core::vector3df& rotation = core::vector3df(0,0,0),
   const core::vector3df& scale = core::vector3df(1.0f, 1.0f, 1.0f))
   : ISceneNode(parent, mgr, id, position, rotation, scale) {}


  virtual ~IAnimatedMeshSceneNode() {};






  virtual void setCurrentFrame(s32 frame) = 0;






  virtual bool setFrameLoop(s32 begin, s32 end) = 0;



  virtual void setAnimationSpeed(f32 framesPerSecond) = 0;
# 84 "H:/CPP/irrlicht-1.3/include/IAnimatedMeshSceneNode.h"
  virtual IShadowVolumeSceneNode* addShadowVolumeSceneNode(s32 id=-1,
   bool zfailmethod=true, f32 infinity=10000.0f) = 0;
# 104 "H:/CPP/irrlicht-1.3/include/IAnimatedMeshSceneNode.h"
  virtual ISceneNode* getMS3DJointNode(const c8* jointName) = 0;
# 123 "H:/CPP/irrlicht-1.3/include/IAnimatedMeshSceneNode.h"
  virtual ISceneNode* getXJointNode(const c8* jointName) = 0;
# 142 "H:/CPP/irrlicht-1.3/include/IAnimatedMeshSceneNode.h"
  virtual ISceneNode* getB3DJointNode(const c8* jointName) = 0;
# 152 "H:/CPP/irrlicht-1.3/include/IAnimatedMeshSceneNode.h"
  virtual bool setMD2Animation(EMD2_ANIMATION_TYPE anim) = 0;
# 165 "H:/CPP/irrlicht-1.3/include/IAnimatedMeshSceneNode.h"
  virtual bool setMD2Animation(const c8* animationName) = 0;


  virtual s32 getFrameNr() = 0;

  virtual s32 getStartFrame() = 0;

  virtual s32 getEndFrame() = 0;



  virtual void setLoopMode(bool playAnimationLooped) = 0;





  virtual void setAnimationEndCallback(IAnimationEndCallBack* callback=0) = 0;




  virtual void setReadOnlyMaterials(bool readonly) = 0;


  virtual bool isReadOnlyMaterials() = 0;


  virtual void setMesh(IAnimatedMesh* mesh) = 0;


  virtual IAnimatedMesh* getMesh(void) = 0;



  virtual const SMD3QuaterionTag& getAbsoluteTransformation( const core::stringc & tagname) = 0;

 };

}
}
# 52 "H:/CPP/irrlicht-1.3/include/irrlicht.h" 2
# 1 "H:/CPP/irrlicht-1.3/include/ICameraSceneNode.h" 1
# 10 "H:/CPP/irrlicht-1.3/include/ICameraSceneNode.h"
# 1 "H:/CPP/irrlicht-1.3/include/SViewFrustum.h" 1
# 14 "H:/CPP/irrlicht-1.3/include/SViewFrustum.h"
namespace irr
{
namespace scene
{






 struct SViewFrustum
 {
  enum VFPLANES
  {

   VF_FAR_PLANE = 0,

   VF_NEAR_PLANE,

   VF_LEFT_PLANE,

   VF_RIGHT_PLANE,

   VF_BOTTOM_PLANE,

   VF_TOP_PLANE,


   VF_PLANE_COUNT
  };


  SViewFrustum() {};



  SViewFrustum(const core::matrix4& mat);



  void setFrom(const core::matrix4& mat);


  core::vector3df cameraPosition;


  core::plane3d<f32> planes[VF_PLANE_COUNT];




  void transform(const core::matrix4 &mat);



  core::vector3df getFarLeftUp() const;



  core::vector3df getFarLeftDown() const;



  core::vector3df getFarRightUp() const;



  core::vector3df getFarRightDown() const;


  const core::aabbox3d<f32> &getBoundingBox() const;


  inline void recalculateBoundingBox();


  core::aabbox3d<f32> boundingBox;


  enum E_TRANSFORMATION_STATE_3
  {
   ETS_VIEW_PROJECTION_3 = video::ETS_PROJECTION + 1,
   ETS_VIEW_MODEL_INVERSE_3,
   ETS_CURRENT_3,
   ETS_COUNT_3
  };

  core::matrix4 Matrices[ETS_COUNT_3];
  void setTransformState( video::E_TRANSFORMATION_STATE state);
 };




 inline void SViewFrustum::transform(const core::matrix4 &mat)
 {
  for (int i=0; i<VF_PLANE_COUNT; ++i)
   mat.transformPlane(planes[i]);

  mat.transformVect(cameraPosition);
  recalculateBoundingBox();
 }




 inline core::vector3df SViewFrustum::getFarLeftUp() const
 {
  core::vector3df p;
  planes[scene::SViewFrustum::VF_FAR_PLANE].getIntersectionWithPlanes(
   planes[scene::SViewFrustum::VF_TOP_PLANE],
   planes[scene::SViewFrustum::VF_LEFT_PLANE], p);

  return p;
 }



 inline core::vector3df SViewFrustum::getFarLeftDown() const
 {
  core::vector3df p;
  planes[scene::SViewFrustum::VF_FAR_PLANE].getIntersectionWithPlanes(
   planes[scene::SViewFrustum::VF_BOTTOM_PLANE],
   planes[scene::SViewFrustum::VF_LEFT_PLANE], p);

  return p;
 }



 inline core::vector3df SViewFrustum::getFarRightUp() const
 {
  core::vector3df p;
  planes[scene::SViewFrustum::VF_FAR_PLANE].getIntersectionWithPlanes(
   planes[scene::SViewFrustum::VF_TOP_PLANE],
   planes[scene::SViewFrustum::VF_RIGHT_PLANE], p);

  return p;
 }



 inline core::vector3df SViewFrustum::getFarRightDown() const
 {
  core::vector3df p;
  planes[scene::SViewFrustum::VF_FAR_PLANE].getIntersectionWithPlanes(
   planes[scene::SViewFrustum::VF_BOTTOM_PLANE],
   planes[scene::SViewFrustum::VF_RIGHT_PLANE], p);

  return p;
 }


 inline const core::aabbox3d<f32> &SViewFrustum::getBoundingBox() const
 {
  return boundingBox;
 }


 inline void SViewFrustum::recalculateBoundingBox()
 {
  boundingBox.reset ( cameraPosition );

  boundingBox.addInternalPoint(getFarLeftUp());
  boundingBox.addInternalPoint(getFarRightUp());
  boundingBox.addInternalPoint(getFarLeftDown());
  boundingBox.addInternalPoint(getFarRightDown());
 }



 inline SViewFrustum::SViewFrustum(const core::matrix4& mat)
 {
  setFrom ( mat );
 }
# 246 "H:/CPP/irrlicht-1.3/include/SViewFrustum.h"
 inline void SViewFrustum::setFrom(const core::matrix4& mat)
 {

  planes[VF_LEFT_PLANE].Normal.X = mat[3 ] + mat[0];
  planes[VF_LEFT_PLANE].Normal.Y = mat[7 ] + mat[4];
  planes[VF_LEFT_PLANE].Normal.Z = mat[11] + mat[8];
  planes[VF_LEFT_PLANE].D = mat[15] + mat[12];


  planes[VF_RIGHT_PLANE].Normal.X = mat[3 ] - mat[0];
  planes[VF_RIGHT_PLANE].Normal.Y = mat[7 ] - mat[4];
  planes[VF_RIGHT_PLANE].Normal.Z = mat[11] - mat[8];
  planes[VF_RIGHT_PLANE].D = mat[15] - mat[12];


  planes[VF_TOP_PLANE].Normal.X = mat[3 ] - mat[1];
  planes[VF_TOP_PLANE].Normal.Y = mat[7 ] - mat[5];
  planes[VF_TOP_PLANE].Normal.Z = mat[11] - mat[9];
  planes[VF_TOP_PLANE].D = mat[15] - mat[13];


  planes[VF_BOTTOM_PLANE].Normal.X = mat[3 ] + mat[1];
  planes[VF_BOTTOM_PLANE].Normal.Y = mat[7 ] + mat[5];
  planes[VF_BOTTOM_PLANE].Normal.Z = mat[11] + mat[9];
  planes[VF_BOTTOM_PLANE].D = mat[15] + mat[13];


  planes[VF_FAR_PLANE].Normal.X = mat[3 ] - mat[2];
  planes[VF_FAR_PLANE].Normal.Y = mat[7 ] - mat[6];
  planes[VF_FAR_PLANE].Normal.Z = mat[11] - mat[10];
  planes[VF_FAR_PLANE].D = mat[15] - mat[14];


  planes[VF_NEAR_PLANE].Normal.X = mat[2];
  planes[VF_NEAR_PLANE].Normal.Y = mat[6];
  planes[VF_NEAR_PLANE].Normal.Z = mat[10];
  planes[VF_NEAR_PLANE].D = mat[14];



  u32 i;
  for ( i=0; i != 6; ++i)
  {
   const f32 len = - core::reciprocal_squareroot ( planes[i].Normal.getLengthSQ() );
   planes[i].Normal *= len;
   planes[i].D *= len;
  }


  recalculateBoundingBox();
 }

 inline void SViewFrustum::setTransformState( video::E_TRANSFORMATION_STATE state)
 {
  switch ( state )
  {
   case video::ETS_VIEW:
    Matrices[ETS_VIEW_PROJECTION_3].setbyproduct_nocheck ( Matrices[ video::ETS_PROJECTION],
                  Matrices[ video::ETS_VIEW]
                 );
    Matrices[ETS_VIEW_MODEL_INVERSE_3] = Matrices[ video::ETS_VIEW];
    Matrices[ETS_VIEW_MODEL_INVERSE_3].makeInverse();
    break;

   case video::ETS_WORLD:
    Matrices[ETS_CURRENT_3].setbyproduct ( Matrices[ ETS_VIEW_PROJECTION_3 ],
              Matrices[ video::ETS_WORLD] );
    break;
   default:
    break;
  }
 }


}
}
# 11 "H:/CPP/irrlicht-1.3/include/ICameraSceneNode.h" 2

namespace irr
{
namespace scene
{







 class ICameraSceneNode : public ISceneNode, public IEventReceiver
 {
 public:


  ICameraSceneNode(ISceneNode* parent, ISceneManager* mgr, s32 id,
   const core::vector3df& position = core::vector3df(0,0,0),
   const core::vector3df& rotation = core::vector3df(0,0,0),
   const core::vector3df& scale = core::vector3df(1.0f,1.0f,1.0f))
   : ISceneNode(parent, mgr, id, position, rotation, scale), IsOrthogonal(false) {}


  virtual ~ICameraSceneNode() {};







  virtual void setProjectionMatrix(const core::matrix4& projection) = 0;



  virtual const core::matrix4& getProjectionMatrix() = 0;



  virtual const core::matrix4& getViewMatrix() = 0;







  virtual bool OnEvent(SEvent event) = 0;



  virtual void setTarget(const core::vector3df& pos) = 0;



  virtual core::vector3df getTarget() const = 0;



  virtual void setUpVector(const core::vector3df& pos) = 0;



  virtual core::vector3df getUpVector() const = 0;



  virtual f32 getNearValue() = 0;



  virtual f32 getFarValue() = 0;



  virtual f32 getAspectRatio() = 0;



  virtual f32 getFOV() = 0;



  virtual void setNearValue(f32 zn) = 0;



  virtual void setFarValue(f32 zf) = 0;



  virtual void setAspectRatio(f32 aspect) = 0;



  virtual void setFOV(f32 fovy) = 0;




  virtual const SViewFrustum* getViewFrustum() const = 0;




  virtual void setInputReceiverEnabled(bool enabled) = 0;


  virtual bool isInputReceiverEnabled() = 0;




  virtual bool isOrthogonal()
  {
   ;
   return IsOrthogonal;
  }




  void setIsOrthogonal( bool orthogonal )
  {
   IsOrthogonal = orthogonal;
  }


 private:

  bool IsOrthogonal;
 };

}
}
# 53 "H:/CPP/irrlicht-1.3/include/irrlicht.h" 2
# 1 "H:/CPP/irrlicht-1.3/include/IDummyTransformationSceneNode.h" 1
# 10 "H:/CPP/irrlicht-1.3/include/IDummyTransformationSceneNode.h"
namespace irr
{
namespace scene
{
# 23 "H:/CPP/irrlicht-1.3/include/IDummyTransformationSceneNode.h"
class IDummyTransformationSceneNode : public ISceneNode
{
public:


 IDummyTransformationSceneNode(ISceneNode* parent, ISceneManager* mgr, s32 id)
  : ISceneNode(parent, mgr, id) {}




 virtual core::matrix4& getRelativeTransformationMatrix() = 0;
};

}
}
# 54 "H:/CPP/irrlicht-1.3/include/irrlicht.h" 2

# 1 "H:/CPP/irrlicht-1.3/include/IFileList.h" 1
# 10 "H:/CPP/irrlicht-1.3/include/IFileList.h"
namespace irr
{
namespace io
{


class IFileList : public virtual IUnknown
{
public:


 virtual ~IFileList() {};




 virtual s32 getFileCount() = 0;







 virtual const c8* getFileName(s32 index) = 0;






 virtual const c8* getFullFileName(s32 index) = 0;
# 50 "H:/CPP/irrlicht-1.3/include/IFileList.h"
 virtual bool isDirectory(s32 index) = 0;
};

}
}
# 56 "H:/CPP/irrlicht-1.3/include/irrlicht.h" 2


# 1 "H:/CPP/irrlicht-1.3/include/IGUICheckBox.h" 1
# 10 "H:/CPP/irrlicht-1.3/include/IGUICheckBox.h"
namespace irr
{
namespace gui
{


 class IGUICheckBox : public IGUIElement
 {
 public:


  IGUICheckBox(IGUIEnvironment* environment, IGUIElement* parent, s32 id, core::rect<s32> rectangle)
   : IGUIElement(EGUIET_CHECK_BOX, environment, parent, id, rectangle) {}


  ~IGUICheckBox() {};


  virtual void setChecked(bool checked) = 0;


  virtual bool isChecked() = 0;
 };

}
}
# 59 "H:/CPP/irrlicht-1.3/include/irrlicht.h" 2
# 1 "H:/CPP/irrlicht-1.3/include/IGUIContextMenu.h" 1
# 10 "H:/CPP/irrlicht-1.3/include/IGUIContextMenu.h"
namespace irr
{
namespace gui
{


 class IGUIContextMenu : public IGUIElement
 {
 public:


  IGUIContextMenu(IGUIEnvironment* environment, IGUIElement* parent, s32 id, core::rect<s32> rectangle)
   : IGUIElement(EGUIET_CONTEXT_MENU, environment, parent, id, rectangle) {}


  ~IGUIContextMenu() {};


  virtual s32 getItemCount() const = 0;
# 40 "H:/CPP/irrlicht-1.3/include/IGUIContextMenu.h"
  virtual s32 addItem(const wchar_t* text, s32 commandId=-1, bool enabled=true,
   bool hasSubMenu=false,
   bool checked=false
   ) = 0;


  virtual void addSeparator() = 0;



  virtual const wchar_t* getItemText(s32 idx) = 0;




  virtual void setItemText(s32 idx, const wchar_t* text) = 0;



  virtual bool isItemEnabled(s32 idx) = 0;




  virtual void setItemEnabled(s32 idx, bool enabled) = 0;




  virtual void setItemChecked(s32 idx, bool enabled) = 0;




  virtual void removeItem(s32 idx) = 0;


  virtual void removeAllItems() = 0;



  virtual s32 getSelectedItem() = 0;



  virtual s32 getItemCommandId(s32 idx) = 0;





  virtual void setItemCommandId(s32 idx, s32 id) = 0;




  virtual IGUIContextMenu* getSubMenu(s32 idx) = 0;
 };

}
}
# 60 "H:/CPP/irrlicht-1.3/include/irrlicht.h" 2
# 1 "H:/CPP/irrlicht-1.3/include/IGUIComboBox.h" 1
# 10 "H:/CPP/irrlicht-1.3/include/IGUIComboBox.h"
namespace irr
{
namespace gui
{

 class IGUIComboBox : public IGUIElement
 {
 public:


  IGUIComboBox(IGUIEnvironment* environment, IGUIElement* parent, s32 id, core::rect<s32> rectangle)
   : IGUIElement(EGUIET_COMBO_BOX, environment, parent, id, rectangle) {}


  ~IGUIComboBox() {};


  virtual s32 getItemCount() = 0;


  virtual const wchar_t* getItem(s32 idx) = 0;


  virtual s32 addItem(const wchar_t* text) = 0;


  virtual void clear() = 0;


  virtual s32 getSelected() = 0;


  virtual void setSelected(s32 id) = 0;

 };


}
}
# 61 "H:/CPP/irrlicht-1.3/include/irrlicht.h" 2

# 1 "H:/CPP/irrlicht-1.3/include/IGUIEditBox.h" 1
# 11 "H:/CPP/irrlicht-1.3/include/IGUIEditBox.h"
namespace irr
{
namespace gui
{
 class IGUIFont;


 class IGUIEditBox : public IGUIElement
 {
 public:


  IGUIEditBox(IGUIEnvironment* environment, IGUIElement* parent, s32 id, core::rect<s32> rectangle)
   : IGUIElement(EGUIET_EDIT_BOX, environment, parent, id, rectangle) {}


  ~IGUIEditBox() {};




  virtual void setOverrideFont(IGUIFont* font=0) = 0;
# 42 "H:/CPP/irrlicht-1.3/include/IGUIEditBox.h"
  virtual void setOverrideColor(video::SColor color) = 0;





  virtual void enableOverrideColor(bool enable) = 0;




  virtual void setMax(s32 max) = 0;


  virtual s32 getMax() = 0;
 };


}
}
# 63 "H:/CPP/irrlicht-1.3/include/irrlicht.h" 2

# 1 "H:/CPP/irrlicht-1.3/include/IGUIFileOpenDialog.h" 1
# 10 "H:/CPP/irrlicht-1.3/include/IGUIFileOpenDialog.h"
namespace irr
{
namespace gui
{


 class IGUIFileOpenDialog : public IGUIElement
 {
 public:


  IGUIFileOpenDialog(IGUIEnvironment* environment, IGUIElement* parent, s32 id, core::rect<s32> rectangle)
   : IGUIElement(EGUIET_FILE_OPEN_DIALOG, environment, parent, id, rectangle) {}


  virtual ~IGUIFileOpenDialog() {};


  virtual const wchar_t* getFilename() = 0;

 };


}
}
# 65 "H:/CPP/irrlicht-1.3/include/irrlicht.h" 2
# 1 "H:/CPP/irrlicht-1.3/include/IGUIColorSelectDialog.h" 1
# 10 "H:/CPP/irrlicht-1.3/include/IGUIColorSelectDialog.h"
namespace irr
{
namespace gui
{


 class IGUIColorSelectDialog : public IGUIElement
 {
 public:


  IGUIColorSelectDialog(IGUIEnvironment* environment, IGUIElement* parent, s32 id, core::rect<s32> rectangle)
   : IGUIElement(EGUIET_COLOR_SELECT_DIALOG, environment, parent, id, rectangle) {}


  virtual ~IGUIColorSelectDialog() {};


 };


}
}
# 66 "H:/CPP/irrlicht-1.3/include/irrlicht.h" 2
# 1 "H:/CPP/irrlicht-1.3/include/IGUIFont.h" 1
# 15 "H:/CPP/irrlicht-1.3/include/IGUIFont.h"
namespace irr
{
namespace gui
{


enum EGUI_FONT_TYPE
{

 EGFT_BITMAP = 0,





 EGFT_VECTOR,



 EGFT_OS,


 EGFT_CUSTOM
};


class IGUIFont : public virtual IUnknown
{
public:


 virtual ~IGUIFont() {};
# 56 "H:/CPP/irrlicht-1.3/include/IGUIFont.h"
 virtual void draw(const wchar_t* text, const core::rect<s32>& position,
  video::SColor color, bool hcenter=false, bool vcenter=false,
  const core::rect<s32>* clip=0) = 0;




 virtual core::dimension2d<s32> getDimension(const wchar_t* text) = 0;






 virtual s32 getCharacterFromPos(const wchar_t* text, s32 pixel_x) = 0;


 virtual EGUI_FONT_TYPE getType() { return EGFT_CUSTOM; }


 virtual void setKerningWidth (s32 kerning) = 0;
 virtual void setKerningHeight (s32 kerning) = 0;
# 88 "H:/CPP/irrlicht-1.3/include/IGUIFont.h"
 virtual s32 getKerningWidth(const wchar_t* thisLetter=0, const wchar_t* previousLetter=0) = 0;


 virtual s32 getKerningHeight() = 0;

};

}
}
# 67 "H:/CPP/irrlicht-1.3/include/irrlicht.h" 2
# 1 "H:/CPP/irrlicht-1.3/include/IGUIFontBitmap.h" 1
# 9 "H:/CPP/irrlicht-1.3/include/IGUIFontBitmap.h"
# 1 "H:/CPP/irrlicht-1.3/include/IGUISpriteBank.h" 1
# 10 "H:/CPP/irrlicht-1.3/include/IGUISpriteBank.h"
namespace irr
{

namespace video
{
 class ITexture;
}

namespace gui
{

struct SGUISpriteFrame
{
 u32 textureNumber;
 u32 rectNumber;
};

struct SGUISprite
{
 SGUISprite() : Frames(), frameTime(0) { };
 core::array<SGUISpriteFrame> Frames;
 u32 frameTime;
};



class IGUISpriteBank : public virtual IUnknown
{
public:


 virtual ~IGUISpriteBank() {};


 virtual core::array< core::rect<s32> >& getPositions() = 0;


 virtual core::array< SGUISprite >& getSprites() = 0;


 virtual u32 getTextureCount() = 0;


 virtual video::ITexture* getTexture(u32 index) = 0;


 virtual void addTexture(video::ITexture* texture) = 0;


 virtual void setTexture(u32 index, video::ITexture* texture) = 0;


 virtual void draw2DSprite(u32 index, const core::position2di& pos, const core::rect<s32>* clip=0,
   const video::SColor& color= video::SColor(255,255,255,255),
    u32 starttime=0, u32 currenttime=0, bool loop=true, bool center=false) = 0;

};

}
}
# 10 "H:/CPP/irrlicht-1.3/include/IGUIFontBitmap.h" 2

namespace irr
{
namespace gui
{


class IGUIFontBitmap : public IGUIFont
{
public:


 virtual ~IGUIFontBitmap() {};


 virtual EGUI_FONT_TYPE getType() { return EGFT_BITMAP; }


 virtual IGUISpriteBank* getSpriteBank() = 0;


 virtual u32 getSpriteNoFromChar(const wchar_t *c) = 0;
# 42 "H:/CPP/irrlicht-1.3/include/IGUIFontBitmap.h"
 virtual s32 getKerningWidth(const wchar_t* thisLetter=0, const wchar_t* previousLetter=0) = 0;

};

}
}
# 68 "H:/CPP/irrlicht-1.3/include/irrlicht.h" 2
# 1 "H:/CPP/irrlicht-1.3/include/IGUIImage.h" 1
# 11 "H:/CPP/irrlicht-1.3/include/IGUIImage.h"
namespace irr
{
namespace gui
{


 class IGUIImage : public IGUIElement
 {
 public:


  IGUIImage(IGUIEnvironment* environment, IGUIElement* parent, s32 id, core::rect<s32> rectangle)
   : IGUIElement(EGUIET_IMAGE, environment, parent, id, rectangle) {}


  ~IGUIImage() {};


  virtual void setImage(video::ITexture* image) = 0;


  virtual void setUseAlphaChannel(bool use) = 0;
 };


}
}
# 69 "H:/CPP/irrlicht-1.3/include/irrlicht.h" 2
# 1 "H:/CPP/irrlicht-1.3/include/IGUIInOutFader.h" 1
# 11 "H:/CPP/irrlicht-1.3/include/IGUIInOutFader.h"
namespace irr
{
namespace gui
{
# 27 "H:/CPP/irrlicht-1.3/include/IGUIInOutFader.h"
 class IGUIInOutFader : public IGUIElement
 {
 public:


  IGUIInOutFader(IGUIEnvironment* environment, IGUIElement* parent, s32 id, core::rect<s32> rectangle)
   : IGUIElement(EGUIET_IN_OUT_FADER, environment, parent, id, rectangle) {}


  ~IGUIInOutFader() {};


  virtual video::SColor getColor() const = 0;



  virtual void setColor(video::SColor color) = 0;
  virtual void setColor(video::SColor source, video::SColor dest) = 0;






  virtual void fadeIn(u32 time) = 0;






  virtual void fadeOut(u32 time) = 0;


  virtual bool isReady() const = 0;
 };


}
}
# 70 "H:/CPP/irrlicht-1.3/include/irrlicht.h" 2
# 1 "H:/CPP/irrlicht-1.3/include/IGUIListBox.h" 1
# 11 "H:/CPP/irrlicht-1.3/include/IGUIListBox.h"
namespace irr
{
namespace gui
{
 class IGUIFont;
 class IGUISpriteBank;


 class IGUIListBox : public IGUIElement
 {
 public:


  IGUIListBox(IGUIEnvironment* environment, IGUIElement* parent, s32 id, core::rect<s32> rectangle)
   : IGUIElement(EGUIET_LIST_BOX, environment, parent, id, rectangle) {}


  ~IGUIListBox() {};


  virtual s32 getItemCount() = 0;


  virtual const wchar_t* getListItem(s32 id) = 0;


  virtual s32 addItem(const wchar_t* text) = 0;






  virtual s32 addItem(const wchar_t* text, s32 icon) = 0;


  virtual void removeItem(s32 index) = 0;





  virtual void setSpriteBank(IGUISpriteBank* bank) = 0;


  virtual void clear() = 0;


  virtual s32 getSelected() = 0;


  virtual void setSelected(s32 id) = 0;
 };


}
}
# 71 "H:/CPP/irrlicht-1.3/include/irrlicht.h" 2
# 1 "H:/CPP/irrlicht-1.3/include/IGUIMeshViewer.h" 1
# 10 "H:/CPP/irrlicht-1.3/include/IGUIMeshViewer.h"
namespace irr
{

namespace video
{
 class SMaterial;
}

namespace scene
{
 class IAnimatedMesh;
}

namespace gui
{


 class IGUIMeshViewer : public IGUIElement
 {
 public:


  IGUIMeshViewer(IGUIEnvironment* environment, IGUIElement* parent, s32 id, core::rect<s32> rectangle)
   : IGUIElement(EGUIET_MESH_VIEWER, environment, parent, id, rectangle) {}


  ~IGUIMeshViewer() {};


  virtual void setMesh(scene::IAnimatedMesh* mesh) = 0;


  virtual void setMaterial(const video::SMaterial& material) = 0;


  virtual const video::SMaterial& getMaterial() = 0;

 };


}
}
# 72 "H:/CPP/irrlicht-1.3/include/irrlicht.h" 2
# 1 "H:/CPP/irrlicht-1.3/include/IGUIScrollBar.h" 1
# 10 "H:/CPP/irrlicht-1.3/include/IGUIScrollBar.h"
namespace irr
{
namespace gui
{


 class IGUIScrollBar : public IGUIElement
 {
 public:


  IGUIScrollBar(IGUIEnvironment* environment, IGUIElement* parent, s32 id, core::rect<s32> rectangle)
   : IGUIElement(EGUIET_SCROLL_BAR, environment, parent, id, rectangle) {}


  ~IGUIScrollBar() {};


  virtual void setMax(s32 max) = 0;


  virtual void setSmallStep(s32 step) = 0;


  virtual s32 getPos() = 0;


  virtual void setPos(s32 pos) = 0;
 };


}
}
# 73 "H:/CPP/irrlicht-1.3/include/irrlicht.h" 2

# 1 "H:/CPP/irrlicht-1.3/include/IGUIStaticText.h" 1
# 11 "H:/CPP/irrlicht-1.3/include/IGUIStaticText.h"
namespace irr
{
namespace gui
{
 class IGUIFont;


 class IGUIStaticText : public IGUIElement
 {
 public:


  IGUIStaticText(IGUIEnvironment* environment, IGUIElement* parent, s32 id, core::rect<s32> rectangle)
   : IGUIElement(EGUIET_STATIC_TEXT, environment, parent, id, rectangle) {}


  ~IGUIStaticText() {};




  virtual void setOverrideFont(IGUIFont* font=0) = 0;



  virtual IGUIFont * getOverrideFont(void) = 0;
# 46 "H:/CPP/irrlicht-1.3/include/IGUIStaticText.h"
  virtual void setOverrideColor(video::SColor color) = 0;



  virtual video::SColor const & getOverrideColor(void) = 0;





  virtual void enableOverrideColor(bool enable) = 0;



  virtual bool isOverrideColorEnabled(void) = 0;




  virtual void setWordWrap(bool enable) = 0;



  virtual bool isWordWrapEnabled(void) = 0;





  virtual s32 getTextHeight() = 0;




  virtual s32 getTextWidth(void) = 0;

 };


}
}
# 75 "H:/CPP/irrlicht-1.3/include/irrlicht.h" 2
# 1 "H:/CPP/irrlicht-1.3/include/IGUITabControl.h" 1
# 11 "H:/CPP/irrlicht-1.3/include/IGUITabControl.h"
namespace irr
{
namespace gui
{

 class IGUITab : public IGUIElement
 {
 public:


  IGUITab(IGUIEnvironment* environment, IGUIElement* parent, s32 id, core::rect<s32> rectangle)
   : IGUIElement(EGUIET_TAB, environment, parent, id, rectangle) {}


  virtual ~IGUITab() {};



  virtual s32 getNumber() = 0;


  virtual void setDrawBackground(bool draw=true) = 0;


  virtual void setBackgroundColor(video::SColor c) = 0;
 };


 class IGUITabControl : public IGUIElement
 {
 public:


  IGUITabControl(IGUIEnvironment* environment, IGUIElement* parent, s32 id, core::rect<s32> rectangle)
   : IGUIElement(EGUIET_TAB_CONTROL, environment, parent, id, rectangle) {}


  virtual ~IGUITabControl() {};


  virtual IGUITab* addTab(const wchar_t* caption, s32 id=-1) = 0;


  virtual s32 getTabcount() = 0;





  virtual IGUITab* getTab(s32 idx) = 0;




  virtual bool setActiveTab(s32 idx) = 0;




  virtual bool setActiveTab(IGUIElement *tab) = 0;


  virtual s32 getActiveTab() = 0;
 };


}
}
# 76 "H:/CPP/irrlicht-1.3/include/irrlicht.h" 2

# 1 "H:/CPP/irrlicht-1.3/include/IGUIToolbar.h" 1
# 10 "H:/CPP/irrlicht-1.3/include/IGUIToolbar.h"
namespace irr
{
namespace video
{
 class ITexture;
}
namespace gui
{
 class IGUIButton;


 class IGUIToolBar : public IGUIElement
 {
 public:


  IGUIToolBar(IGUIEnvironment* environment, IGUIElement* parent, s32 id, core::rect<s32> rectangle)
   : IGUIElement(EGUIET_TOOL_BAR, environment, parent, id, rectangle) {}


  ~IGUIToolBar() {};


  virtual IGUIButton* addButton(s32 id=-1, const wchar_t* text=0,const wchar_t* tooltiptext=0,
   video::ITexture* img=0, video::ITexture* pressedimg=0,
   bool isPushButton=false, bool useAlphaChannel=false) = 0;
 };


}
}
# 78 "H:/CPP/irrlicht-1.3/include/irrlicht.h" 2

# 1 "H:/CPP/irrlicht-1.3/include/ILightSceneNode.h" 1
# 11 "H:/CPP/irrlicht-1.3/include/ILightSceneNode.h"
namespace irr
{
namespace scene
{
# 23 "H:/CPP/irrlicht-1.3/include/ILightSceneNode.h"
class ILightSceneNode : public ISceneNode
{
public:


 ILightSceneNode(ISceneNode* parent, ISceneManager* mgr, s32 id,
  const core::vector3df& position = core::vector3df(0,0,0))
  : ISceneNode(parent, mgr, id, position) {}


 virtual void setLightData(const video::SLight& light) = 0;



 virtual video::SLight& getLightData() = 0;

};

}
}
# 80 "H:/CPP/irrlicht-1.3/include/irrlicht.h" 2



# 1 "H:/CPP/irrlicht-1.3/include/IMeshCache.h" 1
# 11 "H:/CPP/irrlicht-1.3/include/IMeshCache.h"
namespace irr
{

namespace scene
{
 class IMesh;
 class IAnimatedMesh;
 class IAnimatedMeshSceneNode;
 class IMeshLoader;







 class IMeshCache : public virtual IUnknown
 {
 public:


  virtual ~IMeshCache() {};
# 45 "H:/CPP/irrlicht-1.3/include/IMeshCache.h"
  virtual void addMesh(const c8* filename, IAnimatedMesh* mesh) = 0;




  virtual void removeMesh(IAnimatedMesh* mesh) = 0;





  virtual s32 getMeshCount() = 0;


  virtual s32 getMeshIndex(IAnimatedMesh* mesh) = 0;





  virtual IAnimatedMesh* getMeshByIndex(s32 index) = 0;




  virtual const c8* getMeshFilename(s32 index) = 0;



  virtual const c8* getMeshFilename(IAnimatedMesh* mesh) = 0;



  virtual const c8* getMeshFilename(IMesh* mesh) = 0;
 };


}
}
# 84 "H:/CPP/irrlicht-1.3/include/irrlicht.h" 2
# 1 "H:/CPP/irrlicht-1.3/include/IMeshSceneNode.h" 1
# 10 "H:/CPP/irrlicht-1.3/include/IMeshSceneNode.h"
namespace irr
{
namespace scene
{

class IMesh;



class IMeshSceneNode : public ISceneNode
{
public:


 IMeshSceneNode(ISceneNode* parent, ISceneManager* mgr, s32 id,
  const core::vector3df& position, const core::vector3df& rotation,
   const core::vector3df& scale)
  : ISceneNode(parent, mgr, id, position, rotation, scale) {}


 virtual void setMesh(IMesh* mesh) = 0;


 virtual IMesh* getMesh(void) = 0;




 virtual void setReadOnlyMaterials(bool readonly) = 0;


 virtual bool isReadOnlyMaterials() = 0;
};

}
}
# 85 "H:/CPP/irrlicht-1.3/include/irrlicht.h" 2
# 1 "H:/CPP/irrlicht-1.3/include/IMeshManipulator.h" 1
# 14 "H:/CPP/irrlicht-1.3/include/IMeshManipulator.h"
namespace irr
{
namespace scene
{

 class IMesh;
 class IAnimatedMesh;
 struct SMesh;






 class IMeshManipulator : public virtual IUnknown
 {
 public:


  virtual ~IMeshManipulator() {};





  virtual void flipSurfaces(IMesh* mesh) const = 0;




  virtual void setVertexColorAlpha(IMesh* mesh, s32 alpha) const = 0;


  virtual void setVertexColors(IMesh* mesh, video::SColor color) const = 0;



  virtual void recalculateNormals(IMesh* mesh, bool smooth = false) const = 0;



  virtual void recalculateNormals(IMeshBuffer* buffer, bool smooth = false) const = 0;




  virtual void scaleMesh(IMesh* mesh, const core::vector3df& scale) const = 0;




  virtual void transformMesh(IMesh* mesh, const core::matrix4& m) const = 0;
# 74 "H:/CPP/irrlicht-1.3/include/IMeshManipulator.h"
  virtual SMesh* createMeshCopy(IMesh* mesh) const = 0;







  virtual void makePlanarTextureMapping(IMesh* mesh, f32 resolution=0.001f) const = 0;
# 91 "H:/CPP/irrlicht-1.3/include/IMeshManipulator.h"
  virtual IMesh* createMeshWithTangents(IMesh* mesh) const = 0;


  virtual IMesh* createMeshUniquePrimitives(IMesh* mesh) const = 0;


  virtual void recalculateBoundingBox(scene::IMeshBuffer* buffer) const = 0;


  virtual s32 getPolyCount(scene::IMesh* mesh) const = 0;


  virtual s32 getPolyCount(scene::IAnimatedMesh* mesh) const = 0;


  virtual IAnimatedMesh * createAnimatedMesh(scene::IMesh* mesh,
   scene::E_ANIMATED_MESH_TYPE type = scene::EAMT_UNKNOWN) const = 0;

 };

}
}
# 86 "H:/CPP/irrlicht-1.3/include/irrlicht.h" 2
# 1 "H:/CPP/irrlicht-1.3/include/IMetaTriangleSelector.h" 1
# 10 "H:/CPP/irrlicht-1.3/include/IMetaTriangleSelector.h"
namespace irr
{
namespace scene
{






class IMetaTriangleSelector : public ITriangleSelector
{
public:




 virtual void addTriangleSelector(ITriangleSelector* toAdd) = 0;





 virtual bool removeTriangleSelector(ITriangleSelector* toRemove) = 0;


 virtual void removeAllTriangleSelectors() = 0;
};

}
}
# 87 "H:/CPP/irrlicht-1.3/include/irrlicht.h" 2

# 1 "H:/CPP/irrlicht-1.3/include/IrrlichtDevice.h" 1
# 17 "H:/CPP/irrlicht-1.3/include/IrrlichtDevice.h"
# 1 "H:/CPP/irrlicht-1.3/include/ICursorControl.h" 1
# 12 "H:/CPP/irrlicht-1.3/include/ICursorControl.h"
namespace irr
{
namespace gui
{


 class ICursorControl : public virtual IUnknown
 {
 public:




  virtual void setVisible(bool visible) = 0;



  virtual bool isVisible() = 0;






  virtual void setPosition(const core::position2d<f32> &pos) = 0;






  virtual void setPosition(f32 x, f32 y) = 0;



  virtual void setPosition(const core::position2d<s32> &pos) = 0;



  virtual void setPosition(s32 x, s32 y) = 0;




  virtual core::position2d<s32> getPosition() = 0;






  virtual core::position2d<f32> getRelativePosition() = 0;
 };


}
}
# 18 "H:/CPP/irrlicht-1.3/include/IrrlichtDevice.h" 2
# 1 "H:/CPP/irrlicht-1.3/include/IVideoModeList.h" 1
# 11 "H:/CPP/irrlicht-1.3/include/IVideoModeList.h"
namespace irr
{
namespace video
{
# 23 "H:/CPP/irrlicht-1.3/include/IVideoModeList.h"
 class IVideoModeList : public virtual IUnknown
 {
 public:


  virtual ~IVideoModeList() {}



  virtual s32 getVideoModeCount() const = 0;




  virtual core::dimension2d<s32> getVideoModeResolution(s32 modeNumber) const = 0;




  virtual s32 getVideoModeDepth(s32 modeNumber) const = 0;



  virtual core::dimension2d<s32> getDesktopResolution() const = 0;



  virtual s32 getDesktopDepth() const = 0;
 };

}
}
# 19 "H:/CPP/irrlicht-1.3/include/IrrlichtDevice.h" 2
# 1 "H:/CPP/irrlicht-1.3/include/ITimer.h" 1
# 10 "H:/CPP/irrlicht-1.3/include/ITimer.h"
namespace irr
{


class ITimer : public virtual IUnknown
{
public:


 virtual ~ITimer() {}





 virtual u32 getRealTime() = 0;





 virtual u32 getTime() = 0;


 virtual void setTime(u32 time) = 0;





 virtual void stop() = 0;





 virtual void start() = 0;




 virtual void setSpeed(f32 speed = 1.0f) = 0;




 virtual f32 getSpeed() = 0;


 virtual bool isStopped() = 0;





 virtual void tick() = 0;
};

}
# 20 "H:/CPP/irrlicht-1.3/include/IrrlichtDevice.h" 2

# 1 "H:/CPP/irrlicht-1.3/include/IOSOperator.h" 1
# 10 "H:/CPP/irrlicht-1.3/include/IOSOperator.h"
namespace irr
{




class IOSOperator : public virtual IUnknown
{
public:


 virtual ~IOSOperator() {}


 virtual const wchar_t* getOperationSystemVersion() = 0;


 virtual void copyToClipboard(const c8* text) = 0;



 virtual c8* getTextFromClipboard() = 0;




 virtual bool getProcessorSpeedMHz(irr::u32* MHz) = 0;





 virtual bool getSystemMemory(irr::u32* Total, irr::u32* Avail) = 0;

};

}
# 22 "H:/CPP/irrlicht-1.3/include/IrrlichtDevice.h" 2

namespace irr
{




 class IrrlichtDevice : public virtual IUnknown
 {
 public:


  virtual ~IrrlichtDevice() {};
# 63 "H:/CPP/irrlicht-1.3/include/IrrlichtDevice.h"
  virtual bool run() = 0;



  virtual void yield() = 0;






  virtual void sleep(u32 timeMs, bool pauseTimer=false) = 0;



  virtual video::IVideoDriver* getVideoDriver() = 0;



  virtual io::IFileSystem* getFileSystem() = 0;



  virtual gui::IGUIEnvironment* getGUIEnvironment() = 0;


  virtual scene::ISceneManager* getSceneManager() = 0;



  virtual gui::ICursorControl* getCursorControl() = 0;



  virtual ILogger* getLogger() = 0;
# 108 "H:/CPP/irrlicht-1.3/include/IrrlichtDevice.h"
  virtual video::IVideoModeList* getVideoModeList() = 0;






  virtual IOSOperator* getOSOperator() = 0;




  virtual ITimer* getTimer() = 0;



  virtual void setWindowCaption(const wchar_t* text) = 0;
# 137 "H:/CPP/irrlicht-1.3/include/IrrlichtDevice.h"
  virtual bool isWindowActive() = 0;



  virtual void closeDevice() = 0;




  virtual const c8* getVersion() = 0;


  virtual void setEventReceiver(IEventReceiver* receiver) = 0;


  virtual IEventReceiver* getEventReceiver() = 0;






  virtual void postEventFromUser(SEvent event) = 0;



  virtual void setResizeAble(bool resize=false) = 0;
 };

}
# 89 "H:/CPP/irrlicht-1.3/include/irrlicht.h" 2





# 1 "H:/CPP/irrlicht-1.3/include/ISceneUserDataSerializer.h" 1
# 10 "H:/CPP/irrlicht-1.3/include/ISceneUserDataSerializer.h"
namespace irr
{
namespace io
{
 class IAttributes;
}
namespace scene
{
 class ISceneNode;





class ISceneUserDataSerializer
{
public:

 virtual ~ISceneUserDataSerializer() {}




 virtual void OnReadUserData(ISceneNode* forSceneNode, io::IAttributes* userData) = 0;







 virtual io::IAttributes* createUserData(ISceneNode* forSceneNode) = 0;
};

}
}
# 95 "H:/CPP/irrlicht-1.3/include/irrlicht.h" 2


# 1 "H:/CPP/irrlicht-1.3/include/ISceneCollisionManager.h" 1
# 14 "H:/CPP/irrlicht-1.3/include/ISceneCollisionManager.h"
namespace irr
{


namespace scene
{
 class ISceneNode;
 class ICameraSceneNode;
 class ITriangleSelector;


 class ISceneCollisionManager : public virtual IUnknown
 {
 public:


  virtual ~ISceneCollisionManager() {};
# 42 "H:/CPP/irrlicht-1.3/include/ISceneCollisionManager.h"
  virtual bool getCollisionPoint(const core::line3d<f32>& ray,
   ITriangleSelector* selector, core::vector3df& outCollisionPoint,
   core::triangle3df& outTriangle) = 0;
# 66 "H:/CPP/irrlicht-1.3/include/ISceneCollisionManager.h"
  virtual core::vector3df getCollisionResultPosition(
   ITriangleSelector* selector,
   const core::vector3df &ellipsoidPosition,
   const core::vector3df& ellipsoidRadius,
   const core::vector3df& ellipsoidDirectionAndSpeed,
   core::triangle3df& triout,
   bool& outFalling,
   f32 slidingSpeed = 0.0005f,
   const core::vector3df& gravityDirectionAndSpeed
   = core::vector3df(0.0f, 0.0f, 0.0f)) = 0;
# 84 "H:/CPP/irrlicht-1.3/include/ISceneCollisionManager.h"
  virtual core::line3d<f32> getRayFromScreenCoordinates(
   core::position2d<s32> pos, ICameraSceneNode* camera = 0) = 0;
# 98 "H:/CPP/irrlicht-1.3/include/ISceneCollisionManager.h"
  virtual core::position2d<s32> getScreenCoordinatesFrom3DPosition(
   core::vector3df pos, ICameraSceneNode* camera=0) = 0;
# 112 "H:/CPP/irrlicht-1.3/include/ISceneCollisionManager.h"
  virtual ISceneNode* getSceneNodeFromScreenCoordinatesBB(core::position2d<s32> pos,
   s32 idBitMask=0, bool bNoDebugObjects = false) = 0;
# 126 "H:/CPP/irrlicht-1.3/include/ISceneCollisionManager.h"
  virtual ISceneNode* getSceneNodeFromRayBB(core::line3d<f32> ray,
   s32 idBitMask=0, bool bNoDebugObjects = false) = 0;
# 142 "H:/CPP/irrlicht-1.3/include/ISceneCollisionManager.h"
  virtual ISceneNode* getSceneNodeFromCameraBB(ICameraSceneNode* camera,
   s32 idBitMask=0, bool bNoDebugObjects = false) = 0;
 };


}
}
# 98 "H:/CPP/irrlicht-1.3/include/irrlicht.h" 2

# 1 "H:/CPP/irrlicht-1.3/include/IMaterialRendererServices.h" 1
# 12 "H:/CPP/irrlicht-1.3/include/IMaterialRendererServices.h"
namespace irr
{
namespace video
{

class IVideoDriver;



class IMaterialRendererServices
{
public:


 virtual ~IMaterialRendererServices() {}






 virtual void setBasicRenderStates(const SMaterial& material,
  const SMaterial& lastMaterial,
  bool resetAllRenderstates) = 0;
# 60 "H:/CPP/irrlicht-1.3/include/IMaterialRendererServices.h"
 virtual bool setVertexShaderConstant(const c8* name, const f32* floats, int count) = 0;






 virtual void setVertexShaderConstant(const f32* data, s32 startRegister, s32 constantAmount=1) = 0;
# 76 "H:/CPP/irrlicht-1.3/include/IMaterialRendererServices.h"
 virtual bool setPixelShaderConstant(const c8* name, const f32* floats, int count) = 0;






 virtual void setPixelShaderConstant(const f32* data, s32 startRegister, s32 constantAmount=1) = 0;


 virtual IVideoDriver* getVideoDriver() = 0;
};

}
}
# 100 "H:/CPP/irrlicht-1.3/include/irrlicht.h" 2
# 1 "H:/CPP/irrlicht-1.3/include/ISceneNodeFactory.h" 1
# 11 "H:/CPP/irrlicht-1.3/include/ISceneNodeFactory.h"
namespace irr
{


namespace scene
{
 class ISceneNode;
# 28 "H:/CPP/irrlicht-1.3/include/ISceneNodeFactory.h"
 class ISceneNodeFactory : public virtual IUnknown
 {
 public:





  virtual ISceneNode* addSceneNode(ESCENE_NODE_TYPE type, ISceneNode* parent=0) = 0;





  virtual ISceneNode* addSceneNode(const c8* typeName, ISceneNode* parent=0) = 0;


  virtual s32 getCreatableSceneNodeTypeCount() = 0;




  virtual ESCENE_NODE_TYPE getCreateableSceneNodeType(s32 idx) = 0;




  virtual const c8* getCreateableSceneNodeTypeName(s32 idx) = 0;




  virtual const c8* getCreateableSceneNodeTypeName(ESCENE_NODE_TYPE type) = 0;
 };


}
}
# 101 "H:/CPP/irrlicht-1.3/include/irrlicht.h" 2
# 1 "H:/CPP/irrlicht-1.3/include/ISceneNodeAnimatorFactory.h" 1
# 11 "H:/CPP/irrlicht-1.3/include/ISceneNodeAnimatorFactory.h"
namespace irr
{
namespace scene
{
 class ISceneNode;
 class ISceneNodeAnimator;
# 27 "H:/CPP/irrlicht-1.3/include/ISceneNodeAnimatorFactory.h"
 class ISceneNodeAnimatorFactory : public virtual IUnknown
 {
 public:






  virtual ISceneNodeAnimator* createSceneNodeAnimator(ESCENE_NODE_ANIMATOR_TYPE type, ISceneNode* target) = 0;






  virtual ISceneNodeAnimator* createSceneNodeAnimator(const c8* typeName, ISceneNode* target) = 0;


  virtual s32 getCreatableSceneNodeAnimatorTypeCount() = 0;




  virtual ESCENE_NODE_ANIMATOR_TYPE getCreateableSceneNodeAnimatorType(s32 idx) = 0;




  virtual const c8* getCreateableSceneNodeAnimatorTypeName(s32 idx) = 0;




  virtual const c8* getCreateableSceneNodeAnimatorTypeName(ESCENE_NODE_ANIMATOR_TYPE type) = 0;
 };


}
}
# 102 "H:/CPP/irrlicht-1.3/include/irrlicht.h" 2
# 1 "H:/CPP/irrlicht-1.3/include/ISceneNodeAnimatorCollisionResponse.h" 1
# 10 "H:/CPP/irrlicht-1.3/include/ISceneNodeAnimatorCollisionResponse.h"
namespace irr
{
namespace scene
{
# 23 "H:/CPP/irrlicht-1.3/include/ISceneNodeAnimatorCollisionResponse.h"
 class ISceneNodeAnimatorCollisionResponse : public ISceneNodeAnimator
 {
 public:


  virtual ~ISceneNodeAnimatorCollisionResponse() {}






  virtual bool isFalling() = 0;
# 46 "H:/CPP/irrlicht-1.3/include/ISceneNodeAnimatorCollisionResponse.h"
  virtual void setEllipsoidRadius(const core::vector3df& radius) = 0;




  virtual core::vector3df getEllipsoidRadius() const = 0;






  virtual void setGravity(const core::vector3df& gravity) = 0;



  virtual core::vector3df getGravity() const = 0;







  virtual void setEllipsoidTranslation(const core::vector3df &translation) = 0;






  virtual core::vector3df getEllipsoidTranslation() const = 0;





  virtual void setWorld(ITriangleSelector* newWorld) = 0;



  virtual ITriangleSelector* getWorld() const = 0;
 };
}
}
# 103 "H:/CPP/irrlicht-1.3/include/irrlicht.h" 2
# 1 "H:/CPP/irrlicht-1.3/include/IShaderConstantSetCallBack.h" 1
# 10 "H:/CPP/irrlicht-1.3/include/IShaderConstantSetCallBack.h"
namespace irr
{
namespace video
{
 class IMaterialRendererServices;





class IShaderConstantSetCallBack : public virtual IUnknown
{
public:


 virtual ~IShaderConstantSetCallBack() {}
# 58 "H:/CPP/irrlicht-1.3/include/IShaderConstantSetCallBack.h"
 virtual void OnSetConstants(IMaterialRendererServices* services, s32 userData) = 0;
};


}
}
# 104 "H:/CPP/irrlicht-1.3/include/irrlicht.h" 2
# 1 "H:/CPP/irrlicht-1.3/include/IParticleSystemSceneNode.h" 1
# 9 "H:/CPP/irrlicht-1.3/include/IParticleSystemSceneNode.h"
# 1 "H:/CPP/irrlicht-1.3/include/IParticleEmitter.h" 1
# 9 "H:/CPP/irrlicht-1.3/include/IParticleEmitter.h"
# 1 "H:/CPP/irrlicht-1.3/include/SParticle.h" 1
# 11 "H:/CPP/irrlicht-1.3/include/SParticle.h"
namespace irr
{
namespace scene
{

 struct SParticle
 {

  core::vector3df pos;


  core::vector3df vector;


  u32 startTime;


  u32 endTime;


  video::SColor color;



  video::SColor startColor;




  core::vector3df startVector;
 };


}
}
# 10 "H:/CPP/irrlicht-1.3/include/IParticleEmitter.h" 2

namespace irr
{
namespace scene
{


enum E_PARTICLE_EMITTER_TYPE
{
 EPET_POINT = 0,
 EPET_BOX,
 EPET_COUNT
};


const c8* const ParticleEmitterTypeNames[] =
{
 "Point",
 "Box",
 0
};




class IParticleEmitter : public virtual io::IAttributeExchangingObject
{
public:


 virtual ~IParticleEmitter() {};
# 49 "H:/CPP/irrlicht-1.3/include/IParticleEmitter.h"
 virtual s32 emitt(u32 now, u32 timeSinceLastCall, SParticle*& outArray) = 0;




 virtual void serializeAttributes(io::IAttributes* out, io::SAttributeReadWriteOptions* options=0) {}






 virtual s32 deserializeAttributes(s32 startIndex, io::IAttributes* in, io::SAttributeReadWriteOptions* options=0) { return 0; }


 virtual E_PARTICLE_EMITTER_TYPE getType() = 0;
};

}
}
# 10 "H:/CPP/irrlicht-1.3/include/IParticleSystemSceneNode.h" 2
# 1 "H:/CPP/irrlicht-1.3/include/IParticleAffector.h" 1
# 11 "H:/CPP/irrlicht-1.3/include/IParticleAffector.h"
namespace irr
{
namespace scene
{


enum E_PARTICLE_AFFECTOR_TYPE
{
 EPAT_NONE = 0,
 EPAT_FADE_OUT,
 EPAT_GRAVITY,
 EPAT_COUNT
};


const c8* const ParticleAffectorTypeNames[] =
{
 "None",
 "FadeOut",
 "Gravity",
 0
};


class IParticleAffector : public virtual io::IAttributeExchangingObject
{
public:


 IParticleAffector() : Enabled(true) {}





 virtual void affect(u32 now, SParticle* particlearray, u32 count) = 0;


 virtual void setEnabled(bool enabled) {Enabled = enabled;}


 virtual bool getEnabled() const { return Enabled;}




 virtual void serializeAttributes(io::IAttributes* out, io::SAttributeReadWriteOptions* options=0) {}






 virtual s32 deserializeAttributes(s32 startIndex, io::IAttributes* in, io::SAttributeReadWriteOptions* options=0) { return 0; }


 virtual E_PARTICLE_AFFECTOR_TYPE getType() = 0;

protected:
 bool Enabled;
};

}
}
# 11 "H:/CPP/irrlicht-1.3/include/IParticleSystemSceneNode.h" 2


namespace irr
{
namespace scene
{
# 38 "H:/CPP/irrlicht-1.3/include/IParticleSystemSceneNode.h"
class IParticleSystemSceneNode : public ISceneNode
{
public:


 IParticleSystemSceneNode(ISceneNode* parent, ISceneManager* mgr, s32 id,
  const core::vector3df& position = core::vector3df(0,0,0),
  const core::vector3df& rotation = core::vector3df(0,0,0),
  const core::vector3df& scale = core::vector3df(1.0f, 1.0f, 1.0f))
   : ISceneNode(parent, mgr, id, position, rotation, scale) {}


 virtual void setParticleSize(
  const core::dimension2d<f32> &size = core::dimension2d<f32>(5.0f, 5.0f)) = 0;




 virtual void setParticlesAreGlobal(bool global) = 0;
# 65 "H:/CPP/irrlicht-1.3/include/IParticleSystemSceneNode.h"
 virtual void setEmitter(IParticleEmitter* emitter) = 0;
# 75 "H:/CPP/irrlicht-1.3/include/IParticleSystemSceneNode.h"
 virtual void addAffector(IParticleAffector* affector) = 0;


 virtual void removeAllAffectors() = 0;
# 101 "H:/CPP/irrlicht-1.3/include/IParticleSystemSceneNode.h"
 virtual IParticleEmitter* createPointEmitter(
  const core::vector3df& direction = core::vector3df(0.0f,0.03f,0.0f),
  u32 minParticlesPerSecond = 5,
  u32 maxParticlesPerSecond = 10,
  video::SColor minStartColor = video::SColor(255,0,0,0),
  video::SColor maxStartColor = video::SColor(255,255,255,255),
  u32 lifeTimeMin=2000, u32 lifeTimeMax=4000,
  s32 maxAngleDegrees=0) = 0;
# 132 "H:/CPP/irrlicht-1.3/include/IParticleSystemSceneNode.h"
 virtual IParticleEmitter* createBoxEmitter(
  const core::aabbox3df& box = core::aabbox3df(-10,28,-10,10,30,10),
  const core::vector3df& direction = core::vector3df(0.0f,0.03f,0.0f),
  u32 minParticlesPerSecond = 5,
  u32 maxParticlesPerSecond = 10,
  video::SColor minStartColor = video::SColor(255,0,0,0),
  video::SColor maxStartColor = video::SColor(255,255,255,255),
  u32 lifeTimeMin=2000, u32 lifeTimeMax=4000,
  s32 maxAngleDegrees=0) = 0;
# 156 "H:/CPP/irrlicht-1.3/include/IParticleSystemSceneNode.h"
 virtual IParticleAffector* createFadeOutParticleAffector(
  video::SColor targetColor = video::SColor(0,0,0,0),
  u32 timeNeededToFadeOut = 1000) = 0;
# 174 "H:/CPP/irrlicht-1.3/include/IParticleSystemSceneNode.h"
 virtual IParticleAffector* createGravityAffector(
  const core::vector3df& gravity = core::vector3df(0.0f,-0.03f,0.0f),
  u32 timeForceLost = 1000) = 0;
};

}
}
# 105 "H:/CPP/irrlicht-1.3/include/irrlicht.h" 2
# 1 "H:/CPP/irrlicht-1.3/include/ITerrainSceneNode.h" 1
# 15 "H:/CPP/irrlicht-1.3/include/ITerrainSceneNode.h"
# 1 "H:/CPP/irrlicht-1.3/include/SMeshBufferLightMap.h" 1
# 11 "H:/CPP/irrlicht-1.3/include/SMeshBufferLightMap.h"
namespace irr
{
namespace scene
{

 struct SMeshBufferLightMap : public IMeshBuffer
 {

  SMeshBufferLightMap()
  {



  }


  ~SMeshBufferLightMap() {};


  virtual const video::SMaterial& getMaterial() const
  {
   return Material;
  }



  video::SMaterial& getMaterial()
  {
   return Material;
  }


  virtual const void* getVertices() const
  {
   return Vertices.const_pointer();
  }


  virtual void* getVertices()
  {
   return Vertices.pointer();
  }


  virtual u32 getVertexCount() const
  {
   return Vertices.size();
  }


  virtual const u16* getIndices() const
  {
   return Indices.const_pointer();
  }


  virtual u16* getIndices()
  {
   return Indices.pointer();
  }


  virtual u32 getIndexCount() const
  {
   return Indices.size();
  }


  virtual const core::aabbox3d<f32>& getBoundingBox() const
  {
   return BoundingBox;
  }


  virtual void setBoundingBox( const core::aabbox3df& box)
  {
   BoundingBox = box;
  }



  void recalculateBoundingBox()
  {
   if (Vertices.empty())
    BoundingBox.reset(0,0,0);
   else
   {
    BoundingBox.reset(Vertices[0].Pos);
    for (u32 i=1; i<Vertices.size(); ++i)
     BoundingBox.addInternalPoint(Vertices[i].Pos);
   }
  }


  virtual video::E_VERTEX_TYPE getVertexType() const
  {
   return video::EVT_2TCOORDS;
  }


  virtual u32 getVertexPitch() const
  {
   return sizeof ( video::S3DVertex2TCoords );
  }


  video::SMaterial Material;
  core::array<video::S3DVertex2TCoords> Vertices;
  core::array<u16> Indices;
  core::aabbox3d<f32> BoundingBox;
 };

}
}
# 16 "H:/CPP/irrlicht-1.3/include/ITerrainSceneNode.h" 2



namespace irr
{
namespace scene
{
# 44 "H:/CPP/irrlicht-1.3/include/ITerrainSceneNode.h"
 class ITerrainSceneNode : public ISceneNode
 {
 public:


  ITerrainSceneNode(ISceneNode* parent, ISceneManager* mgr, s32 id,
   const core::vector3df& position = core::vector3df(0.0f, 0.0f, 0.0f),
   const core::vector3df& rotation = core::vector3df(0.0f, 0.0f, 0.0f),
   const core::vector3df& scale = core::vector3df(1.0f, 1.0f, 1.0f) )
   : ISceneNode (parent, mgr, id, position, rotation, scale) {}


  virtual ~ITerrainSceneNode() {};


  virtual const core::aabbox3d<f32>& getBoundingBox ( ) const = 0;


  virtual const core::aabbox3d<f32>& getBoundingBox (s32 patchX, s32 patchZ) const = 0;


  virtual u32 getIndexCount() = 0;


  virtual IMesh* getMesh() = 0;




  virtual void getMeshBufferForLOD(SMeshBufferLightMap& mb, s32 LOD) = 0;
# 83 "H:/CPP/irrlicht-1.3/include/ITerrainSceneNode.h"
  virtual s32 getIndicesForPatch(core::array<u32>& indices,
   s32 patchX, s32 patchZ, s32 LOD = 0 ) = 0;




  virtual s32 getCurrentLODOfPatches(core::array<s32>& LODs) = 0;





  virtual void setLODOfPatch( s32 patchX, s32 patchZ, s32 LOD ) = 0;


  virtual core::vector3df getTerrainCenter() = 0;


  virtual f32 getHeight( f32 x, f32 y ) = 0;




  virtual void setCameraMovementDelta(f32 delta) = 0;




  virtual void setCameraRotationDelta(f32 delta) = 0;



  virtual void setDynamicSelectorUpdate(bool bVal) = 0;







  virtual bool overrideLODDistance(s32 LOD, f64 newDistance) = 0;
# 133 "H:/CPP/irrlicht-1.3/include/ITerrainSceneNode.h"
  virtual void scaleTexture(f32 scale = 1.0f, f32 scale2 = 0.0f) = 0;
 };

}
}
# 106 "H:/CPP/irrlicht-1.3/include/irrlicht.h" 2
# 1 "H:/CPP/irrlicht-1.3/include/ITextSceneNode.h" 1
# 10 "H:/CPP/irrlicht-1.3/include/ITextSceneNode.h"
namespace irr
{
namespace scene
{


class ITextSceneNode : public ISceneNode
{
public:


 ITextSceneNode(ISceneNode* parent, ISceneManager* mgr, s32 id,
  const core::vector3df& position = core::vector3df(0,0,0))
   : ISceneNode(parent, mgr, id, position) {}


 virtual void setText(const wchar_t* text) = 0;


 virtual void setTextColor(video::SColor color) = 0;
};

}
}
# 107 "H:/CPP/irrlicht-1.3/include/irrlicht.h" 2


# 1 "H:/CPP/irrlicht-1.3/include/IBillboardSceneNode.h" 1
# 10 "H:/CPP/irrlicht-1.3/include/IBillboardSceneNode.h"
namespace irr
{
namespace scene
{






class IBillboardSceneNode : public ISceneNode
{
public:


 IBillboardSceneNode(ISceneNode* parent, ISceneManager* mgr, s32 id,
  const core::vector3df& position = core::vector3df(0,0,0))
  : ISceneNode(parent, mgr, id, position) {}


 virtual void setSize(const core::dimension2d<f32>& size) = 0;


 virtual const core::dimension2d<f32>& getSize() = 0;



 virtual void setColor(const video::SColor & overallColor) = 0;




 virtual void setColor(const video::SColor & topColor, const video::SColor & bottomColor) = 0;




 virtual void getColor(video::SColor & topColor, video::SColor & bottomColor) = 0;

};

}
}
# 110 "H:/CPP/irrlicht-1.3/include/irrlicht.h" 2




# 1 "H:/CPP/irrlicht-1.3/include/IWriteFile.h" 1
# 10 "H:/CPP/irrlicht-1.3/include/IWriteFile.h"
namespace irr
{
namespace io
{


 class IWriteFile : public virtual IUnknown
 {
 public:

  virtual ~IWriteFile() {};





  virtual s32 write(const void* buffer, s32 sizeToWrite) = 0;







  virtual bool seek(s32 finalPos, bool relativeMovement = false) = 0;



  virtual s32 getPos() = 0;



  virtual const c8* getFileName() = 0;
 };


 IWriteFile* createWriteFile(const c8* fileName, bool append);

}
}
# 115 "H:/CPP/irrlicht-1.3/include/irrlicht.h" 2

# 1 "H:/CPP/irrlicht-1.3/include/IXMLWriter.h" 1
# 12 "H:/CPP/irrlicht-1.3/include/IXMLWriter.h"
namespace irr
{
namespace io
{





 class IXMLWriter : public virtual IUnknown
 {
 public:


  virtual ~IXMLWriter() {};




  virtual void writeXMLHeader() = 0;
# 48 "H:/CPP/irrlicht-1.3/include/IXMLWriter.h"
  virtual void writeElement(const wchar_t* name, bool empty=false,
   const wchar_t* attr1Name = 0, const wchar_t* attr1Value = 0,
   const wchar_t* attr2Name = 0, const wchar_t* attr2Value = 0,
   const wchar_t* attr3Name = 0, const wchar_t* attr3Value = 0,
   const wchar_t* attr4Name = 0, const wchar_t* attr4Value = 0,
   const wchar_t* attr5Name = 0, const wchar_t* attr5Value = 0) = 0;


  virtual void writeElement(const wchar_t* name, bool empty,
    core::array<core::stringw> &names, core::array<core::stringw> &values) = 0;


  virtual void writeComment(const wchar_t* comment) = 0;


  virtual void writeClosingTag(const wchar_t* name) = 0;



  virtual void writeText(const wchar_t* text) = 0;


  virtual void writeLineBreak() = 0;
 };

}
}
# 117 "H:/CPP/irrlicht-1.3/include/irrlicht.h" 2
# 130 "H:/CPP/irrlicht-1.3/include/irrlicht.h"
# 1 "H:/CPP/irrlicht-1.3/include/SAnimatedMesh.h" 1
# 13 "H:/CPP/irrlicht-1.3/include/SAnimatedMesh.h"
namespace irr
{
namespace scene
{


 struct SAnimatedMesh : public IAnimatedMesh
 {

  SAnimatedMesh()
  {




   Type = EAMT_UNKNOWN;
  }



  ~SAnimatedMesh()
  {

   for (u32 i=0; i<Meshes.size(); ++i)
    Meshes[i]->drop();
  };




  virtual s32 getFrameCount()
  {
   return Meshes.size();
  }
# 58 "H:/CPP/irrlicht-1.3/include/SAnimatedMesh.h"
  virtual IMesh* getMesh(s32 frame, s32 detailLevel, s32 startFrameLoop=-1, s32 endFrameLoop=-1)
  {
   if (Meshes.empty())
    return 0;

   return Meshes[frame];
  }



  void addMesh(IMesh* mesh)
  {
   if (mesh)
   {
    mesh->grab();
    Meshes.push_back(mesh);
   }
  }




  virtual const core::aabbox3d<f32>& getBoundingBox() const
  {
   return Box;
  }


  virtual void setBoundingBox( const core::aabbox3df& box)
  {
   Box = box;
  }

  void recalculateBoundingBox()
  {
   Box.reset(0,0,0);

   if (Meshes.empty())
    return;

   Box = Meshes[0]->getBoundingBox();

   for (u32 i=1; i<Meshes.size(); ++i)
    Box.addInternalBox(Meshes[i]->getBoundingBox());
  }



  virtual E_ANIMATED_MESH_TYPE getMeshType() const
  {
   return Type;
  }

  core::aabbox3d<f32> Box;
  core::array<IMesh*> Meshes;
  E_ANIMATED_MESH_TYPE Type;
 };


}
}
# 131 "H:/CPP/irrlicht-1.3/include/irrlicht.h" 2
# 1 "H:/CPP/irrlicht-1.3/include/SKeyMap.h" 1
# 10 "H:/CPP/irrlicht-1.3/include/SKeyMap.h"
namespace irr
{


 enum EKEY_ACTION
 {
  EKA_MOVE_FORWARD = 0,
  EKA_MOVE_BACKWARD,
  EKA_STRAFE_LEFT,
  EKA_STRAFE_RIGHT,
  EKA_JUMP_UP,
  EKA_COUNT,


  EKA_FORCE_32BIT = 0x7fffffff
 };


 struct SKeyMap
 {
  EKEY_ACTION Action;
  EKEY_CODE KeyCode;
 };

}
# 132 "H:/CPP/irrlicht-1.3/include/irrlicht.h" 2

# 1 "H:/CPP/irrlicht-1.3/include/SMesh.h" 1
# 13 "H:/CPP/irrlicht-1.3/include/SMesh.h"
namespace irr
{
namespace scene
{

 struct SMesh : public IMesh
 {

  SMesh()
  {



  }


  ~SMesh()
  {

   for (u32 i=0; i<MeshBuffers.size(); ++i)
   {
    MeshBuffers[i]->drop();
   }
  };


  virtual u32 getMeshBufferCount() const
  {
   return MeshBuffers.size();
  }


  virtual IMeshBuffer* getMeshBuffer(u32 nr) const
  {
   return MeshBuffers[nr];
  }



  virtual IMeshBuffer* getMeshBuffer( const video::SMaterial & material) const
  {
   for (s32 i = (s32) MeshBuffers.size(); --i >= 0; )
   {
    if ( !(material != MeshBuffers[i]->getMaterial()) )
     return MeshBuffers[i];
   }

   return 0;
  }


  virtual const core::aabbox3d<f32>& getBoundingBox() const
  {
   return BoundingBox;
  }


  virtual void setBoundingBox( const core::aabbox3df& box)
  {
   BoundingBox = box;
  }


  void recalculateBoundingBox()
  {
   if (MeshBuffers.size())
   {
    BoundingBox = MeshBuffers[0]->getBoundingBox();
    for (u32 i=1; i<MeshBuffers.size(); ++i)
     BoundingBox.addInternalBox(MeshBuffers[i]->getBoundingBox());
   }
   else
    BoundingBox.reset(0.0f, 0.0f, 0.0f);
  }


  void addMeshBuffer(IMeshBuffer* buf)
  {
   if (buf)
   {
    buf->grab();
    MeshBuffers.push_back(buf);
   }
  }


  virtual void setMaterialFlag(video::E_MATERIAL_FLAG flag, bool newvalue)
  {
   for (u32 i=0; i<MeshBuffers.size(); ++i)
    MeshBuffers[i]->getMaterial().setFlag(flag, newvalue);
  }

  core::array<IMeshBuffer*> MeshBuffers;
  core::aabbox3d<f32> BoundingBox;
 };


}
}
# 134 "H:/CPP/irrlicht-1.3/include/irrlicht.h" 2
# 1 "H:/CPP/irrlicht-1.3/include/SMeshBuffer.h" 1
# 11 "H:/CPP/irrlicht-1.3/include/SMeshBuffer.h"
namespace irr
{
namespace scene
{

 struct SMeshBuffer : public IMeshBuffer
 {

  SMeshBuffer()
  {



  }


  ~SMeshBuffer() {};


  virtual const video::SMaterial& getMaterial() const
  {
   return Material;
  }


  virtual video::SMaterial& getMaterial()
  {
   return Material;
  }


  virtual const void* getVertices() const
  {
   return Vertices.const_pointer();
  }


  virtual void* getVertices()
  {
   return Vertices.pointer();
  }


  virtual u32 getVertexCount() const
  {
   return Vertices.size();
  }


  virtual const u16* getIndices() const
  {
   return Indices.const_pointer();
  }


  virtual u16* getIndices()
  {
   return Indices.pointer();
  }


  virtual u32 getIndexCount() const
  {
   return Indices.size();
  }


  virtual const core::aabbox3d<f32>& getBoundingBox() const
  {
   return BoundingBox;
  }


  virtual void setBoundingBox( const core::aabbox3df& box)
  {
   BoundingBox = box;
  }



  void recalculateBoundingBox()
  {
   if (Vertices.empty())
    BoundingBox.reset(0,0,0);
   else
   {
    BoundingBox.reset(Vertices[0].Pos);
    for (u32 i=1; i<Vertices.size(); ++i)
     BoundingBox.addInternalPoint(Vertices[i].Pos);
   }
  }


  virtual video::E_VERTEX_TYPE getVertexType() const
  {
   return video::EVT_STANDARD;
  }


  virtual u32 getVertexPitch() const
  {
   return sizeof ( video::S3DVertex );
  }


  video::SMaterial Material;
  core::array<video::S3DVertex> Vertices;
  core::array<u16> Indices;
  core::aabbox3d<f32> BoundingBox;
 };

}
}
# 135 "H:/CPP/irrlicht-1.3/include/irrlicht.h" 2

# 1 "H:/CPP/irrlicht-1.3/include/SMeshBufferTangents.h" 1
# 11 "H:/CPP/irrlicht-1.3/include/SMeshBufferTangents.h"
namespace irr
{
namespace scene
{

 struct SMeshBufferTangents : public IMeshBuffer
 {

  SMeshBufferTangents()
  {



  }


  ~SMeshBufferTangents() {};


  virtual const video::SMaterial& getMaterial() const
  {
   return Material;
  }


  virtual video::SMaterial& getMaterial()
  {
   return Material;
  }


  virtual const void* getVertices() const
  {
   return Vertices.const_pointer();
  }


  virtual void* getVertices()
  {
   return Vertices.pointer();
  }


  virtual u32 getVertexCount() const
  {
   return Vertices.size();
  }


  virtual const u16* getIndices() const
  {
   return Indices.const_pointer();
  }


  virtual u16* getIndices()
  {
   return Indices.pointer();
  }


  virtual u32 getIndexCount() const
  {
   return Indices.size();
  }


  virtual const core::aabbox3d<f32>& getBoundingBox() const
  {
   return BoundingBox;
  }


  virtual void setBoundingBox( const core::aabbox3df& box)
  {
   BoundingBox = box;
  }



  void recalculateBoundingBox()
  {
   if (Vertices.empty())
    BoundingBox.reset(0,0,0);
   else
   {
    BoundingBox.reset(Vertices[0].Pos);
    for (u32 i=1; i<Vertices.size(); ++i)
     BoundingBox.addInternalPoint(Vertices[i].Pos);
   }
  }


  virtual video::E_VERTEX_TYPE getVertexType() const
  {
   return video::EVT_TANGENTS;
  }


  virtual u32 getVertexPitch() const
  {
   return sizeof ( video::S3DVertexTangents );
  }


  video::SMaterial Material;
  core::array<video::S3DVertexTangents> Vertices;
  core::array<u16> Indices;
  core::aabbox3d<f32> BoundingBox;
 };

}
}
# 137 "H:/CPP/irrlicht-1.3/include/irrlicht.h" 2
# 252 "H:/CPP/irrlicht-1.3/include/irrlicht.h"
# 1 "H:/CPP/irrlicht-1.3/include/SIrrCreationParameters.h" 1







namespace irr
{


 struct SIrrlichtCreationParameters
 {

  SIrrlichtCreationParameters()
  {
   DriverType = video::EDT_BURNINGSVIDEO;
   WindowSize = core::dimension2d<s32>(800, 600);
   Bits = 16;
   Fullscreen = false;
   Stencilbuffer = false;
   Vsync = false;
   AntiAlias = false;
   HighPrecisionFPU = false;
   EventReceiver = 0;
   WindowId = 0;
   SDK_version_do_not_use = "1.3";
  }





  video::E_DRIVER_TYPE DriverType;


  core::dimension2d<s32> WindowSize;


  u32 Bits;



  bool Fullscreen;






  bool Stencilbuffer;




  bool Vsync;
# 67 "H:/CPP/irrlicht-1.3/include/SIrrCreationParameters.h"
  bool AntiAlias;







  bool HighPrecisionFPU;


  IEventReceiver* EventReceiver;
# 128 "H:/CPP/irrlicht-1.3/include/SIrrCreationParameters.h"
  s32 WindowId;




  const c8* SDK_version_do_not_use;
 };


}
# 253 "H:/CPP/irrlicht-1.3/include/irrlicht.h" 2


namespace irr
{
# 277 "H:/CPP/irrlicht-1.3/include/irrlicht.h"
 __attribute__((dllimport)) IrrlichtDevice* __attribute__((__cdecl__)) createDevice(
  video::E_DRIVER_TYPE deviceType = video::EDT_SOFTWARE,
  const core::dimension2d<s32>& windowSize = core::dimension2d<s32>(640,480),
  u32 bits = 16,
  bool fullscreen = false,
  bool stencilbuffer=false,
  bool vsync=false,
  IEventReceiver* receiver = 0,
  const c8* sdk_version_do_not_use = "1.3");
# 295 "H:/CPP/irrlicht-1.3/include/irrlicht.h"
 __attribute__((dllimport)) IrrlichtDevice* __attribute__((__cdecl__)) createDeviceEx(
  const SIrrlichtCreationParameters& parameters);






 namespace core
 {
 }


 namespace gui
 {
 }


 namespace io
 {
 }


 namespace scene
 {
 }


 namespace video
 {
 }
}
# 10 "shooter.cpp" 2

# 1 "H:/CPP/wxdevcpp6.10/include/windows.h" 1
# 16 "H:/CPP/wxdevcpp6.10/include/windows.h"
       
# 17 "H:/CPP/wxdevcpp6.10/include/windows.h" 3
# 48 "H:/CPP/wxdevcpp6.10/include/windows.h" 3
# 1 "H:/CPP/wxdevcpp6.10/include/windef.h" 1 3



       
# 5 "H:/CPP/wxdevcpp6.10/include/windef.h" 3



extern "C" {
# 222 "H:/CPP/wxdevcpp6.10/include/windef.h" 3
typedef unsigned long DWORD;
typedef int WINBOOL,*PWINBOOL,*LPWINBOOL;



typedef WINBOOL BOOL;



typedef unsigned char BYTE;

typedef BOOL *PBOOL,*LPBOOL;
typedef unsigned short WORD;
typedef float FLOAT;
typedef FLOAT *PFLOAT;
typedef BYTE *PBYTE,*LPBYTE;
typedef int *PINT,*LPINT;
typedef WORD *PWORD,*LPWORD;
typedef long *LPLONG;
typedef DWORD *PDWORD,*LPDWORD;
typedef const void *PCVOID,*LPCVOID;
typedef int INT;
typedef unsigned int UINT,*PUINT,*LPUINT;

# 1 "H:/CPP/wxdevcpp6.10/include/winnt.h" 1 3



       
# 5 "H:/CPP/wxdevcpp6.10/include/winnt.h" 3
# 31 "H:/CPP/wxdevcpp6.10/include/winnt.h" 3
extern "C" {


# 1 "H:/CPP/wxdevcpp6.10/include/winerror.h" 1 3



       
# 5 "H:/CPP/wxdevcpp6.10/include/winerror.h" 3
# 35 "H:/CPP/wxdevcpp6.10/include/winnt.h" 2 3
# 49 "H:/CPP/wxdevcpp6.10/include/winnt.h" 3
typedef char CHAR;
typedef short SHORT;
typedef long LONG;
typedef char CCHAR, *PCCHAR;
typedef unsigned char UCHAR,*PUCHAR;
typedef unsigned short USHORT,*PUSHORT;
typedef unsigned long ULONG,*PULONG;
typedef char *PSZ;

typedef void *PVOID,*LPVOID;





typedef void* PVOID64;
# 77 "H:/CPP/wxdevcpp6.10/include/winnt.h" 3
typedef wchar_t WCHAR;
typedef WCHAR *PWCHAR,*LPWCH,*PWCH,*NWPSTR,*LPWSTR,*PWSTR;
typedef const WCHAR *LPCWCH,*PCWCH,*LPCWSTR,*PCWSTR;
typedef CHAR *PCHAR,*LPCH,*PCH,*NPSTR,*LPSTR,*PSTR;
typedef const CHAR *LPCCH,*PCSTR,*LPCSTR;
# 92 "H:/CPP/wxdevcpp6.10/include/winnt.h" 3
typedef CHAR TCHAR;
typedef CHAR _TCHAR;


typedef TCHAR TBYTE,*PTCH,*PTBYTE;
typedef TCHAR *LPTCH,*PTSTR,*LPTSTR,*LP,*PTCHAR;
typedef const TCHAR *LPCTSTR;
# 117 "H:/CPP/wxdevcpp6.10/include/winnt.h" 3
typedef SHORT *PSHORT;
typedef LONG *PLONG;

typedef void *HANDLE;





typedef HANDLE *PHANDLE,*LPHANDLE;
typedef DWORD LCID;
typedef PDWORD PLCID;
typedef WORD LANGID;
# 139 "H:/CPP/wxdevcpp6.10/include/winnt.h" 3
typedef long long LONGLONG;
typedef unsigned long long DWORDLONG;



typedef LONGLONG *PLONGLONG;
typedef DWORDLONG *PDWORDLONG;
typedef DWORDLONG ULONGLONG,*PULONGLONG;
typedef LONGLONG USN;
# 157 "H:/CPP/wxdevcpp6.10/include/winnt.h" 3
typedef BYTE BOOLEAN,*PBOOLEAN;

typedef BYTE FCHAR;
typedef WORD FSHORT;
typedef DWORD FLONG;


# 1 "H:/CPP/wxdevcpp6.10/include/basetsd.h" 1 3



       
# 5 "H:/CPP/wxdevcpp6.10/include/basetsd.h" 3
# 48 "H:/CPP/wxdevcpp6.10/include/basetsd.h" 3
extern "C" {

typedef int LONG32, *PLONG32;

typedef int INT32, *PINT32;

typedef unsigned int ULONG32, *PULONG32;
typedef unsigned int DWORD32, *PDWORD32;
typedef unsigned int UINT32, *PUINT32;
# 97 "H:/CPP/wxdevcpp6.10/include/basetsd.h" 3
typedef int INT_PTR, *PINT_PTR;
typedef unsigned int UINT_PTR, *PUINT_PTR;
typedef long LONG_PTR, *PLONG_PTR;
typedef unsigned long ULONG_PTR, *PULONG_PTR;
typedef unsigned short UHALF_PTR, *PUHALF_PTR;
typedef short HALF_PTR, *PHALF_PTR;
typedef unsigned long HANDLE_PTR;


typedef ULONG_PTR SIZE_T, *PSIZE_T;
typedef LONG_PTR SSIZE_T, *PSSIZE_T;
typedef ULONG_PTR DWORD_PTR, *PDWORD_PTR;
typedef long long LONG64, *PLONG64;
typedef long long INT64, *PINT64;
typedef unsigned long long ULONG64, *PULONG64;
typedef unsigned long long DWORD64, *PDWORD64;
typedef unsigned long long UINT64, *PUINT64;

}
# 165 "H:/CPP/wxdevcpp6.10/include/winnt.h" 2 3
# 1343 "H:/CPP/wxdevcpp6.10/include/winnt.h" 3
typedef DWORD ACCESS_MASK, *PACCESS_MASK;







typedef struct _GUID {
 unsigned long Data1;
 unsigned short Data2;
 unsigned short Data3;
 unsigned char Data4[8];
} GUID, *REFGUID, *LPGUID;


typedef struct _GENERIC_MAPPING {
 ACCESS_MASK GenericRead;
 ACCESS_MASK GenericWrite;
 ACCESS_MASK GenericExecute;
 ACCESS_MASK GenericAll;
} GENERIC_MAPPING, *PGENERIC_MAPPING;
typedef struct _ACE_HEADER {
 BYTE AceType;
 BYTE AceFlags;
 WORD AceSize;
} ACE_HEADER, *PACE_HEADER;
typedef struct _ACCESS_ALLOWED_ACE {
 ACE_HEADER Header;
 ACCESS_MASK Mask;
 DWORD SidStart;
} ACCESS_ALLOWED_ACE, *PACCESS_ALLOWED_ACE;
typedef struct _ACCESS_DENIED_ACE {
 ACE_HEADER Header;
 ACCESS_MASK Mask;
 DWORD SidStart;
} ACCESS_DENIED_ACE, *PACCESS_DENIED_ACE;
typedef struct _SYSTEM_AUDIT_ACE {
 ACE_HEADER Header;
 ACCESS_MASK Mask;
 DWORD SidStart;
} SYSTEM_AUDIT_ACE;
typedef SYSTEM_AUDIT_ACE *PSYSTEM_AUDIT_ACE;
typedef struct _SYSTEM_ALARM_ACE {
 ACE_HEADER Header;
 ACCESS_MASK Mask;
 DWORD SidStart;
} SYSTEM_ALARM_ACE,*PSYSTEM_ALARM_ACE;
typedef struct _ACCESS_ALLOWED_OBJECT_ACE {
 ACE_HEADER Header;
 ACCESS_MASK Mask;
 DWORD Flags;
 GUID ObjectType;
 GUID InheritedObjectType;
 DWORD SidStart;
} ACCESS_ALLOWED_OBJECT_ACE,*PACCESS_ALLOWED_OBJECT_ACE;
typedef struct _ACCESS_DENIED_OBJECT_ACE {
 ACE_HEADER Header;
 ACCESS_MASK Mask;
 DWORD Flags;
 GUID ObjectType;
 GUID InheritedObjectType;
 DWORD SidStart;
} ACCESS_DENIED_OBJECT_ACE,*PACCESS_DENIED_OBJECT_ACE;
typedef struct _SYSTEM_AUDIT_OBJECT_ACE {
 ACE_HEADER Header;
 ACCESS_MASK Mask;
 DWORD Flags;
 GUID ObjectType;
 GUID InheritedObjectType;
 DWORD SidStart;
} SYSTEM_AUDIT_OBJECT_ACE,*PSYSTEM_AUDIT_OBJECT_ACE;
typedef struct _SYSTEM_ALARM_OBJECT_ACE {
 ACE_HEADER Header;
 ACCESS_MASK Mask;
 DWORD Flags;
 GUID ObjectType;
 GUID InheritedObjectType;
 DWORD SidStart;
} SYSTEM_ALARM_OBJECT_ACE,*PSYSTEM_ALARM_OBJECT_ACE;
typedef struct _ACL {
 BYTE AclRevision;
 BYTE Sbz1;
 WORD AclSize;
 WORD AceCount;
 WORD Sbz2;
} ACL,*PACL;
typedef struct _ACL_REVISION_INFORMATION {
 DWORD AclRevision;
} ACL_REVISION_INFORMATION;
typedef struct _ACL_SIZE_INFORMATION {
 DWORD AceCount;
 DWORD AclBytesInUse;
 DWORD AclBytesFree;
} ACL_SIZE_INFORMATION;
# 1452 "H:/CPP/wxdevcpp6.10/include/winnt.h" 3
typedef struct _FLOATING_SAVE_AREA {
 DWORD ControlWord;
 DWORD StatusWord;
 DWORD TagWord;
 DWORD ErrorOffset;
 DWORD ErrorSelector;
 DWORD DataOffset;
 DWORD DataSelector;
 BYTE RegisterArea[80];
 DWORD Cr0NpxState;
} FLOATING_SAVE_AREA;
typedef struct _CONTEXT {
 DWORD ContextFlags;
 DWORD Dr0;
 DWORD Dr1;
 DWORD Dr2;
 DWORD Dr3;
 DWORD Dr6;
 DWORD Dr7;
 FLOATING_SAVE_AREA FloatSave;
 DWORD SegGs;
 DWORD SegFs;
 DWORD SegEs;
 DWORD SegDs;
 DWORD Edi;
 DWORD Esi;
 DWORD Ebx;
 DWORD Edx;
 DWORD Ecx;
 DWORD Eax;
 DWORD Ebp;
 DWORD Eip;
 DWORD SegCs;
 DWORD EFlags;
 DWORD Esp;
 DWORD SegSs;
 BYTE ExtendedRegisters[512];
} CONTEXT;
# 1971 "H:/CPP/wxdevcpp6.10/include/winnt.h" 3
typedef CONTEXT *PCONTEXT,*LPCONTEXT;
typedef struct _EXCEPTION_RECORD {
 DWORD ExceptionCode;
 DWORD ExceptionFlags;
 struct _EXCEPTION_RECORD *ExceptionRecord;
 PVOID ExceptionAddress;
 DWORD NumberParameters;
 DWORD ExceptionInformation[15];
} EXCEPTION_RECORD,*PEXCEPTION_RECORD,*LPEXCEPTION_RECORD;
typedef struct _EXCEPTION_POINTERS {
 PEXCEPTION_RECORD ExceptionRecord;
 PCONTEXT ContextRecord;
} EXCEPTION_POINTERS,*PEXCEPTION_POINTERS,*LPEXCEPTION_POINTERS;
typedef union _LARGE_INTEGER {
  struct {
    DWORD LowPart;
    LONG HighPart;
  } u;

  __extension__ struct {
    DWORD LowPart;
    LONG HighPart;
  };

  LONGLONG QuadPart;
} LARGE_INTEGER, *PLARGE_INTEGER;
typedef union _ULARGE_INTEGER {
  struct {
    DWORD LowPart;
    DWORD HighPart;
  } u;

  __extension__ struct {
    DWORD LowPart;
    DWORD HighPart;
  };

  ULONGLONG QuadPart;
} ULARGE_INTEGER, *PULARGE_INTEGER;
typedef struct _LUID {
  DWORD LowPart;
  LONG HighPart;
} LUID, *PLUID;
#pragma pack(push,4)
typedef struct _LUID_AND_ATTRIBUTES {
 LUID Luid;
 DWORD Attributes;
} LUID_AND_ATTRIBUTES, *PLUID_AND_ATTRIBUTES;
#pragma pack(pop)
typedef LUID_AND_ATTRIBUTES LUID_AND_ATTRIBUTES_ARRAY[1];
typedef LUID_AND_ATTRIBUTES_ARRAY *PLUID_AND_ATTRIBUTES_ARRAY;
typedef struct _PRIVILEGE_SET {
 DWORD PrivilegeCount;
 DWORD Control;
 LUID_AND_ATTRIBUTES Privilege[1];
} PRIVILEGE_SET,*PPRIVILEGE_SET;
typedef struct _SECURITY_ATTRIBUTES {
 DWORD nLength;
 LPVOID lpSecurityDescriptor;
 BOOL bInheritHandle;
} SECURITY_ATTRIBUTES,*PSECURITY_ATTRIBUTES,*LPSECURITY_ATTRIBUTES;
typedef enum _SECURITY_IMPERSONATION_LEVEL {
 SecurityAnonymous,
 SecurityIdentification,
 SecurityImpersonation,
 SecurityDelegation
} SECURITY_IMPERSONATION_LEVEL,*PSECURITY_IMPERSONATION_LEVEL;
typedef BOOLEAN SECURITY_CONTEXT_TRACKING_MODE,*PSECURITY_CONTEXT_TRACKING_MODE;
typedef struct _SECURITY_QUALITY_OF_SERVICE {
 DWORD Length;
 SECURITY_IMPERSONATION_LEVEL ImpersonationLevel;
 SECURITY_CONTEXT_TRACKING_MODE ContextTrackingMode;
 BOOLEAN EffectiveOnly;
} SECURITY_QUALITY_OF_SERVICE,*PSECURITY_QUALITY_OF_SERVICE;
typedef PVOID PACCESS_TOKEN;
typedef struct _SE_IMPERSONATION_STATE {
 PACCESS_TOKEN Token;
 BOOLEAN CopyOnOpen;
 BOOLEAN EffectiveOnly;
 SECURITY_IMPERSONATION_LEVEL Level;
} SE_IMPERSONATION_STATE,*PSE_IMPERSONATION_STATE;
typedef struct _SID_IDENTIFIER_AUTHORITY {
 BYTE Value[6];
} SID_IDENTIFIER_AUTHORITY,*PSID_IDENTIFIER_AUTHORITY,*LPSID_IDENTIFIER_AUTHORITY;
typedef PVOID PSID;
typedef struct _SID {
   BYTE Revision;
   BYTE SubAuthorityCount;
   SID_IDENTIFIER_AUTHORITY IdentifierAuthority;
   DWORD SubAuthority[1];
} SID, *PISID;
typedef struct _SID_AND_ATTRIBUTES {
 PSID Sid;
 DWORD Attributes;
} SID_AND_ATTRIBUTES, *PSID_AND_ATTRIBUTES;
typedef SID_AND_ATTRIBUTES SID_AND_ATTRIBUTES_ARRAY[1];
typedef SID_AND_ATTRIBUTES_ARRAY *PSID_AND_ATTRIBUTES_ARRAY;
typedef struct _TOKEN_SOURCE {
 CHAR SourceName[8];
 LUID SourceIdentifier;
} TOKEN_SOURCE,*PTOKEN_SOURCE;
typedef struct _TOKEN_CONTROL {
 LUID TokenId;
 LUID AuthenticationId;
 LUID ModifiedId;
 TOKEN_SOURCE TokenSource;
} TOKEN_CONTROL,*PTOKEN_CONTROL;
typedef struct _TOKEN_DEFAULT_DACL {
 PACL DefaultDacl;
} TOKEN_DEFAULT_DACL,*PTOKEN_DEFAULT_DACL;
typedef struct _TOKEN_GROUPS {
 DWORD GroupCount;
 SID_AND_ATTRIBUTES Groups[1];
} TOKEN_GROUPS,*PTOKEN_GROUPS,*LPTOKEN_GROUPS;
typedef struct _TOKEN_OWNER {
 PSID Owner;
} TOKEN_OWNER,*PTOKEN_OWNER;
typedef struct _TOKEN_PRIMARY_GROUP {
 PSID PrimaryGroup;
} TOKEN_PRIMARY_GROUP,*PTOKEN_PRIMARY_GROUP;
typedef struct _TOKEN_PRIVILEGES {
 DWORD PrivilegeCount;
 LUID_AND_ATTRIBUTES Privileges[1];
} TOKEN_PRIVILEGES,*PTOKEN_PRIVILEGES,*LPTOKEN_PRIVILEGES;
typedef enum tagTOKEN_TYPE {
 TokenPrimary = 1,
 TokenImpersonation
} TOKEN_TYPE,*PTOKEN_TYPE;
typedef struct _TOKEN_STATISTICS {
 LUID TokenId;
 LUID AuthenticationId;
 LARGE_INTEGER ExpirationTime;
 TOKEN_TYPE TokenType;
 SECURITY_IMPERSONATION_LEVEL ImpersonationLevel;
 DWORD DynamicCharged;
 DWORD DynamicAvailable;
 DWORD GroupCount;
 DWORD PrivilegeCount;
 LUID ModifiedId;
} TOKEN_STATISTICS, *PTOKEN_STATISTICS;
typedef struct _TOKEN_USER {
 SID_AND_ATTRIBUTES User;
} TOKEN_USER, *PTOKEN_USER;
typedef DWORD SECURITY_INFORMATION,*PSECURITY_INFORMATION;
typedef WORD SECURITY_DESCRIPTOR_CONTROL,*PSECURITY_DESCRIPTOR_CONTROL;
typedef struct _SECURITY_DESCRIPTOR {
 BYTE Revision;
 BYTE Sbz1;
 SECURITY_DESCRIPTOR_CONTROL Control;
 PSID Owner;
 PSID Group;
 PACL Sacl;
 PACL Dacl;
} SECURITY_DESCRIPTOR, *PSECURITY_DESCRIPTOR, *PISECURITY_DESCRIPTOR;
typedef enum _TOKEN_INFORMATION_CLASS {
 TokenUser=1,
 TokenGroups,
 TokenPrivileges,
 TokenOwner,
 TokenPrimaryGroup,
 TokenDefaultDacl,
 TokenSource,
 TokenType,
 TokenImpersonationLevel,
 TokenStatistics,
 TokenRestrictedSids,
 TokenSessionId,
 TokenGroupsAndPrivileges,
 TokenSessionReference,
 TokenSandBoxInert,
 TokenAuditPolicy,
 TokenOrigin
} TOKEN_INFORMATION_CLASS;
typedef enum _SID_NAME_USE {
 SidTypeUser=1,
 SidTypeGroup,
 SidTypeDomain,
 SidTypeAlias,
 SidTypeWellKnownGroup,
 SidTypeDeletedAccount,
 SidTypeInvalid,
 SidTypeUnknown,
 SidTypeComputer
} SID_NAME_USE,*PSID_NAME_USE;
typedef struct _QUOTA_LIMITS {
 SIZE_T PagedPoolLimit;
 SIZE_T NonPagedPoolLimit;
 SIZE_T MinimumWorkingSetSize;
 SIZE_T MaximumWorkingSetSize;
 SIZE_T PagefileLimit;
 LARGE_INTEGER TimeLimit;
} QUOTA_LIMITS,*PQUOTA_LIMITS;
typedef struct _IO_COUNTERS {
 ULONGLONG ReadOperationCount;
 ULONGLONG WriteOperationCount;
 ULONGLONG OtherOperationCount;
 ULONGLONG ReadTransferCount;
 ULONGLONG WriteTransferCount;
 ULONGLONG OtherTransferCount;
} IO_COUNTERS, *PIO_COUNTERS;
typedef struct _FILE_NOTIFY_INFORMATION {
 DWORD NextEntryOffset;
 DWORD Action;
 DWORD FileNameLength;
 WCHAR FileName[1];
} FILE_NOTIFY_INFORMATION,*PFILE_NOTIFY_INFORMATION;
typedef struct _TAPE_ERASE {
 DWORD Type;
 BOOLEAN Immediate;
} TAPE_ERASE,*PTAPE_ERASE;
typedef struct _TAPE_GET_DRIVE_PARAMETERS {
 BOOLEAN ECC;
 BOOLEAN Compression;
 BOOLEAN DataPadding;
 BOOLEAN ReportSetmarks;
  DWORD DefaultBlockSize;
  DWORD MaximumBlockSize;
  DWORD MinimumBlockSize;
  DWORD MaximumPartitionCount;
  DWORD FeaturesLow;
  DWORD FeaturesHigh;
  DWORD EOTWarningZoneSize;
} TAPE_GET_DRIVE_PARAMETERS,*PTAPE_GET_DRIVE_PARAMETERS;
typedef struct _TAPE_GET_MEDIA_PARAMETERS {
 LARGE_INTEGER Capacity;
 LARGE_INTEGER Remaining;
 DWORD BlockSize;
 DWORD PartitionCount;
 BOOLEAN WriteProtected;
} TAPE_GET_MEDIA_PARAMETERS,*PTAPE_GET_MEDIA_PARAMETERS;
typedef struct _TAPE_GET_POSITION {
 ULONG Type;
 ULONG Partition;
 ULONG OffsetLow;
 ULONG OffsetHigh;
} TAPE_GET_POSITION,*PTAPE_GET_POSITION;
typedef struct _TAPE_PREPARE {
 DWORD Operation;
 BOOLEAN Immediate;
} TAPE_PREPARE,*PTAPE_PREPARE;
typedef struct _TAPE_SET_DRIVE_PARAMETERS {
 BOOLEAN ECC;
 BOOLEAN Compression;
 BOOLEAN DataPadding;
 BOOLEAN ReportSetmarks;
 ULONG EOTWarningZoneSize;
} TAPE_SET_DRIVE_PARAMETERS,*PTAPE_SET_DRIVE_PARAMETERS;
typedef struct _TAPE_SET_MEDIA_PARAMETERS {
 ULONG BlockSize;
} TAPE_SET_MEDIA_PARAMETERS,*PTAPE_SET_MEDIA_PARAMETERS;
typedef struct _TAPE_SET_POSITION {
 DWORD Method;
 DWORD Partition;
 LARGE_INTEGER Offset;
 BOOLEAN Immediate;
} TAPE_SET_POSITION,*PTAPE_SET_POSITION;
typedef struct _TAPE_WRITE_MARKS {
 DWORD Type;
 DWORD Count;
 BOOLEAN Immediate;
} TAPE_WRITE_MARKS,*PTAPE_WRITE_MARKS;
typedef struct _TAPE_CREATE_PARTITION {
 DWORD Method;
 DWORD Count;
 DWORD Size;
} TAPE_CREATE_PARTITION,*PTAPE_CREATE_PARTITION;
typedef struct _MEMORY_BASIC_INFORMATION {
 PVOID BaseAddress;
 PVOID AllocationBase;
 DWORD AllocationProtect;
 DWORD RegionSize;
 DWORD State;
 DWORD Protect;
 DWORD Type;
} MEMORY_BASIC_INFORMATION,*PMEMORY_BASIC_INFORMATION;
typedef struct _MESSAGE_RESOURCE_ENTRY {
 WORD Length;
 WORD Flags;
 BYTE Text[1];
} MESSAGE_RESOURCE_ENTRY,*PMESSAGE_RESOURCE_ENTRY;
typedef struct _MESSAGE_RESOURCE_BLOCK {
 DWORD LowId;
 DWORD HighId;
 DWORD OffsetToEntries;
} MESSAGE_RESOURCE_BLOCK,*PMESSAGE_RESOURCE_BLOCK;
typedef struct _MESSAGE_RESOURCE_DATA {
 DWORD NumberOfBlocks;
 MESSAGE_RESOURCE_BLOCK Blocks[1];
} MESSAGE_RESOURCE_DATA,*PMESSAGE_RESOURCE_DATA;
typedef struct _LIST_ENTRY {
 struct _LIST_ENTRY *Flink;
 struct _LIST_ENTRY *Blink;
} LIST_ENTRY,*PLIST_ENTRY;
typedef struct _SINGLE_LIST_ENTRY {
 struct _SINGLE_LIST_ENTRY *Next;
} SINGLE_LIST_ENTRY,*PSINGLE_LIST_ENTRY;






typedef union _SLIST_HEADER {
 ULONGLONG Alignment;
 __extension__ struct {
  SINGLE_LIST_ENTRY Next;
  WORD Depth;
  WORD Sequence;
 } ;
} SLIST_HEADER,*PSLIST_HEADER;


typedef struct _RTL_CRITICAL_SECTION_DEBUG {
 WORD Type;
 WORD CreatorBackTraceIndex;
 struct _RTL_CRITICAL_SECTION *CriticalSection;
 LIST_ENTRY ProcessLocksList;
 DWORD EntryCount;
 DWORD ContentionCount;
 DWORD Spare[2];
} RTL_CRITICAL_SECTION_DEBUG,*PRTL_CRITICAL_SECTION_DEBUG;
typedef struct _RTL_CRITICAL_SECTION {
 PRTL_CRITICAL_SECTION_DEBUG DebugInfo;
 LONG LockCount;
 LONG RecursionCount;
 HANDLE OwningThread;
 HANDLE LockSemaphore;
 DWORD Reserved;
} RTL_CRITICAL_SECTION,*PRTL_CRITICAL_SECTION;
typedef struct _EVENTLOGRECORD {
 DWORD Length;
 DWORD Reserved;
 DWORD RecordNumber;
 DWORD TimeGenerated;
 DWORD TimeWritten;
 DWORD EventID;
 WORD EventType;
 WORD NumStrings;
 WORD EventCategory;
 WORD ReservedFlags;
 DWORD ClosingRecordNumber;
 DWORD StringOffset;
 DWORD UserSidLength;
 DWORD UserSidOffset;
 DWORD DataLength;
 DWORD DataOffset;
} EVENTLOGRECORD,*PEVENTLOGRECORD;
typedef struct _OSVERSIONINFOA {
 DWORD dwOSVersionInfoSize;
 DWORD dwMajorVersion;
 DWORD dwMinorVersion;
 DWORD dwBuildNumber;
 DWORD dwPlatformId;
 CHAR szCSDVersion[128];
} OSVERSIONINFOA,*POSVERSIONINFOA,*LPOSVERSIONINFOA;
typedef struct _OSVERSIONINFOW {
 DWORD dwOSVersionInfoSize;
 DWORD dwMajorVersion;
 DWORD dwMinorVersion;
 DWORD dwBuildNumber;
 DWORD dwPlatformId;
 WCHAR szCSDVersion[128];
} OSVERSIONINFOW,*POSVERSIONINFOW,*LPOSVERSIONINFOW;
typedef struct _OSVERSIONINFOEXA {
 DWORD dwOSVersionInfoSize;
 DWORD dwMajorVersion;
 DWORD dwMinorVersion;
 DWORD dwBuildNumber;
 DWORD dwPlatformId;
 CHAR szCSDVersion[128];
 WORD wServicePackMajor;
 WORD wServicePackMinor;
 WORD wSuiteMask;
 BYTE wProductType;
 BYTE wReserved;
} OSVERSIONINFOEXA, *POSVERSIONINFOEXA, *LPOSVERSIONINFOEXA;
typedef struct _OSVERSIONINFOEXW {
 DWORD dwOSVersionInfoSize;
 DWORD dwMajorVersion;
 DWORD dwMinorVersion;
 DWORD dwBuildNumber;
 DWORD dwPlatformId;
 WCHAR szCSDVersion[128];
 WORD wServicePackMajor;
 WORD wServicePackMinor;
 WORD wSuiteMask;
 BYTE wProductType;
 BYTE wReserved;
} OSVERSIONINFOEXW, *POSVERSIONINFOEXW, *LPOSVERSIONINFOEXW;
#pragma pack(push,2)
typedef struct _IMAGE_VXD_HEADER {
 WORD e32_magic;
 BYTE e32_border;
 BYTE e32_worder;
 DWORD e32_level;
 WORD e32_cpu;
 WORD e32_os;
 DWORD e32_ver;
 DWORD e32_mflags;
 DWORD e32_mpages;
 DWORD e32_startobj;
 DWORD e32_eip;
 DWORD e32_stackobj;
 DWORD e32_esp;
 DWORD e32_pagesize;
 DWORD e32_lastpagesize;
 DWORD e32_fixupsize;
 DWORD e32_fixupsum;
 DWORD e32_ldrsize;
 DWORD e32_ldrsum;
 DWORD e32_objtab;
 DWORD e32_objcnt;
 DWORD e32_objmap;
 DWORD e32_itermap;
 DWORD e32_rsrctab;
 DWORD e32_rsrccnt;
 DWORD e32_restab;
 DWORD e32_enttab;
 DWORD e32_dirtab;
 DWORD e32_dircnt;
 DWORD e32_fpagetab;
 DWORD e32_frectab;
 DWORD e32_impmod;
 DWORD e32_impmodcnt;
 DWORD e32_impproc;
 DWORD e32_pagesum;
 DWORD e32_datapage;
 DWORD e32_preload;
 DWORD e32_nrestab;
 DWORD e32_cbnrestab;
 DWORD e32_nressum;
 DWORD e32_autodata;
 DWORD e32_debuginfo;
 DWORD e32_debuglen;
 DWORD e32_instpreload;
 DWORD e32_instdemand;
 DWORD e32_heapsize;
 BYTE e32_res3[12];
 DWORD e32_winresoff;
 DWORD e32_winreslen;
 WORD e32_devid;
 WORD e32_ddkver;
} IMAGE_VXD_HEADER,*PIMAGE_VXD_HEADER;
#pragma pack(pop)
#pragma pack(push,4)
typedef struct _IMAGE_FILE_HEADER {
 WORD Machine;
 WORD NumberOfSections;
 DWORD TimeDateStamp;
 DWORD PointerToSymbolTable;
 DWORD NumberOfSymbols;
 WORD SizeOfOptionalHeader;
 WORD Characteristics;
} IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;
typedef struct _IMAGE_DATA_DIRECTORY {
 DWORD VirtualAddress;
 DWORD Size;
} IMAGE_DATA_DIRECTORY,*PIMAGE_DATA_DIRECTORY;
typedef struct _IMAGE_OPTIONAL_HEADER {
 WORD Magic;
 BYTE MajorLinkerVersion;
 BYTE MinorLinkerVersion;
 DWORD SizeOfCode;
 DWORD SizeOfInitializedData;
 DWORD SizeOfUninitializedData;
 DWORD AddressOfEntryPoint;
 DWORD BaseOfCode;
 DWORD BaseOfData;
 DWORD ImageBase;
 DWORD SectionAlignment;
 DWORD FileAlignment;
 WORD MajorOperatingSystemVersion;
 WORD MinorOperatingSystemVersion;
 WORD MajorImageVersion;
 WORD MinorImageVersion;
 WORD MajorSubsystemVersion;
 WORD MinorSubsystemVersion;
 DWORD Reserved1;
 DWORD SizeOfImage;
 DWORD SizeOfHeaders;
 DWORD CheckSum;
 WORD Subsystem;
 WORD DllCharacteristics;
 DWORD SizeOfStackReserve;
 DWORD SizeOfStackCommit;
 DWORD SizeOfHeapReserve;
 DWORD SizeOfHeapCommit;
 DWORD LoaderFlags;
 DWORD NumberOfRvaAndSizes;
 IMAGE_DATA_DIRECTORY DataDirectory[16];
} IMAGE_OPTIONAL_HEADER,*PIMAGE_OPTIONAL_HEADER;
typedef struct _IMAGE_ROM_OPTIONAL_HEADER {
 WORD Magic;
 BYTE MajorLinkerVersion;
 BYTE MinorLinkerVersion;
 DWORD SizeOfCode;
 DWORD SizeOfInitializedData;
 DWORD SizeOfUninitializedData;
 DWORD AddressOfEntryPoint;
 DWORD BaseOfCode;
 DWORD BaseOfData;
 DWORD BaseOfBss;
 DWORD GprMask;
 DWORD CprMask[4];
 DWORD GpValue;
} IMAGE_ROM_OPTIONAL_HEADER,*PIMAGE_ROM_OPTIONAL_HEADER;
#pragma pack(pop)
#pragma pack(push,2)
typedef struct _IMAGE_DOS_HEADER {
 WORD e_magic;
 WORD e_cblp;
 WORD e_cp;
 WORD e_crlc;
 WORD e_cparhdr;
 WORD e_minalloc;
 WORD e_maxalloc;
 WORD e_ss;
 WORD e_sp;
 WORD e_csum;
 WORD e_ip;
 WORD e_cs;
 WORD e_lfarlc;
 WORD e_ovno;
 WORD e_res[4];
 WORD e_oemid;
 WORD e_oeminfo;
 WORD e_res2[10];
 LONG e_lfanew;
} IMAGE_DOS_HEADER,*PIMAGE_DOS_HEADER;
typedef struct _IMAGE_OS2_HEADER {
 WORD ne_magic;
 CHAR ne_ver;
 CHAR ne_rev;
 WORD ne_enttab;
 WORD ne_cbenttab;
 LONG ne_crc;
 WORD ne_flags;
 WORD ne_autodata;
 WORD ne_heap;
 WORD ne_stack;
 LONG ne_csip;
 LONG ne_sssp;
 WORD ne_cseg;
 WORD ne_cmod;
 WORD ne_cbnrestab;
 WORD ne_segtab;
 WORD ne_rsrctab;
 WORD ne_restab;
 WORD ne_modtab;
 WORD ne_imptab;
 LONG ne_nrestab;
 WORD ne_cmovent;
 WORD ne_align;
 WORD ne_cres;
 BYTE ne_exetyp;
 BYTE ne_flagsothers;
 WORD ne_pretthunks;
 WORD ne_psegrefbytes;
 WORD ne_swaparea;
 WORD ne_expver;
} IMAGE_OS2_HEADER,*PIMAGE_OS2_HEADER;
#pragma pack(pop)
#pragma pack(push,4)
typedef struct _IMAGE_NT_HEADERS {
 DWORD Signature;
 IMAGE_FILE_HEADER FileHeader;
 IMAGE_OPTIONAL_HEADER OptionalHeader;
} IMAGE_NT_HEADERS,*PIMAGE_NT_HEADERS;
typedef struct _IMAGE_ROM_HEADERS {
 IMAGE_FILE_HEADER FileHeader;
 IMAGE_ROM_OPTIONAL_HEADER OptionalHeader;
} IMAGE_ROM_HEADERS,*PIMAGE_ROM_HEADERS;
typedef struct _IMAGE_SECTION_HEADER {
 BYTE Name[8];
 union {
  DWORD PhysicalAddress;
  DWORD VirtualSize;
 } Misc;
 DWORD VirtualAddress;
 DWORD SizeOfRawData;
 DWORD PointerToRawData;
 DWORD PointerToRelocations;
 DWORD PointerToLinenumbers;
 WORD NumberOfRelocations;
 WORD NumberOfLinenumbers;
 DWORD Characteristics;
} IMAGE_SECTION_HEADER,*PIMAGE_SECTION_HEADER;
#pragma pack(pop)
#pragma pack(push,2)
typedef struct _IMAGE_SYMBOL {
 union {
  BYTE ShortName[8];
  struct {
   DWORD Short;
   DWORD Long;
  } Name;
  PBYTE LongName[2];
 } N;
 DWORD Value;
 SHORT SectionNumber;
 WORD Type;
 BYTE StorageClass;
 BYTE NumberOfAuxSymbols;
} IMAGE_SYMBOL,*PIMAGE_SYMBOL;
typedef union _IMAGE_AUX_SYMBOL {
 struct {
  DWORD TagIndex;
  union {
   struct {
    WORD Linenumber;
    WORD Size;
   } LnSz;
   DWORD TotalSize;
  } Misc;
  union {
   struct {
    DWORD PointerToLinenumber;
    DWORD PointerToNextFunction;
   } Function;
   struct {
    WORD Dimension[4];
   } Array;
  } FcnAry;
  WORD TvIndex;
 } Sym;
 struct {
  BYTE Name[18];
 } File;
 struct {
  DWORD Length;
  WORD NumberOfRelocations;
  WORD NumberOfLinenumbers;
  DWORD CheckSum;
  SHORT Number;
  BYTE Selection;
 } Section;
} IMAGE_AUX_SYMBOL,*PIMAGE_AUX_SYMBOL;
typedef struct _IMAGE_COFF_SYMBOLS_HEADER {
 DWORD NumberOfSymbols;
 DWORD LvaToFirstSymbol;
 DWORD NumberOfLinenumbers;
 DWORD LvaToFirstLinenumber;
 DWORD RvaToFirstByteOfCode;
 DWORD RvaToLastByteOfCode;
 DWORD RvaToFirstByteOfData;
 DWORD RvaToLastByteOfData;
} IMAGE_COFF_SYMBOLS_HEADER,*PIMAGE_COFF_SYMBOLS_HEADER;
typedef struct _IMAGE_RELOCATION {
 __extension__ union {
  DWORD VirtualAddress;
  DWORD RelocCount;
 } ;
 DWORD SymbolTableIndex;
 WORD Type;
} IMAGE_RELOCATION,*PIMAGE_RELOCATION;
#pragma pack(pop)
#pragma pack(push,4)
typedef struct _IMAGE_BASE_RELOCATION {
 DWORD VirtualAddress;
 DWORD SizeOfBlock;
} IMAGE_BASE_RELOCATION,*PIMAGE_BASE_RELOCATION;
#pragma pack(pop)
#pragma pack(push,2)
typedef struct _IMAGE_LINENUMBER {
 union {
  DWORD SymbolTableIndex;
  DWORD VirtualAddress;
 } Type;
 WORD Linenumber;
} IMAGE_LINENUMBER,*PIMAGE_LINENUMBER;
#pragma pack(pop)
#pragma pack(push,4)
typedef struct _IMAGE_ARCHIVE_MEMBER_HEADER {
 BYTE Name[16];
 BYTE Date[12];
 BYTE UserID[6];
 BYTE GroupID[6];
 BYTE Mode[8];
 BYTE Size[10];
 BYTE EndHeader[2];
} IMAGE_ARCHIVE_MEMBER_HEADER,*PIMAGE_ARCHIVE_MEMBER_HEADER;
typedef struct _IMAGE_EXPORT_DIRECTORY {
 DWORD Characteristics;
 DWORD TimeDateStamp;
 WORD MajorVersion;
 WORD MinorVersion;
 DWORD Name;
 DWORD Base;
 DWORD NumberOfFunctions;
 DWORD NumberOfNames;
 DWORD AddressOfFunctions;
 DWORD AddressOfNames;
 DWORD AddressOfNameOrdinals;
} IMAGE_EXPORT_DIRECTORY,*PIMAGE_EXPORT_DIRECTORY;
typedef struct _IMAGE_IMPORT_BY_NAME {
 WORD Hint;
 BYTE Name[1];
} IMAGE_IMPORT_BY_NAME,*PIMAGE_IMPORT_BY_NAME;
typedef struct _IMAGE_THUNK_DATA32 {
 union {
  DWORD ForwarderString;
  DWORD Function;
  DWORD Ordinal;
  DWORD AddressOfData;
 } u1;
} IMAGE_THUNK_DATA32,*PIMAGE_THUNK_DATA32;
typedef struct _IMAGE_THUNK_DATA64 {
 union {
  ULONGLONG ForwarderString;
  ULONGLONG Function;
  ULONGLONG Ordinal;
  ULONGLONG AddressOfData;
 } u1;
} IMAGE_THUNK_DATA64, *PIMAGE_THUNK_DATA64;




typedef IMAGE_THUNK_DATA32 IMAGE_THUNK_DATA;
typedef PIMAGE_THUNK_DATA32 PIMAGE_THUNK_DATA;

typedef struct _IMAGE_IMPORT_DESCRIPTOR {
 __extension__ union {
  DWORD Characteristics;
  DWORD OriginalFirstThunk;
 } ;
 DWORD TimeDateStamp;
 DWORD ForwarderChain;
 DWORD Name;
 DWORD FirstThunk;
} IMAGE_IMPORT_DESCRIPTOR,*PIMAGE_IMPORT_DESCRIPTOR;
typedef struct _IMAGE_BOUND_IMPORT_DESCRIPTOR {
 DWORD TimeDateStamp;
 WORD OffsetModuleName;
 WORD NumberOfModuleForwarderRefs;
} IMAGE_BOUND_IMPORT_DESCRIPTOR,*PIMAGE_BOUND_IMPORT_DESCRIPTOR;
typedef struct _IMAGE_BOUND_FORWARDER_REF {
 DWORD TimeDateStamp;
 WORD OffsetModuleName;
 WORD Reserved;
} IMAGE_BOUND_FORWARDER_REF,*PIMAGE_BOUND_FORWARDER_REF;
typedef void(__attribute__((__stdcall__)) *PIMAGE_TLS_CALLBACK)(PVOID,DWORD,PVOID);
typedef struct _IMAGE_TLS_DIRECTORY32 {
 DWORD StartAddressOfRawData;
 DWORD EndAddressOfRawData;
 DWORD AddressOfIndex;
 DWORD AddressOfCallBacks;
 DWORD SizeOfZeroFill;
 DWORD Characteristics;
} IMAGE_TLS_DIRECTORY32,*PIMAGE_TLS_DIRECTORY32;
typedef struct _IMAGE_TLS_DIRECTORY64 {
 ULONGLONG StartAddressOfRawData;
 ULONGLONG EndAddressOfRawData;
 ULONGLONG AddressOfIndex;
 ULONGLONG AddressOfCallBacks;
 DWORD SizeOfZeroFill;
 DWORD Characteristics;
} IMAGE_TLS_DIRECTORY64, *PIMAGE_TLS_DIRECTORY64;




typedef IMAGE_TLS_DIRECTORY32 IMAGE_TLS_DIRECTORY;
typedef PIMAGE_TLS_DIRECTORY32 PIMAGE_TLS_DIRECTORY;

typedef struct _IMAGE_RESOURCE_DIRECTORY {
 DWORD Characteristics;
 DWORD TimeDateStamp;
 WORD MajorVersion;
 WORD MinorVersion;
 WORD NumberOfNamedEntries;
 WORD NumberOfIdEntries;
} IMAGE_RESOURCE_DIRECTORY,*PIMAGE_RESOURCE_DIRECTORY;
__extension__ typedef struct _IMAGE_RESOURCE_DIRECTORY_ENTRY {
 __extension__ union {
  __extension__ struct {
   DWORD NameOffset:31;
   DWORD NameIsString:1;
  };
  DWORD Name;
  WORD Id;
 } ;
 __extension__ union {
  DWORD OffsetToData;
  __extension__ struct {
   DWORD OffsetToDirectory:31;
   DWORD DataIsDirectory:1;
  } ;
 } ;
} IMAGE_RESOURCE_DIRECTORY_ENTRY,*PIMAGE_RESOURCE_DIRECTORY_ENTRY;
typedef struct _IMAGE_RESOURCE_DIRECTORY_STRING {
 WORD Length;
 CHAR NameString[1];
} IMAGE_RESOURCE_DIRECTORY_STRING,*PIMAGE_RESOURCE_DIRECTORY_STRING;
typedef struct _IMAGE_RESOURCE_DIR_STRING_U {
 WORD Length;
 WCHAR NameString[1];
} IMAGE_RESOURCE_DIR_STRING_U,*PIMAGE_RESOURCE_DIR_STRING_U;
typedef struct _IMAGE_RESOURCE_DATA_ENTRY {
 DWORD OffsetToData;
 DWORD Size;
 DWORD CodePage;
 DWORD Reserved;
} IMAGE_RESOURCE_DATA_ENTRY,*PIMAGE_RESOURCE_DATA_ENTRY;
typedef struct _IMAGE_LOAD_CONFIG_DIRECTORY {
 DWORD Characteristics;
 DWORD TimeDateStamp;
 WORD MajorVersion;
 WORD MinorVersion;
 DWORD GlobalFlagsClear;
 DWORD GlobalFlagsSet;
 DWORD CriticalSectionDefaultTimeout;
 DWORD DeCommitFreeBlockThreshold;
 DWORD DeCommitTotalFreeThreshold;
 PVOID LockPrefixTable;
 DWORD MaximumAllocationSize;
 DWORD VirtualMemoryThreshold;
 DWORD ProcessHeapFlags;
 DWORD Reserved[4];
} IMAGE_LOAD_CONFIG_DIRECTORY,*PIMAGE_LOAD_CONFIG_DIRECTORY;
typedef struct _IMAGE_RUNTIME_FUNCTION_ENTRY {
 DWORD BeginAddress;
 DWORD EndAddress;
 PVOID ExceptionHandler;
 PVOID HandlerData;
 DWORD PrologEndAddress;
} IMAGE_RUNTIME_FUNCTION_ENTRY,*PIMAGE_RUNTIME_FUNCTION_ENTRY;
typedef struct _IMAGE_DEBUG_DIRECTORY {
 DWORD Characteristics;
 DWORD TimeDateStamp;
 WORD MajorVersion;
 WORD MinorVersion;
 DWORD Type;
 DWORD SizeOfData;
 DWORD AddressOfRawData;
 DWORD PointerToRawData;
} IMAGE_DEBUG_DIRECTORY,*PIMAGE_DEBUG_DIRECTORY;
typedef struct _FPO_DATA {
 DWORD ulOffStart;
 DWORD cbProcSize;
 DWORD cdwLocals;
 WORD cdwParams;
 WORD cbProlog:8;
 WORD cbRegs:3;
 WORD fHasSEH:1;
 WORD fUseBP:1;
 WORD reserved:1;
 WORD cbFrame:2;
} FPO_DATA,*PFPO_DATA;
typedef struct _IMAGE_DEBUG_MISC {
 DWORD DataType;
 DWORD Length;
 BOOLEAN Unicode;
 BYTE Reserved[3];
 BYTE Data[1];
} IMAGE_DEBUG_MISC,*PIMAGE_DEBUG_MISC;
typedef struct _IMAGE_FUNCTION_ENTRY {
 DWORD StartingAddress;
 DWORD EndingAddress;
 DWORD EndOfPrologue;
} IMAGE_FUNCTION_ENTRY,*PIMAGE_FUNCTION_ENTRY;
typedef struct _IMAGE_SEPARATE_DEBUG_HEADER {
 WORD Signature;
 WORD Flags;
 WORD Machine;
 WORD Characteristics;
 DWORD TimeDateStamp;
 DWORD CheckSum;
 DWORD ImageBase;
 DWORD SizeOfImage;
 DWORD NumberOfSections;
 DWORD ExportedNamesSize;
 DWORD DebugDirectorySize;
 DWORD SectionAlignment;
 DWORD Reserved[2];
} IMAGE_SEPARATE_DEBUG_HEADER,*PIMAGE_SEPARATE_DEBUG_HEADER;
#pragma pack(pop)
typedef enum _CM_SERVICE_NODE_TYPE {
 DriverType=1,
 FileSystemType=2,
 Win32ServiceOwnProcess=16,
 Win32ServiceShareProcess=32,
 AdapterType=4,
 RecognizerType=8
} SERVICE_NODE_TYPE;
typedef enum _CM_SERVICE_LOAD_TYPE {
 BootLoad=0,
 SystemLoad=1,
 AutoLoad=2,
 DemandLoad=3,
 DisableLoad=4
} SERVICE_LOAD_TYPE;
typedef enum _CM_ERROR_CONTROL_TYPE {
 IgnoreError=0,
 NormalError=1,
 SevereError=2,
 CriticalError=3
} SERVICE_ERROR_TYPE;
typedef struct _NT_TIB {
 struct _EXCEPTION_REGISTRATION_RECORD *ExceptionList;
 PVOID StackBase;
 PVOID StackLimit;
 PVOID SubSystemTib;
 __extension__ union {
  PVOID FiberData;
  DWORD Version;
 } ;
 PVOID ArbitraryUserPointer;
 struct _NT_TIB *Self;
} NT_TIB,*PNT_TIB;
typedef struct _REPARSE_DATA_BUFFER {
 DWORD ReparseTag;
 WORD ReparseDataLength;
 WORD Reserved;
 __extension__ union {
  struct {
   WORD SubstituteNameOffset;
   WORD SubstituteNameLength;
   WORD PrintNameOffset;
   WORD PrintNameLength;
   WCHAR PathBuffer[1];
  } SymbolicLinkReparseBuffer;
  struct {
   WORD SubstituteNameOffset;
   WORD SubstituteNameLength;
   WORD PrintNameOffset;
   WORD PrintNameLength;
   WCHAR PathBuffer[1];
  } MountPointReparseBuffer;
  struct {
   BYTE DataBuffer[1];
  } GenericReparseBuffer;
 } ;
} REPARSE_DATA_BUFFER, *PREPARSE_DATA_BUFFER;
typedef struct _REPARSE_GUID_DATA_BUFFER {
 DWORD ReparseTag;
 WORD ReparseDataLength;
 WORD Reserved;
 GUID ReparseGuid;
 struct {
  BYTE DataBuffer[1];
 } GenericReparseBuffer;
} REPARSE_GUID_DATA_BUFFER, *PREPARSE_GUID_DATA_BUFFER;
typedef struct _REPARSE_POINT_INFORMATION {
 WORD ReparseDataLength;
 WORD UnparsedNameLength;
} REPARSE_POINT_INFORMATION, *PREPARSE_POINT_INFORMATION;

typedef union _FILE_SEGMENT_ELEMENT {
 PVOID64 Buffer;
 ULONGLONG Alignment;
}FILE_SEGMENT_ELEMENT, *PFILE_SEGMENT_ELEMENT;
# 2969 "H:/CPP/wxdevcpp6.10/include/winnt.h" 3
typedef enum _JOBOBJECTINFOCLASS {
 JobObjectBasicAccountingInformation = 1,
 JobObjectBasicLimitInformation,
 JobObjectBasicProcessIdList,
 JobObjectBasicUIRestrictions,
 JobObjectSecurityLimitInformation,
 JobObjectEndOfJobTimeInformation,
 JobObjectAssociateCompletionPortInformation,
 JobObjectBasicAndIoAccountingInformation,
 JobObjectExtendedLimitInformation,
 JobObjectJobSetInformation,
 MaxJobObjectInfoClass
} JOBOBJECTINFOCLASS;
typedef struct _JOBOBJECT_BASIC_ACCOUNTING_INFORMATION {
 LARGE_INTEGER TotalUserTime;
 LARGE_INTEGER TotalKernelTime;
 LARGE_INTEGER ThisPeriodTotalUserTime;
 LARGE_INTEGER ThisPeriodTotalKernelTime;
 DWORD TotalPageFaultCount;
 DWORD TotalProcesses;
 DWORD ActiveProcesses;
 DWORD TotalTerminatedProcesses;
} JOBOBJECT_BASIC_ACCOUNTING_INFORMATION,*PJOBOBJECT_BASIC_ACCOUNTING_INFORMATION;
typedef struct _JOBOBJECT_BASIC_LIMIT_INFORMATION {
 LARGE_INTEGER PerProcessUserTimeLimit;
 LARGE_INTEGER PerJobUserTimeLimit;
 DWORD LimitFlags;
 SIZE_T MinimumWorkingSetSize;
 SIZE_T MaximumWorkingSetSize;
 DWORD ActiveProcessLimit;
 ULONG_PTR Affinity;
 DWORD PriorityClass;
 DWORD SchedulingClass;
} JOBOBJECT_BASIC_LIMIT_INFORMATION,*PJOBOBJECT_BASIC_LIMIT_INFORMATION;
typedef struct _JOBOBJECT_BASIC_PROCESS_ID_LIST {
 DWORD NumberOfAssignedProcesses;
 DWORD NumberOfProcessIdsInList;
 ULONG_PTR ProcessIdList[1];
} JOBOBJECT_BASIC_PROCESS_ID_LIST, *PJOBOBJECT_BASIC_PROCESS_ID_LIST;
typedef struct _JOBOBJECT_BASIC_UI_RESTRICTIONS {
 DWORD UIRestrictionsClass;
} JOBOBJECT_BASIC_UI_RESTRICTIONS,*PJOBOBJECT_BASIC_UI_RESTRICTIONS;
typedef struct _JOBOBJECT_SECURITY_LIMIT_INFORMATION {
 DWORD SecurityLimitFlags;
 HANDLE JobToken;
 PTOKEN_GROUPS SidsToDisable;
 PTOKEN_PRIVILEGES PrivilegesToDelete;
 PTOKEN_GROUPS RestrictedSids;
} JOBOBJECT_SECURITY_LIMIT_INFORMATION,*PJOBOBJECT_SECURITY_LIMIT_INFORMATION;
typedef struct _JOBOBJECT_END_OF_JOB_TIME_INFORMATION {
 DWORD EndOfJobTimeAction;
} JOBOBJECT_END_OF_JOB_TIME_INFORMATION,*PJOBOBJECT_END_OF_JOB_TIME_INFORMATION;
typedef struct _JOBOBJECT_ASSOCIATE_COMPLETION_PORT {
 PVOID CompletionKey;
 HANDLE CompletionPort;
} JOBOBJECT_ASSOCIATE_COMPLETION_PORT,*PJOBOBJECT_ASSOCIATE_COMPLETION_PORT;
typedef struct _JOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION {
 JOBOBJECT_BASIC_ACCOUNTING_INFORMATION BasicInfo;
 IO_COUNTERS IoInfo;
} JOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION,*PJOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION;
typedef struct _JOBOBJECT_EXTENDED_LIMIT_INFORMATION {
 JOBOBJECT_BASIC_LIMIT_INFORMATION BasicLimitInformation;
 IO_COUNTERS IoInfo;
 SIZE_T ProcessMemoryLimit;
 SIZE_T JobMemoryLimit;
 SIZE_T PeakProcessMemoryUsed;
 SIZE_T PeakJobMemoryUsed;
} JOBOBJECT_EXTENDED_LIMIT_INFORMATION,*PJOBOBJECT_EXTENDED_LIMIT_INFORMATION;
typedef struct _JOBOBJECT_JOBSET_INFORMATION {
 DWORD MemberLevel;
} JOBOBJECT_JOBSET_INFORMATION,*PJOBOBJECT_JOBSET_INFORMATION;



# 1 "H:/CPP/wxdevcpp6.10/include/pshpack4.h" 1 3

#pragma pack(push,4)
# 3044 "H:/CPP/wxdevcpp6.10/include/winnt.h" 2 3






typedef enum _LATENCY_TIME {
 LT_DONT_CARE,
 LT_LOWEST_LATENCY
} LATENCY_TIME, *PLATENCY_TIME;

typedef enum _SYSTEM_POWER_STATE {
 PowerSystemUnspecified,
 PowerSystemWorking,
 PowerSystemSleeping1,
 PowerSystemSleeping2,
 PowerSystemSleeping3,
 PowerSystemHibernate,
 PowerSystemShutdown,
 PowerSystemMaximum
} SYSTEM_POWER_STATE, *PSYSTEM_POWER_STATE;


typedef enum {
 PowerActionNone,
 PowerActionReserved,
 PowerActionSleep,
 PowerActionHibernate,
 PowerActionShutdown,
 PowerActionShutdownReset,
 PowerActionShutdownOff,
 PowerActionWarmEject
} POWER_ACTION, *PPOWER_ACTION;

typedef enum _DEVICE_POWER_STATE {
 PowerDeviceUnspecified,
 PowerDeviceD0,
 PowerDeviceD1,
 PowerDeviceD2,
 PowerDeviceD3,
 PowerDeviceMaximum
} DEVICE_POWER_STATE, *PDEVICE_POWER_STATE;

typedef struct {
 DWORD Granularity;
 DWORD Capacity;
} BATTERY_REPORTING_SCALE, *PBATTERY_REPORTING_SCALE;

typedef struct _POWER_ACTION_POLICY {
 POWER_ACTION Action;
 ULONG Flags;
 ULONG EventCode;
} POWER_ACTION_POLICY, *PPOWER_ACTION_POLICY;
# 3125 "H:/CPP/wxdevcpp6.10/include/winnt.h" 3
typedef struct _SYSTEM_POWER_LEVEL {
 BOOLEAN Enable;
 UCHAR Spare[3];
 ULONG BatteryLevel;
 POWER_ACTION_POLICY PowerPolicy;
 SYSTEM_POWER_STATE MinSystemState;
} SYSTEM_POWER_LEVEL, *PSYSTEM_POWER_LEVEL;

typedef struct _SYSTEM_POWER_POLICY {
 ULONG Revision;
 POWER_ACTION_POLICY PowerButton;
 POWER_ACTION_POLICY SleepButton;
 POWER_ACTION_POLICY LidClose;
 SYSTEM_POWER_STATE LidOpenWake;
 ULONG Reserved;
 POWER_ACTION_POLICY Idle;
 ULONG IdleTimeout;
 UCHAR IdleSensitivity;
 UCHAR DynamicThrottle;
 UCHAR Spare2[2];
 SYSTEM_POWER_STATE MinSleep;
 SYSTEM_POWER_STATE MaxSleep;
 SYSTEM_POWER_STATE ReducedLatencySleep;
 ULONG WinLogonFlags;
 ULONG Spare3;
 ULONG DozeS4Timeout;
 ULONG BroadcastCapacityResolution;
 SYSTEM_POWER_LEVEL DischargePolicy[4];
 ULONG VideoTimeout;
 BOOLEAN VideoDimDisplay;
 ULONG VideoReserved[3];
 ULONG SpindownTimeout;
 BOOLEAN OptimizeForPower;
 UCHAR FanThrottleTolerance;
 UCHAR ForcedThrottle;
 UCHAR MinThrottle;
 POWER_ACTION_POLICY OverThrottled;
} SYSTEM_POWER_POLICY, *PSYSTEM_POWER_POLICY;

typedef struct _SYSTEM_POWER_CAPABILITIES {
 BOOLEAN PowerButtonPresent;
 BOOLEAN SleepButtonPresent;
 BOOLEAN LidPresent;
 BOOLEAN SystemS1;
 BOOLEAN SystemS2;
 BOOLEAN SystemS3;
 BOOLEAN SystemS4;
 BOOLEAN SystemS5;
 BOOLEAN HiberFilePresent;
 BOOLEAN FullWake;
 BOOLEAN VideoDimPresent;
 BOOLEAN ApmPresent;
 BOOLEAN UpsPresent;
 BOOLEAN ThermalControl;
 BOOLEAN ProcessorThrottle;
 UCHAR ProcessorMinThrottle;
 UCHAR ProcessorMaxThrottle;
 UCHAR spare2[4];
 BOOLEAN DiskSpinDown;
 UCHAR spare3[8];
 BOOLEAN SystemBatteriesPresent;
 BOOLEAN BatteriesAreShortTerm;
 BATTERY_REPORTING_SCALE BatteryScale[3];
 SYSTEM_POWER_STATE AcOnLineWake;
 SYSTEM_POWER_STATE SoftLidWake;
 SYSTEM_POWER_STATE RtcWake;
 SYSTEM_POWER_STATE MinDeviceWakeState;
 SYSTEM_POWER_STATE DefaultLowLatencyWake;
} SYSTEM_POWER_CAPABILITIES, *PSYSTEM_POWER_CAPABILITIES;

typedef struct _SYSTEM_BATTERY_STATE {
 BOOLEAN AcOnLine;
 BOOLEAN BatteryPresent;
 BOOLEAN Charging;
 BOOLEAN Discharging;
 BOOLEAN Spare1[4];
 ULONG MaxCapacity;
 ULONG RemainingCapacity;
 ULONG Rate;
 ULONG EstimatedTime;
 ULONG DefaultAlert1;
 ULONG DefaultAlert2;
} SYSTEM_BATTERY_STATE, *PSYSTEM_BATTERY_STATE;

typedef enum _POWER_INFORMATION_LEVEL {
 SystemPowerPolicyAc,
 SystemPowerPolicyDc,
 VerifySystemPolicyAc,
 VerifySystemPolicyDc,
 SystemPowerCapabilities,
 SystemBatteryState,
 SystemPowerStateHandler,
 ProcessorStateHandler,
 SystemPowerPolicyCurrent,
 AdministratorPowerPolicy,
 SystemReserveHiberFile,
 ProcessorInformation,
 SystemPowerInformation,
 ProcessorStateHandler2,
 LastWakeTime,
 LastSleepTime,
 SystemExecutionState,
 SystemPowerStateNotifyHandler,
 ProcessorPowerPolicyAc,
 ProcessorPowerPolicyDc,
 VerifyProcessorPowerPolicyAc,
 VerifyProcessorPowerPolicyDc,
 ProcessorPowerPolicyCurrent
} POWER_INFORMATION_LEVEL;





typedef struct _SYSTEM_POWER_INFORMATION {
 ULONG MaxIdlenessAllowed;
 ULONG Idleness;
 ULONG TimeRemaining;
 UCHAR CoolingMode;
} SYSTEM_POWER_INFORMATION,*PSYSTEM_POWER_INFORMATION;
# 3308 "H:/CPP/wxdevcpp6.10/include/winnt.h" 3
typedef struct _PROCESSOR_POWER_POLICY_INFO {
 ULONG TimeCheck;
 ULONG DemoteLimit;
 ULONG PromoteLimit;
 UCHAR DemotePercent;
 UCHAR PromotePercent;
 UCHAR Spare[2];
 ULONG AllowDemotion : 1;
 ULONG AllowPromotion : 1;
 ULONG Reserved : 30;
} PROCESSOR_POWER_POLICY_INFO, *PPROCESSOR_POWER_POLICY_INFO;
typedef struct _PROCESSOR_POWER_POLICY {
 ULONG Revision;
 UCHAR DynamicThrottle;
 UCHAR Spare[3];
 ULONG Reserved;
 ULONG PolicyCount;
 PROCESSOR_POWER_POLICY_INFO Policy[3];
} PROCESSOR_POWER_POLICY, *PPROCESSOR_POWER_POLICY;
typedef struct _ADMINISTRATOR_POWER_POLICY {
 SYSTEM_POWER_STATE MinSleep;
 SYSTEM_POWER_STATE MaxSleep;
 ULONG MinVideoTimeout;
 ULONG MaxVideoTimeout;
 ULONG MinSpindownTimeout;
 ULONG MaxSpindownTimeout;
} ADMINISTRATOR_POWER_POLICY, *PADMINISTRATOR_POWER_POLICY;
# 1 "H:/CPP/wxdevcpp6.10/include/poppack.h" 1 3

#pragma pack(pop)
# 3336 "H:/CPP/wxdevcpp6.10/include/winnt.h" 2 3
# 3346 "H:/CPP/wxdevcpp6.10/include/winnt.h" 3
typedef OSVERSIONINFOA OSVERSIONINFO,*POSVERSIONINFO,*LPOSVERSIONINFO;
typedef OSVERSIONINFOEXA OSVERSIONINFOEX,*POSVERSIONINFOEX,*LPOSVERSIONINFOEX;
# 3357 "H:/CPP/wxdevcpp6.10/include/winnt.h" 3
PVOID GetCurrentFiber(void);
PVOID GetFiberData(void);





extern __inline__ PVOID GetCurrentFiber(void)
{
    void* ret;
    __asm__ __volatile__ (
 "mov{l}	{%%fs:0x10,%0|%0,%%fs:0x10}"
 : "=r" (ret)
 );
    return ret;
}

extern __inline__ PVOID GetFiberData(void)
{
    void* ret;
    __asm__ __volatile__ (
 "mov{l}	{%%fs:0x10,%0|%0,%%fs:0x10}\n\t"
 "mov{l}	{(%0),%0|%0,[%0]}"
 : "=r" (ret)
 );
    return ret;
}

static __inline__ struct _TEB * NtCurrentTeb(void)
{
    struct _TEB *ret;

    __asm__ __volatile__ (
        "mov{l} {%%fs:0x18,%0|%0,%%fs:0x18}\n"
        : "=r" (ret)
        :
    );

    return ret;
}
# 3452 "H:/CPP/wxdevcpp6.10/include/winnt.h" 3
}
# 247 "H:/CPP/wxdevcpp6.10/include/windef.h" 2 3

typedef UINT_PTR WPARAM;
typedef LONG_PTR LPARAM;
typedef LONG_PTR LRESULT;

typedef LONG HRESULT;



typedef WORD ATOM;

typedef HANDLE HGLOBAL;
typedef HANDLE HLOCAL;
typedef HANDLE GLOBALHANDLE;
typedef HANDLE LOCALHANDLE;
typedef void *HGDIOBJ;
typedef struct HACCEL__{int i;}*HACCEL;
typedef struct HBITMAP__{int i;}*HBITMAP;
typedef struct HBRUSH__{int i;}*HBRUSH;
typedef struct HCOLORSPACE__{int i;}*HCOLORSPACE;
typedef struct HDC__{int i;}*HDC;
typedef struct HGLRC__{int i;}*HGLRC;
typedef struct HDESK__{int i;}*HDESK;
typedef struct HENHMETAFILE__{int i;}*HENHMETAFILE;
typedef struct HFONT__{int i;}*HFONT;
typedef struct HICON__{int i;}*HICON;
typedef struct HKEY__{int i;}*HKEY;


typedef struct HMONITOR__{int i;}*HMONITOR;

typedef struct HTERMINAL__{int i;}*HTERMINAL;
typedef struct HWINEVENTHOOK__{int i;}*HWINEVENTHOOK;

typedef HKEY *PHKEY;
typedef struct HMENU__{int i;}*HMENU;
typedef struct HMETAFILE__{int i;}*HMETAFILE;
typedef struct HINSTANCE__{int i;}*HINSTANCE;
typedef HINSTANCE HMODULE;
typedef struct HPALETTE__{int i;}*HPALETTE;
typedef struct HPEN__{int i;}*HPEN;
typedef struct HRGN__{int i;}*HRGN;
typedef struct HRSRC__{int i;}*HRSRC;
typedef struct HSTR__{int i;}*HSTR;
typedef struct HTASK__{int i;}*HTASK;
typedef struct HWND__{int i;}*HWND;
typedef struct HWINSTA__{int i;}*HWINSTA;
typedef struct HKL__{int i;}*HKL;
typedef int HFILE;
typedef HICON HCURSOR;
typedef DWORD COLORREF;
typedef int (__attribute__((__stdcall__)) *FARPROC)();
typedef int (__attribute__((__stdcall__)) *NEARPROC)();
typedef int (__attribute__((__stdcall__)) *PROC)();
typedef struct tagRECT {
 LONG left;
 LONG top;
 LONG right;
 LONG bottom;
} RECT,*PRECT,*LPRECT;
typedef const RECT *LPCRECT;
typedef struct tagRECTL {
 LONG left;
 LONG top;
 LONG right;
 LONG bottom;
} RECTL,*PRECTL,*LPRECTL;
typedef const RECTL *LPCRECTL;
typedef struct tagPOINT {
 LONG x;
 LONG y;
} POINT,POINTL,*PPOINT,*LPPOINT,*PPOINTL,*LPPOINTL;
typedef struct tagSIZE {
 LONG cx;
 LONG cy;
} SIZE,SIZEL,*PSIZE,*LPSIZE,*PSIZEL,*LPSIZEL;
typedef struct tagPOINTS {
 SHORT x;
 SHORT y;
} POINTS,*PPOINTS,*LPPOINTS;


}
# 49 "H:/CPP/wxdevcpp6.10/include/windows.h" 2 3
# 1 "H:/CPP/wxdevcpp6.10/include/wincon.h" 1 3



       
# 5 "H:/CPP/wxdevcpp6.10/include/wincon.h" 3



extern "C" {
# 58 "H:/CPP/wxdevcpp6.10/include/wincon.h" 3
typedef struct _CHAR_INFO {
 union {
  WCHAR UnicodeChar;
  CHAR AsciiChar;
 } Char;
 WORD Attributes;
} CHAR_INFO, *PCHAR_INFO;
typedef struct _SMALL_RECT {
 SHORT Left;
 SHORT Top;
 SHORT Right;
 SHORT Bottom;
} SMALL_RECT, *PSMALL_RECT;
typedef struct _CONSOLE_CURSOR_INFO {
 DWORD dwSize;
 BOOL bVisible;
} CONSOLE_CURSOR_INFO,*PCONSOLE_CURSOR_INFO;
typedef struct _COORD {
 SHORT X;
 SHORT Y;
} COORD, *PCOORD;
typedef struct _CONSOLE_FONT_INFO {
 DWORD nFont;
 COORD dwFontSize;
} CONSOLE_FONT_INFO, *PCONSOLE_FONT_INFO;
typedef struct _CONSOLE_SCREEN_BUFFER_INFO {
 COORD dwSize;
 COORD dwCursorPosition;
 WORD wAttributes;
 SMALL_RECT srWindow;
 COORD dwMaximumWindowSize;
} CONSOLE_SCREEN_BUFFER_INFO,*PCONSOLE_SCREEN_BUFFER_INFO;
typedef BOOL(__attribute__((__stdcall__)) *PHANDLER_ROUTINE)(DWORD);
typedef struct _KEY_EVENT_RECORD {
 BOOL bKeyDown;
 WORD wRepeatCount;
 WORD wVirtualKeyCode;
 WORD wVirtualScanCode;
 union {
  WCHAR UnicodeChar;
  CHAR AsciiChar;
 } uChar;
 DWORD dwControlKeyState;
}


 __attribute__((packed))

KEY_EVENT_RECORD;

typedef struct _MOUSE_EVENT_RECORD {
 COORD dwMousePosition;
 DWORD dwButtonState;
 DWORD dwControlKeyState;
 DWORD dwEventFlags;
} MOUSE_EVENT_RECORD;
typedef struct _WINDOW_BUFFER_SIZE_RECORD { COORD dwSize; } WINDOW_BUFFER_SIZE_RECORD;
typedef struct _MENU_EVENT_RECORD { UINT dwCommandId; } MENU_EVENT_RECORD,*PMENU_EVENT_RECORD;
typedef struct _FOCUS_EVENT_RECORD { BOOL bSetFocus; } FOCUS_EVENT_RECORD;
typedef struct _INPUT_RECORD {
 WORD EventType;
 union {
  KEY_EVENT_RECORD KeyEvent;
  MOUSE_EVENT_RECORD MouseEvent;
  WINDOW_BUFFER_SIZE_RECORD WindowBufferSizeEvent;
  MENU_EVENT_RECORD MenuEvent;
  FOCUS_EVENT_RECORD FocusEvent;
 } Event;
} INPUT_RECORD,*PINPUT_RECORD;

BOOL __attribute__((__stdcall__)) AllocConsole(void);




HANDLE __attribute__((__stdcall__)) CreateConsoleScreenBuffer(DWORD,DWORD,const SECURITY_ATTRIBUTES*,DWORD,LPVOID);
BOOL __attribute__((__stdcall__)) FillConsoleOutputAttribute(HANDLE,WORD,DWORD,COORD,PDWORD);
BOOL __attribute__((__stdcall__)) FillConsoleOutputCharacterA(HANDLE,CHAR,DWORD,COORD,PDWORD);
BOOL __attribute__((__stdcall__)) FillConsoleOutputCharacterW(HANDLE,WCHAR,DWORD,COORD,PDWORD);
BOOL __attribute__((__stdcall__)) FlushConsoleInputBuffer(HANDLE);
BOOL __attribute__((__stdcall__)) FreeConsole(void);
BOOL __attribute__((__stdcall__)) GenerateConsoleCtrlEvent(DWORD,DWORD);
UINT __attribute__((__stdcall__)) GetConsoleCP(void);
BOOL __attribute__((__stdcall__)) GetConsoleCursorInfo(HANDLE,PCONSOLE_CURSOR_INFO);
BOOL __attribute__((__stdcall__)) GetConsoleMode(HANDLE,PDWORD);
UINT __attribute__((__stdcall__)) GetConsoleOutputCP(void);
BOOL __attribute__((__stdcall__)) GetConsoleScreenBufferInfo(HANDLE,PCONSOLE_SCREEN_BUFFER_INFO);
DWORD __attribute__((__stdcall__)) GetConsoleTitleA(LPSTR,DWORD);
DWORD __attribute__((__stdcall__)) GetConsoleTitleW(LPWSTR,DWORD);




COORD __attribute__((__stdcall__)) GetLargestConsoleWindowSize(HANDLE);
BOOL __attribute__((__stdcall__)) GetNumberOfConsoleInputEvents(HANDLE,PDWORD);
BOOL __attribute__((__stdcall__)) GetNumberOfConsoleMouseButtons(PDWORD);
BOOL __attribute__((__stdcall__)) PeekConsoleInputA(HANDLE,PINPUT_RECORD,DWORD,PDWORD);
BOOL __attribute__((__stdcall__)) PeekConsoleInputW(HANDLE,PINPUT_RECORD,DWORD,PDWORD);
BOOL __attribute__((__stdcall__)) ReadConsoleA(HANDLE,PVOID,DWORD,PDWORD,PVOID);
BOOL __attribute__((__stdcall__)) ReadConsoleW(HANDLE,PVOID,DWORD,PDWORD,PVOID);
BOOL __attribute__((__stdcall__)) ReadConsoleInputA(HANDLE,PINPUT_RECORD,DWORD,PDWORD);
BOOL __attribute__((__stdcall__)) ReadConsoleInputW(HANDLE,PINPUT_RECORD,DWORD,PDWORD);
BOOL __attribute__((__stdcall__)) ReadConsoleOutputAttribute(HANDLE,LPWORD,DWORD,COORD,LPDWORD);
BOOL __attribute__((__stdcall__)) ReadConsoleOutputCharacterA(HANDLE,LPSTR,DWORD,COORD,PDWORD);
BOOL __attribute__((__stdcall__)) ReadConsoleOutputCharacterW(HANDLE,LPWSTR,DWORD,COORD,PDWORD);
BOOL __attribute__((__stdcall__)) ReadConsoleOutputA(HANDLE,PCHAR_INFO,COORD,COORD,PSMALL_RECT);
BOOL __attribute__((__stdcall__)) ReadConsoleOutputW(HANDLE,PCHAR_INFO,COORD,COORD,PSMALL_RECT);
BOOL __attribute__((__stdcall__)) ScrollConsoleScreenBufferA(HANDLE,const SMALL_RECT*,const SMALL_RECT*,COORD,const CHAR_INFO*);
BOOL __attribute__((__stdcall__)) ScrollConsoleScreenBufferW(HANDLE,const SMALL_RECT*,const SMALL_RECT*,COORD,const CHAR_INFO*);
BOOL __attribute__((__stdcall__)) SetConsoleActiveScreenBuffer(HANDLE);
BOOL __attribute__((__stdcall__)) SetConsoleCP(UINT);
BOOL __attribute__((__stdcall__)) SetConsoleCtrlHandler(PHANDLER_ROUTINE,BOOL);
BOOL __attribute__((__stdcall__)) SetConsoleCursorInfo(HANDLE,const CONSOLE_CURSOR_INFO*);
BOOL __attribute__((__stdcall__)) SetConsoleCursorPosition(HANDLE,COORD);



BOOL __attribute__((__stdcall__)) SetConsoleMode(HANDLE,DWORD);
BOOL __attribute__((__stdcall__)) SetConsoleOutputCP(UINT);
BOOL __attribute__((__stdcall__)) SetConsoleScreenBufferSize(HANDLE,COORD);
BOOL __attribute__((__stdcall__)) SetConsoleTextAttribute(HANDLE,WORD);
BOOL __attribute__((__stdcall__)) SetConsoleTitleA(LPCSTR);
BOOL __attribute__((__stdcall__)) SetConsoleTitleW(LPCWSTR);
BOOL __attribute__((__stdcall__)) SetConsoleWindowInfo(HANDLE,BOOL,const SMALL_RECT*);
BOOL __attribute__((__stdcall__)) WriteConsoleA(HANDLE,PCVOID,DWORD,PDWORD,PVOID);
BOOL __attribute__((__stdcall__)) WriteConsoleW(HANDLE,PCVOID,DWORD,PDWORD,PVOID);
BOOL __attribute__((__stdcall__)) WriteConsoleInputA(HANDLE,const INPUT_RECORD*,DWORD,PDWORD);
BOOL __attribute__((__stdcall__)) WriteConsoleInputW(HANDLE,const INPUT_RECORD*,DWORD,PDWORD);
BOOL __attribute__((__stdcall__)) WriteConsoleOutputA(HANDLE,const CHAR_INFO*,COORD,COORD,PSMALL_RECT);
BOOL __attribute__((__stdcall__)) WriteConsoleOutputW(HANDLE,const CHAR_INFO*,COORD,COORD,PSMALL_RECT);
BOOL __attribute__((__stdcall__)) WriteConsoleOutputAttribute(HANDLE,const WORD*,DWORD,COORD,PDWORD);
BOOL __attribute__((__stdcall__)) WriteConsoleOutputCharacterA(HANDLE,LPCSTR,DWORD,COORD,PDWORD);
BOOL __attribute__((__stdcall__)) WriteConsoleOutputCharacterW(HANDLE,LPCWSTR,DWORD,COORD,PDWORD);
# 223 "H:/CPP/wxdevcpp6.10/include/wincon.h" 3
}
# 50 "H:/CPP/wxdevcpp6.10/include/windows.h" 2 3
# 1 "H:/CPP/wxdevcpp6.10/include/winbase.h" 1 3



       
# 5 "H:/CPP/wxdevcpp6.10/include/winbase.h" 3
# 24 "H:/CPP/wxdevcpp6.10/include/winbase.h" 3
extern "C" {
# 551 "H:/CPP/wxdevcpp6.10/include/winbase.h" 3
typedef struct _FILETIME {
 DWORD dwLowDateTime;
 DWORD dwHighDateTime;
} FILETIME,*PFILETIME,*LPFILETIME;
typedef struct _BY_HANDLE_FILE_INFORMATION {
 DWORD dwFileAttributes;
 FILETIME ftCreationTime;
 FILETIME ftLastAccessTime;
 FILETIME ftLastWriteTime;
 DWORD dwVolumeSerialNumber;
 DWORD nFileSizeHigh;
 DWORD nFileSizeLow;
 DWORD nNumberOfLinks;
 DWORD nFileIndexHigh;
 DWORD nFileIndexLow;
} BY_HANDLE_FILE_INFORMATION,*LPBY_HANDLE_FILE_INFORMATION;
typedef struct _DCB {
 DWORD DCBlength;
 DWORD BaudRate;
 DWORD fBinary:1;
 DWORD fParity:1;
 DWORD fOutxCtsFlow:1;
 DWORD fOutxDsrFlow:1;
 DWORD fDtrControl:2;
 DWORD fDsrSensitivity:1;
 DWORD fTXContinueOnXoff:1;
 DWORD fOutX:1;
 DWORD fInX:1;
 DWORD fErrorChar:1;
 DWORD fNull:1;
 DWORD fRtsControl:2;
 DWORD fAbortOnError:1;
 DWORD fDummy2:17;
 WORD wReserved;
 WORD XonLim;
 WORD XoffLim;
 BYTE ByteSize;
 BYTE Parity;
 BYTE StopBits;
 char XonChar;
 char XoffChar;
 char ErrorChar;
 char EofChar;
 char EvtChar;
 WORD wReserved1;
} DCB,*LPDCB;
typedef struct _COMM_CONFIG {
 DWORD dwSize;
 WORD wVersion;
 WORD wReserved;
 DCB dcb;
 DWORD dwProviderSubType;
 DWORD dwProviderOffset;
 DWORD dwProviderSize;
 WCHAR wcProviderData[1];
} COMMCONFIG,*LPCOMMCONFIG;
typedef struct _COMMPROP {
 WORD wPacketLength;
 WORD wPacketVersion;
 DWORD dwServiceMask;
 DWORD dwReserved1;
 DWORD dwMaxTxQueue;
 DWORD dwMaxRxQueue;
 DWORD dwMaxBaud;
 DWORD dwProvSubType;
 DWORD dwProvCapabilities;
 DWORD dwSettableParams;
 DWORD dwSettableBaud;
 WORD wSettableData;
 WORD wSettableStopParity;
 DWORD dwCurrentTxQueue;
 DWORD dwCurrentRxQueue;
 DWORD dwProvSpec1;
 DWORD dwProvSpec2;
 WCHAR wcProvChar[1];
} COMMPROP,*LPCOMMPROP;
typedef struct _COMMTIMEOUTS {
 DWORD ReadIntervalTimeout;
 DWORD ReadTotalTimeoutMultiplier;
 DWORD ReadTotalTimeoutConstant;
 DWORD WriteTotalTimeoutMultiplier;
 DWORD WriteTotalTimeoutConstant;
} COMMTIMEOUTS,*LPCOMMTIMEOUTS;
typedef struct _COMSTAT {
 DWORD fCtsHold:1;
 DWORD fDsrHold:1;
 DWORD fRlsdHold:1;
 DWORD fXoffHold:1;
 DWORD fXoffSent:1;
 DWORD fEof:1;
 DWORD fTxim:1;
 DWORD fReserved:25;
 DWORD cbInQue;
 DWORD cbOutQue;
} COMSTAT,*LPCOMSTAT;
typedef DWORD (__attribute__((__stdcall__)) *LPTHREAD_START_ROUTINE)(LPVOID);
typedef struct _CREATE_PROCESS_DEBUG_INFO {
 HANDLE hFile;
 HANDLE hProcess;
 HANDLE hThread;
 LPVOID lpBaseOfImage;
 DWORD dwDebugInfoFileOffset;
 DWORD nDebugInfoSize;
 LPVOID lpThreadLocalBase;
 LPTHREAD_START_ROUTINE lpStartAddress;
 LPVOID lpImageName;
 WORD fUnicode;
} CREATE_PROCESS_DEBUG_INFO,*LPCREATE_PROCESS_DEBUG_INFO;
typedef struct _CREATE_THREAD_DEBUG_INFO {
 HANDLE hThread;
 LPVOID lpThreadLocalBase;
 LPTHREAD_START_ROUTINE lpStartAddress;
} CREATE_THREAD_DEBUG_INFO,*LPCREATE_THREAD_DEBUG_INFO;
typedef struct _EXCEPTION_DEBUG_INFO {
 EXCEPTION_RECORD ExceptionRecord;
 DWORD dwFirstChance;
} EXCEPTION_DEBUG_INFO,*LPEXCEPTION_DEBUG_INFO;
typedef struct _EXIT_THREAD_DEBUG_INFO {
 DWORD dwExitCode;
} EXIT_THREAD_DEBUG_INFO,*LPEXIT_THREAD_DEBUG_INFO;
typedef struct _EXIT_PROCESS_DEBUG_INFO {
 DWORD dwExitCode;
} EXIT_PROCESS_DEBUG_INFO,*LPEXIT_PROCESS_DEBUG_INFO;
typedef struct _LOAD_DLL_DEBUG_INFO {
 HANDLE hFile;
 LPVOID lpBaseOfDll;
 DWORD dwDebugInfoFileOffset;
 DWORD nDebugInfoSize;
 LPVOID lpImageName;
 WORD fUnicode;
} LOAD_DLL_DEBUG_INFO,*LPLOAD_DLL_DEBUG_INFO;
typedef struct _UNLOAD_DLL_DEBUG_INFO {
 LPVOID lpBaseOfDll;
} UNLOAD_DLL_DEBUG_INFO,*LPUNLOAD_DLL_DEBUG_INFO;
typedef struct _OUTPUT_DEBUG_STRING_INFO {
 LPSTR lpDebugStringData;
 WORD fUnicode;
 WORD nDebugStringLength;
} OUTPUT_DEBUG_STRING_INFO,*LPOUTPUT_DEBUG_STRING_INFO;
typedef struct _RIP_INFO {
 DWORD dwError;
 DWORD dwType;
} RIP_INFO,*LPRIP_INFO;
typedef struct _DEBUG_EVENT {
 DWORD dwDebugEventCode;
 DWORD dwProcessId;
 DWORD dwThreadId;
 union {
  EXCEPTION_DEBUG_INFO Exception;
  CREATE_THREAD_DEBUG_INFO CreateThread;
  CREATE_PROCESS_DEBUG_INFO CreateProcessInfo;
  EXIT_THREAD_DEBUG_INFO ExitThread;
  EXIT_PROCESS_DEBUG_INFO ExitProcess;
  LOAD_DLL_DEBUG_INFO LoadDll;
  UNLOAD_DLL_DEBUG_INFO UnloadDll;
  OUTPUT_DEBUG_STRING_INFO DebugString;
  RIP_INFO RipInfo;
 } u;
} DEBUG_EVENT,*LPDEBUG_EVENT;
typedef struct _OVERLAPPED {
 DWORD Internal;
 DWORD InternalHigh;
 DWORD Offset;
 DWORD OffsetHigh;
 HANDLE hEvent;
} OVERLAPPED,*POVERLAPPED,*LPOVERLAPPED;
typedef struct _STARTUPINFOA {
 DWORD cb;
 LPSTR lpReserved;
 LPSTR lpDesktop;
 LPSTR lpTitle;
 DWORD dwX;
 DWORD dwY;
 DWORD dwXSize;
 DWORD dwYSize;
 DWORD dwXCountChars;
 DWORD dwYCountChars;
 DWORD dwFillAttribute;
 DWORD dwFlags;
 WORD wShowWindow;
 WORD cbReserved2;
 PBYTE lpReserved2;
 HANDLE hStdInput;
 HANDLE hStdOutput;
 HANDLE hStdError;
} STARTUPINFOA,*LPSTARTUPINFOA;
typedef struct _STARTUPINFOW {
 DWORD cb;
 LPWSTR lpReserved;
 LPWSTR lpDesktop;
 LPWSTR lpTitle;
 DWORD dwX;
 DWORD dwY;
 DWORD dwXSize;
 DWORD dwYSize;
 DWORD dwXCountChars;
 DWORD dwYCountChars;
 DWORD dwFillAttribute;
 DWORD dwFlags;
 WORD wShowWindow;
 WORD cbReserved2;
 PBYTE lpReserved2;
 HANDLE hStdInput;
 HANDLE hStdOutput;
 HANDLE hStdError;
} STARTUPINFOW,*LPSTARTUPINFOW;
typedef struct _PROCESS_INFORMATION {
 HANDLE hProcess;
 HANDLE hThread;
 DWORD dwProcessId;
 DWORD dwThreadId;
} PROCESS_INFORMATION,*PPROCESS_INFORMATION,*LPPROCESS_INFORMATION;
typedef struct _CRITICAL_SECTION_DEBUG {
 WORD Type;
 WORD CreatorBackTraceIndex;
 struct _CRITICAL_SECTION *CriticalSection;
 LIST_ENTRY ProcessLocksList;
 DWORD EntryCount;
 DWORD ContentionCount;
 DWORD Spare [2];
} CRITICAL_SECTION_DEBUG,*PCRITICAL_SECTION_DEBUG;
typedef struct _CRITICAL_SECTION {
 PCRITICAL_SECTION_DEBUG DebugInfo;
 LONG LockCount;
 LONG RecursionCount;
 HANDLE OwningThread;
 HANDLE LockSemaphore;
 DWORD SpinCount;
} CRITICAL_SECTION,*PCRITICAL_SECTION,*LPCRITICAL_SECTION;
typedef struct _SYSTEMTIME {
 WORD wYear;
 WORD wMonth;
 WORD wDayOfWeek;
 WORD wDay;
 WORD wHour;
 WORD wMinute;
 WORD wSecond;
 WORD wMilliseconds;
} SYSTEMTIME,*LPSYSTEMTIME;
typedef struct _WIN32_FILE_ATTRIBUTE_DATA {
 DWORD dwFileAttributes;
 FILETIME ftCreationTime;
 FILETIME ftLastAccessTime;
 FILETIME ftLastWriteTime;
 DWORD nFileSizeHigh;
 DWORD nFileSizeLow;
} WIN32_FILE_ATTRIBUTE_DATA,*LPWIN32_FILE_ATTRIBUTE_DATA;
typedef struct _WIN32_FIND_DATAA {
 DWORD dwFileAttributes;
 FILETIME ftCreationTime;
 FILETIME ftLastAccessTime;
 FILETIME ftLastWriteTime;
 DWORD nFileSizeHigh;
 DWORD nFileSizeLow;
 DWORD dwReserved0;
 DWORD dwReserved1;
 CHAR cFileName[260];
 CHAR cAlternateFileName[14];
} WIN32_FIND_DATAA,*PWIN32_FIND_DATAA,*LPWIN32_FIND_DATAA;
typedef struct _WIN32_FIND_DATAW {
 DWORD dwFileAttributes;
 FILETIME ftCreationTime;
 FILETIME ftLastAccessTime;
 FILETIME ftLastWriteTime;
 DWORD nFileSizeHigh;
 DWORD nFileSizeLow;
 DWORD dwReserved0;
 DWORD dwReserved1;
 WCHAR cFileName[260];
 WCHAR cAlternateFileName[14];
} WIN32_FIND_DATAW,*PWIN32_FIND_DATAW,*LPWIN32_FIND_DATAW;
typedef struct _WIN32_STREAM_ID {
 DWORD dwStreamId;
 DWORD dwStreamAttributes;
 LARGE_INTEGER Size;
 DWORD dwStreamNameSize;
 WCHAR cStreamName[1];
} WIN32_STREAM_ID, *LPWIN32_STREAM_ID;
typedef enum _FINDEX_INFO_LEVELS {
 FindExInfoStandard,
 FindExInfoMaxInfoLevel
} FINDEX_INFO_LEVELS;
typedef enum _FINDEX_SEARCH_OPS {
 FindExSearchNameMatch,
 FindExSearchLimitToDirectories,
 FindExSearchLimitToDevices,
 FindExSearchMaxSearchOp
} FINDEX_SEARCH_OPS;
typedef enum _ACL_INFORMATION_CLASS {
 AclRevisionInformation=1,
 AclSizeInformation
} ACL_INFORMATION_CLASS;
typedef struct tagHW_PROFILE_INFOA {
 DWORD dwDockInfo;
 CHAR szHwProfileGuid[39];
 CHAR szHwProfileName[80];
} HW_PROFILE_INFOA,*LPHW_PROFILE_INFOA;
typedef struct tagHW_PROFILE_INFOW {
 DWORD dwDockInfo;
 WCHAR szHwProfileGuid[39];
 WCHAR szHwProfileName[80];
} HW_PROFILE_INFOW,*LPHW_PROFILE_INFOW;
typedef enum _GET_FILEEX_INFO_LEVELS {
 GetFileExInfoStandard,
 GetFileExMaxInfoLevel
} GET_FILEEX_INFO_LEVELS;
typedef struct _SYSTEM_INFO {
 __extension__ union {
  DWORD dwOemId;
  __extension__ struct {
   WORD wProcessorArchitecture;
   WORD wReserved;
  } ;
 } ;
 DWORD dwPageSize;
 PVOID lpMinimumApplicationAddress;
 PVOID lpMaximumApplicationAddress;
 DWORD dwActiveProcessorMask;
 DWORD dwNumberOfProcessors;
 DWORD dwProcessorType;
 DWORD dwAllocationGranularity;
 WORD wProcessorLevel;
 WORD wProcessorRevision;
} SYSTEM_INFO,*LPSYSTEM_INFO;
typedef struct _SYSTEM_POWER_STATUS {
 BYTE ACLineStatus;
 BYTE BatteryFlag;
 BYTE BatteryLifePercent;
 BYTE Reserved1;
 DWORD BatteryLifeTime;
 DWORD BatteryFullLifeTime;
} SYSTEM_POWER_STATUS,*LPSYSTEM_POWER_STATUS;
typedef struct _TIME_ZONE_INFORMATION {
 LONG Bias;
 WCHAR StandardName[32];
 SYSTEMTIME StandardDate;
 LONG StandardBias;
 WCHAR DaylightName[32];
 SYSTEMTIME DaylightDate;
 LONG DaylightBias;
} TIME_ZONE_INFORMATION,*LPTIME_ZONE_INFORMATION;
typedef struct _MEMORYSTATUS {
 DWORD dwLength;
 DWORD dwMemoryLoad;
 DWORD dwTotalPhys;
 DWORD dwAvailPhys;
 DWORD dwTotalPageFile;
 DWORD dwAvailPageFile;
 DWORD dwTotalVirtual;
 DWORD dwAvailVirtual;
} MEMORYSTATUS,*LPMEMORYSTATUS;
# 915 "H:/CPP/wxdevcpp6.10/include/winbase.h" 3
typedef struct _LDT_ENTRY {
 WORD LimitLow;
 WORD BaseLow;
 union {
  struct {
   BYTE BaseMid;
   BYTE Flags1;
   BYTE Flags2;
   BYTE BaseHi;
  } Bytes;
  struct {
   DWORD BaseMid:8;
   DWORD Type:5;
   DWORD Dpl:2;
   DWORD Pres:1;
   DWORD LimitHi:4;
   DWORD Sys:1;
   DWORD Reserved_0:1;
   DWORD Default_Big:1;
   DWORD Granularity:1;
   DWORD BaseHi:8;
  } Bits;
 } HighWord;
} LDT_ENTRY,*PLDT_ENTRY,*LPLDT_ENTRY;
typedef struct _PROCESS_HEAP_ENTRY {
 PVOID lpData;
 DWORD cbData;
 BYTE cbOverhead;
 BYTE iRegionIndex;
 WORD wFlags;
 __extension__ union {
  struct {
   HANDLE hMem;
   DWORD dwReserved[3];
  } Block;
  struct {
   DWORD dwCommittedSize;
   DWORD dwUnCommittedSize;
   LPVOID lpFirstBlock;
   LPVOID lpLastBlock;
  } Region;
 } ;
} PROCESS_HEAP_ENTRY,*LPPROCESS_HEAP_ENTRY;
typedef struct _OFSTRUCT {
 BYTE cBytes;
 BYTE fFixedDisk;
 WORD nErrCode;
 WORD Reserved1;
 WORD Reserved2;
 CHAR szPathName[128];
} OFSTRUCT,*LPOFSTRUCT,*POFSTRUCT;
typedef struct _WIN_CERTIFICATE {
      DWORD dwLength;
      WORD wRevision;
      WORD wCertificateType;
      BYTE bCertificate[1];
} WIN_CERTIFICATE, *LPWIN_CERTIFICATE;
# 1032 "H:/CPP/wxdevcpp6.10/include/winbase.h" 3
typedef DWORD(__attribute__((__stdcall__)) *LPPROGRESS_ROUTINE)(LARGE_INTEGER,LARGE_INTEGER,LARGE_INTEGER,LARGE_INTEGER,DWORD,DWORD,HANDLE,HANDLE,LPVOID);
typedef void(__attribute__((__stdcall__)) *LPFIBER_START_ROUTINE)(PVOID);
typedef BOOL(__attribute__((__stdcall__)) *ENUMRESLANGPROC)(HMODULE,LPCTSTR,LPCTSTR,WORD,LONG);
typedef BOOL(__attribute__((__stdcall__)) *ENUMRESNAMEPROC)(HMODULE,LPCTSTR,LPTSTR,LONG);
typedef BOOL(__attribute__((__stdcall__)) *ENUMRESTYPEPROC)(HMODULE,LPTSTR,LONG);
typedef void(__attribute__((__stdcall__)) *LPOVERLAPPED_COMPLETION_ROUTINE)(DWORD,DWORD,LPOVERLAPPED);
typedef LONG(__attribute__((__stdcall__)) *PTOP_LEVEL_EXCEPTION_FILTER)(LPEXCEPTION_POINTERS);
typedef PTOP_LEVEL_EXCEPTION_FILTER LPTOP_LEVEL_EXCEPTION_FILTER;
typedef void(__attribute__((__stdcall__)) *PAPCFUNC)(DWORD);
typedef void(__attribute__((__stdcall__)) *PTIMERAPCROUTINE)(PVOID,DWORD,DWORD);






int __attribute__((__stdcall__)) WinMain(HINSTANCE,HINSTANCE,LPSTR,int);



int __attribute__((__stdcall__)) wWinMain(HINSTANCE,HINSTANCE,LPWSTR,int);
 long __attribute__((__stdcall__)) _hread(HFILE,LPVOID,long);
 long __attribute__((__stdcall__)) _hwrite(HFILE,LPCSTR,long);
 HFILE __attribute__((__stdcall__)) _lclose(HFILE);
 HFILE __attribute__((__stdcall__)) _lcreat(LPCSTR,int);
 LONG __attribute__((__stdcall__)) _llseek(HFILE,LONG,int);
 HFILE __attribute__((__stdcall__)) _lopen(LPCSTR,int);
 UINT __attribute__((__stdcall__)) _lread(HFILE,LPVOID,UINT);
 UINT __attribute__((__stdcall__)) _lwrite(HFILE,LPCSTR,UINT);

 BOOL __attribute__((__stdcall__)) AccessCheck(PSECURITY_DESCRIPTOR,HANDLE,DWORD,PGENERIC_MAPPING,PPRIVILEGE_SET,PDWORD,PDWORD,PBOOL);
 BOOL __attribute__((__stdcall__)) AccessCheckAndAuditAlarmA(LPCSTR,LPVOID,LPSTR,LPSTR,PSECURITY_DESCRIPTOR,DWORD,PGENERIC_MAPPING,BOOL,PDWORD,PBOOL,PBOOL);
 BOOL __attribute__((__stdcall__)) AccessCheckAndAuditAlarmW(LPCWSTR,LPVOID,LPWSTR,LPWSTR,PSECURITY_DESCRIPTOR,DWORD,PGENERIC_MAPPING,BOOL,PDWORD,PBOOL,PBOOL);



 BOOL __attribute__((__stdcall__)) AddAccessAllowedAce(PACL,DWORD,DWORD,PSID);
 BOOL __attribute__((__stdcall__)) AddAccessDeniedAce(PACL,DWORD,DWORD,PSID);




 BOOL __attribute__((__stdcall__)) AddAce(PACL,DWORD,DWORD,PVOID,DWORD);
 ATOM __attribute__((__stdcall__)) AddAtomA(LPCSTR);
 ATOM __attribute__((__stdcall__)) AddAtomW(LPCWSTR);
 BOOL __attribute__((__stdcall__)) AddAuditAccessAce(PACL,DWORD,DWORD,PSID,BOOL,BOOL);






 BOOL __attribute__((__stdcall__)) AdjustTokenGroups(HANDLE,BOOL,PTOKEN_GROUPS,DWORD,PTOKEN_GROUPS,PDWORD);
 BOOL __attribute__((__stdcall__)) AdjustTokenPrivileges(HANDLE,BOOL,PTOKEN_PRIVILEGES,DWORD,PTOKEN_PRIVILEGES,PDWORD);
 BOOL __attribute__((__stdcall__)) AllocateAndInitializeSid(PSID_IDENTIFIER_AUTHORITY,BYTE,DWORD,DWORD,DWORD,DWORD,DWORD,DWORD,DWORD,DWORD,PSID*);
 BOOL __attribute__((__stdcall__)) AllocateLocallyUniqueId(PLUID);
 BOOL __attribute__((__stdcall__)) AreAllAccessesGranted(DWORD,DWORD);
 BOOL __attribute__((__stdcall__)) AreAnyAccessesGranted(DWORD,DWORD);
 BOOL __attribute__((__stdcall__)) AreFileApisANSI(void);
 BOOL __attribute__((__stdcall__)) BackupEventLogA(HANDLE,LPCSTR);
 BOOL __attribute__((__stdcall__)) BackupEventLogW(HANDLE,LPCWSTR);
 BOOL __attribute__((__stdcall__)) BackupRead(HANDLE,LPBYTE,DWORD,LPDWORD,BOOL,BOOL,LPVOID*);
 BOOL __attribute__((__stdcall__)) BackupSeek(HANDLE,DWORD,DWORD,LPDWORD,LPDWORD,LPVOID*);
 BOOL __attribute__((__stdcall__)) BackupWrite(HANDLE,LPBYTE,DWORD,LPDWORD,BOOL,BOOL,LPVOID*);
 BOOL __attribute__((__stdcall__)) Beep(DWORD,DWORD);
 HANDLE __attribute__((__stdcall__)) BeginUpdateResourceA(LPCSTR,BOOL);
 HANDLE __attribute__((__stdcall__)) BeginUpdateResourceW(LPCWSTR,BOOL);
 BOOL __attribute__((__stdcall__)) BuildCommDCBA(LPCSTR,LPDCB);
 BOOL __attribute__((__stdcall__)) BuildCommDCBW(LPCWSTR,LPDCB);
 BOOL __attribute__((__stdcall__)) BuildCommDCBAndTimeoutsA(LPCSTR,LPDCB,LPCOMMTIMEOUTS);
 BOOL __attribute__((__stdcall__)) BuildCommDCBAndTimeoutsW(LPCWSTR,LPDCB,LPCOMMTIMEOUTS);
 BOOL __attribute__((__stdcall__)) CallNamedPipeA(LPCSTR,PVOID,DWORD,PVOID,DWORD,PDWORD,DWORD);
 BOOL __attribute__((__stdcall__)) CallNamedPipeW(LPCWSTR,PVOID,DWORD,PVOID,DWORD,PDWORD,DWORD);
 BOOL __attribute__((__stdcall__)) CancelDeviceWakeupRequest(HANDLE);
 BOOL __attribute__((__stdcall__)) CancelIo(HANDLE);
 BOOL __attribute__((__stdcall__)) CancelWaitableTimer(HANDLE);





 BOOL __attribute__((__stdcall__)) ClearCommBreak(HANDLE);
 BOOL __attribute__((__stdcall__)) ClearCommError(HANDLE,PDWORD,LPCOMSTAT);
 BOOL __attribute__((__stdcall__)) ClearEventLogA(HANDLE,LPCSTR);
 BOOL __attribute__((__stdcall__)) ClearEventLogW(HANDLE,LPCWSTR);
 BOOL __attribute__((__stdcall__)) CloseEventLog(HANDLE);
 BOOL __attribute__((__stdcall__)) CloseHandle(HANDLE);
 BOOL __attribute__((__stdcall__)) CommConfigDialogA(LPCSTR,HWND,LPCOMMCONFIG);
 BOOL __attribute__((__stdcall__)) CommConfigDialogW(LPCWSTR,HWND,LPCOMMCONFIG);
 LONG __attribute__((__stdcall__)) CompareFileTime(const FILETIME*,const FILETIME*);
 BOOL __attribute__((__stdcall__)) ConnectNamedPipe(HANDLE,LPOVERLAPPED);
 BOOL __attribute__((__stdcall__)) ContinueDebugEvent(DWORD,DWORD,DWORD);

 BOOL __attribute__((__stdcall__)) ConvertFiberToThread(void);

 PVOID __attribute__((__stdcall__)) ConvertThreadToFiber(PVOID);
 BOOL __attribute__((__stdcall__)) CopyFileA(LPCSTR,LPCSTR,BOOL);
 BOOL __attribute__((__stdcall__)) CopyFileW(LPCWSTR,LPCWSTR,BOOL);
 BOOL __attribute__((__stdcall__)) CopyFileExA(LPCSTR,LPCSTR,LPPROGRESS_ROUTINE,LPVOID,LPBOOL,DWORD);
 BOOL __attribute__((__stdcall__)) CopyFileExW(LPCWSTR,LPCWSTR,LPPROGRESS_ROUTINE,LPVOID,LPBOOL,DWORD);
# 1140 "H:/CPP/wxdevcpp6.10/include/winbase.h" 3
 BOOL __attribute__((__stdcall__)) CopySid(DWORD,PSID,PSID);




 BOOL __attribute__((__stdcall__)) CreateDirectoryA(LPCSTR,LPSECURITY_ATTRIBUTES);
 BOOL __attribute__((__stdcall__)) CreateDirectoryW(LPCWSTR,LPSECURITY_ATTRIBUTES);
 BOOL __attribute__((__stdcall__)) CreateDirectoryExA(LPCSTR,LPCSTR,LPSECURITY_ATTRIBUTES);
 BOOL __attribute__((__stdcall__)) CreateDirectoryExW(LPCWSTR,LPCWSTR,LPSECURITY_ATTRIBUTES);
 HANDLE __attribute__((__stdcall__)) CreateEventA(LPSECURITY_ATTRIBUTES,BOOL,BOOL,LPCSTR);
 HANDLE __attribute__((__stdcall__)) CreateEventW(LPSECURITY_ATTRIBUTES,BOOL,BOOL,LPCWSTR);
 LPVOID __attribute__((__stdcall__)) CreateFiber(SIZE_T,LPFIBER_START_ROUTINE,LPVOID);

 LPVOID __attribute__((__stdcall__)) CreateFiberEx(SIZE_T,SIZE_T,DWORD,LPFIBER_START_ROUTINE,LPVOID);

 HANDLE __attribute__((__stdcall__)) CreateFileA(LPCSTR,DWORD,DWORD,LPSECURITY_ATTRIBUTES,DWORD,DWORD,HANDLE);
 HANDLE __attribute__((__stdcall__)) CreateFileW(LPCWSTR,DWORD,DWORD,LPSECURITY_ATTRIBUTES,DWORD,DWORD,HANDLE);
 HANDLE __attribute__((__stdcall__)) CreateFileMappingA(HANDLE,LPSECURITY_ATTRIBUTES,DWORD,DWORD,DWORD,LPCSTR);
 HANDLE __attribute__((__stdcall__)) CreateFileMappingW(HANDLE,LPSECURITY_ATTRIBUTES,DWORD,DWORD,DWORD,LPCWSTR);




 HANDLE __attribute__((__stdcall__)) CreateIoCompletionPort(HANDLE,HANDLE,DWORD,DWORD);






 HANDLE __attribute__((__stdcall__)) CreateMailslotA(LPCSTR,DWORD,DWORD,LPSECURITY_ATTRIBUTES);
 HANDLE __attribute__((__stdcall__)) CreateMailslotW(LPCWSTR,DWORD,DWORD,LPSECURITY_ATTRIBUTES);



 HANDLE __attribute__((__stdcall__)) CreateMutexA(LPSECURITY_ATTRIBUTES,BOOL,LPCSTR);
 HANDLE __attribute__((__stdcall__)) CreateMutexW(LPSECURITY_ATTRIBUTES,BOOL,LPCWSTR);
 HANDLE __attribute__((__stdcall__)) CreateNamedPipeA(LPCSTR,DWORD,DWORD,DWORD,DWORD,DWORD,DWORD,LPSECURITY_ATTRIBUTES);
 HANDLE __attribute__((__stdcall__)) CreateNamedPipeW(LPCWSTR,DWORD,DWORD,DWORD,DWORD,DWORD,DWORD,LPSECURITY_ATTRIBUTES);
 BOOL __attribute__((__stdcall__)) CreatePipe(PHANDLE,PHANDLE,LPSECURITY_ATTRIBUTES,DWORD);
 BOOL __attribute__((__stdcall__)) CreatePrivateObjectSecurity(PSECURITY_DESCRIPTOR,PSECURITY_DESCRIPTOR,PSECURITY_DESCRIPTOR*,BOOL,HANDLE,PGENERIC_MAPPING);
 BOOL __attribute__((__stdcall__)) CreateProcessA(LPCSTR,LPSTR,LPSECURITY_ATTRIBUTES,LPSECURITY_ATTRIBUTES,BOOL,DWORD,PVOID,LPCSTR,LPSTARTUPINFOA,LPPROCESS_INFORMATION);
 BOOL __attribute__((__stdcall__)) CreateProcessW(LPCWSTR,LPWSTR,LPSECURITY_ATTRIBUTES,LPSECURITY_ATTRIBUTES,BOOL,DWORD,PVOID,LPCWSTR,LPSTARTUPINFOW,LPPROCESS_INFORMATION);
 BOOL __attribute__((__stdcall__)) CreateProcessAsUserA(HANDLE,LPCSTR,LPSTR,LPSECURITY_ATTRIBUTES,LPSECURITY_ATTRIBUTES,BOOL,DWORD,PVOID,LPCSTR,LPSTARTUPINFOA,LPPROCESS_INFORMATION);
 BOOL __attribute__((__stdcall__)) CreateProcessAsUserW(HANDLE,LPCWSTR,LPWSTR,LPSECURITY_ATTRIBUTES,LPSECURITY_ATTRIBUTES,BOOL,DWORD,PVOID,LPCWSTR,LPSTARTUPINFOW,LPPROCESS_INFORMATION);
# 1193 "H:/CPP/wxdevcpp6.10/include/winbase.h" 3
 HANDLE __attribute__((__stdcall__)) CreateRemoteThread(HANDLE,LPSECURITY_ATTRIBUTES,DWORD,LPTHREAD_START_ROUTINE,LPVOID,DWORD,LPDWORD);
 HANDLE __attribute__((__stdcall__)) CreateSemaphoreA(LPSECURITY_ATTRIBUTES,LONG,LONG,LPCSTR);
 HANDLE __attribute__((__stdcall__)) CreateSemaphoreW(LPSECURITY_ATTRIBUTES,LONG,LONG,LPCWSTR);
 DWORD __attribute__((__stdcall__)) CreateTapePartition(HANDLE,DWORD,DWORD,DWORD);




 HANDLE __attribute__((__stdcall__)) CreateThread(LPSECURITY_ATTRIBUTES,DWORD,LPTHREAD_START_ROUTINE,PVOID,DWORD,PDWORD);
 HANDLE __attribute__((__stdcall__)) CreateWaitableTimerA(LPSECURITY_ATTRIBUTES,BOOL,LPCSTR);
 HANDLE __attribute__((__stdcall__)) CreateWaitableTimerW(LPSECURITY_ATTRIBUTES,BOOL,LPCWSTR);



 BOOL __attribute__((__stdcall__)) DebugActiveProcess(DWORD);



 void __attribute__((__stdcall__)) DebugBreak(void);




 BOOL __attribute__((__stdcall__)) DefineDosDeviceA(DWORD,LPCSTR,LPCSTR);
 BOOL __attribute__((__stdcall__)) DefineDosDeviceW(DWORD,LPCWSTR,LPCWSTR);

 BOOL __attribute__((__stdcall__)) DeleteAce(PACL,DWORD);
 ATOM __attribute__((__stdcall__)) DeleteAtom(ATOM);
 void __attribute__((__stdcall__)) DeleteCriticalSection(PCRITICAL_SECTION);
 void __attribute__((__stdcall__)) DeleteFiber(PVOID);
 BOOL __attribute__((__stdcall__)) DeleteFileA(LPCSTR);
 BOOL __attribute__((__stdcall__)) DeleteFileW(LPCWSTR);







 BOOL __attribute__((__stdcall__)) DeregisterEventSource(HANDLE);
 BOOL __attribute__((__stdcall__)) DestroyPrivateObjectSecurity(PSECURITY_DESCRIPTOR*);
 BOOL __attribute__((__stdcall__)) DeviceIoControl(HANDLE,DWORD,PVOID,DWORD,PVOID,DWORD,PDWORD,POVERLAPPED);
 BOOL __attribute__((__stdcall__)) DisableThreadLibraryCalls(HMODULE);




 BOOL __attribute__((__stdcall__)) DisconnectNamedPipe(HANDLE);
 BOOL __attribute__((__stdcall__)) DosDateTimeToFileTime(WORD,WORD,LPFILETIME);
 BOOL __attribute__((__stdcall__)) DuplicateHandle(HANDLE,HANDLE,HANDLE,PHANDLE,DWORD,BOOL,DWORD);
 BOOL __attribute__((__stdcall__)) DuplicateToken(HANDLE,SECURITY_IMPERSONATION_LEVEL,PHANDLE);
 BOOL __attribute__((__stdcall__)) DuplicateTokenEx(HANDLE,DWORD,LPSECURITY_ATTRIBUTES,SECURITY_IMPERSONATION_LEVEL,TOKEN_TYPE,PHANDLE);
 BOOL __attribute__((__stdcall__)) EncryptFileA(LPCSTR);
 BOOL __attribute__((__stdcall__)) EncryptFileW(LPCWSTR);
 BOOL __attribute__((__stdcall__)) EndUpdateResourceA(HANDLE,BOOL);
 BOOL __attribute__((__stdcall__)) EndUpdateResourceW(HANDLE,BOOL);
 void __attribute__((__stdcall__)) EnterCriticalSection(LPCRITICAL_SECTION);
 BOOL __attribute__((__stdcall__)) EnumResourceLanguagesA(HMODULE,LPCSTR,LPCSTR,ENUMRESLANGPROC,LONG_PTR);
 BOOL __attribute__((__stdcall__)) EnumResourceLanguagesW(HMODULE,LPCWSTR,LPCWSTR,ENUMRESLANGPROC,LONG_PTR);
 BOOL __attribute__((__stdcall__)) EnumResourceNamesA(HMODULE,LPCSTR,ENUMRESNAMEPROC,LONG_PTR);
 BOOL __attribute__((__stdcall__)) EnumResourceNamesW(HMODULE,LPCWSTR,ENUMRESNAMEPROC,LONG_PTR);
 BOOL __attribute__((__stdcall__)) EnumResourceTypesA(HMODULE,ENUMRESTYPEPROC,LONG_PTR);
 BOOL __attribute__((__stdcall__)) EnumResourceTypesW(HMODULE,ENUMRESTYPEPROC,LONG_PTR);
 BOOL __attribute__((__stdcall__)) EqualPrefixSid(PSID,PSID);
 BOOL __attribute__((__stdcall__)) EqualSid(PSID,PSID);
 DWORD __attribute__((__stdcall__)) EraseTape(HANDLE,DWORD,BOOL);
 BOOL __attribute__((__stdcall__)) EscapeCommFunction(HANDLE,DWORD);
__attribute__((noreturn)) void __attribute__((__stdcall__)) ExitProcess(UINT);
__attribute__((noreturn)) void __attribute__((__stdcall__)) ExitThread(DWORD);
 DWORD __attribute__((__stdcall__)) ExpandEnvironmentStringsA(LPCSTR,LPSTR,DWORD);
 DWORD __attribute__((__stdcall__)) ExpandEnvironmentStringsW(LPCWSTR,LPWSTR,DWORD);
 void __attribute__((__stdcall__)) FatalAppExitA(UINT,LPCSTR);
 void __attribute__((__stdcall__)) FatalAppExitW(UINT,LPCWSTR);
 void __attribute__((__stdcall__)) FatalExit(int);
 BOOL __attribute__((__stdcall__)) FileEncryptionStatusA(LPCSTR,LPDWORD);
 BOOL __attribute__((__stdcall__)) FileEncryptionStatusW(LPCWSTR,LPDWORD);
 BOOL __attribute__((__stdcall__)) FileTimeToDosDateTime(const FILETIME *,LPWORD,LPWORD);
 BOOL __attribute__((__stdcall__)) FileTimeToLocalFileTime(const FILETIME *,LPFILETIME);
 BOOL __attribute__((__stdcall__)) FileTimeToSystemTime(const FILETIME *,LPSYSTEMTIME);





 ATOM __attribute__((__stdcall__)) FindAtomA(LPCSTR);
 ATOM __attribute__((__stdcall__)) FindAtomW(LPCWSTR);
 BOOL __attribute__((__stdcall__)) FindClose(HANDLE);
 BOOL __attribute__((__stdcall__)) FindCloseChangeNotification(HANDLE);
 HANDLE __attribute__((__stdcall__)) FindFirstChangeNotificationA(LPCSTR,BOOL,DWORD);
 HANDLE __attribute__((__stdcall__)) FindFirstChangeNotificationW(LPCWSTR,BOOL,DWORD);
 HANDLE __attribute__((__stdcall__)) FindFirstFileA(LPCSTR,LPWIN32_FIND_DATAA);
 HANDLE __attribute__((__stdcall__)) FindFirstFileW(LPCWSTR,LPWIN32_FIND_DATAW);
 HANDLE __attribute__((__stdcall__)) FindFirstFileExA(LPCSTR,FINDEX_INFO_LEVELS,PVOID,FINDEX_SEARCH_OPS,PVOID,DWORD);
 HANDLE __attribute__((__stdcall__)) FindFirstFileExW(LPCWSTR,FINDEX_INFO_LEVELS,PVOID,FINDEX_SEARCH_OPS,PVOID,DWORD);
 BOOL __attribute__((__stdcall__)) FindFirstFreeAce(PACL,PVOID*);






 BOOL __attribute__((__stdcall__)) FindNextChangeNotification(HANDLE);
 BOOL __attribute__((__stdcall__)) FindNextFileA(HANDLE,LPWIN32_FIND_DATAA);
 BOOL __attribute__((__stdcall__)) FindNextFileW(HANDLE,LPWIN32_FIND_DATAW);
# 1305 "H:/CPP/wxdevcpp6.10/include/winbase.h" 3
 HRSRC __attribute__((__stdcall__)) FindResourceA(HMODULE,LPCSTR,LPCSTR);
 HRSRC __attribute__((__stdcall__)) FindResourceW(HINSTANCE,LPCWSTR,LPCWSTR);
 HRSRC __attribute__((__stdcall__)) FindResourceExA(HINSTANCE,LPCSTR,LPCSTR,WORD);
 HRSRC __attribute__((__stdcall__)) FindResourceExW(HINSTANCE,LPCWSTR,LPCWSTR,WORD);




 BOOL __attribute__((__stdcall__)) FlushFileBuffers(HANDLE);
 BOOL __attribute__((__stdcall__)) FlushInstructionCache(HANDLE,PCVOID,DWORD);
 BOOL __attribute__((__stdcall__)) FlushViewOfFile(PCVOID,DWORD);
 DWORD __attribute__((__stdcall__)) FormatMessageA(DWORD,PCVOID,DWORD,DWORD,LPSTR,DWORD,va_list*);
 DWORD __attribute__((__stdcall__)) FormatMessageW(DWORD,PCVOID,DWORD,DWORD,LPWSTR,DWORD,va_list*);
 BOOL __attribute__((__stdcall__)) FreeEnvironmentStringsA(LPSTR);
 BOOL __attribute__((__stdcall__)) FreeEnvironmentStringsW(LPWSTR);
 BOOL __attribute__((__stdcall__)) FreeLibrary(HMODULE);
__attribute__((noreturn)) void __attribute__((__stdcall__)) FreeLibraryAndExitThread(HMODULE,DWORD);



 BOOL __attribute__((__stdcall__)) FreeResource(HGLOBAL);

 PVOID __attribute__((__stdcall__)) FreeSid(PSID);
 BOOL __attribute__((__stdcall__)) GetAce(PACL,DWORD,LPVOID*);
 BOOL __attribute__((__stdcall__)) GetAclInformation(PACL,PVOID,DWORD,ACL_INFORMATION_CLASS);
 UINT __attribute__((__stdcall__)) GetAtomNameA(ATOM,LPSTR,int);
 UINT __attribute__((__stdcall__)) GetAtomNameW(ATOM,LPWSTR,int);
 BOOL __attribute__((__stdcall__)) GetBinaryTypeA(LPCSTR,PDWORD);
 BOOL __attribute__((__stdcall__)) GetBinaryTypeW(LPCWSTR,PDWORD);
 LPSTR __attribute__((__stdcall__)) GetCommandLineA(void);
 LPWSTR __attribute__((__stdcall__)) GetCommandLineW(void);
 BOOL __attribute__((__stdcall__)) GetCommConfig(HANDLE,LPCOMMCONFIG,PDWORD);
 BOOL __attribute__((__stdcall__)) GetCommMask(HANDLE,PDWORD);
 BOOL __attribute__((__stdcall__)) GetCommModemStatus(HANDLE,PDWORD);
 BOOL __attribute__((__stdcall__)) GetCommProperties(HANDLE,LPCOMMPROP);
 BOOL __attribute__((__stdcall__)) GetCommState(HANDLE,LPDCB);
 BOOL __attribute__((__stdcall__)) GetCommTimeouts(HANDLE,LPCOMMTIMEOUTS);
 DWORD __attribute__((__stdcall__)) GetCompressedFileSizeA(LPCSTR,PDWORD);
 DWORD __attribute__((__stdcall__)) GetCompressedFileSizeW(LPCWSTR,PDWORD);
 BOOL __attribute__((__stdcall__)) GetComputerNameA(LPSTR,PDWORD);
 BOOL __attribute__((__stdcall__)) GetComputerNameW(LPWSTR,PDWORD);







 DWORD __attribute__((__stdcall__)) GetCurrentDirectoryA(DWORD,LPSTR);
 DWORD __attribute__((__stdcall__)) GetCurrentDirectoryW(DWORD,LPWSTR);
 BOOL __attribute__((__stdcall__)) GetCurrentHwProfileA(LPHW_PROFILE_INFOA);
 BOOL __attribute__((__stdcall__)) GetCurrentHwProfileW(LPHW_PROFILE_INFOW);
 HANDLE __attribute__((__stdcall__)) GetCurrentProcess(void);
 DWORD __attribute__((__stdcall__)) GetCurrentProcessId(void);
 HANDLE __attribute__((__stdcall__)) GetCurrentThread(void);
 DWORD __attribute__((__stdcall__)) GetCurrentThreadId(void);

 BOOL __attribute__((__stdcall__)) GetDefaultCommConfigA(LPCSTR,LPCOMMCONFIG,PDWORD);
 BOOL __attribute__((__stdcall__)) GetDefaultCommConfigW(LPCWSTR,LPCOMMCONFIG,PDWORD);
 BOOL __attribute__((__stdcall__)) GetDevicePowerState(HANDLE, BOOL*);
 BOOL __attribute__((__stdcall__)) GetDiskFreeSpaceA(LPCSTR,PDWORD,PDWORD,PDWORD,PDWORD);
 BOOL __attribute__((__stdcall__)) GetDiskFreeSpaceW(LPCWSTR,PDWORD,PDWORD,PDWORD,PDWORD);
 BOOL __attribute__((__stdcall__)) GetDiskFreeSpaceExA(LPCSTR,PULARGE_INTEGER,PULARGE_INTEGER,PULARGE_INTEGER);
 BOOL __attribute__((__stdcall__)) GetDiskFreeSpaceExW(LPCWSTR,PULARGE_INTEGER,PULARGE_INTEGER,PULARGE_INTEGER);




 UINT __attribute__((__stdcall__)) GetDriveTypeA(LPCSTR);
 UINT __attribute__((__stdcall__)) GetDriveTypeW(LPCWSTR);
 LPSTR __attribute__((__stdcall__)) GetEnvironmentStrings(void);
 LPSTR __attribute__((__stdcall__)) GetEnvironmentStringsA(void);
 LPWSTR __attribute__((__stdcall__)) GetEnvironmentStringsW(void);
 DWORD __attribute__((__stdcall__)) GetEnvironmentVariableA(LPCSTR,LPSTR,DWORD);
 DWORD __attribute__((__stdcall__)) GetEnvironmentVariableW(LPCWSTR,LPWSTR,DWORD);
 BOOL __attribute__((__stdcall__)) GetExitCodeProcess(HANDLE,PDWORD);
 BOOL __attribute__((__stdcall__)) GetExitCodeThread(HANDLE,PDWORD);
 DWORD __attribute__((__stdcall__)) GetFileAttributesA(LPCSTR);
 DWORD __attribute__((__stdcall__)) GetFileAttributesW(LPCWSTR);
 BOOL __attribute__((__stdcall__)) GetFileAttributesExA(LPCSTR,GET_FILEEX_INFO_LEVELS,PVOID);
 BOOL __attribute__((__stdcall__)) GetFileAttributesExW(LPCWSTR,GET_FILEEX_INFO_LEVELS,PVOID);
 BOOL __attribute__((__stdcall__)) GetFileInformationByHandle(HANDLE,LPBY_HANDLE_FILE_INFORMATION);
 BOOL __attribute__((__stdcall__)) GetFileSecurityA(LPCSTR,SECURITY_INFORMATION,PSECURITY_DESCRIPTOR,DWORD,PDWORD);
 BOOL __attribute__((__stdcall__)) GetFileSecurityW(LPCWSTR,SECURITY_INFORMATION,PSECURITY_DESCRIPTOR,DWORD,PDWORD);
 DWORD __attribute__((__stdcall__)) GetFileSize(HANDLE,PDWORD);



 BOOL __attribute__((__stdcall__)) GetFileTime(HANDLE,LPFILETIME,LPFILETIME,LPFILETIME);
 DWORD __attribute__((__stdcall__)) GetFileType(HANDLE);

 DWORD __attribute__((__stdcall__)) GetFullPathNameA(LPCSTR,DWORD,LPSTR,LPSTR*);
 DWORD __attribute__((__stdcall__)) GetFullPathNameW(LPCWSTR,DWORD,LPWSTR,LPWSTR*);
 BOOL __attribute__((__stdcall__)) GetHandleInformation(HANDLE,PDWORD);
 BOOL __attribute__((__stdcall__)) GetKernelObjectSecurity(HANDLE,SECURITY_INFORMATION,PSECURITY_DESCRIPTOR,DWORD,PDWORD);
 DWORD __attribute__((__stdcall__)) GetLastError(void);
 DWORD __attribute__((__stdcall__)) GetLengthSid(PSID);
 void __attribute__((__stdcall__)) GetLocalTime(LPSYSTEMTIME);
 DWORD __attribute__((__stdcall__)) GetLogicalDrives(void);
 DWORD __attribute__((__stdcall__)) GetLogicalDriveStringsA(DWORD,LPSTR);
 DWORD __attribute__((__stdcall__)) GetLogicalDriveStringsW(DWORD,LPWSTR);




 BOOL __attribute__((__stdcall__)) GetMailslotInfo(HANDLE,PDWORD,PDWORD,PDWORD,PDWORD);
 DWORD __attribute__((__stdcall__)) GetModuleFileNameA(HINSTANCE,LPSTR,DWORD);
 DWORD __attribute__((__stdcall__)) GetModuleFileNameW(HINSTANCE,LPWSTR,DWORD);
 HMODULE __attribute__((__stdcall__)) GetModuleHandleA(LPCSTR);
 HMODULE __attribute__((__stdcall__)) GetModuleHandleW(LPCWSTR);




 BOOL __attribute__((__stdcall__)) GetNamedPipeHandleStateA(HANDLE,PDWORD,PDWORD,PDWORD,PDWORD,LPSTR,DWORD);
 BOOL __attribute__((__stdcall__)) GetNamedPipeHandleStateW(HANDLE,PDWORD,PDWORD,PDWORD,PDWORD,LPWSTR,DWORD);
 BOOL __attribute__((__stdcall__)) GetNamedPipeInfo(HANDLE,PDWORD,PDWORD,PDWORD,PDWORD);



 BOOL __attribute__((__stdcall__)) GetNumberOfEventLogRecords(HANDLE,PDWORD);
 BOOL __attribute__((__stdcall__)) GetOldestEventLogRecord(HANDLE,PDWORD);
 BOOL __attribute__((__stdcall__)) GetOverlappedResult(HANDLE,LPOVERLAPPED,PDWORD,BOOL);
 DWORD __attribute__((__stdcall__)) GetPriorityClass(HANDLE);
 BOOL __attribute__((__stdcall__)) GetPrivateObjectSecurity(PSECURITY_DESCRIPTOR,SECURITY_INFORMATION,PSECURITY_DESCRIPTOR,DWORD,PDWORD);
 UINT __attribute__((__stdcall__)) GetPrivateProfileIntA(LPCSTR,LPCSTR,INT,LPCSTR);
 UINT __attribute__((__stdcall__)) GetPrivateProfileIntW(LPCWSTR,LPCWSTR,INT,LPCWSTR);
 DWORD __attribute__((__stdcall__)) GetPrivateProfileSectionA(LPCSTR,LPSTR,DWORD,LPCSTR);
 DWORD __attribute__((__stdcall__)) GetPrivateProfileSectionW(LPCWSTR,LPWSTR,DWORD,LPCWSTR);
 DWORD __attribute__((__stdcall__)) GetPrivateProfileSectionNamesA(LPSTR,DWORD,LPCSTR);
 DWORD __attribute__((__stdcall__)) GetPrivateProfileSectionNamesW(LPWSTR,DWORD,LPCWSTR);
 DWORD __attribute__((__stdcall__)) GetPrivateProfileStringA(LPCSTR,LPCSTR,LPCSTR,LPSTR,DWORD,LPCSTR);
 DWORD __attribute__((__stdcall__)) GetPrivateProfileStringW(LPCWSTR,LPCWSTR,LPCWSTR,LPWSTR,DWORD,LPCWSTR);
 BOOL __attribute__((__stdcall__)) GetPrivateProfileStructA(LPCSTR,LPCSTR,LPVOID,UINT,LPCSTR);
 BOOL __attribute__((__stdcall__)) GetPrivateProfileStructW(LPCWSTR,LPCWSTR,LPVOID,UINT,LPCWSTR);
 FARPROC __attribute__((__stdcall__)) GetProcAddress(HINSTANCE,LPCSTR);
 BOOL __attribute__((__stdcall__)) GetProcessAffinityMask(HANDLE,PDWORD,PDWORD);



 HANDLE __attribute__((__stdcall__)) GetProcessHeap(void);
 DWORD __attribute__((__stdcall__)) GetProcessHeaps(DWORD,PHANDLE);






 BOOL __attribute__((__stdcall__)) GetProcessPriorityBoost(HANDLE,PBOOL);
 BOOL __attribute__((__stdcall__)) GetProcessShutdownParameters(PDWORD,PDWORD);
 BOOL __attribute__((__stdcall__)) GetProcessTimes(HANDLE,LPFILETIME,LPFILETIME,LPFILETIME,LPFILETIME);
 DWORD __attribute__((__stdcall__)) GetProcessVersion(DWORD);
 HWINSTA __attribute__((__stdcall__)) GetProcessWindowStation(void);
 BOOL __attribute__((__stdcall__)) GetProcessWorkingSetSize(HANDLE,PSIZE_T,PSIZE_T);
 UINT __attribute__((__stdcall__)) GetProfileIntA(LPCSTR,LPCSTR,INT);
 UINT __attribute__((__stdcall__)) GetProfileIntW(LPCWSTR,LPCWSTR,INT);
 DWORD __attribute__((__stdcall__)) GetProfileSectionA(LPCSTR,LPSTR,DWORD);
 DWORD __attribute__((__stdcall__)) GetProfileSectionW(LPCWSTR,LPWSTR,DWORD);
 DWORD __attribute__((__stdcall__)) GetProfileStringA(LPCSTR,LPCSTR,LPCSTR,LPSTR,DWORD);
 DWORD __attribute__((__stdcall__)) GetProfileStringW(LPCWSTR,LPCWSTR,LPCWSTR,LPWSTR,DWORD);
 BOOL __attribute__((__stdcall__)) GetQueuedCompletionStatus(HANDLE,PDWORD,PDWORD,LPOVERLAPPED*,DWORD);
 BOOL __attribute__((__stdcall__)) GetSecurityDescriptorControl(PSECURITY_DESCRIPTOR,PSECURITY_DESCRIPTOR_CONTROL,PDWORD);
 BOOL __attribute__((__stdcall__)) GetSecurityDescriptorDacl(PSECURITY_DESCRIPTOR,LPBOOL,PACL*,LPBOOL);
 BOOL __attribute__((__stdcall__)) GetSecurityDescriptorGroup(PSECURITY_DESCRIPTOR,PSID*,LPBOOL);
 DWORD __attribute__((__stdcall__)) GetSecurityDescriptorLength(PSECURITY_DESCRIPTOR);
 BOOL __attribute__((__stdcall__)) GetSecurityDescriptorOwner(PSECURITY_DESCRIPTOR,PSID*,LPBOOL);
 BOOL __attribute__((__stdcall__)) GetSecurityDescriptorSacl(PSECURITY_DESCRIPTOR,LPBOOL,PACL*,LPBOOL);
 DWORD __attribute__((__stdcall__)) GetShortPathNameA(LPCSTR,LPSTR,DWORD);
 DWORD __attribute__((__stdcall__)) GetShortPathNameW(LPCWSTR,LPWSTR,DWORD);
 PSID_IDENTIFIER_AUTHORITY __attribute__((__stdcall__)) GetSidIdentifierAuthority(PSID);
 DWORD __attribute__((__stdcall__)) GetSidLengthRequired(UCHAR);
 PDWORD __attribute__((__stdcall__)) GetSidSubAuthority(PSID,DWORD);
 PUCHAR __attribute__((__stdcall__)) GetSidSubAuthorityCount(PSID);
 void __attribute__((__stdcall__)) GetStartupInfoA(LPSTARTUPINFOA);
 void __attribute__((__stdcall__)) GetStartupInfoW(LPSTARTUPINFOW);
 HANDLE __attribute__((__stdcall__)) GetStdHandle(DWORD);
 UINT __attribute__((__stdcall__)) GetSystemDirectoryA(LPSTR,UINT);
 UINT __attribute__((__stdcall__)) GetSystemDirectoryW(LPWSTR,UINT);
 void __attribute__((__stdcall__)) GetSystemInfo(LPSYSTEM_INFO);
 BOOL __attribute__((__stdcall__)) GetSystemPowerStatus(LPSYSTEM_POWER_STATUS);



 void __attribute__((__stdcall__)) GetSystemTime(LPSYSTEMTIME);



 BOOL __attribute__((__stdcall__)) GetSystemTimeAdjustment(PDWORD,PDWORD,PBOOL);
 void __attribute__((__stdcall__)) GetSystemTimeAsFileTime(LPFILETIME);
# 1502 "H:/CPP/wxdevcpp6.10/include/winbase.h" 3
 DWORD __attribute__((__stdcall__)) GetTapeParameters(HANDLE,DWORD,PDWORD,PVOID);
 DWORD __attribute__((__stdcall__)) GetTapePosition(HANDLE,DWORD,PDWORD,PDWORD,PDWORD);
 DWORD __attribute__((__stdcall__)) GetTapeStatus(HANDLE);
 UINT __attribute__((__stdcall__)) GetTempFileNameA(LPCSTR,LPCSTR,UINT,LPSTR);
 UINT __attribute__((__stdcall__)) GetTempFileNameW(LPCWSTR,LPCWSTR,UINT,LPWSTR);
 DWORD __attribute__((__stdcall__)) GetTempPathA(DWORD,LPSTR);
 DWORD __attribute__((__stdcall__)) GetTempPathW(DWORD,LPWSTR);
 BOOL __attribute__((__stdcall__)) GetThreadContext(HANDLE,LPCONTEXT);



 int __attribute__((__stdcall__)) GetThreadPriority(HANDLE);
 BOOL __attribute__((__stdcall__)) GetThreadPriorityBoost(HANDLE,PBOOL);
 BOOL __attribute__((__stdcall__)) GetThreadSelectorEntry(HANDLE,DWORD,LPLDT_ENTRY);
 BOOL __attribute__((__stdcall__)) GetThreadTimes(HANDLE,LPFILETIME,LPFILETIME,LPFILETIME,LPFILETIME);
 DWORD __attribute__((__stdcall__)) GetTickCount(void);
 DWORD __attribute__((__stdcall__)) GetTimeZoneInformation(LPTIME_ZONE_INFORMATION);
 BOOL __attribute__((__stdcall__)) GetTokenInformation(HANDLE,TOKEN_INFORMATION_CLASS,PVOID,DWORD,PDWORD);
 BOOL __attribute__((__stdcall__)) GetUserNameA (LPSTR,PDWORD);
 BOOL __attribute__((__stdcall__)) GetUserNameW(LPWSTR,PDWORD);
 DWORD __attribute__((__stdcall__)) GetVersion(void);
 BOOL __attribute__((__stdcall__)) GetVersionExA(LPOSVERSIONINFOA);
 BOOL __attribute__((__stdcall__)) GetVersionExW(LPOSVERSIONINFOW);
 BOOL __attribute__((__stdcall__)) GetVolumeInformationA(LPCSTR,LPSTR,DWORD,PDWORD,PDWORD,PDWORD,LPSTR,DWORD);
 BOOL __attribute__((__stdcall__)) GetVolumeInformationW(LPCWSTR,LPWSTR,DWORD,PDWORD,PDWORD,PDWORD,LPWSTR,DWORD);
# 1537 "H:/CPP/wxdevcpp6.10/include/winbase.h" 3
 UINT __attribute__((__stdcall__)) GetWindowsDirectoryA(LPSTR,UINT);
 UINT __attribute__((__stdcall__)) GetWindowsDirectoryW(LPWSTR,UINT);
 DWORD __attribute__((__stdcall__)) GetWindowThreadProcessId(HWND,PDWORD);
 UINT __attribute__((__stdcall__)) GetWriteWatch(DWORD,PVOID,SIZE_T,PVOID*,PULONG_PTR,PULONG);
 ATOM __attribute__((__stdcall__)) GlobalAddAtomA(LPCSTR);
 ATOM __attribute__((__stdcall__)) GlobalAddAtomW( LPCWSTR);
 HGLOBAL __attribute__((__stdcall__)) GlobalAlloc(UINT,DWORD);
 SIZE_T __attribute__((__stdcall__)) GlobalCompact(DWORD);
 ATOM __attribute__((__stdcall__)) GlobalDeleteAtom(ATOM);

 ATOM __attribute__((__stdcall__)) GlobalFindAtomA(LPCSTR);
 ATOM __attribute__((__stdcall__)) GlobalFindAtomW(LPCWSTR);
 void __attribute__((__stdcall__)) GlobalFix(HGLOBAL);
 UINT __attribute__((__stdcall__)) GlobalFlags(HGLOBAL);
 HGLOBAL __attribute__((__stdcall__)) GlobalFree(HGLOBAL);
 UINT __attribute__((__stdcall__)) GlobalGetAtomNameA(ATOM,LPSTR,int);
 UINT __attribute__((__stdcall__)) GlobalGetAtomNameW(ATOM,LPWSTR,int);
 HGLOBAL __attribute__((__stdcall__)) GlobalHandle(PCVOID);
 LPVOID __attribute__((__stdcall__)) GlobalLock(HGLOBAL);
 void __attribute__((__stdcall__)) GlobalMemoryStatus(LPMEMORYSTATUS);



 HGLOBAL __attribute__((__stdcall__)) GlobalReAlloc(HGLOBAL,DWORD,UINT);
 DWORD __attribute__((__stdcall__)) GlobalSize(HGLOBAL);
 void __attribute__((__stdcall__)) GlobalUnfix(HGLOBAL);
 BOOL __attribute__((__stdcall__)) GlobalUnlock(HGLOBAL);
 BOOL __attribute__((__stdcall__)) GlobalUnWire(HGLOBAL);
 PVOID __attribute__((__stdcall__)) GlobalWire(HGLOBAL);

 PVOID __attribute__((__stdcall__)) HeapAlloc(HANDLE,DWORD,DWORD);
SIZE_T __attribute__((__stdcall__)) HeapCompact(HANDLE,DWORD);
 HANDLE __attribute__((__stdcall__)) HeapCreate(DWORD,DWORD,DWORD);
 BOOL __attribute__((__stdcall__)) HeapDestroy(HANDLE);
 BOOL __attribute__((__stdcall__)) HeapFree(HANDLE,DWORD,PVOID);
 BOOL __attribute__((__stdcall__)) HeapLock(HANDLE);



 PVOID __attribute__((__stdcall__)) HeapReAlloc(HANDLE,DWORD,PVOID,DWORD);



 DWORD __attribute__((__stdcall__)) HeapSize(HANDLE,DWORD,PCVOID);
 BOOL __attribute__((__stdcall__)) HeapUnlock(HANDLE);
 BOOL __attribute__((__stdcall__)) HeapValidate(HANDLE,DWORD,PCVOID);
 BOOL __attribute__((__stdcall__)) HeapWalk(HANDLE,LPPROCESS_HEAP_ENTRY);
 BOOL __attribute__((__stdcall__)) ImpersonateLoggedOnUser(HANDLE);
 BOOL __attribute__((__stdcall__)) ImpersonateNamedPipeClient(HANDLE);
 BOOL __attribute__((__stdcall__)) ImpersonateSelf(SECURITY_IMPERSONATION_LEVEL);
 BOOL __attribute__((__stdcall__)) InitAtomTable(DWORD);
 BOOL __attribute__((__stdcall__)) InitializeAcl(PACL,DWORD,DWORD);
 void __attribute__((__stdcall__)) InitializeCriticalSection(LPCRITICAL_SECTION);
 BOOL __attribute__((__stdcall__)) InitializeCriticalSectionAndSpinCount(LPCRITICAL_SECTION,DWORD);
 DWORD __attribute__((__stdcall__)) SetCriticalSectionSpinCount(LPCRITICAL_SECTION,DWORD);
 BOOL __attribute__((__stdcall__)) InitializeSecurityDescriptor(PSECURITY_DESCRIPTOR,DWORD);
 BOOL __attribute__((__stdcall__)) InitializeSid (PSID,PSID_IDENTIFIER_AUTHORITY,BYTE);
# 1603 "H:/CPP/wxdevcpp6.10/include/winbase.h" 3
LONG __attribute__((__stdcall__)) InterlockedCompareExchange(LPLONG,LONG,LONG);



LONG __attribute__((__stdcall__)) InterlockedDecrement(LPLONG);
LONG __attribute__((__stdcall__)) InterlockedExchange(LPLONG,LONG);



LONG __attribute__((__stdcall__)) InterlockedExchangeAdd(LPLONG,LONG);



LONG __attribute__((__stdcall__)) InterlockedIncrement(LPLONG);







 BOOL __attribute__((__stdcall__)) IsBadCodePtr(FARPROC);
 BOOL __attribute__((__stdcall__)) IsBadHugeReadPtr(PCVOID,UINT);
 BOOL __attribute__((__stdcall__)) IsBadHugeWritePtr(PVOID,UINT);
 BOOL __attribute__((__stdcall__)) IsBadReadPtr(PCVOID,UINT);
 BOOL __attribute__((__stdcall__)) IsBadStringPtrA(LPCSTR,UINT);
 BOOL __attribute__((__stdcall__)) IsBadStringPtrW(LPCWSTR,UINT);
 BOOL __attribute__((__stdcall__)) IsBadWritePtr(PVOID,UINT);
 BOOL __attribute__((__stdcall__)) IsDebuggerPresent(void);



 BOOL __attribute__((__stdcall__)) IsProcessorFeaturePresent(DWORD);
 BOOL __attribute__((__stdcall__)) IsSystemResumeAutomatic(void);
 BOOL __attribute__((__stdcall__)) IsTextUnicode(PCVOID,int,LPINT);
 BOOL __attribute__((__stdcall__)) IsValidAcl(PACL);
 BOOL __attribute__((__stdcall__)) IsValidSecurityDescriptor(PSECURITY_DESCRIPTOR);
 BOOL __attribute__((__stdcall__)) IsValidSid(PSID);



 void __attribute__((__stdcall__)) LeaveCriticalSection(LPCRITICAL_SECTION);

 HINSTANCE __attribute__((__stdcall__)) LoadLibraryA(LPCSTR);
 HINSTANCE __attribute__((__stdcall__)) LoadLibraryExA(LPCSTR,HANDLE,DWORD);
 HINSTANCE __attribute__((__stdcall__)) LoadLibraryExW(LPCWSTR,HANDLE,DWORD);
 HINSTANCE __attribute__((__stdcall__)) LoadLibraryW(LPCWSTR);
 DWORD __attribute__((__stdcall__)) LoadModule(LPCSTR,PVOID);
 HGLOBAL __attribute__((__stdcall__)) LoadResource(HINSTANCE,HRSRC);
 HLOCAL __attribute__((__stdcall__)) LocalAlloc(UINT,SIZE_T);
 SIZE_T __attribute__((__stdcall__)) LocalCompact(UINT);
 HLOCAL LocalDiscard(HLOCAL);
 BOOL __attribute__((__stdcall__)) LocalFileTimeToFileTime(const FILETIME *,LPFILETIME);
 UINT __attribute__((__stdcall__)) LocalFlags(HLOCAL);
 HLOCAL __attribute__((__stdcall__)) LocalFree(HLOCAL);
 HLOCAL __attribute__((__stdcall__)) LocalHandle(LPCVOID);
 PVOID __attribute__((__stdcall__)) LocalLock(HLOCAL);
 HLOCAL __attribute__((__stdcall__)) LocalReAlloc(HLOCAL,SIZE_T,UINT);
 SIZE_T __attribute__((__stdcall__)) LocalShrink(HLOCAL,UINT);
 UINT __attribute__((__stdcall__)) LocalSize(HLOCAL);
 BOOL __attribute__((__stdcall__)) LocalUnlock(HLOCAL);
 BOOL __attribute__((__stdcall__)) LockFile(HANDLE,DWORD,DWORD,DWORD,DWORD);
 BOOL __attribute__((__stdcall__)) LockFileEx(HANDLE,DWORD,DWORD,DWORD,DWORD,LPOVERLAPPED);
 PVOID __attribute__((__stdcall__)) LockResource(HGLOBAL);

 BOOL __attribute__((__stdcall__)) LogonUserA(LPSTR,LPSTR,LPSTR,DWORD,DWORD,PHANDLE);
 BOOL __attribute__((__stdcall__)) LogonUserW(LPWSTR,LPWSTR,LPWSTR,DWORD,DWORD,PHANDLE);
 BOOL __attribute__((__stdcall__)) LookupAccountNameA(LPCSTR,LPCSTR,PSID,PDWORD,LPSTR,PDWORD,PSID_NAME_USE);
 BOOL __attribute__((__stdcall__)) LookupAccountNameW(LPCWSTR,LPCWSTR,PSID,PDWORD,LPWSTR,PDWORD,PSID_NAME_USE);
 BOOL __attribute__((__stdcall__)) LookupAccountSidA(LPCSTR,PSID,LPSTR,PDWORD,LPSTR,PDWORD,PSID_NAME_USE);
 BOOL __attribute__((__stdcall__)) LookupAccountSidW(LPCWSTR,PSID,LPWSTR,PDWORD,LPWSTR,PDWORD,PSID_NAME_USE);
 BOOL __attribute__((__stdcall__)) LookupPrivilegeDisplayNameA(LPCSTR,LPCSTR,LPSTR,PDWORD,PDWORD);
 BOOL __attribute__((__stdcall__)) LookupPrivilegeDisplayNameW(LPCWSTR,LPCWSTR,LPWSTR,PDWORD,PDWORD);
 BOOL __attribute__((__stdcall__)) LookupPrivilegeNameA(LPCSTR,PLUID,LPSTR,PDWORD);
 BOOL __attribute__((__stdcall__)) LookupPrivilegeNameW(LPCWSTR,PLUID,LPWSTR,PDWORD);
 BOOL __attribute__((__stdcall__)) LookupPrivilegeValueA(LPCSTR,LPCSTR,PLUID);
 BOOL __attribute__((__stdcall__)) LookupPrivilegeValueW(LPCWSTR,LPCWSTR,PLUID);
 LPSTR __attribute__((__stdcall__)) lstrcatA(LPSTR,LPCSTR);
 LPWSTR __attribute__((__stdcall__)) lstrcatW(LPWSTR,LPCWSTR);
 int __attribute__((__stdcall__)) lstrcmpA(LPCSTR,LPCSTR);
 int __attribute__((__stdcall__)) lstrcmpiA(LPCSTR,LPCSTR);
 int __attribute__((__stdcall__)) lstrcmpiW( LPCWSTR,LPCWSTR);
 int __attribute__((__stdcall__)) lstrcmpW(LPCWSTR,LPCWSTR);
 LPSTR __attribute__((__stdcall__)) lstrcpyA(LPSTR,LPCSTR);
 LPSTR __attribute__((__stdcall__)) lstrcpynA(LPSTR,LPCSTR,int);
 LPWSTR __attribute__((__stdcall__)) lstrcpynW(LPWSTR,LPCWSTR,int);
 LPWSTR __attribute__((__stdcall__)) lstrcpyW(LPWSTR,LPCWSTR);
 int __attribute__((__stdcall__)) lstrlenA(LPCSTR);
 int __attribute__((__stdcall__)) lstrlenW(LPCWSTR);
 BOOL __attribute__((__stdcall__)) MakeAbsoluteSD(PSECURITY_DESCRIPTOR,PSECURITY_DESCRIPTOR,PDWORD,PACL,PDWORD,PACL,PDWORD,PSID,PDWORD,PSID,PDWORD);

 BOOL __attribute__((__stdcall__)) MakeSelfRelativeSD(PSECURITY_DESCRIPTOR,PSECURITY_DESCRIPTOR,PDWORD);
 void __attribute__((__stdcall__)) MapGenericMask(PDWORD,PGENERIC_MAPPING);
 PVOID __attribute__((__stdcall__)) MapViewOfFile(HANDLE,DWORD,DWORD,DWORD,DWORD);
 PVOID __attribute__((__stdcall__)) MapViewOfFileEx(HANDLE,DWORD,DWORD,DWORD,DWORD,PVOID);
 BOOL __attribute__((__stdcall__)) MoveFileA(LPCSTR,LPCSTR);
 BOOL __attribute__((__stdcall__)) MoveFileExA(LPCSTR,LPCSTR,DWORD);
 BOOL __attribute__((__stdcall__)) MoveFileExW(LPCWSTR,LPCWSTR,DWORD);
 BOOL __attribute__((__stdcall__)) MoveFileW(LPCWSTR,LPCWSTR);
 int __attribute__((__stdcall__)) MulDiv(int,int,int);
 BOOL __attribute__((__stdcall__)) NotifyChangeEventLog(HANDLE,HANDLE);
 BOOL __attribute__((__stdcall__)) ObjectCloseAuditAlarmA(LPCSTR,PVOID,BOOL);
 BOOL __attribute__((__stdcall__)) ObjectCloseAuditAlarmW(LPCWSTR,PVOID,BOOL);
 BOOL __attribute__((__stdcall__)) ObjectDeleteAuditAlarmA(LPCSTR,PVOID,BOOL);
 BOOL __attribute__((__stdcall__)) ObjectDeleteAuditAlarmW(LPCWSTR,PVOID,BOOL);
 BOOL __attribute__((__stdcall__)) ObjectOpenAuditAlarmA(LPCSTR,PVOID,LPSTR,LPSTR,PSECURITY_DESCRIPTOR,HANDLE,DWORD,DWORD,PPRIVILEGE_SET,BOOL,BOOL,PBOOL);
 BOOL __attribute__((__stdcall__)) ObjectOpenAuditAlarmW(LPCWSTR,PVOID,LPWSTR,LPWSTR,PSECURITY_DESCRIPTOR,HANDLE,DWORD,DWORD,PPRIVILEGE_SET,BOOL,BOOL,PBOOL);
 BOOL __attribute__((__stdcall__)) ObjectPrivilegeAuditAlarmA(LPCSTR,PVOID,HANDLE,DWORD,PPRIVILEGE_SET,BOOL);
 BOOL __attribute__((__stdcall__)) ObjectPrivilegeAuditAlarmW(LPCWSTR,PVOID,HANDLE,DWORD,PPRIVILEGE_SET,BOOL);
 HANDLE __attribute__((__stdcall__)) OpenBackupEventLogA(LPCSTR,LPCSTR);
 HANDLE __attribute__((__stdcall__)) OpenBackupEventLogW(LPCWSTR,LPCWSTR);
 HANDLE __attribute__((__stdcall__)) OpenEventA(DWORD,BOOL,LPCSTR);
 HANDLE __attribute__((__stdcall__)) OpenEventLogA (LPCSTR,LPCSTR);
 HANDLE __attribute__((__stdcall__)) OpenEventLogW(LPCWSTR,LPCWSTR);
 HANDLE __attribute__((__stdcall__)) OpenEventW(DWORD,BOOL,LPCWSTR);
 HFILE __attribute__((__stdcall__)) OpenFile(LPCSTR,LPOFSTRUCT,UINT);
 HANDLE __attribute__((__stdcall__)) OpenFileMappingA(DWORD,BOOL,LPCSTR);
 HANDLE __attribute__((__stdcall__)) OpenFileMappingW(DWORD,BOOL,LPCWSTR);
 HANDLE __attribute__((__stdcall__)) OpenMutexA(DWORD,BOOL,LPCSTR);
 HANDLE __attribute__((__stdcall__)) OpenMutexW(DWORD,BOOL,LPCWSTR);
 HANDLE __attribute__((__stdcall__)) OpenProcess(DWORD,BOOL,DWORD);
 BOOL __attribute__((__stdcall__)) OpenProcessToken(HANDLE,DWORD,PHANDLE);
 HANDLE __attribute__((__stdcall__)) OpenSemaphoreA(DWORD,BOOL,LPCSTR);
 HANDLE __attribute__((__stdcall__)) OpenSemaphoreW(DWORD,BOOL,LPCWSTR);



 BOOL __attribute__((__stdcall__)) OpenThreadToken(HANDLE,DWORD,BOOL,PHANDLE);
 HANDLE __attribute__((__stdcall__)) OpenWaitableTimerA(DWORD,BOOL,LPCSTR);
 HANDLE __attribute__((__stdcall__)) OpenWaitableTimerW(DWORD,BOOL,LPCWSTR);
 void __attribute__((__stdcall__)) OutputDebugStringA(LPCSTR);
 void __attribute__((__stdcall__)) OutputDebugStringW(LPCWSTR);
 BOOL __attribute__((__stdcall__)) PeekNamedPipe(HANDLE,PVOID,DWORD,PDWORD,PDWORD,PDWORD);
 BOOL __attribute__((__stdcall__)) PostQueuedCompletionStatus(HANDLE,DWORD,DWORD,LPOVERLAPPED);
 DWORD __attribute__((__stdcall__)) PrepareTape(HANDLE,DWORD,BOOL);
 BOOL __attribute__((__stdcall__)) PrivilegeCheck (HANDLE,PPRIVILEGE_SET,PBOOL);
 BOOL __attribute__((__stdcall__)) PrivilegedServiceAuditAlarmA(LPCSTR,LPCSTR,HANDLE,PPRIVILEGE_SET,BOOL);
 BOOL __attribute__((__stdcall__)) PrivilegedServiceAuditAlarmW(LPCWSTR,LPCWSTR,HANDLE,PPRIVILEGE_SET,BOOL);



 BOOL __attribute__((__stdcall__)) PulseEvent(HANDLE);
 BOOL __attribute__((__stdcall__)) PurgeComm(HANDLE,DWORD);



 DWORD __attribute__((__stdcall__)) QueryDosDeviceA(LPCSTR,LPSTR,DWORD);
 DWORD __attribute__((__stdcall__)) QueryDosDeviceW(LPCWSTR,LPWSTR,DWORD);



 BOOL __attribute__((__stdcall__)) QueryPerformanceCounter(PLARGE_INTEGER);
 BOOL __attribute__((__stdcall__)) QueryPerformanceFrequency(PLARGE_INTEGER);
 DWORD __attribute__((__stdcall__)) QueueUserAPC(PAPCFUNC,HANDLE,DWORD);



 void __attribute__((__stdcall__)) RaiseException(DWORD,DWORD,DWORD,const DWORD*);
 BOOL __attribute__((__stdcall__)) ReadDirectoryChangesW(HANDLE,PVOID,DWORD,BOOL,DWORD,PDWORD,LPOVERLAPPED,LPOVERLAPPED_COMPLETION_ROUTINE);
 BOOL __attribute__((__stdcall__)) ReadEventLogA(HANDLE,DWORD,DWORD,PVOID,DWORD,DWORD *,DWORD *);
 BOOL __attribute__((__stdcall__)) ReadEventLogW(HANDLE,DWORD,DWORD,PVOID,DWORD,DWORD *,DWORD *);
 BOOL __attribute__((__stdcall__)) ReadFile(HANDLE,PVOID,DWORD,PDWORD,LPOVERLAPPED);
 BOOL __attribute__((__stdcall__)) ReadFileEx(HANDLE,PVOID,DWORD,LPOVERLAPPED,LPOVERLAPPED_COMPLETION_ROUTINE);
 BOOL __attribute__((__stdcall__)) ReadFileScatter(HANDLE,FILE_SEGMENT_ELEMENT*,DWORD,LPDWORD,LPOVERLAPPED);
 BOOL __attribute__((__stdcall__)) ReadProcessMemory(HANDLE,PCVOID,PVOID,DWORD,PDWORD);
 HANDLE __attribute__((__stdcall__)) RegisterEventSourceA (LPCSTR,LPCSTR);
 HANDLE __attribute__((__stdcall__)) RegisterEventSourceW(LPCWSTR,LPCWSTR);







 BOOL __attribute__((__stdcall__)) ReleaseMutex(HANDLE);
 BOOL __attribute__((__stdcall__)) ReleaseSemaphore(HANDLE,LONG,LPLONG);
 BOOL __attribute__((__stdcall__)) RemoveDirectoryA(LPCSTR);
 BOOL __attribute__((__stdcall__)) RemoveDirectoryW(LPCWSTR);







 BOOL __attribute__((__stdcall__)) ReportEventA(HANDLE,WORD,WORD,DWORD,PSID,WORD,DWORD,LPCSTR*,PVOID);
 BOOL __attribute__((__stdcall__)) ReportEventW(HANDLE,WORD,WORD,DWORD,PSID,WORD,DWORD,LPCWSTR*,PVOID);
 BOOL __attribute__((__stdcall__)) ResetEvent(HANDLE);
 UINT __attribute__((__stdcall__)) ResetWriteWatch(LPVOID,SIZE_T);



 DWORD __attribute__((__stdcall__)) ResumeThread(HANDLE);
 BOOL __attribute__((__stdcall__)) RevertToSelf(void);
 DWORD __attribute__((__stdcall__)) SearchPathA(LPCSTR,LPCSTR,LPCSTR,DWORD,LPSTR,LPSTR*);
 DWORD __attribute__((__stdcall__)) SearchPathW(LPCWSTR,LPCWSTR,LPCWSTR,DWORD,LPWSTR,LPWSTR*);
 BOOL __attribute__((__stdcall__)) SetAclInformation(PACL,PVOID,DWORD,ACL_INFORMATION_CLASS);
 BOOL __attribute__((__stdcall__)) SetCommBreak(HANDLE);
 BOOL __attribute__((__stdcall__)) SetCommConfig(HANDLE,LPCOMMCONFIG,DWORD);
 BOOL __attribute__((__stdcall__)) SetCommMask(HANDLE,DWORD);
 BOOL __attribute__((__stdcall__)) SetCommState(HANDLE,LPDCB);
 BOOL __attribute__((__stdcall__)) SetCommTimeouts(HANDLE,LPCOMMTIMEOUTS);
 BOOL __attribute__((__stdcall__)) SetComputerNameA(LPCSTR);
 BOOL __attribute__((__stdcall__)) SetComputerNameW(LPCWSTR);




 BOOL __attribute__((__stdcall__)) SetCurrentDirectoryA(LPCSTR);
 BOOL __attribute__((__stdcall__)) SetCurrentDirectoryW(LPCWSTR);
 BOOL __attribute__((__stdcall__)) SetDefaultCommConfigA(LPCSTR,LPCOMMCONFIG,DWORD);
 BOOL __attribute__((__stdcall__)) SetDefaultCommConfigW(LPCWSTR,LPCOMMCONFIG,DWORD);




 BOOL __attribute__((__stdcall__)) SetEndOfFile(HANDLE);
 BOOL __attribute__((__stdcall__)) SetEnvironmentVariableA(LPCSTR,LPCSTR);
 BOOL __attribute__((__stdcall__)) SetEnvironmentVariableW(LPCWSTR,LPCWSTR);
 UINT __attribute__((__stdcall__)) SetErrorMode(UINT);
 BOOL __attribute__((__stdcall__)) SetEvent(HANDLE);
 void __attribute__((__stdcall__)) SetFileApisToANSI(void);
 void __attribute__((__stdcall__)) SetFileApisToOEM(void);
 BOOL __attribute__((__stdcall__)) SetFileAttributesA(LPCSTR,DWORD);
 BOOL __attribute__((__stdcall__)) SetFileAttributesW(LPCWSTR,DWORD);
 DWORD __attribute__((__stdcall__)) SetFilePointer(HANDLE,LONG,PLONG,DWORD);
 BOOL __attribute__((__stdcall__)) SetFilePointerEx(HANDLE,LARGE_INTEGER,PLARGE_INTEGER,DWORD);
 BOOL __attribute__((__stdcall__)) SetFileSecurityA(LPCSTR,SECURITY_INFORMATION,PSECURITY_DESCRIPTOR);
 BOOL __attribute__((__stdcall__)) SetFileSecurityW(LPCWSTR,SECURITY_INFORMATION,PSECURITY_DESCRIPTOR);




 BOOL __attribute__((__stdcall__)) SetFileTime(HANDLE,const FILETIME*,const FILETIME*,const FILETIME*);







 UINT __attribute__((__stdcall__)) SetHandleCount(UINT);
 BOOL __attribute__((__stdcall__)) SetHandleInformation(HANDLE,DWORD,DWORD);
 BOOL __attribute__((__stdcall__)) SetKernelObjectSecurity(HANDLE,SECURITY_INFORMATION,PSECURITY_DESCRIPTOR);
 void __attribute__((__stdcall__)) SetLastError(DWORD);
 void __attribute__((__stdcall__)) SetLastErrorEx(DWORD,DWORD);
 BOOL __attribute__((__stdcall__)) SetLocalTime(const SYSTEMTIME*);
 BOOL __attribute__((__stdcall__)) SetMailslotInfo(HANDLE,DWORD);
 BOOL __attribute__((__stdcall__)) SetNamedPipeHandleState(HANDLE,PDWORD,PDWORD,PDWORD);
 BOOL __attribute__((__stdcall__)) SetPriorityClass(HANDLE,DWORD);
 BOOL __attribute__((__stdcall__)) SetPrivateObjectSecurity(SECURITY_INFORMATION,PSECURITY_DESCRIPTOR,PSECURITY_DESCRIPTOR *,PGENERIC_MAPPING,HANDLE);
 BOOL __attribute__((__stdcall__)) SetProcessAffinityMask(HANDLE,DWORD);
 BOOL __attribute__((__stdcall__)) SetProcessPriorityBoost(HANDLE,BOOL);
 BOOL __attribute__((__stdcall__)) SetProcessShutdownParameters(DWORD,DWORD);
 BOOL __attribute__((__stdcall__)) SetProcessWorkingSetSize(HANDLE,DWORD,DWORD);
 BOOL __attribute__((__stdcall__)) SetSecurityDescriptorControl(PSECURITY_DESCRIPTOR,SECURITY_DESCRIPTOR_CONTROL,SECURITY_DESCRIPTOR_CONTROL);
 BOOL __attribute__((__stdcall__)) SetSecurityDescriptorDacl(PSECURITY_DESCRIPTOR,BOOL,PACL,BOOL);
 BOOL __attribute__((__stdcall__)) SetSecurityDescriptorGroup(PSECURITY_DESCRIPTOR,PSID,BOOL);
 BOOL __attribute__((__stdcall__)) SetSecurityDescriptorOwner(PSECURITY_DESCRIPTOR,PSID,BOOL);
 BOOL __attribute__((__stdcall__)) SetSecurityDescriptorSacl(PSECURITY_DESCRIPTOR,BOOL,PACL,BOOL);
 BOOL __attribute__((__stdcall__)) SetStdHandle(DWORD,HANDLE);

 BOOL __attribute__((__stdcall__)) SetSystemPowerState(BOOL,BOOL);
 BOOL __attribute__((__stdcall__)) SetSystemTime(const SYSTEMTIME*);
 BOOL __attribute__((__stdcall__)) SetSystemTimeAdjustment(DWORD,BOOL);
 DWORD __attribute__((__stdcall__)) SetTapeParameters(HANDLE,DWORD,PVOID);
 DWORD __attribute__((__stdcall__)) SetTapePosition(HANDLE,DWORD,DWORD,DWORD,DWORD,BOOL);
 DWORD __attribute__((__stdcall__)) SetThreadAffinityMask(HANDLE,DWORD);
 BOOL __attribute__((__stdcall__)) SetThreadContext(HANDLE,const CONTEXT*);



 DWORD __attribute__((__stdcall__)) SetThreadIdealProcessor(HANDLE,DWORD);
 BOOL __attribute__((__stdcall__)) SetThreadPriority(HANDLE,int);
 BOOL __attribute__((__stdcall__)) SetThreadPriorityBoost(HANDLE,BOOL);
 BOOL __attribute__((__stdcall__)) SetThreadToken (PHANDLE,HANDLE);
 BOOL __attribute__((__stdcall__)) SetTimeZoneInformation(const TIME_ZONE_INFORMATION *);
 BOOL __attribute__((__stdcall__)) SetTokenInformation(HANDLE,TOKEN_INFORMATION_CLASS,PVOID,DWORD);
 LPTOP_LEVEL_EXCEPTION_FILTER __attribute__((__stdcall__)) SetUnhandledExceptionFilter(LPTOP_LEVEL_EXCEPTION_FILTER);
 BOOL __attribute__((__stdcall__)) SetupComm(HANDLE,DWORD,DWORD);
 BOOL __attribute__((__stdcall__)) SetVolumeLabelA(LPCSTR,LPCSTR);
 BOOL __attribute__((__stdcall__)) SetVolumeLabelW(LPCWSTR,LPCWSTR);




 BOOL __attribute__((__stdcall__)) SetWaitableTimer(HANDLE,const LARGE_INTEGER*,LONG,PTIMERAPCROUTINE,PVOID,BOOL);
 DWORD __attribute__((__stdcall__)) SignalObjectAndWait(HANDLE,HANDLE,DWORD,BOOL);
 DWORD __attribute__((__stdcall__)) SizeofResource(HINSTANCE,HRSRC);
 void __attribute__((__stdcall__)) Sleep(DWORD);
 DWORD __attribute__((__stdcall__)) SleepEx(DWORD,BOOL);
 DWORD __attribute__((__stdcall__)) SuspendThread(HANDLE);
 void __attribute__((__stdcall__)) SwitchToFiber(PVOID);
 BOOL __attribute__((__stdcall__)) SwitchToThread(void);
 BOOL __attribute__((__stdcall__)) SystemTimeToFileTime(const SYSTEMTIME*,LPFILETIME);
 BOOL __attribute__((__stdcall__)) SystemTimeToTzSpecificLocalTime(LPTIME_ZONE_INFORMATION,LPSYSTEMTIME,LPSYSTEMTIME);
 BOOL __attribute__((__stdcall__)) TerminateProcess(HANDLE,UINT);
 BOOL __attribute__((__stdcall__)) TerminateThread(HANDLE,DWORD);
 DWORD __attribute__((__stdcall__)) TlsAlloc(void);
 BOOL __attribute__((__stdcall__)) TlsFree(DWORD);
 PVOID __attribute__((__stdcall__)) TlsGetValue(DWORD);
 BOOL __attribute__((__stdcall__)) TlsSetValue(DWORD,PVOID);
 BOOL __attribute__((__stdcall__)) TransactNamedPipe(HANDLE,PVOID,DWORD,PVOID,DWORD,PDWORD,LPOVERLAPPED);
 BOOL __attribute__((__stdcall__)) TransmitCommChar(HANDLE,char);
 BOOL __attribute__((__stdcall__)) TryEnterCriticalSection(LPCRITICAL_SECTION);
 LONG __attribute__((__stdcall__)) UnhandledExceptionFilter(LPEXCEPTION_POINTERS);
 BOOL __attribute__((__stdcall__)) UnlockFile(HANDLE,DWORD,DWORD,DWORD,DWORD);
 BOOL __attribute__((__stdcall__)) UnlockFileEx(HANDLE,DWORD,DWORD,DWORD,LPOVERLAPPED);


 BOOL __attribute__((__stdcall__)) UnmapViewOfFile(PVOID);



 BOOL __attribute__((__stdcall__)) UpdateResourceA(HANDLE,LPCSTR,LPCSTR,WORD,PVOID,DWORD);
 BOOL __attribute__((__stdcall__)) UpdateResourceW(HANDLE,LPCWSTR,LPCWSTR,WORD,PVOID,DWORD);
 BOOL __attribute__((__stdcall__)) VerifyVersionInfoA(LPOSVERSIONINFOEXA,DWORD,DWORDLONG);
 BOOL __attribute__((__stdcall__)) VerifyVersionInfoW(LPOSVERSIONINFOEXW,DWORD,DWORDLONG);
 PVOID __attribute__((__stdcall__)) VirtualAlloc(PVOID,DWORD,DWORD,DWORD);
 PVOID __attribute__((__stdcall__)) VirtualAllocEx(HANDLE,PVOID,DWORD,DWORD,DWORD);
 BOOL __attribute__((__stdcall__)) VirtualFree(PVOID,DWORD,DWORD);
 BOOL __attribute__((__stdcall__)) VirtualFreeEx(HANDLE,PVOID,DWORD,DWORD);
 BOOL __attribute__((__stdcall__)) VirtualLock(PVOID,DWORD);
 BOOL __attribute__((__stdcall__)) VirtualProtect(PVOID,DWORD,DWORD,PDWORD);
 BOOL __attribute__((__stdcall__)) VirtualProtectEx(HANDLE,PVOID,DWORD,DWORD,PDWORD);
 DWORD __attribute__((__stdcall__)) VirtualQuery(LPCVOID,PMEMORY_BASIC_INFORMATION,DWORD);
 DWORD __attribute__((__stdcall__)) VirtualQueryEx(HANDLE,LPCVOID,PMEMORY_BASIC_INFORMATION,DWORD);
 BOOL __attribute__((__stdcall__)) VirtualUnlock(PVOID,DWORD);
 BOOL __attribute__((__stdcall__)) WaitCommEvent(HANDLE,PDWORD,LPOVERLAPPED);
 BOOL __attribute__((__stdcall__)) WaitForDebugEvent(LPDEBUG_EVENT,DWORD);
 DWORD __attribute__((__stdcall__)) WaitForMultipleObjects(DWORD,const HANDLE*,BOOL,DWORD);
 DWORD __attribute__((__stdcall__)) WaitForMultipleObjectsEx(DWORD,const HANDLE*,BOOL,DWORD,BOOL);
 DWORD __attribute__((__stdcall__)) WaitForSingleObject(HANDLE,DWORD);
 DWORD __attribute__((__stdcall__)) WaitForSingleObjectEx(HANDLE,DWORD,BOOL);
 BOOL __attribute__((__stdcall__)) WaitNamedPipeA(LPCSTR,DWORD);
 BOOL __attribute__((__stdcall__)) WaitNamedPipeW(LPCWSTR,DWORD);
 BOOL __attribute__((__stdcall__)) WinLoadTrustProvider(GUID*);
 BOOL __attribute__((__stdcall__)) WriteFile(HANDLE,PCVOID,DWORD,PDWORD,LPOVERLAPPED);
 BOOL __attribute__((__stdcall__)) WriteFileEx(HANDLE,PCVOID,DWORD,LPOVERLAPPED,LPOVERLAPPED_COMPLETION_ROUTINE);
 BOOL __attribute__((__stdcall__)) WriteFileGather(HANDLE,FILE_SEGMENT_ELEMENT*,DWORD,LPDWORD,LPOVERLAPPED);
 BOOL __attribute__((__stdcall__)) WritePrivateProfileSectionA(LPCSTR,LPCSTR,LPCSTR);
 BOOL __attribute__((__stdcall__)) WritePrivateProfileSectionW(LPCWSTR,LPCWSTR,LPCWSTR);
 BOOL __attribute__((__stdcall__)) WritePrivateProfileStringA(LPCSTR,LPCSTR,LPCSTR,LPCSTR);
 BOOL __attribute__((__stdcall__)) WritePrivateProfileStringW(LPCWSTR,LPCWSTR,LPCWSTR,LPCWSTR);
 BOOL __attribute__((__stdcall__)) WritePrivateProfileStructA(LPCSTR,LPCSTR,LPVOID,UINT,LPCSTR);
 BOOL __attribute__((__stdcall__)) WritePrivateProfileStructW(LPCWSTR,LPCWSTR,LPVOID,UINT,LPCWSTR);
 BOOL __attribute__((__stdcall__)) WriteProcessMemory(HANDLE,LPVOID,LPCVOID,SIZE_T,SIZE_T*);
 BOOL __attribute__((__stdcall__)) WriteProfileSectionA(LPCSTR,LPCSTR);
 BOOL __attribute__((__stdcall__)) WriteProfileSectionW(LPCWSTR,LPCWSTR);
 BOOL __attribute__((__stdcall__)) WriteProfileStringA(LPCSTR,LPCSTR,LPCSTR);
 BOOL __attribute__((__stdcall__)) WriteProfileStringW(LPCWSTR,LPCWSTR,LPCWSTR);
 DWORD __attribute__((__stdcall__)) WriteTapemark(HANDLE,DWORD,DWORD,BOOL);
# 2163 "H:/CPP/wxdevcpp6.10/include/winbase.h" 3
typedef STARTUPINFOA STARTUPINFO,*LPSTARTUPINFO;
typedef WIN32_FIND_DATAA WIN32_FIND_DATA,*PWIN32_FIND_DATA,*LPWIN32_FIND_DATA;
typedef HW_PROFILE_INFOA HW_PROFILE_INFO,*LPHW_PROFILE_INFO;
# 2360 "H:/CPP/wxdevcpp6.10/include/winbase.h" 3
}
# 51 "H:/CPP/wxdevcpp6.10/include/windows.h" 2 3

# 1 "H:/CPP/wxdevcpp6.10/include/wingdi.h" 1 3




       
# 6 "H:/CPP/wxdevcpp6.10/include/wingdi.h" 3



extern "C" {
# 1227 "H:/CPP/wxdevcpp6.10/include/wingdi.h" 3
typedef struct _ABC {
 int abcA;
 UINT abcB;
 int abcC;
} ABC,*LPABC;
typedef struct _ABCFLOAT {
 FLOAT abcfA;
 FLOAT abcfB;
 FLOAT abcfC;
} ABCFLOAT,*LPABCFLOAT;
typedef struct tagBITMAP {
 LONG bmType;
 LONG bmWidth;
 LONG bmHeight;
 LONG bmWidthBytes;
 WORD bmPlanes;
 WORD bmBitsPixel;
 LPVOID bmBits;
} BITMAP,*PBITMAP,*LPBITMAP;
typedef struct tagBITMAPCOREHEADER {
 DWORD bcSize;
 WORD bcWidth;
 WORD bcHeight;
 WORD bcPlanes;
 WORD bcBitCount;
} BITMAPCOREHEADER,*LPBITMAPCOREHEADER,*PBITMAPCOREHEADER;
#pragma pack(push,1)
typedef struct tagRGBTRIPLE {
 BYTE rgbtBlue;
 BYTE rgbtGreen;
 BYTE rgbtRed;
} RGBTRIPLE,*LPRGBTRIPLE;
#pragma pack(pop)
#pragma pack(push,2)
typedef struct tagBITMAPFILEHEADER {
 WORD bfType;
 DWORD bfSize;
 WORD bfReserved1;
 WORD bfReserved2;
 DWORD bfOffBits;
} BITMAPFILEHEADER,*LPBITMAPFILEHEADER,*PBITMAPFILEHEADER;
#pragma pack(pop)
typedef struct _BITMAPCOREINFO {
 BITMAPCOREHEADER bmciHeader;
 RGBTRIPLE bmciColors[1];
} BITMAPCOREINFO,*LPBITMAPCOREINFO,*PBITMAPCOREINFO;
typedef struct tagBITMAPINFOHEADER{
 DWORD biSize;
 LONG biWidth;
 LONG biHeight;
 WORD biPlanes;
 WORD biBitCount;
 DWORD biCompression;
 DWORD biSizeImage;
 LONG biXPelsPerMeter;
 LONG biYPelsPerMeter;
 DWORD biClrUsed;
 DWORD biClrImportant;
} BITMAPINFOHEADER,*LPBITMAPINFOHEADER,*PBITMAPINFOHEADER;
typedef struct tagRGBQUAD {
 BYTE rgbBlue;
 BYTE rgbGreen;
 BYTE rgbRed;
 BYTE rgbReserved;
} RGBQUAD,*LPRGBQUAD;
typedef struct tagBITMAPINFO {
 BITMAPINFOHEADER bmiHeader;
 RGBQUAD bmiColors[1];
} BITMAPINFO,*LPBITMAPINFO,*PBITMAPINFO;
typedef long FXPT16DOT16,*LPFXPT16DOT16;
typedef long FXPT2DOT30,*LPFXPT2DOT30;
typedef struct tagCIEXYZ {
 FXPT2DOT30 ciexyzX;
 FXPT2DOT30 ciexyzY;
 FXPT2DOT30 ciexyzZ;
} CIEXYZ,*LPCIEXYZ;
typedef struct tagCIEXYZTRIPLE {
 CIEXYZ ciexyzRed;
 CIEXYZ ciexyzGreen;
 CIEXYZ ciexyzBlue;
} CIEXYZTRIPLE,*LPCIEXYZTRIPLE;
typedef struct {
 DWORD bV4Size;
 LONG bV4Width;
 LONG bV4Height;
 WORD bV4Planes;
 WORD bV4BitCount;
 DWORD bV4V4Compression;
 DWORD bV4SizeImage;
 LONG bV4XPelsPerMeter;
 LONG bV4YPelsPerMeter;
 DWORD bV4ClrUsed;
 DWORD bV4ClrImportant;
 DWORD bV4RedMask;
 DWORD bV4GreenMask;
 DWORD bV4BlueMask;
 DWORD bV4AlphaMask;
 DWORD bV4CSType;
 CIEXYZTRIPLE bV4Endpoints;
 DWORD bV4GammaRed;
 DWORD bV4GammaGreen;
 DWORD bV4GammaBlue;
} BITMAPV4HEADER,*LPBITMAPV4HEADER,*PBITMAPV4HEADER;
typedef struct tagFONTSIGNATURE {
 DWORD fsUsb[4];
 DWORD fsCsb[2];
} FONTSIGNATURE,*LPFONTSIGNATURE;
typedef struct {
 UINT ciCharset;
 UINT ciACP;
 FONTSIGNATURE fs;
} CHARSETINFO,*LPCHARSETINFO;
typedef struct tagCOLORADJUSTMENT {
 WORD caSize;
 WORD caFlags;
 WORD caIlluminantIndex;
 WORD caRedGamma;
 WORD caGreenGamma;
 WORD caBlueGamma;
 WORD caReferenceBlack;
 WORD caReferenceWhite;
 SHORT caContrast;
 SHORT caBrightness;
 SHORT caColorfulness;
 SHORT caRedGreenTint;
} COLORADJUSTMENT,*LPCOLORADJUSTMENT;
typedef struct _devicemodeA {
  BYTE dmDeviceName[32];
  WORD dmSpecVersion;
  WORD dmDriverVersion;
  WORD dmSize;
  WORD dmDriverExtra;
  DWORD dmFields;
  __extension__ union {
    __extension__ struct {
      short dmOrientation;
      short dmPaperSize;
      short dmPaperLength;
      short dmPaperWidth;
      short dmScale;
      short dmCopies;
      short dmDefaultSource;
      short dmPrintQuality;
    } ;
    POINTL dmPosition;
    DWORD dmDisplayOrientation;
    DWORD dmDisplayFixedOutput;
  } ;

  short dmColor;
  short dmDuplex;
  short dmYResolution;
  short dmTTOption;
  short dmCollate;
  BYTE dmFormName[32];
  WORD dmLogPixels;
  DWORD dmBitsPerPel;
  DWORD dmPelsWidth;
  DWORD dmPelsHeight;
  __extension__ union {
    DWORD dmDisplayFlags;
    DWORD dmNup;
  } ;
  DWORD dmDisplayFrequency;

  DWORD dmICMMethod;
  DWORD dmICMIntent;
  DWORD dmMediaType;
  DWORD dmDitherType;
  DWORD dmReserved1;
  DWORD dmReserved2;

  DWORD dmPanningWidth;
  DWORD dmPanningHeight;


} DEVMODEA,*LPDEVMODEA,*PDEVMODEA;
typedef struct _devicemodeW {
  WCHAR dmDeviceName[32];
  WORD dmSpecVersion;
  WORD dmDriverVersion;
  WORD dmSize;
  WORD dmDriverExtra;
  DWORD dmFields;
  __extension__ union {
    __extension__ struct {
      short dmOrientation;
      short dmPaperSize;
      short dmPaperLength;
      short dmPaperWidth;
      short dmScale;
      short dmCopies;
      short dmDefaultSource;
      short dmPrintQuality;
    } ;
    POINTL dmPosition;
    DWORD dmDisplayOrientation;
    DWORD dmDisplayFixedOutput;
  } ;

  short dmColor;
  short dmDuplex;
  short dmYResolution;
  short dmTTOption;
  short dmCollate;
  WCHAR dmFormName[32];
  WORD dmLogPixels;
  DWORD dmBitsPerPel;
  DWORD dmPelsWidth;
  DWORD dmPelsHeight;
  __extension__ union {
    DWORD dmDisplayFlags;
    DWORD dmNup;
  } ;
  DWORD dmDisplayFrequency;

  DWORD dmICMMethod;
  DWORD dmICMIntent;
  DWORD dmMediaType;
  DWORD dmDitherType;
  DWORD dmReserved1;
  DWORD dmReserved2;

  DWORD dmPanningWidth;
  DWORD dmPanningHeight;


} DEVMODEW,*LPDEVMODEW,*PDEVMODEW;
typedef struct tagDIBSECTION {
 BITMAP dsBm;
 BITMAPINFOHEADER dsBmih;
 DWORD dsBitfields[3];
 HANDLE dshSection;
 DWORD dsOffset;
} DIBSECTION;
typedef struct _DOCINFOA {
 int cbSize;
 LPCSTR lpszDocName;
 LPCSTR lpszOutput;
 LPCSTR lpszDatatype;
 DWORD fwType;
} DOCINFOA,*LPDOCINFOA;
typedef struct _DOCINFOW {
 int cbSize;
 LPCWSTR lpszDocName;
 LPCWSTR lpszOutput;
 LPCWSTR lpszDatatype;
 DWORD fwType;
} DOCINFOW,*LPDOCINFOW;
typedef struct tagEMR {
 DWORD iType;
 DWORD nSize;
} EMR,*PEMR;
typedef struct tagEMRANGLEARC {
 EMR emr;
 POINTL ptlCenter;
 DWORD nRadius;
 FLOAT eStartAngle;
 FLOAT eSweepAngle;
} EMRANGLEARC,*PEMRANGLEARC;
typedef struct tagEMRARC {
 EMR emr;
 RECTL rclBox;
 POINTL ptlStart;
 POINTL ptlEnd;
} EMRARC,*PEMRARC,EMRARCTO,*PEMRARCTO,EMRCHORD,*PEMRCHORD,EMRPIE,*PEMRPIE;
typedef struct _XFORM {
 FLOAT eM11;
 FLOAT eM12;
 FLOAT eM21;
 FLOAT eM22;
 FLOAT eDx;
 FLOAT eDy;
} XFORM,*PXFORM,*LPXFORM;
typedef struct tagEMRBITBLT {
 EMR emr;
 RECTL rclBounds;
 LONG xDest;
 LONG yDest;
 LONG cxDest;
 LONG cyDest;
 DWORD dwRop;
 LONG xSrc;
 LONG ySrc;
 XFORM xformSrc;
 COLORREF crBkColorSrc;
 DWORD iUsageSrc;
 DWORD offBmiSrc;
 DWORD offBitsSrc;
 DWORD cbBitsSrc;
} EMRBITBLT,*PEMRBITBLT;
typedef struct tagLOGBRUSH {
 UINT lbStyle;
 COLORREF lbColor;
 LONG lbHatch;
} LOGBRUSH,*PLOGBRUSH,*LPLOGBRUSH;
typedef LOGBRUSH PATTERN,*PPATTERN,*LPPATTERN;
typedef struct tagEMRCREATEBRUSHINDIRECT {
 EMR emr;
 DWORD ihBrush;
 LOGBRUSH lb;
} EMRCREATEBRUSHINDIRECT,*PEMRCREATEBRUSHINDIRECT;
typedef LONG LCSCSTYPE;
typedef LONG LCSGAMUTMATCH;
typedef struct tagLOGCOLORSPACEA {
 DWORD lcsSignature;
 DWORD lcsVersion;
 DWORD lcsSize;
 LCSCSTYPE lcsCSType;
 LCSGAMUTMATCH lcsIntent;
 CIEXYZTRIPLE lcsEndpoints;
 DWORD lcsGammaRed;
 DWORD lcsGammaGreen;
 DWORD lcsGammaBlue;
 CHAR lcsFilename[260];
} LOGCOLORSPACEA,*LPLOGCOLORSPACEA;
typedef struct tagLOGCOLORSPACEW {
 DWORD lcsSignature;
 DWORD lcsVersion;
 DWORD lcsSize;
 LCSCSTYPE lcsCSType;
 LCSGAMUTMATCH lcsIntent;
 CIEXYZTRIPLE lcsEndpoints;
 DWORD lcsGammaRed;
 DWORD lcsGammaGreen;
 DWORD lcsGammaBlue;
 WCHAR lcsFilename[260];
} LOGCOLORSPACEW,*LPLOGCOLORSPACEW;
typedef struct tagEMRCREATECOLORSPACE {
 EMR emr;
 DWORD ihCS;
 LOGCOLORSPACEW lcs;
} EMRCREATECOLORSPACE,*PEMRCREATECOLORSPACE;
typedef struct tagEMRCREATEDIBPATTERNBRUSHPT {
 EMR emr;
 DWORD ihBrush;
 DWORD iUsage;
 DWORD offBmi;
 DWORD cbBmi;
 DWORD offBits;
 DWORD cbBits;
} EMRCREATEDIBPATTERNBRUSHPT,*PEMRCREATEDIBPATTERNBRUSHPT;
typedef struct tagEMRCREATEMONOBRUSH {
 EMR emr;
 DWORD ihBrush;
 DWORD iUsage;
 DWORD offBmi;
 DWORD cbBmi;
 DWORD offBits;
 DWORD cbBits;
} EMRCREATEMONOBRUSH,*PEMRCREATEMONOBRUSH;
typedef struct tagPALETTEENTRY {
 BYTE peRed;
 BYTE peGreen;
 BYTE peBlue;
 BYTE peFlags;
} PALETTEENTRY,*LPPALETTEENTRY,*PPALETTEENTRY;
typedef struct tagLOGPALETTE {
 WORD palVersion;
 WORD palNumEntries;
 PALETTEENTRY palPalEntry[1];
} LOGPALETTE,*NPLOGPALETTE,*PLOGPALETTE,*LPLOGPALETTE;
typedef struct tagEMRCREATEPALETTE {
 EMR emr;
 DWORD ihPal;
 LOGPALETTE lgpl;
} EMRCREATEPALETTE,*PEMRCREATEPALETTE;
typedef struct tagLOGPEN {
 UINT lopnStyle;
 POINT lopnWidth;
 COLORREF lopnColor;
} LOGPEN,*PLOGPEN,*LPLOGPEN;
typedef struct tagEMRCREATEPEN {
 EMR emr;
 DWORD ihPen;
 LOGPEN lopn;
} EMRCREATEPEN,*PEMRCREATEPEN;
typedef struct tagEMRELLIPSE {
 EMR emr;
 RECTL rclBox;
} EMRELLIPSE,*PEMRELLIPSE,EMRRECTANGLE,*PEMRRECTANGLE;
typedef struct tagEMREOF {
 EMR emr;
 DWORD nPalEntries;
 DWORD offPalEntries;
 DWORD nSizeLast;
} EMREOF,*PEMREOF;
typedef struct tagEMREXCLUDECLIPRECT {
 EMR emr;
 RECTL rclClip;
} EMREXCLUDECLIPRECT,*PEMREXCLUDECLIPRECT,EMRINTERSECTCLIPRECT,*PEMRINTERSECTCLIPRECT;
typedef struct tagPANOSE {
 BYTE bFamilyType;
 BYTE bSerifStyle;
 BYTE bWeight;
 BYTE bProportion;
 BYTE bContrast;
 BYTE bStrokeVariation;
 BYTE bArmStyle;
 BYTE bLetterform;
 BYTE bMidline;
 BYTE bXHeight;
} PANOSE;
typedef struct tagLOGFONTA {
 LONG lfHeight;
 LONG lfWidth;
 LONG lfEscapement;
 LONG lfOrientation;
 LONG lfWeight;
 BYTE lfItalic;
 BYTE lfUnderline;
 BYTE lfStrikeOut;
 BYTE lfCharSet;
 BYTE lfOutPrecision;
 BYTE lfClipPrecision;
 BYTE lfQuality;
 BYTE lfPitchAndFamily;
 CHAR lfFaceName[32];
} LOGFONTA,*PLOGFONTA,*LPLOGFONTA;
typedef struct tagLOGFONTW {
 LONG lfHeight;
 LONG lfWidth;
 LONG lfEscapement;
 LONG lfOrientation;
 LONG lfWeight;
 BYTE lfItalic;
 BYTE lfUnderline;
 BYTE lfStrikeOut;
 BYTE lfCharSet;
 BYTE lfOutPrecision;
 BYTE lfClipPrecision;
 BYTE lfQuality;
 BYTE lfPitchAndFamily;
 WCHAR lfFaceName[32];
} LOGFONTW,*PLOGFONTW,*LPLOGFONTW;
typedef struct tagEXTLOGFONTA {
 LOGFONTA elfLogFont;
 BYTE elfFullName[64];
 BYTE elfStyle[32];
 DWORD elfVersion;
 DWORD elfStyleSize;
 DWORD elfMatch;
 DWORD elfReserved;
 BYTE elfVendorId[4];
 DWORD elfCulture;
 PANOSE elfPanose;
} EXTLOGFONTA,*PEXTLOGFONTA,*LPEXTLOGFONTA;
typedef struct tagEXTLOGFONTW {
 LOGFONTW elfLogFont;
 WCHAR elfFullName[64];
 WCHAR elfStyle[32];
 DWORD elfVersion;
 DWORD elfStyleSize;
 DWORD elfMatch;
 DWORD elfReserved;
 BYTE elfVendorId[4];
 DWORD elfCulture;
 PANOSE elfPanose;
} EXTLOGFONTW,*PEXTLOGFONTW,*LPEXTLOGFONTW;
typedef struct tagEMREXTCREATEFONTINDIRECTW {
 EMR emr;
 DWORD ihFont;
 EXTLOGFONTW elfw;
} EMREXTCREATEFONTINDIRECTW,*PEMREXTCREATEFONTINDIRECTW;
typedef struct tagEXTLOGPEN {
 UINT elpPenStyle;
 UINT elpWidth;
 UINT elpBrushStyle;
 COLORREF elpColor;
 LONG elpHatch;
 DWORD elpNumEntries;
 DWORD elpStyleEntry[1];
} EXTLOGPEN,*PEXTLOGPEN,*LPEXTLOGPEN;
typedef struct tagEMREXTCREATEPEN {
 EMR emr;
 DWORD ihPen;
 DWORD offBmi;
 DWORD cbBmi;
 DWORD offBits;
 DWORD cbBits;
 EXTLOGPEN elp;
} EMREXTCREATEPEN,*PEMREXTCREATEPEN;
typedef struct tagEMREXTFLOODFILL {
 EMR emr;
 POINTL ptlStart;
 COLORREF crColor;
 DWORD iMode;
} EMREXTFLOODFILL,*PEMREXTFLOODFILL;
typedef struct tagEMREXTSELECTCLIPRGN {
 EMR emr;
 DWORD cbRgnData;
 DWORD iMode;
 BYTE RgnData[1];
} EMREXTSELECTCLIPRGN,*PEMREXTSELECTCLIPRGN;
typedef struct tagEMRTEXT {
 POINTL ptlReference;
 DWORD nChars;
 DWORD offString;
 DWORD fOptions;
 RECTL rcl;
 DWORD offDx;
} EMRTEXT,*PEMRTEXT;
typedef struct tagEMREXTTEXTOUTA {
 EMR emr;
 RECTL rclBounds;
 DWORD iGraphicsMode;
 FLOAT exScale;
 FLOAT eyScale;
 EMRTEXT emrtext;
} EMREXTTEXTOUTA,*PEMREXTTEXTOUTA,EMREXTTEXTOUTW,*PEMREXTTEXTOUTW;
typedef struct tagEMRFILLPATH {
 EMR emr;
 RECTL rclBounds;
} EMRFILLPATH,*PEMRFILLPATH,EMRSTROKEANDFILLPATH,*PEMRSTROKEANDFILLPATH,EMRSTROKEPATH,*PEMRSTROKEPATH;
typedef struct tagEMRFILLRGN {
 EMR emr;
 RECTL rclBounds;
 DWORD cbRgnData;
 DWORD ihBrush;
 BYTE RgnData[1];
} EMRFILLRGN,*PEMRFILLRGN;
typedef struct tagEMRFORMAT {
 DWORD dSignature;
 DWORD nVersion;
 DWORD cbData;
 DWORD offData;
} EMRFORMAT;
typedef struct tagEMRFRAMERGN {
 EMR emr;
 RECTL rclBounds;
 DWORD cbRgnData;
 DWORD ihBrush;
 SIZEL szlStroke;
 BYTE RgnData[1];
} EMRFRAMERGN,*PEMRFRAMERGN;
typedef struct tagEMRGDICOMMENT {
 EMR emr;
 DWORD cbData;
 BYTE Data[1];
} EMRGDICOMMENT,*PEMRGDICOMMENT;
typedef struct tagEMRINVERTRGN {
 EMR emr;
 RECTL rclBounds;
 DWORD cbRgnData;
 BYTE RgnData[1];
} EMRINVERTRGN,*PEMRINVERTRGN,EMRPAINTRGN,*PEMRPAINTRGN;
typedef struct tagEMRLINETO {
 EMR emr;
 POINTL ptl;
} EMRLINETO,*PEMRLINETO,EMRMOVETOEX,*PEMRMOVETOEX;
typedef struct tagEMRMASKBLT {
 EMR emr;
 RECTL rclBounds;
 LONG xDest;
 LONG yDest;
 LONG cxDest;
 LONG cyDest;
 DWORD dwRop;
 LONG xSrc;
 LONG ySrc;
 XFORM xformSrc;
 COLORREF crBkColorSrc;
 DWORD iUsageSrc;
 DWORD offBmiSrc;
 DWORD cbBmiSrc;
 DWORD offBitsSrc;
 DWORD cbBitsSrc;
 LONG xMask;
 LONG yMask;
 DWORD iUsageMask;
 DWORD offBmiMask;
 DWORD cbBmiMask;
 DWORD offBitsMask;
 DWORD cbBitsMask;
} EMRMASKBLT,*PEMRMASKBLT;
typedef struct tagEMRMODIFYWORLDTRANSFORM {
 EMR emr;
 XFORM xform;
 DWORD iMode;
} EMRMODIFYWORLDTRANSFORM,*PEMRMODIFYWORLDTRANSFORM;
typedef struct tagEMROFFSETCLIPRGN {
 EMR emr;
 POINTL ptlOffset;
} EMROFFSETCLIPRGN,*PEMROFFSETCLIPRGN;
typedef struct tagEMRPLGBLT {
 EMR emr;
 RECTL rclBounds;
 POINTL aptlDest[3];
 LONG xSrc;
 LONG ySrc;
 LONG cxSrc;
 LONG cySrc;
 XFORM xformSrc;
 COLORREF crBkColorSrc;
 DWORD iUsageSrc;
 DWORD offBmiSrc;
 DWORD cbBmiSrc;
 DWORD offBitsSrc;
 DWORD cbBitsSrc;
 LONG xMask;
 LONG yMask;
 DWORD iUsageMask;
 DWORD offBmiMask;
 DWORD cbBmiMask;
 DWORD offBitsMask;
 DWORD cbBitsMask;
} EMRPLGBLT,*PEMRPLGBLT;
typedef struct tagEMRPOLYDRAW {
 EMR emr;
 RECTL rclBounds;
 DWORD cptl;
 POINTL aptl[1];
 BYTE abTypes[1];
} EMRPOLYDRAW,*PEMRPOLYDRAW;
typedef struct tagEMRPOLYDRAW16 {
 EMR emr;
 RECTL rclBounds;
 DWORD cpts;
 POINTS apts[1];
 BYTE abTypes[1];
} EMRPOLYDRAW16,*PEMRPOLYDRAW16;
typedef struct tagEMRPOLYLINE {
 EMR emr;
 RECTL rclBounds;
 DWORD cptl;
 POINTL aptl[1];
} EMRPOLYLINE,*PEMRPOLYLINE,EMRPOLYBEZIER,*PEMRPOLYBEZIER,EMRPOLYGON,*PEMRPOLYGON,EMRPOLYBEZIERTO,*PEMRPOLYBEZIERTO,EMRPOLYLINETO,*PEMRPOLYLINETO;
typedef struct tagEMRPOLYLINE16 {
 EMR emr;
 RECTL rclBounds;
 DWORD cpts;
 POINTL apts[1];
} EMRPOLYLINE16,*PEMRPOLYLINE16,EMRPOLYBEZIER16,*PEMRPOLYBEZIER16,EMRPOLYGON16,*PEMRPOLYGON16,EMRPOLYBEZIERTO16,*PEMRPOLYBEZIERTO16,EMRPOLYLINETO16,*PEMRPOLYLINETO16;
typedef struct tagEMRPOLYPOLYLINE {
 EMR emr;
 RECTL rclBounds;
 DWORD nPolys;
 DWORD cptl;
 DWORD aPolyCounts[1];
 POINTL aptl[1];
} EMRPOLYPOLYLINE,*PEMRPOLYPOLYLINE,EMRPOLYPOLYGON,*PEMRPOLYPOLYGON;
typedef struct tagEMRPOLYPOLYLINE16 {
 EMR emr;
 RECTL rclBounds;
 DWORD nPolys;
 DWORD cpts;
 DWORD aPolyCounts[1];
 POINTS apts[1];
} EMRPOLYPOLYLINE16,*PEMRPOLYPOLYLINE16,EMRPOLYPOLYGON16,*PEMRPOLYPOLYGON16;
typedef struct tagEMRPOLYTEXTOUTA {
 EMR emr;
 RECTL rclBounds;
 DWORD iGraphicsMode;
 FLOAT exScale;
 FLOAT eyScale;
 LONG cStrings;
 EMRTEXT aemrtext[1];
} EMRPOLYTEXTOUTA,*PEMRPOLYTEXTOUTA,EMRPOLYTEXTOUTW,*PEMRPOLYTEXTOUTW;
typedef struct tagEMRRESIZEPALETTE {
 EMR emr;
 DWORD ihPal;
 DWORD cEntries;
} EMRRESIZEPALETTE,*PEMRRESIZEPALETTE;
typedef struct tagEMRRESTOREDC {
 EMR emr;
 LONG iRelative;
} EMRRESTOREDC,*PEMRRESTOREDC;
typedef struct tagEMRROUNDRECT {
 EMR emr;
 RECTL rclBox;
 SIZEL szlCorner;
} EMRROUNDRECT,*PEMRROUNDRECT;
typedef struct tagEMRSCALEVIEWPORTEXTEX {
 EMR emr;
 LONG xNum;
 LONG xDenom;
 LONG yNum;
 LONG yDenom;
} EMRSCALEVIEWPORTEXTEX,*PEMRSCALEVIEWPORTEXTEX,EMRSCALEWINDOWEXTEX,*PEMRSCALEWINDOWEXTEX;
typedef struct tagEMRSELECTCOLORSPACE {
 EMR emr;
 DWORD ihCS;
} EMRSELECTCOLORSPACE,*PEMRSELECTCOLORSPACE,EMRDELETECOLORSPACE,*PEMRDELETECOLORSPACE;
typedef struct tagEMRSELECTOBJECT {
 EMR emr;
 DWORD ihObject;
} EMRSELECTOBJECT,*PEMRSELECTOBJECT,EMRDELETEOBJECT,*PEMRDELETEOBJECT;
typedef struct tagEMRSELECTPALETTE {
 EMR emr;
 DWORD ihPal;
} EMRSELECTPALETTE,*PEMRSELECTPALETTE;
typedef struct tagEMRSETARCDIRECTION {
 EMR emr;
 DWORD iArcDirection;
} EMRSETARCDIRECTION,*PEMRSETARCDIRECTION;
typedef struct tagEMRSETTEXTCOLOR {
 EMR emr;
 COLORREF crColor;
} EMRSETBKCOLOR,*PEMRSETBKCOLOR,EMRSETTEXTCOLOR,*PEMRSETTEXTCOLOR;
typedef struct tagEMRSETCOLORADJUSTMENT {
 EMR emr;
 COLORADJUSTMENT ColorAdjustment;
} EMRSETCOLORADJUSTMENT,*PEMRSETCOLORADJUSTMENT;
typedef struct tagEMRSETDIBITSTODEVICE {
 EMR emr;
 RECTL rclBounds;
 LONG xDest;
 LONG yDest;
 LONG xSrc;
 LONG ySrc;
 LONG cxSrc;
 LONG cySrc;
 DWORD offBmiSrc;
 DWORD cbBmiSrc;
 DWORD offBitsSrc;
 DWORD cbBitsSrc;
 DWORD iUsageSrc;
 DWORD iStartScan;
 DWORD cScans;
} EMRSETDIBITSTODEVICE,*PEMRSETDIBITSTODEVICE;
typedef struct tagEMRSETMAPPERFLAGS {
 EMR emr;
 DWORD dwFlags;
} EMRSETMAPPERFLAGS,*PEMRSETMAPPERFLAGS;
typedef struct tagEMRSETMITERLIMIT {
 EMR emr;
 FLOAT eMiterLimit;
} EMRSETMITERLIMIT,*PEMRSETMITERLIMIT;
typedef struct tagEMRSETPALETTEENTRIES {
 EMR emr;
 DWORD ihPal;
 DWORD iStart;
 DWORD cEntries;
 PALETTEENTRY aPalEntries[1];
} EMRSETPALETTEENTRIES,*PEMRSETPALETTEENTRIES;
typedef struct tagEMRSETPIXELV {
 EMR emr;
 POINTL ptlPixel;
 COLORREF crColor;
} EMRSETPIXELV,*PEMRSETPIXELV;
typedef struct tagEMRSETVIEWPORTEXTEX {
 EMR emr;
 SIZEL szlExtent;
} EMRSETVIEWPORTEXTEX,*PEMRSETVIEWPORTEXTEX,EMRSETWINDOWEXTEX,*PEMRSETWINDOWEXTEX;
typedef struct tagEMRSETVIEWPORTORGEX {
 EMR emr;
 POINTL ptlOrigin;
} EMRSETVIEWPORTORGEX,*PEMRSETVIEWPORTORGEX,EMRSETWINDOWORGEX,*PEMRSETWINDOWORGEX,EMRSETBRUSHORGEX,*PEMRSETBRUSHORGEX;
typedef struct tagEMRSETWORLDTRANSFORM {
 EMR emr;
 XFORM xform;
} EMRSETWORLDTRANSFORM,*PEMRSETWORLDTRANSFORM;
typedef struct tagEMRSTRETCHBLT {
 EMR emr;
 RECTL rclBounds;
 LONG xDest;
 LONG yDest;
 LONG cxDest;
 LONG cyDest;
 DWORD dwRop;
 LONG xSrc;
 LONG ySrc;
 XFORM xformSrc;
 COLORREF crBkColorSrc;
 DWORD iUsageSrc;
 DWORD offBmiSrc;
 DWORD cbBmiSrc;
 DWORD offBitsSrc;
 DWORD cbBitsSrc;
 LONG cxSrc;
 LONG cySrc;
} EMRSTRETCHBLT,*PEMRSTRETCHBLT;
typedef struct tagEMRSTRETCHDIBITS {
 EMR emr;
 RECTL rclBounds;
 LONG xDest;
 LONG yDest;
 LONG xSrc;
 LONG ySrc;
 LONG cxSrc;
 LONG cySrc;
 DWORD offBmiSrc;
 DWORD cbBmiSrc;
 DWORD offBitsSrc;
 DWORD cbBitsSrc;
 DWORD iUsageSrc;
 DWORD dwRop;
 LONG cxDest;
 LONG cyDest;
} EMRSTRETCHDIBITS,*PEMRSTRETCHDIBITS;
typedef struct tagABORTPATH {
 EMR emr;
} EMRABORTPATH,*PEMRABORTPATH,EMRBEGINPATH,*PEMRBEGINPATH,EMRENDPATH,*PEMRENDPATH,EMRCLOSEFIGURE,*PEMRCLOSEFIGURE,EMRFLATTENPATH,*PEMRFLATTENPATH,EMRWIDENPATH,*PEMRWIDENPATH,EMRSETMETARGN,*PEMRSETMETARGN,EMRSAVEDC,*PEMRSAVEDC,EMRREALIZEPALETTE,*PEMRREALIZEPALETTE;
typedef struct tagEMRSELECTCLIPPATH {
 EMR emr;
 DWORD iMode;
} EMRSELECTCLIPPATH,*PEMRSELECTCLIPPATH,EMRSETBKMODE,*PEMRSETBKMODE,EMRSETMAPMODE,*PEMRSETMAPMODE,EMRSETPOLYFILLMODE,*PEMRSETPOLYFILLMODE,EMRSETROP2,*PEMRSETROP2,EMRSETSTRETCHBLTMODE,*PEMRSETSTRETCHBLTMODE,EMRSETTEXTALIGN,*PEMRSETTEXTALIGN,EMRENABLEICM,*PEMRENABLEICM;
#pragma pack(push,2)
typedef struct tagMETAHEADER {
 WORD mtType;
 WORD mtHeaderSize;
 WORD mtVersion;
 DWORD mtSize;
 WORD mtNoObjects;
 DWORD mtMaxRecord;
 WORD mtNoParameters;
} METAHEADER,*PMETAHEADER,*LPMETAHEADER;
#pragma pack(pop)
typedef struct tagENHMETAHEADER {
 DWORD iType;
 DWORD nSize;
 RECTL rclBounds;
 RECTL rclFrame;
 DWORD dSignature;
 DWORD nVersion;
 DWORD nBytes;
 DWORD nRecords;
 WORD nHandles;
 WORD sReserved;
 DWORD nDescription;
 DWORD offDescription;
 DWORD nPalEntries;
 SIZEL szlDevice;
 SIZEL szlMillimeters;

 DWORD cbPixelFormat;
 DWORD offPixelFormat;
 DWORD bOpenGL;




} ENHMETAHEADER,*LPENHMETAHEADER;
typedef struct tagMETARECORD {
 DWORD rdSize;
 WORD rdFunction;
 WORD rdParm[1];
} METARECORD,*PMETARECORD,*LPMETARECORD;
typedef struct tagENHMETARECORD {
 DWORD iType;
 DWORD nSize;
 DWORD dParm[1];
} ENHMETARECORD,*LPENHMETARECORD;
typedef struct tagHANDLETABLE {
 HGDIOBJ objectHandle[1];
} HANDLETABLE,*LPHANDLETABLE;
typedef struct tagTEXTMETRICA {
 LONG tmHeight;
 LONG tmAscent;
 LONG tmDescent;
 LONG tmInternalLeading;
 LONG tmExternalLeading;
 LONG tmAveCharWidth;
 LONG tmMaxCharWidth;
 LONG tmWeight;
 LONG tmOverhang;
 LONG tmDigitizedAspectX;
 LONG tmDigitizedAspectY;
 BYTE tmFirstChar;
 BYTE tmLastChar;
 BYTE tmDefaultChar;
 BYTE tmBreakChar;
 BYTE tmItalic;
 BYTE tmUnderlined;
 BYTE tmStruckOut;
 BYTE tmPitchAndFamily;
 BYTE tmCharSet;
} TEXTMETRICA,*PTEXTMETRICA,*LPTEXTMETRICA;
typedef struct tagTEXTMETRICW {
 LONG tmHeight;
 LONG tmAscent;
 LONG tmDescent;
 LONG tmInternalLeading;
 LONG tmExternalLeading;
 LONG tmAveCharWidth;
 LONG tmMaxCharWidth;
 LONG tmWeight;
 LONG tmOverhang;
 LONG tmDigitizedAspectX;
 LONG tmDigitizedAspectY;
 WCHAR tmFirstChar;
 WCHAR tmLastChar;
 WCHAR tmDefaultChar;
 WCHAR tmBreakChar;
 BYTE tmItalic;
 BYTE tmUnderlined;
 BYTE tmStruckOut;
 BYTE tmPitchAndFamily;
 BYTE tmCharSet;
} TEXTMETRICW,*PTEXTMETRICW,*LPTEXTMETRICW;
typedef struct _RGNDATAHEADER {
 DWORD dwSize;
 DWORD iType;
 DWORD nCount;
 DWORD nRgnSize;
 RECT rcBound;
} RGNDATAHEADER;
typedef struct _RGNDATA {
 RGNDATAHEADER rdh;
 char Buffer[1];
} RGNDATA,*PRGNDATA, *LPRGNDATA;


typedef struct tagGCP_RESULTSA {
 DWORD lStructSize;
 LPSTR lpOutString;
 UINT *lpOrder;
 INT *lpDx;
 INT *lpCaretPos;
 LPSTR lpClass;
 LPWSTR lpGlyphs;
 UINT nGlyphs;
 UINT nMaxFit;
} GCP_RESULTSA,*LPGCP_RESULTSA;
typedef struct tagGCP_RESULTSW {
 DWORD lStructSize;
 LPWSTR lpOutString;
 UINT *lpOrder;
 INT *lpDx;
 INT *lpCaretPos;
 LPWSTR lpClass;
 LPWSTR lpGlyphs;
 UINT nGlyphs;
 UINT nMaxFit;
} GCP_RESULTSW,*LPGCP_RESULTSW;
typedef struct _GLYPHMETRICS {
 UINT gmBlackBoxX;
 UINT gmBlackBoxY;
 POINT gmptGlyphOrigin;
 short gmCellIncX;
 short gmCellIncY;
} GLYPHMETRICS,*LPGLYPHMETRICS;
# 2174 "H:/CPP/wxdevcpp6.10/include/wingdi.h" 3
typedef struct tagKERNINGPAIR {
 WORD wFirst;
 WORD wSecond;
 int iKernAmount;
} KERNINGPAIR,*LPKERNINGPAIR;
typedef struct _FIXED {
 WORD fract;
 short value;
} FIXED;
typedef struct _MAT2 {
 FIXED eM11;
 FIXED eM12;
 FIXED eM21;
 FIXED eM22;
} MAT2,*LPMAT2;
typedef struct _OUTLINETEXTMETRICA {
 UINT otmSize;
 TEXTMETRICA otmTextMetrics;
 BYTE otmFiller;
 PANOSE otmPanoseNumber;
 UINT otmfsSelection;
 UINT otmfsType;
 int otmsCharSlopeRise;
 int otmsCharSlopeRun;
 int otmItalicAngle;
 UINT otmEMSquare;
 int otmAscent;
 int otmDescent;
 UINT otmLineGap;
 UINT otmsCapEmHeight;
 UINT otmsXHeight;
 RECT otmrcFontBox;
 int otmMacAscent;
 int otmMacDescent;
 UINT otmMacLineGap;
 UINT otmusMinimumPPEM;
 POINT otmptSubscriptSize;
 POINT otmptSubscriptOffset;
 POINT otmptSuperscriptSize;
 POINT otmptSuperscriptOffset;
 UINT otmsStrikeoutSize;
 int otmsStrikeoutPosition;
 int otmsUnderscoreSize;
 int otmsUnderscorePosition;
 PSTR otmpFamilyName;
 PSTR otmpFaceName;
 PSTR otmpStyleName;
 PSTR otmpFullName;
} OUTLINETEXTMETRICA,*POUTLINETEXTMETRICA,*LPOUTLINETEXTMETRICA;
typedef struct _OUTLINETEXTMETRICW {
 UINT otmSize;
 TEXTMETRICW otmTextMetrics;
 BYTE otmFiller;
 PANOSE otmPanoseNumber;
 UINT otmfsSelection;
 UINT otmfsType;
 int otmsCharSlopeRise;
 int otmsCharSlopeRun;
 int otmItalicAngle;
 UINT otmEMSquare;
 int otmAscent;
 int otmDescent;
 UINT otmLineGap;
 UINT otmsCapEmHeight;
 UINT otmsXHeight;
 RECT otmrcFontBox;
 int otmMacAscent;
 int otmMacDescent;
 UINT otmMacLineGap;
 UINT otmusMinimumPPEM;
 POINT otmptSubscriptSize;
 POINT otmptSubscriptOffset;
 POINT otmptSuperscriptSize;
 POINT otmptSuperscriptOffset;
 UINT otmsStrikeoutSize;
 int otmsStrikeoutPosition;
 int otmsUnderscoreSize;
 int otmsUnderscorePosition;
 PSTR otmpFamilyName;
 PSTR otmpFaceName;
 PSTR otmpStyleName;
 PSTR otmpFullName;
} OUTLINETEXTMETRICW,*POUTLINETEXTMETRICW,*LPOUTLINETEXTMETRICW;
typedef struct _RASTERIZER_STATUS {
 short nSize;
 short wFlags;
 short nLanguageID;
} RASTERIZER_STATUS,*LPRASTERIZER_STATUS;
typedef struct _POLYTEXTA {
 int x;
 int y;
 UINT n;
 LPCSTR lpstr;
 UINT uiFlags;
 RECT rcl;
 int *pdx;
} POLYTEXTA, *PPOLYTEXTA, *LPPOLYTEXTA;
typedef struct _POLYTEXTW {
 int x;
 int y;
 UINT n;
 LPCWSTR lpstr;
 UINT uiFlags;
 RECT rcl;
 int *pdx;
} POLYTEXTW, *PPOLYTEXTW, *LPPOLYTEXTW;
typedef struct tagPIXELFORMATDESCRIPTOR {
 WORD nSize;
 WORD nVersion;
 DWORD dwFlags;
 BYTE iPixelType;
 BYTE cColorBits;
 BYTE cRedBits;
 BYTE cRedShift;
 BYTE cGreenBits;
 BYTE cGreenShift;
 BYTE cBlueBits;
 BYTE cBlueShift;
 BYTE cAlphaBits;
 BYTE cAlphaShift;
 BYTE cAccumBits;
 BYTE cAccumRedBits;
 BYTE cAccumGreenBits;
 BYTE cAccumBlueBits;
 BYTE cAccumAlphaBits;
 BYTE cDepthBits;
 BYTE cStencilBits;
 BYTE cAuxBuffers;
 BYTE iLayerType;
 BYTE bReserved;
 DWORD dwLayerMask;
 DWORD dwVisibleMask;
 DWORD dwDamageMask;
} PIXELFORMATDESCRIPTOR,*PPIXELFORMATDESCRIPTOR,*LPPIXELFORMATDESCRIPTOR;
typedef struct tagMETAFILEPICT {
 LONG mm;
 LONG xExt;
 LONG yExt;
 HMETAFILE hMF;
} METAFILEPICT,*LPMETAFILEPICT;
typedef struct tagLOCALESIGNATURE {
 DWORD lsUsb[4];
 DWORD lsCsbDefault[2];
 DWORD lsCsbSupported[2];
} LOCALESIGNATURE,*PLOCALESIGNATURE,*LPLOCALESIGNATURE;
typedef LONG LCSTYPE;
#pragma pack(push,4)
typedef struct tagNEWTEXTMETRICA {
 LONG tmHeight;
 LONG tmAscent;
 LONG tmDescent;
 LONG tmInternalLeading;
 LONG tmExternalLeading;
 LONG tmAveCharWidth;
 LONG tmMaxCharWidth;
 LONG tmWeight;
 LONG tmOverhang;
 LONG tmDigitizedAspectX;
 LONG tmDigitizedAspectY;
 BYTE tmFirstChar;
 BYTE tmLastChar;
 BYTE tmDefaultChar;
 BYTE tmBreakChar;
 BYTE tmItalic;
 BYTE tmUnderlined;
 BYTE tmStruckOut;
 BYTE tmPitchAndFamily;
 BYTE tmCharSet;
 DWORD ntmFlags;
 UINT ntmSizeEM;
 UINT ntmCellHeight;
 UINT ntmAvgWidth;
} NEWTEXTMETRICA,*PNEWTEXTMETRICA,*LPNEWTEXTMETRICA;
typedef struct tagNEWTEXTMETRICW {
 LONG tmHeight;
 LONG tmAscent;
 LONG tmDescent;
 LONG tmInternalLeading;
 LONG tmExternalLeading;
 LONG tmAveCharWidth;
 LONG tmMaxCharWidth;
 LONG tmWeight;
 LONG tmOverhang;
 LONG tmDigitizedAspectX;
 LONG tmDigitizedAspectY;
 WCHAR tmFirstChar;
 WCHAR tmLastChar;
 WCHAR tmDefaultChar;
 WCHAR tmBreakChar;
 BYTE tmItalic;
 BYTE tmUnderlined;
 BYTE tmStruckOut;
 BYTE tmPitchAndFamily;
 BYTE tmCharSet;
 DWORD ntmFlags;
 UINT ntmSizeEM;
 UINT ntmCellHeight;
 UINT ntmAvgWidth;
} NEWTEXTMETRICW,*PNEWTEXTMETRICW,*LPNEWTEXTMETRICW;
#pragma pack(pop)
typedef struct tagNEWTEXTMETRICEXA {
 NEWTEXTMETRICA ntmTm;
 FONTSIGNATURE ntmFontSig;
} NEWTEXTMETRICEXA;
typedef struct tagNEWTEXTMETRICEXW {
 NEWTEXTMETRICW ntmTm;
 FONTSIGNATURE ntmFontSig;
} NEWTEXTMETRICEXW;
typedef struct tagPELARRAY {
 LONG paXCount;
 LONG paYCount;
 LONG paXExt;
 LONG paYExt;
 BYTE paRGBs;
} PELARRAY,*PPELARRAY,*LPPELARRAY;
typedef struct tagENUMLOGFONTA {
 LOGFONTA elfLogFont;
 BYTE elfFullName[64];
 BYTE elfStyle[32];
} ENUMLOGFONTA,*LPENUMLOGFONTA;
typedef struct tagENUMLOGFONTW {
 LOGFONTW elfLogFont;
 WCHAR elfFullName[64];
 WCHAR elfStyle[32];
} ENUMLOGFONTW,*LPENUMLOGFONTW;
typedef struct tagENUMLOGFONTEXA {
 LOGFONTA elfLogFont;
 BYTE elfFullName[64];
 BYTE elfStyle[32];
 BYTE elfScript[32];
} ENUMLOGFONTEXA,*LPENUMLOGFONTEXA;
typedef struct tagENUMLOGFONTEXW {
 LOGFONTW elfLogFont;
 WCHAR elfFullName[64];
 WCHAR elfStyle[32];
 WCHAR elfScript[32];
} ENUMLOGFONTEXW,*LPENUMLOGFONTEXW;
typedef struct tagPOINTFX {
 FIXED x;
 FIXED y;
} POINTFX,*LPPOINTFX;
typedef struct tagTTPOLYCURVE {
 WORD wType;
 WORD cpfx;
 POINTFX apfx[1];
} TTPOLYCURVE,*LPTTPOLYCURVE;
typedef struct tagTTPOLYGONHEADER {
 DWORD cb;
 DWORD dwType;
 POINTFX pfxStart;
} TTPOLYGONHEADER,*LPTTPOLYGONHEADER;
typedef struct _POINTFLOAT {
 FLOAT x;
 FLOAT y;
} POINTFLOAT,*PPOINTFLOAT;
typedef struct _GLYPHMETRICSFLOAT {
 FLOAT gmfBlackBoxX;
 FLOAT gmfBlackBoxY;
 POINTFLOAT gmfptGlyphOrigin;
 FLOAT gmfCellIncX;
 FLOAT gmfCellIncY;
} GLYPHMETRICSFLOAT,*PGLYPHMETRICSFLOAT,*LPGLYPHMETRICSFLOAT;
typedef struct tagLAYERPLANEDESCRIPTOR {
 WORD nSize;
 WORD nVersion;
 DWORD dwFlags;
 BYTE iPixelType;
 BYTE cColorBits;
 BYTE cRedBits;
 BYTE cRedShift;
 BYTE cGreenBits;
 BYTE cGreenShift;
 BYTE cBlueBits;
 BYTE cBlueShift;
 BYTE cAlphaBits;
 BYTE cAlphaShift;
 BYTE cAccumBits;
 BYTE cAccumRedBits;
 BYTE cAccumGreenBits;
 BYTE cAccumBlueBits;
 BYTE cAccumAlphaBits;
 BYTE cDepthBits;
 BYTE cStencilBits;
 BYTE cAuxBuffers;
 BYTE iLayerPlane;
 BYTE bReserved;
 COLORREF crTransparent;
} LAYERPLANEDESCRIPTOR,*PLAYERPLANEDESCRIPTOR,*LPLAYERPLANEDESCRIPTOR;
typedef struct _BLENDFUNCTION {
    BYTE BlendOp;
    BYTE BlendFlags;
    BYTE SourceConstantAlpha;
    BYTE AlphaFormat;
} BLENDFUNCTION,*PBLENDFUNCTION,*LPBLENDFUNCTION;

typedef struct _DESIGNVECTOR {
 DWORD dvReserved;
 DWORD dvNumAxes;
 LONG dvValues[16];
} DESIGNVECTOR, *PDESIGNVECTOR, *LPDESIGNVECTOR;
# 2486 "H:/CPP/wxdevcpp6.10/include/wingdi.h" 3
typedef USHORT COLOR16;
typedef struct _TRIVERTEX {
 LONG x;
 LONG y;
 COLOR16 Red;
 COLOR16 Green;
 COLOR16 Blue;
 COLOR16 Alpha;
} TRIVERTEX, *PTRIVERTEX, *LPTRIVERTEX;
typedef struct _GRADIENT_TRIANGLE {
 ULONG Vertex1;
 ULONG Vertex2;
 ULONG Vertex3;
} GRADIENT_TRIANGLE,*PGRADIENT_TRIANGLE,*LPGRADIENT_TRIANGLE;
typedef struct _GRADIENT_RECT {
 ULONG UpperLeft;
 ULONG LowerRight;
}GRADIENT_RECT,*PGRADIENT_RECT,*LPGRADIENT_RECT;
typedef struct _DISPLAY_DEVICEA {
  DWORD cb;
  CHAR DeviceName[32];
  CHAR DeviceString[128];
  DWORD StateFlags;
  CHAR DeviceID[128];
  CHAR DeviceKey[128];
} DISPLAY_DEVICEA, *PDISPLAY_DEVICEA, *LPDISPLAY_DEVICEA;
typedef struct _DISPLAY_DEVICEW {
  DWORD cb;
  WCHAR DeviceName[32];
  WCHAR DeviceString[128];
  DWORD StateFlags;
  WCHAR DeviceID[128];
  WCHAR DeviceKey[128];
} DISPLAY_DEVICEW, *PDISPLAY_DEVICEW, *LPDISPLAY_DEVICEW;

typedef BOOL (__attribute__((__stdcall__)) *ABORTPROC)(HDC,int);
typedef int (__attribute__((__stdcall__)) *MFENUMPROC)(HDC,HANDLETABLE*,METARECORD*,int,LPARAM);
typedef int (__attribute__((__stdcall__)) *ENHMFENUMPROC)(HDC,HANDLETABLE*,ENHMETARECORD*,int,LPARAM);
typedef int (__attribute__((__stdcall__)) *OLDFONTENUMPROCA)(const LOGFONTA*,const TEXTMETRICA*,DWORD,LPARAM);
typedef int (__attribute__((__stdcall__)) *OLDFONTENUMPROCW)(const LOGFONTW*,const TEXTMETRICW*,DWORD,LPARAM);
typedef OLDFONTENUMPROCA FONTENUMPROCA;
typedef OLDFONTENUMPROCW FONTENUMPROCW;
typedef int (__attribute__((__stdcall__)) *ICMENUMPROCA)(LPSTR,LPARAM);
typedef int (__attribute__((__stdcall__)) *ICMENUMPROCW)(LPWSTR,LPARAM);
typedef void (__attribute__((__stdcall__)) *GOBJENUMPROC)(LPVOID,LPARAM);
typedef void (__attribute__((__stdcall__)) *LINEDDAPROC)(int,int,LPARAM);
typedef UINT (__attribute__((__stdcall__)) *LPFNDEVMODE)(HWND,HMODULE,LPDEVMODEA,LPSTR,LPSTR,LPDEVMODEA,LPSTR,UINT);
typedef DWORD (__attribute__((__stdcall__)) *LPFNDEVCAPS)(LPSTR,LPSTR,UINT,LPSTR,LPDEVMODEA);
# 2552 "H:/CPP/wxdevcpp6.10/include/wingdi.h" 3
 int __attribute__((__stdcall__)) AbortDoc(HDC);
 BOOL __attribute__((__stdcall__)) AbortPath(HDC);
 int __attribute__((__stdcall__)) AddFontResourceA(LPCSTR);
 int __attribute__((__stdcall__)) AddFontResourceW(LPCWSTR);





 BOOL __attribute__((__stdcall__)) AngleArc(HDC,int,int,DWORD,FLOAT,FLOAT);
 BOOL __attribute__((__stdcall__)) AnimatePalette(HPALETTE,UINT,UINT,const PALETTEENTRY*);
 BOOL __attribute__((__stdcall__)) Arc(HDC,int,int,int,int,int,int,int,int);
 BOOL __attribute__((__stdcall__)) ArcTo(HDC,int,int,int,int,int,int,int,int);
 BOOL __attribute__((__stdcall__)) BeginPath(HDC);
 BOOL __attribute__((__stdcall__)) BitBlt(HDC,int,int,int,int,HDC,int,int,DWORD);
 BOOL __attribute__((__stdcall__)) CancelDC(HDC);
 BOOL __attribute__((__stdcall__)) CheckColorsInGamut(HDC,PVOID,PVOID,DWORD);
 BOOL __attribute__((__stdcall__)) Chord(HDC,int,int,int,int,int,int,int,int);
 int __attribute__((__stdcall__)) ChoosePixelFormat(HDC,const PIXELFORMATDESCRIPTOR*);
 HENHMETAFILE __attribute__((__stdcall__)) CloseEnhMetaFile(HDC);
 BOOL __attribute__((__stdcall__)) CloseFigure(HDC);
 HMETAFILE __attribute__((__stdcall__)) CloseMetaFile(HDC);
 BOOL __attribute__((__stdcall__)) ColorMatchToTarget(HDC,HDC,DWORD);
 int __attribute__((__stdcall__)) CombineRgn(HRGN,HRGN,HRGN,int);
 BOOL __attribute__((__stdcall__)) CombineTransform(LPXFORM,const XFORM*,const XFORM*);
 HENHMETAFILE __attribute__((__stdcall__)) CopyEnhMetaFileA(HENHMETAFILE,LPCSTR);
 HENHMETAFILE __attribute__((__stdcall__)) CopyEnhMetaFileW(HENHMETAFILE,LPCWSTR);
 HMETAFILE __attribute__((__stdcall__)) CopyMetaFileA(HMETAFILE,LPCSTR);
 HMETAFILE __attribute__((__stdcall__)) CopyMetaFileW(HMETAFILE,LPCWSTR);
 HBITMAP __attribute__((__stdcall__)) CreateBitmap(int,int,UINT,UINT,PCVOID);
 HBITMAP __attribute__((__stdcall__)) CreateBitmapIndirect(const BITMAP*);
 HBRUSH __attribute__((__stdcall__)) CreateBrushIndirect(const LOGBRUSH*);
 HCOLORSPACE __attribute__((__stdcall__)) CreateColorSpaceA(LPLOGCOLORSPACEA);
 HCOLORSPACE __attribute__((__stdcall__)) CreateColorSpaceW(LPLOGCOLORSPACEW);
 HBITMAP __attribute__((__stdcall__)) CreateCompatibleBitmap(HDC,int,int);
 HDC __attribute__((__stdcall__)) CreateCompatibleDC(HDC);
 HDC __attribute__((__stdcall__)) CreateDCA(LPCSTR,LPCSTR,LPCSTR,const DEVMODEA*);
 HDC __attribute__((__stdcall__)) CreateDCW(LPCWSTR,LPCWSTR,LPCWSTR,const DEVMODEW*);
 HBITMAP __attribute__((__stdcall__)) CreateDIBitmap(HDC,const BITMAPINFOHEADER*,DWORD,PCVOID,const BITMAPINFO*,UINT);
 HBRUSH __attribute__((__stdcall__)) CreateDIBPatternBrush(HGLOBAL,UINT);
 HBRUSH __attribute__((__stdcall__)) CreateDIBPatternBrushPt(PCVOID,UINT);
 HBITMAP __attribute__((__stdcall__)) CreateDIBSection(HDC,const BITMAPINFO*,UINT,void**,HANDLE,DWORD);
 HBITMAP __attribute__((__stdcall__)) CreateDiscardableBitmap(HDC,int,int);
 HRGN __attribute__((__stdcall__)) CreateEllipticRgn(int,int,int,int);
 HRGN __attribute__((__stdcall__)) CreateEllipticRgnIndirect(LPCRECT);
 HDC __attribute__((__stdcall__)) CreateEnhMetaFileA(HDC,LPCSTR,LPCRECT,LPCSTR);
 HDC __attribute__((__stdcall__)) CreateEnhMetaFileW(HDC,LPCWSTR,LPCRECT,LPCWSTR);
 HFONT __attribute__((__stdcall__)) CreateFontA(int,int,int,int,int,DWORD,DWORD,DWORD,DWORD,DWORD,DWORD,DWORD,DWORD,LPCSTR);
 HFONT __attribute__((__stdcall__)) CreateFontW(int,int,int,int,int,DWORD,DWORD,DWORD,DWORD,DWORD,DWORD,DWORD,DWORD,LPCWSTR);
 HFONT __attribute__((__stdcall__)) CreateFontIndirectA(const LOGFONTA*);
 HFONT __attribute__((__stdcall__)) CreateFontIndirectW(const LOGFONTW*);
 HPALETTE __attribute__((__stdcall__)) CreateHalftonePalette(HDC);
 HBRUSH __attribute__((__stdcall__)) CreateHatchBrush(int,COLORREF);
 HDC __attribute__((__stdcall__)) CreateICA(LPCSTR,LPCSTR,LPCSTR,const DEVMODEA*);
 HDC __attribute__((__stdcall__)) CreateICW(LPCWSTR,LPCWSTR,LPCWSTR,const DEVMODEW*);
 HDC __attribute__((__stdcall__)) CreateMetaFileA(LPCSTR);
 HDC __attribute__((__stdcall__)) CreateMetaFileW(LPCWSTR);
 HPALETTE __attribute__((__stdcall__)) CreatePalette(const LOGPALETTE*);
 HBRUSH __attribute__((__stdcall__)) CreatePatternBrush(HBITMAP);
 HPEN __attribute__((__stdcall__)) CreatePen(int,int,COLORREF);
 HPEN __attribute__((__stdcall__)) CreatePenIndirect(const LOGPEN*);
 HRGN __attribute__((__stdcall__)) CreatePolygonRgn(const POINT*,int,int);
 HRGN __attribute__((__stdcall__)) CreatePolyPolygonRgn(const POINT*,const INT*,int,int);
 HRGN __attribute__((__stdcall__)) CreateRectRgn(int,int,int,int);
 HRGN __attribute__((__stdcall__)) CreateRectRgnIndirect(LPCRECT);
 HRGN __attribute__((__stdcall__)) CreateRoundRectRgn(int,int,int,int,int,int);
 BOOL __attribute__((__stdcall__)) CreateScalableFontResourceA(DWORD,LPCSTR,LPCSTR,LPCSTR);
 BOOL __attribute__((__stdcall__)) CreateScalableFontResourceW(DWORD,LPCWSTR,LPCWSTR,LPCWSTR);
 HBRUSH __attribute__((__stdcall__)) CreateSolidBrush(COLORREF);
 BOOL __attribute__((__stdcall__)) DeleteColorSpace(HCOLORSPACE);
 BOOL __attribute__((__stdcall__)) DeleteDC(HDC);
 BOOL __attribute__((__stdcall__)) DeleteEnhMetaFile(HENHMETAFILE);
 BOOL __attribute__((__stdcall__)) DeleteMetaFile(HMETAFILE);
 BOOL __attribute__((__stdcall__)) DeleteObject(HGDIOBJ);
 int __attribute__((__stdcall__)) DescribePixelFormat(HDC,int,UINT,LPPIXELFORMATDESCRIPTOR);
 DWORD __attribute__((__stdcall__)) DeviceCapabilitiesA(LPCSTR,LPCSTR,WORD,LPSTR,const DEVMODEA*);
 DWORD __attribute__((__stdcall__)) DeviceCapabilitiesW(LPCWSTR,LPCWSTR,WORD,LPWSTR,const DEVMODEW*);
 BOOL __attribute__((__stdcall__)) DPtoLP(HDC,LPPOINT,int);
 int __attribute__((__stdcall__)) DrawEscape(HDC,int,int,LPCSTR);
 BOOL __attribute__((__stdcall__)) Ellipse(HDC,int,int,int,int);
 int __attribute__((__stdcall__)) EndDoc(HDC);
 int __attribute__((__stdcall__)) EndPage(HDC);
 BOOL __attribute__((__stdcall__)) EndPath(HDC);
 BOOL __attribute__((__stdcall__)) EnumEnhMetaFile(HDC,HENHMETAFILE,ENHMFENUMPROC,PVOID,LPCRECT);
 int __attribute__((__stdcall__)) EnumFontFamiliesA(HDC,LPCSTR,FONTENUMPROCA,LPARAM);
 int __attribute__((__stdcall__)) EnumFontFamiliesW(HDC,LPCWSTR,FONTENUMPROCW,LPARAM);
 int __attribute__((__stdcall__)) EnumFontFamiliesExA(HDC,PLOGFONTA,FONTENUMPROCA,LPARAM,DWORD);
 int __attribute__((__stdcall__)) EnumFontFamiliesExW(HDC,PLOGFONTW,FONTENUMPROCW,LPARAM,DWORD);
 int __attribute__((__stdcall__)) EnumFontsA(HDC,LPCSTR,FONTENUMPROCA,LPARAM);
 int __attribute__((__stdcall__)) EnumFontsW(HDC,LPCWSTR,FONTENUMPROCW,LPARAM);
 int __attribute__((__stdcall__)) EnumICMProfilesA(HDC,ICMENUMPROCA,LPARAM);
 int __attribute__((__stdcall__)) EnumICMProfilesW(HDC,ICMENUMPROCW,LPARAM);
 BOOL __attribute__((__stdcall__)) EnumMetaFile(HDC,HMETAFILE,MFENUMPROC,LPARAM);
 int __attribute__((__stdcall__)) EnumObjects(HDC,int,GOBJENUMPROC,LPARAM);
 BOOL __attribute__((__stdcall__)) EqualRgn(HRGN,HRGN);
 int __attribute__((__stdcall__)) Escape(HDC,int,int,LPCSTR,PVOID);
 int __attribute__((__stdcall__)) ExcludeClipRect(HDC,int,int,int,int);
 int __attribute__((__stdcall__)) ExcludeUpdateRgn(HDC,HWND);
 HPEN __attribute__((__stdcall__)) ExtCreatePen(DWORD,DWORD,const LOGBRUSH*,DWORD,const DWORD*);
 HRGN __attribute__((__stdcall__)) ExtCreateRegion(const XFORM*,DWORD,const RGNDATA*);
 int __attribute__((__stdcall__)) ExtEscape(HDC,int,int,LPCSTR,int,LPSTR);
 BOOL __attribute__((__stdcall__)) ExtFloodFill(HDC,int,int,COLORREF,UINT);
 int __attribute__((__stdcall__)) ExtSelectClipRgn(HDC,HRGN,int);
 BOOL __attribute__((__stdcall__)) ExtTextOutA(HDC,int,int,UINT,LPCRECT,LPCSTR,UINT,const INT*);
 BOOL __attribute__((__stdcall__)) ExtTextOutW(HDC,int,int,UINT,LPCRECT,LPCWSTR,UINT,const INT*);
 BOOL __attribute__((__stdcall__)) FillPath(HDC);
 int __attribute__((__stdcall__)) FillRect(HDC,LPCRECT,HBRUSH);
 int __attribute__((__stdcall__)) FillRgn(HDC,HRGN,HBRUSH);
 BOOL __attribute__((__stdcall__)) FixBrushOrgEx(HDC,int,int,LPPOINT);
 BOOL __attribute__((__stdcall__)) FlattenPath(HDC);
 BOOL __attribute__((__stdcall__)) FloodFill(HDC,int,int,COLORREF);
 BOOL __attribute__((__stdcall__)) GdiComment(HDC,UINT,const BYTE*);
 BOOL __attribute__((__stdcall__)) GdiFlush(void);
 DWORD __attribute__((__stdcall__)) GdiGetBatchLimit(void);
 DWORD __attribute__((__stdcall__)) GdiSetBatchLimit(DWORD);
 int __attribute__((__stdcall__)) GetArcDirection(HDC);
 BOOL __attribute__((__stdcall__)) GetAspectRatioFilterEx(HDC,LPSIZE);
 LONG __attribute__((__stdcall__)) GetBitmapBits(HBITMAP,LONG,PVOID);
 BOOL __attribute__((__stdcall__)) GetBitmapDimensionEx(HBITMAP,LPSIZE);
 COLORREF __attribute__((__stdcall__)) GetBkColor(HDC);
 int __attribute__((__stdcall__)) GetBkMode(HDC);
 UINT __attribute__((__stdcall__)) GetBoundsRect(HDC,LPRECT,UINT);
 BOOL __attribute__((__stdcall__)) GetBrushOrgEx(HDC,LPPOINT);
 BOOL __attribute__((__stdcall__)) GetCharABCWidthsA(HDC,UINT,UINT,LPABC);
 BOOL __attribute__((__stdcall__)) GetCharABCWidthsW(HDC,UINT,UINT,LPABC);
 BOOL __attribute__((__stdcall__)) GetCharABCWidthsFloatA(HDC,UINT,UINT,LPABCFLOAT);
 BOOL __attribute__((__stdcall__)) GetCharABCWidthsFloatW(HDC,UINT,UINT,LPABCFLOAT);
 DWORD __attribute__((__stdcall__)) GetCharacterPlacementA(HDC,LPCSTR,int,int,LPGCP_RESULTSA,DWORD);
 DWORD __attribute__((__stdcall__)) GetCharacterPlacementW(HDC,LPCWSTR,int,int,LPGCP_RESULTSW,DWORD);
 BOOL __attribute__((__stdcall__)) GetCharWidth32A(HDC,UINT,UINT,LPINT);
 BOOL __attribute__((__stdcall__)) GetCharWidth32W(HDC,UINT,UINT,LPINT);
 BOOL __attribute__((__stdcall__)) GetCharWidthA(HDC,UINT,UINT,LPINT);
 BOOL __attribute__((__stdcall__)) GetCharWidthW(HDC,UINT,UINT,LPINT);
 BOOL __attribute__((__stdcall__)) GetCharWidthFloatA(HDC,UINT,UINT,PFLOAT);
 BOOL __attribute__((__stdcall__)) GetCharWidthFloatW(HDC,UINT,UINT,PFLOAT);
 int __attribute__((__stdcall__)) GetClipBox(HDC,LPRECT);
 int __attribute__((__stdcall__)) GetClipRgn(HDC,HRGN);
 BOOL __attribute__((__stdcall__)) GetColorAdjustment(HDC,LPCOLORADJUSTMENT);
 HANDLE __attribute__((__stdcall__)) GetColorSpace(HDC);
 HGDIOBJ __attribute__((__stdcall__)) GetCurrentObject(HDC,UINT);
 BOOL __attribute__((__stdcall__)) GetCurrentPositionEx(HDC,LPPOINT);
 HCURSOR __attribute__((__stdcall__)) GetCursor(void);
 BOOL __attribute__((__stdcall__)) GetDCOrgEx(HDC,LPPOINT);
 int __attribute__((__stdcall__)) GetDeviceCaps(HDC,int);
 BOOL __attribute__((__stdcall__)) GetDeviceGammaRamp(HDC,PVOID);
 UINT __attribute__((__stdcall__)) GetDIBColorTable(HDC,UINT,UINT,RGBQUAD*);
 int __attribute__((__stdcall__)) GetDIBits(HDC,HBITMAP,UINT,UINT,PVOID,LPBITMAPINFO,UINT);
 HENHMETAFILE __attribute__((__stdcall__)) GetEnhMetaFileA(LPCSTR);
 HENHMETAFILE __attribute__((__stdcall__)) GetEnhMetaFileW(LPCWSTR);
 UINT __attribute__((__stdcall__)) GetEnhMetaFileBits(HENHMETAFILE,UINT,LPBYTE);
 UINT __attribute__((__stdcall__)) GetEnhMetaFileDescriptionA(HENHMETAFILE,UINT,LPSTR);
 UINT __attribute__((__stdcall__)) GetEnhMetaFileDescriptionW(HENHMETAFILE,UINT,LPWSTR);
 UINT __attribute__((__stdcall__)) GetEnhMetaFileHeader(HENHMETAFILE,UINT,LPENHMETAHEADER);
 UINT __attribute__((__stdcall__)) GetEnhMetaFilePaletteEntries(HENHMETAFILE,UINT,LPPALETTEENTRY);
 UINT __attribute__((__stdcall__)) GetEnhMetaFilePixelFormat(HENHMETAFILE,DWORD,const PIXELFORMATDESCRIPTOR*);
 DWORD __attribute__((__stdcall__)) GetFontData(HDC,DWORD,DWORD,PVOID,DWORD);
 DWORD __attribute__((__stdcall__)) GetFontLanguageInfo(HDC);
 DWORD __attribute__((__stdcall__)) GetGlyphOutlineA(HDC,UINT,UINT,LPGLYPHMETRICS,DWORD,PVOID,const MAT2*);
 DWORD __attribute__((__stdcall__)) GetGlyphOutlineW(HDC,UINT,UINT,LPGLYPHMETRICS,DWORD,PVOID,const MAT2*);
 int __attribute__((__stdcall__)) GetGraphicsMode(HDC);
 BOOL __attribute__((__stdcall__)) GetICMProfileA(HDC,LPDWORD,LPSTR);
 BOOL __attribute__((__stdcall__)) GetICMProfileW(HDC,LPDWORD,LPWSTR);
 DWORD __attribute__((__stdcall__)) GetKerningPairsA(HDC,DWORD,LPKERNINGPAIR);
 DWORD __attribute__((__stdcall__)) GetKerningPairsW(HDC,DWORD,LPKERNINGPAIR);
 BOOL __attribute__((__stdcall__)) GetLogColorSpaceA(HCOLORSPACE,LPLOGCOLORSPACEA,DWORD);
 BOOL __attribute__((__stdcall__)) GetLogColorSpaceW(HCOLORSPACE,LPLOGCOLORSPACEW,DWORD);
 int __attribute__((__stdcall__)) GetMapMode(HDC);
 HMETAFILE __attribute__((__stdcall__)) GetMetaFileA(LPCSTR);
 HMETAFILE __attribute__((__stdcall__)) GetMetaFileW(LPCWSTR);
 UINT __attribute__((__stdcall__)) GetMetaFileBitsEx(HMETAFILE,UINT,PVOID);
 int __attribute__((__stdcall__)) GetMetaRgn(HDC,HRGN);
 BOOL __attribute__((__stdcall__)) GetMiterLimit(HDC,PFLOAT);
 COLORREF __attribute__((__stdcall__)) GetNearestColor(HDC,COLORREF);
 UINT __attribute__((__stdcall__)) GetNearestPaletteIndex(HPALETTE,COLORREF);
 int __attribute__((__stdcall__)) GetObjectA(HGDIOBJ,int,PVOID);
 int __attribute__((__stdcall__)) GetObjectW(HGDIOBJ,int,PVOID);
 DWORD __attribute__((__stdcall__)) GetObjectType(HGDIOBJ);
 UINT __attribute__((__stdcall__)) GetOutlineTextMetricsA(HDC,UINT,LPOUTLINETEXTMETRICA);
 UINT __attribute__((__stdcall__)) GetOutlineTextMetricsW(HDC,UINT,LPOUTLINETEXTMETRICW);
 UINT __attribute__((__stdcall__)) GetPaletteEntries(HPALETTE,UINT,UINT,LPPALETTEENTRY);
 int __attribute__((__stdcall__)) GetPath(HDC,LPPOINT,PBYTE,int);
 COLORREF __attribute__((__stdcall__)) GetPixel(HDC,int,int);
 int __attribute__((__stdcall__)) GetPixelFormat(HDC);
 int __attribute__((__stdcall__)) GetPolyFillMode(HDC);
 BOOL __attribute__((__stdcall__)) GetRasterizerCaps(LPRASTERIZER_STATUS,UINT);
 int __attribute__((__stdcall__)) GetRandomRgn (HDC,HRGN,INT);
 DWORD __attribute__((__stdcall__)) GetRegionData(HRGN,DWORD,LPRGNDATA);
 int __attribute__((__stdcall__)) GetRgnBox(HRGN,LPRECT);
 int __attribute__((__stdcall__)) GetROP2(HDC);
 HGDIOBJ __attribute__((__stdcall__)) GetStockObject(int);
 int __attribute__((__stdcall__)) GetStretchBltMode(HDC);
 UINT __attribute__((__stdcall__)) GetSystemPaletteEntries(HDC,UINT,UINT,LPPALETTEENTRY);
 UINT __attribute__((__stdcall__)) GetSystemPaletteUse(HDC);
 UINT __attribute__((__stdcall__)) GetTextAlign(HDC);
 int __attribute__((__stdcall__)) GetTextCharacterExtra(HDC);
 int __attribute__((__stdcall__)) GetTextCharset(HDC);
 int __attribute__((__stdcall__)) GetTextCharsetInfo(HDC,LPFONTSIGNATURE,DWORD);
 COLORREF __attribute__((__stdcall__)) GetTextColor(HDC);
 BOOL __attribute__((__stdcall__)) GetTextExtentExPointA(HDC,LPCSTR,int,int,LPINT,LPINT,LPSIZE);
 BOOL __attribute__((__stdcall__)) GetTextExtentExPointW( HDC,LPCWSTR,int,int,LPINT,LPINT,LPSIZE );
 BOOL __attribute__((__stdcall__)) GetTextExtentPointA(HDC,LPCSTR,int,LPSIZE);
 BOOL __attribute__((__stdcall__)) GetTextExtentPointW(HDC,LPCWSTR,int,LPSIZE);
 BOOL __attribute__((__stdcall__)) GetTextExtentPoint32A(HDC,LPCSTR,int,LPSIZE);
 BOOL __attribute__((__stdcall__)) GetTextExtentPoint32W( HDC,LPCWSTR,int,LPSIZE);
 int __attribute__((__stdcall__)) GetTextFaceA(HDC,int,LPSTR);
 int __attribute__((__stdcall__)) GetTextFaceW(HDC,int,LPWSTR);
 BOOL __attribute__((__stdcall__)) GetTextMetricsA(HDC,LPTEXTMETRICA);
 BOOL __attribute__((__stdcall__)) GetTextMetricsW(HDC,LPTEXTMETRICW);
 BOOL __attribute__((__stdcall__)) GetViewportExtEx(HDC,LPSIZE);
 BOOL __attribute__((__stdcall__)) GetViewportOrgEx(HDC,LPPOINT);
 BOOL __attribute__((__stdcall__)) GetWindowExtEx(HDC,LPSIZE);
 BOOL __attribute__((__stdcall__)) GetWindowOrgEx(HDC,LPPOINT);
 UINT __attribute__((__stdcall__)) GetWinMetaFileBits(HENHMETAFILE,UINT,LPBYTE,INT,HDC);
 BOOL __attribute__((__stdcall__)) GetWorldTransform(HDC,LPXFORM);
 int __attribute__((__stdcall__)) IntersectClipRect(HDC,int,int,int,int);
 BOOL __attribute__((__stdcall__)) InvertRgn(HDC,HRGN);
 BOOL __attribute__((__stdcall__)) LineDDA(int,int,int,int,LINEDDAPROC,LPARAM);
 BOOL __attribute__((__stdcall__)) LineTo(HDC,int,int);
 BOOL __attribute__((__stdcall__)) LPtoDP(HDC,LPPOINT,int);
 BOOL __attribute__((__stdcall__)) MaskBlt(HDC,int,int,int,int,HDC,int,int,HBITMAP,int,int,DWORD);
 BOOL __attribute__((__stdcall__)) ModifyWorldTransform(HDC,const XFORM*,DWORD);
 BOOL __attribute__((__stdcall__)) MoveToEx(HDC,int,int,LPPOINT);
 int __attribute__((__stdcall__)) OffsetClipRgn(HDC,int,int);
 int __attribute__((__stdcall__)) OffsetRgn(HRGN,int,int);
 BOOL __attribute__((__stdcall__)) OffsetViewportOrgEx(HDC,int,int,LPPOINT);
 BOOL __attribute__((__stdcall__)) OffsetWindowOrgEx(HDC,int,int,LPPOINT);
 BOOL __attribute__((__stdcall__)) PaintRgn(HDC,HRGN);
 BOOL __attribute__((__stdcall__)) PatBlt(HDC,int,int,int,int,DWORD);
 HRGN __attribute__((__stdcall__)) PathToRegion(HDC);
 BOOL __attribute__((__stdcall__)) Pie(HDC,int,int,int,int,int,int,int,int);
 BOOL __attribute__((__stdcall__)) PlayEnhMetaFile(HDC,HENHMETAFILE,LPCRECT);
 BOOL __attribute__((__stdcall__)) PlayEnhMetaFileRecord(HDC,LPHANDLETABLE,const ENHMETARECORD*,UINT);
 BOOL __attribute__((__stdcall__)) PlayMetaFile(HDC,HMETAFILE);
 BOOL __attribute__((__stdcall__)) PlayMetaFileRecord(HDC,LPHANDLETABLE,LPMETARECORD,UINT);
 BOOL __attribute__((__stdcall__)) PlgBlt(HDC,const POINT*,HDC,int,int,int,int,HBITMAP,int,int);
 BOOL __attribute__((__stdcall__)) PolyBezier(HDC,const POINT*,DWORD);
 BOOL __attribute__((__stdcall__)) PolyBezierTo(HDC,const POINT*,DWORD);
 BOOL __attribute__((__stdcall__)) PolyDraw(HDC,const POINT*,const BYTE*,int);
 BOOL __attribute__((__stdcall__)) Polygon(HDC,const POINT*,int);
 BOOL __attribute__((__stdcall__)) Polyline(HDC,const POINT*,int);
 BOOL __attribute__((__stdcall__)) PolylineTo(HDC,const POINT*,DWORD);
 BOOL __attribute__((__stdcall__)) PolyPolygon(HDC,const POINT*,const INT*,int);
 BOOL __attribute__((__stdcall__)) PolyPolyline(HDC,const POINT*,const DWORD*,DWORD);
 BOOL __attribute__((__stdcall__)) PolyTextOutA(HDC,const POLYTEXTA*,int);
 BOOL __attribute__((__stdcall__)) PolyTextOutW(HDC,const POLYTEXTW*,int);
 BOOL __attribute__((__stdcall__)) PtInRegion(HRGN,int,int);
 BOOL __attribute__((__stdcall__)) PtVisible(HDC,int,int);
 UINT __attribute__((__stdcall__)) RealizePalette(HDC);
 BOOL __attribute__((__stdcall__)) Rectangle(HDC,int,int,int,int);
 BOOL __attribute__((__stdcall__)) RectInRegion(HRGN,LPCRECT);
 BOOL __attribute__((__stdcall__)) RectVisible(HDC,LPCRECT);
 BOOL __attribute__((__stdcall__)) RemoveFontResourceA(LPCSTR);
 BOOL __attribute__((__stdcall__)) RemoveFontResourceW(LPCWSTR);





 HDC __attribute__((__stdcall__)) ResetDCA(HDC,const DEVMODEA*);
 HDC __attribute__((__stdcall__)) ResetDCW(HDC,const DEVMODEW*);
 BOOL __attribute__((__stdcall__)) ResizePalette(HPALETTE,UINT);
 BOOL __attribute__((__stdcall__)) RestoreDC(HDC,int);
 BOOL __attribute__((__stdcall__)) RoundRect(HDC,int,int,int,int,int,int);
 int __attribute__((__stdcall__)) SaveDC(HDC);
 BOOL __attribute__((__stdcall__)) ScaleViewportExtEx(HDC,int,int,int,int,LPSIZE);
 BOOL __attribute__((__stdcall__)) ScaleWindowExtEx(HDC,int,int,int,int,LPSIZE);
 BOOL __attribute__((__stdcall__)) SelectClipPath(HDC,int);
 int __attribute__((__stdcall__)) SelectClipRgn(HDC,HRGN);
 HGDIOBJ __attribute__((__stdcall__)) SelectObject(HDC,HGDIOBJ);
 HPALETTE __attribute__((__stdcall__)) SelectPalette(HDC,HPALETTE,BOOL);
 int __attribute__((__stdcall__)) SetAbortProc(HDC,ABORTPROC);
 int __attribute__((__stdcall__)) SetArcDirection(HDC,int);
 LONG __attribute__((__stdcall__)) SetBitmapBits(HBITMAP,DWORD,PCVOID);
 BOOL __attribute__((__stdcall__)) SetBitmapDimensionEx(HBITMAP,int,int,LPSIZE);
 COLORREF __attribute__((__stdcall__)) SetBkColor(HDC,COLORREF);
 int __attribute__((__stdcall__)) SetBkMode(HDC,int);
 UINT __attribute__((__stdcall__)) SetBoundsRect(HDC,LPCRECT,UINT);
 BOOL __attribute__((__stdcall__)) SetBrushOrgEx(HDC,int,int,LPPOINT);
 BOOL __attribute__((__stdcall__)) SetColorAdjustment(HDC,const COLORADJUSTMENT*);
 BOOL __attribute__((__stdcall__)) SetColorSpace(HDC,HCOLORSPACE);




 BOOL __attribute__((__stdcall__)) SetDeviceGammaRamp(HDC,PVOID);
 UINT __attribute__((__stdcall__)) SetDIBColorTable(HDC,UINT,UINT,const RGBQUAD*);
 int __attribute__((__stdcall__)) SetDIBits(HDC,HBITMAP,UINT,UINT,PCVOID,const BITMAPINFO*,UINT);
 int __attribute__((__stdcall__)) SetDIBitsToDevice(HDC,int,int,DWORD,DWORD,int,int,UINT,UINT,PCVOID,const BITMAPINFO*,UINT);
 HENHMETAFILE __attribute__((__stdcall__)) SetEnhMetaFileBits(UINT,const BYTE*);
 int __attribute__((__stdcall__)) SetGraphicsMode(HDC,int);
 int __attribute__((__stdcall__)) SetICMMode(HDC,int);
 BOOL __attribute__((__stdcall__)) SetICMProfileA(HDC,LPSTR);
 BOOL __attribute__((__stdcall__)) SetICMProfileW(HDC,LPWSTR);
 int __attribute__((__stdcall__)) SetMapMode(HDC,int);
 DWORD __attribute__((__stdcall__)) SetMapperFlags(HDC,DWORD);
 HMETAFILE __attribute__((__stdcall__)) SetMetaFileBitsEx(UINT,const BYTE *);
 int __attribute__((__stdcall__)) SetMetaRgn(HDC);
 BOOL __attribute__((__stdcall__)) SetMiterLimit(HDC,FLOAT,PFLOAT);
 UINT __attribute__((__stdcall__)) SetPaletteEntries(HPALETTE,UINT,UINT,const PALETTEENTRY*);
 COLORREF __attribute__((__stdcall__)) SetPixel(HDC,int,int,COLORREF);
 BOOL __attribute__((__stdcall__)) SetPixelFormat(HDC,int,const PIXELFORMATDESCRIPTOR*);
 BOOL __attribute__((__stdcall__)) SetPixelV(HDC,int,int,COLORREF);
 int __attribute__((__stdcall__)) SetPolyFillMode(HDC,int);
 BOOL __attribute__((__stdcall__)) SetRectRgn(HRGN,int,int,int,int);
 int __attribute__((__stdcall__)) SetROP2(HDC,int);
 int __attribute__((__stdcall__)) SetStretchBltMode(HDC,int);
 UINT __attribute__((__stdcall__)) SetSystemPaletteUse(HDC,UINT);
 UINT __attribute__((__stdcall__)) SetTextAlign(HDC,UINT);
 int __attribute__((__stdcall__)) SetTextCharacterExtra(HDC,int);
 COLORREF __attribute__((__stdcall__)) SetTextColor(HDC,COLORREF);
 BOOL __attribute__((__stdcall__)) SetTextJustification(HDC,int,int);
 BOOL __attribute__((__stdcall__)) SetViewportExtEx(HDC,int,int,LPSIZE);
 BOOL __attribute__((__stdcall__)) SetViewportOrgEx(HDC,int,int,LPPOINT);
 BOOL __attribute__((__stdcall__)) SetWindowExtEx(HDC,int,int,LPSIZE);
 BOOL __attribute__((__stdcall__)) SetWindowOrgEx(HDC,int,int,LPPOINT);
 HENHMETAFILE __attribute__((__stdcall__)) SetWinMetaFileBits(UINT,const BYTE*,HDC,const METAFILEPICT*);
 BOOL __attribute__((__stdcall__)) SetWorldTransform(HDC,const XFORM *);
 int __attribute__((__stdcall__)) StartDocA(HDC,const DOCINFOA*);
 int __attribute__((__stdcall__)) StartDocW(HDC,const DOCINFOW*);
 int __attribute__((__stdcall__)) StartPage(HDC);
 BOOL __attribute__((__stdcall__)) StretchBlt(HDC,int,int,int,int,HDC,int,int,int,int,DWORD);
 int __attribute__((__stdcall__)) StretchDIBits(HDC,int,int,int,int,int,int,int,int,const void *,const BITMAPINFO *,UINT,DWORD);
 BOOL __attribute__((__stdcall__)) StrokeAndFillPath(HDC);
 BOOL __attribute__((__stdcall__)) StrokePath(HDC);
 BOOL __attribute__((__stdcall__)) SwapBuffers(HDC);
 BOOL __attribute__((__stdcall__)) TextOutA(HDC,int,int,LPCSTR,int);
 BOOL __attribute__((__stdcall__)) TextOutW(HDC,int,int,LPCWSTR,int);
 BOOL __attribute__((__stdcall__)) TranslateCharsetInfo(PDWORD,LPCHARSETINFO,DWORD);
 BOOL __attribute__((__stdcall__)) UnrealizeObject(HGDIOBJ);
 BOOL __attribute__((__stdcall__)) UpdateColors(HDC);
 BOOL __attribute__((__stdcall__)) UpdateICMRegKeyA(DWORD,DWORD,LPSTR,UINT);
 BOOL __attribute__((__stdcall__)) UpdateICMRegKeyW(DWORD,DWORD,LPWSTR,UINT);
 BOOL __attribute__((__stdcall__)) WidenPath(HDC);
 BOOL __attribute__((__stdcall__)) wglCopyContext(HGLRC,HGLRC,UINT);
 HGLRC __attribute__((__stdcall__)) wglCreateContext(HDC);
 HGLRC __attribute__((__stdcall__)) wglCreateLayerContext(HDC,int);
 BOOL __attribute__((__stdcall__)) wglDeleteContext(HGLRC);
 BOOL __attribute__((__stdcall__)) wglDescribeLayerPlane(HDC,int,int,UINT,LPLAYERPLANEDESCRIPTOR);
 HGLRC __attribute__((__stdcall__)) wglGetCurrentContext(void);
 HDC __attribute__((__stdcall__)) wglGetCurrentDC(void);
 int __attribute__((__stdcall__)) wglGetLayerPaletteEntries(HDC,int,int,int,COLORREF*);
 PROC __attribute__((__stdcall__)) wglGetProcAddress(LPCSTR);
 BOOL __attribute__((__stdcall__)) wglMakeCurrent(HDC,HGLRC);
 BOOL __attribute__((__stdcall__)) wglRealizeLayerPalette(HDC,int,BOOL);
 int __attribute__((__stdcall__)) wglSetLayerPaletteEntries(HDC,int,int,int,const COLORREF*);
 BOOL __attribute__((__stdcall__)) wglShareLists(HGLRC,HGLRC);
 BOOL __attribute__((__stdcall__)) wglSwapLayerBuffers(HDC,UINT);
 BOOL __attribute__((__stdcall__)) wglUseFontBitmapsA(HDC,DWORD,DWORD,DWORD);
 BOOL __attribute__((__stdcall__)) wglUseFontBitmapsW(HDC,DWORD,DWORD,DWORD);
 BOOL __attribute__((__stdcall__)) wglUseFontOutlinesA(HDC,DWORD,DWORD,DWORD,FLOAT,FLOAT,int,LPGLYPHMETRICSFLOAT);
 BOOL __attribute__((__stdcall__)) wglUseFontOutlinesW(HDC,DWORD,DWORD,DWORD,FLOAT,FLOAT,int,LPGLYPHMETRICSFLOAT);
# 2992 "H:/CPP/wxdevcpp6.10/include/wingdi.h" 3
typedef BYTE BCHAR;
typedef DOCINFOA DOCINFO, *LPDOCINFO;
typedef LOGFONTA LOGFONT,*PLOGFONT,*LPLOGFONT;
typedef TEXTMETRICA TEXTMETRIC,*PTEXTMETRIC,*LPTEXTMETRIC;


typedef DEVMODEA DEVMODE,*PDEVMODE,*LPDEVMODE;





typedef EXTLOGFONTA EXTLOGFONT,*PEXTLOGFONT,*LPEXTLOGFONT;
typedef GCP_RESULTSA GCP_RESULTS,*LPGCP_RESULTS;
typedef OUTLINETEXTMETRICA OUTLINETEXTMETRIC,*POUTLINETEXTMETRIC,*LPOUTLINETEXTMETRIC;
typedef POLYTEXTA POLYTEXT,*PPOLYTEXT,*LPPOLYTEXT;
typedef LOGCOLORSPACEA LOGCOLORSPACE,*LPLOGCOLORSPACE;
typedef NEWTEXTMETRICA NEWTEXTMETRIC,*PNEWTEXTMETRIC,*LPNEWTEXTMETRIC;
typedef NEWTEXTMETRICEXA NEWTEXTMETRICEX;
typedef ENUMLOGFONTA ENUMLOGFONT,*LPENUMLOGFONT;
typedef ENUMLOGFONTEXA ENUMLOGFONTEX,*LPENUMLOGFONTEX;
typedef DISPLAY_DEVICEA DISPLAY_DEVICE, *PDISPLAY_DEVICE, *LPDISPLAY_DEVICE;
# 3071 "H:/CPP/wxdevcpp6.10/include/wingdi.h" 3
}
# 53 "H:/CPP/wxdevcpp6.10/include/windows.h" 2 3


# 1 "H:/CPP/wxdevcpp6.10/include/winuser.h" 1 3



       
# 5 "H:/CPP/wxdevcpp6.10/include/winuser.h" 3



extern "C" {
# 2364 "H:/CPP/wxdevcpp6.10/include/winuser.h" 3
typedef BOOL(__attribute__((__stdcall__)) *DLGPROC)(HWND,UINT,WPARAM,LPARAM);
typedef void(__attribute__((__stdcall__)) *TIMERPROC)(HWND,UINT,UINT,DWORD);
typedef BOOL(__attribute__((__stdcall__)) *GRAYSTRINGPROC)(HDC,LPARAM,int);
typedef LRESULT(__attribute__((__stdcall__)) *HOOKPROC)(int,WPARAM,LPARAM);
typedef BOOL(__attribute__((__stdcall__)) *PROPENUMPROCA)(HWND,LPCSTR,HANDLE);
typedef BOOL(__attribute__((__stdcall__)) *PROPENUMPROCW)(HWND,LPCWSTR,HANDLE);
typedef BOOL(__attribute__((__stdcall__)) *PROPENUMPROCEXA)(HWND,LPSTR,HANDLE,DWORD);
typedef BOOL(__attribute__((__stdcall__)) *PROPENUMPROCEXW)(HWND,LPWSTR,HANDLE,DWORD);
typedef int(__attribute__((__stdcall__)) *EDITWORDBREAKPROCA)(LPSTR,int,int,int);
typedef int(__attribute__((__stdcall__)) *EDITWORDBREAKPROCW)(LPWSTR,int,int,int);
typedef LRESULT(__attribute__((__stdcall__)) *WNDPROC)(HWND,UINT,WPARAM,LPARAM);
typedef BOOL(__attribute__((__stdcall__)) *DRAWSTATEPROC)(HDC,LPARAM,WPARAM,int,int);
typedef BOOL(__attribute__((__stdcall__)) *WNDENUMPROC)(HWND,LPARAM);
typedef BOOL(__attribute__((__stdcall__)) *ENUMWINDOWSPROC)(HWND,LPARAM);
typedef BOOL(__attribute__((__stdcall__))* MONITORENUMPROC)(HMONITOR,HDC,LPRECT,LPARAM);
typedef BOOL(__attribute__((__stdcall__)) *NAMEENUMPROCA)(LPSTR,LPARAM);
typedef BOOL(__attribute__((__stdcall__)) *NAMEENUMPROCW)(LPWSTR,LPARAM);
typedef NAMEENUMPROCA DESKTOPENUMPROCA;
typedef NAMEENUMPROCW DESKTOPENUMPROCW;
typedef NAMEENUMPROCA WINSTAENUMPROCA;
typedef NAMEENUMPROCW WINSTAENUMPROCW;
typedef void(__attribute__((__stdcall__)) *SENDASYNCPROC)(HWND,UINT,DWORD,LRESULT);
typedef struct HHOOK__{int i;}*HHOOK;
typedef struct HDWP__{int i;}*HDWP;
typedef struct HDEVNOTIFY__{int i;}*HDEVNOTIFY;
typedef struct tagACCEL {
 BYTE fVirt;
 WORD key;
 WORD cmd;
} ACCEL,*LPACCEL;
typedef struct tagACCESSTIMEOUT {
 UINT cbSize;
 DWORD dwFlags;
 DWORD iTimeOutMSec;
} ACCESSTIMEOUT, *LPACCESSTIMEOUT;
typedef struct tagANIMATIONINFO {
 UINT cbSize;
 int iMinAnimate;
} ANIMATIONINFO,*LPANIMATIONINFO;
typedef struct tagCREATESTRUCTA {
 LPVOID lpCreateParams;
 HINSTANCE hInstance;
 HMENU hMenu;
 HWND hwndParent;
 int cy;
 int cx;
 int y;
 int x;
 LONG style;
 LPCSTR lpszName;
 LPCSTR lpszClass;
 DWORD dwExStyle;
} CREATESTRUCTA,*LPCREATESTRUCTA;
typedef struct tagCREATESTRUCTW {
 LPVOID lpCreateParams;
 HINSTANCE hInstance;
 HMENU hMenu;
 HWND hwndParent;
 int cy;
 int cx;
 int y;
 int x;
 LONG style;
 LPCWSTR lpszName;
 LPCWSTR lpszClass;
 DWORD dwExStyle;
} CREATESTRUCTW,*LPCREATESTRUCTW;
typedef struct tagCBT_CREATEWNDA {
 LPCREATESTRUCTA lpcs;
 HWND hwndInsertAfter;
} CBT_CREATEWNDA, *LPCBT_CREATEWNDA;
typedef struct tagCBT_CREATEWNDW {
 LPCREATESTRUCTW lpcs;
 HWND hwndInsertAfter;
} CBT_CREATEWNDW, *LPCBT_CREATEWNDW;
typedef struct tagCBTACTIVATESTRUCT {
 BOOL fMouse;
 HWND hWndActive;
} CBTACTIVATESTRUCT,*LPCBTACTIVATESTRUCT;
typedef struct tagCLIENTCREATESTRUCT {
 HANDLE hWindowMenu;
 UINT idFirstChild;
} CLIENTCREATESTRUCT,*LPCLIENTCREATESTRUCT;
typedef struct tagCOMPAREITEMSTRUCT {
 UINT CtlType;
 UINT CtlID;
 HWND hwndItem;
 UINT itemID1;
 DWORD itemData1;
 UINT itemID2;
 DWORD itemData2;
 DWORD dwLocaleId;
} COMPAREITEMSTRUCT,*LPCOMPAREITEMSTRUCT;
typedef struct tagCOPYDATASTRUCT {
 DWORD dwData;
 DWORD cbData;
 PVOID lpData;
} COPYDATASTRUCT,*PCOPYDATASTRUCT;
typedef struct tagCURSORSHAPE {
 int xHotSpot;
 int yHotSpot;
 int cx;
 int cy;
 int cbWidth;
    BYTE Planes;
    BYTE BitsPixel;
} CURSORSHAPE,*LPCURSORSHAPE;
typedef struct tagCWPRETSTRUCT {
 LRESULT lResult;
 LPARAM lParam;
 WPARAM wParam;
 DWORD message;
 HWND hwnd;
} CWPRETSTRUCT;
typedef struct tagCWPSTRUCT {
 LPARAM lParam;
 WPARAM wParam;
 UINT message;
 HWND hwnd;
} CWPSTRUCT,*PCWPSTRUCT;
typedef struct tagDEBUGHOOKINFO {
 DWORD idThread;
 DWORD idThreadInstaller;
 LPARAM lParam;
 WPARAM wParam;
 int code;
} DEBUGHOOKINFO,*PDEBUGHOOKINFO,*LPDEBUGHOOKINFO;
typedef struct tagDELETEITEMSTRUCT {
 UINT CtlType;
 UINT CtlID;
 UINT itemID;
 HWND hwndItem;
 UINT itemData;
} DELETEITEMSTRUCT,*PDELETEITEMSTRUCT,*LPDELETEITEMSTRUCT;
#pragma pack(push,2)
typedef struct {
 DWORD style;
 DWORD dwExtendedStyle;
 short x;
 short y;
 short cx;
 short cy;
 WORD id;
} DLGITEMTEMPLATE,*LPDLGITEMTEMPLATE;
typedef struct {
 DWORD style;
 DWORD dwExtendedStyle;
 WORD cdit;
 short x;
 short y;
 short cx;
 short cy;
} DLGTEMPLATE,*LPDLGTEMPLATE,*LPDLGTEMPLATEA,*LPDLGTEMPLATEW;
typedef const DLGTEMPLATE *LPCDLGTEMPLATE;
#pragma pack(pop)
typedef struct tagDRAWITEMSTRUCT {
 UINT CtlType;
 UINT CtlID;
 UINT itemID;
 UINT itemAction;
 UINT itemState;
 HWND hwndItem;
 HDC hDC;
 RECT rcItem;
 DWORD itemData;
} DRAWITEMSTRUCT,*LPDRAWITEMSTRUCT,*PDRAWITEMSTRUCT;
typedef struct {
 UINT cbSize;
 int iTabLength;
 int iLeftMargin;
 int iRightMargin;
 UINT uiLengthDrawn;
} DRAWTEXTPARAMS,*LPDRAWTEXTPARAMS;
typedef struct tagPAINTSTRUCT {
 HDC hdc;
 BOOL fErase;
 RECT rcPaint;
 BOOL fRestore;
 BOOL fIncUpdate;
 BYTE rgbReserved[32];
} PAINTSTRUCT,*LPPAINTSTRUCT;
typedef struct tagMSG {
 HWND hwnd;
 UINT message;
 WPARAM wParam;
 LPARAM lParam;
 DWORD time;
 POINT pt;
} MSG,*LPMSG,*PMSG;
typedef struct _ICONINFO {
 BOOL fIcon;
 DWORD xHotspot;
 DWORD yHotspot;
 HBITMAP hbmMask;
 HBITMAP hbmColor;
} ICONINFO,*PICONINFO;
typedef struct tagNMHDR {
 HWND hwndFrom;
 UINT idFrom;
 UINT code;
} NMHDR,*LPNMHDR;
typedef struct _WNDCLASSA {
 UINT style;
 WNDPROC lpfnWndProc;
 int cbClsExtra;
 int cbWndExtra;
 HINSTANCE hInstance;
 HICON hIcon;
 HCURSOR hCursor;
 HBRUSH hbrBackground;
 LPCSTR lpszMenuName;
 LPCSTR lpszClassName;
} WNDCLASSA,*LPWNDCLASSA,*PWNDCLASSA;
typedef struct _WNDCLASSW {
 UINT style;
 WNDPROC lpfnWndProc;
 int cbClsExtra;
 int cbWndExtra;
 HINSTANCE hInstance;
 HICON hIcon;
 HCURSOR hCursor;
 HBRUSH hbrBackground;
 LPCWSTR lpszMenuName;
 LPCWSTR lpszClassName;
} WNDCLASSW,*LPWNDCLASSW,*PWNDCLASSW;
typedef struct _WNDCLASSEXA {
 UINT cbSize;
 UINT style;
 WNDPROC lpfnWndProc;
 int cbClsExtra;
 int cbWndExtra;
 HINSTANCE hInstance;
 HICON hIcon;
 HCURSOR hCursor;
 HBRUSH hbrBackground;
 LPCSTR lpszMenuName;
 LPCSTR lpszClassName;
 HICON hIconSm;
} WNDCLASSEXA,*LPWNDCLASSEXA,*PWNDCLASSEXA;
typedef struct _WNDCLASSEXW {
 UINT cbSize;
 UINT style;
 WNDPROC lpfnWndProc;
 int cbClsExtra;
 int cbWndExtra;
 HINSTANCE hInstance;
 HICON hIcon;
 HCURSOR hCursor;
 HBRUSH hbrBackground;
 LPCWSTR lpszMenuName;
 LPCWSTR lpszClassName;
 HICON hIconSm;
} WNDCLASSEXW,*LPWNDCLASSEXW,*PWNDCLASSEXW;
typedef struct tagMENUITEMINFOA {
 UINT cbSize;
 UINT fMask;
 UINT fType;
 UINT fState;
 UINT wID;
 HMENU hSubMenu;
 HBITMAP hbmpChecked;
 HBITMAP hbmpUnchecked;
 DWORD dwItemData;
 LPSTR dwTypeData;
 UINT cch;



} MENUITEMINFOA,*LPMENUITEMINFOA;
typedef const MENUITEMINFOA *LPCMENUITEMINFOA;
typedef struct tagMENUITEMINFOW {
 UINT cbSize;
 UINT fMask;
 UINT fType;
 UINT fState;
 UINT wID;
 HMENU hSubMenu;
 HBITMAP hbmpChecked;
 HBITMAP hbmpUnchecked;
 DWORD dwItemData;
 LPWSTR dwTypeData;
 UINT cch;



} MENUITEMINFOW,*LPMENUITEMINFOW;
typedef const MENUITEMINFOW *LPCMENUITEMINFOW;
typedef struct tagSCROLLINFO {
 UINT cbSize;
 UINT fMask;
 int nMin;
 int nMax;
 UINT nPage;
 int nPos;
 int nTrackPos;
} SCROLLINFO,*LPSCROLLINFO;
typedef const SCROLLINFO *LPCSCROLLINFO;
typedef struct _WINDOWPLACEMENT {
 UINT length;
 UINT flags;
 UINT showCmd;
 POINT ptMinPosition;
 POINT ptMaxPosition;
 RECT rcNormalPosition;
} WINDOWPLACEMENT,*LPWINDOWPLACEMENT,*PWINDOWPLACEMENT;
typedef struct {
 WORD versionNumber;
 WORD offset;
} MENUITEMTEMPLATEHEADER;
typedef struct {
 WORD mtOption;
 WORD mtID;
 WCHAR mtString[1];
} MENUITEMTEMPLATE;
typedef void MENUTEMPLATE,MENUTEMPLATEA,MENUTEMPLATEW,*LPMENUTEMPLATEA,*LPMENUTEMPLATEW,*LPMENUTEMPLATE;
typedef struct tagHELPINFO {
 UINT cbSize;
 int iContextType;
 int iCtrlId;
 HANDLE hItemHandle;
 DWORD dwContextId;
 POINT MousePos;
} HELPINFO,*LPHELPINFO;
typedef void(__attribute__((__stdcall__)) *MSGBOXCALLBACK)(LPHELPINFO);
typedef struct {
 UINT cbSize;
 HWND hwndOwner;
 HINSTANCE hInstance;
 LPCSTR lpszText;
 LPCSTR lpszCaption;
 DWORD dwStyle;
 LPCSTR lpszIcon;
 DWORD dwContextHelpId;
 MSGBOXCALLBACK lpfnMsgBoxCallback;
 DWORD dwLanguageId;
} MSGBOXPARAMSA,*PMSGBOXPARAMSA,*LPMSGBOXPARAMSA;
typedef struct {
 UINT cbSize;
 HWND hwndOwner;
 HINSTANCE hInstance;
 LPCWSTR lpszText;
 LPCWSTR lpszCaption;
 DWORD dwStyle;
 LPCWSTR lpszIcon;
 DWORD dwContextHelpId;
 MSGBOXCALLBACK lpfnMsgBoxCallback;
 DWORD dwLanguageId;
} MSGBOXPARAMSW,*PMSGBOXPARAMSW,*LPMSGBOXPARAMSW;
typedef struct tagUSEROBJECTFLAGS {
 BOOL fInherit;
 BOOL fReserved;
 DWORD dwFlags;
} USEROBJECTFLAGS;
typedef struct tagFILTERKEYS {
 UINT cbSize;
 DWORD dwFlags;
 DWORD iWaitMSec;
 DWORD iDelayMSec;
 DWORD iRepeatMSec;
 DWORD iBounceMSec;
} FILTERKEYS;
typedef struct tagHIGHCONTRASTA {
 UINT cbSize;
 DWORD dwFlags;
 LPSTR lpszDefaultScheme;
} HIGHCONTRASTA,*LPHIGHCONTRASTA;
typedef struct tagHIGHCONTRASTW {
 UINT cbSize;
 DWORD dwFlags;
 LPWSTR lpszDefaultScheme;
} HIGHCONTRASTW,*LPHIGHCONTRASTW;

typedef struct tagICONMETRICSA {
 UINT cbSize;
 int iHorzSpacing;
 int iVertSpacing;
 int iTitleWrap;
 LOGFONTA lfFont;
} ICONMETRICSA,*LPICONMETRICSA;
typedef struct tagICONMETRICSW {
 UINT cbSize;
 int iHorzSpacing;
 int iVertSpacing;
 int iTitleWrap;
 LOGFONTW lfFont;
} ICONMETRICSW,*LPICONMETRICSW;

typedef struct tagMINIMIZEDMETRICS {
 UINT cbSize;
 int iWidth;
 int iHorzGap;
 int iVertGap;
 int iArrange;
} MINIMIZEDMETRICS,*LPMINIMIZEDMETRICS;
typedef struct tagMOUSEKEYS{
 UINT cbSize;
 DWORD dwFlags;
 DWORD iMaxSpeed;
 DWORD iTimeToMaxSpeed;
 DWORD iCtrlSpeed;
 DWORD dwReserved1;
 DWORD dwReserved2;
} MOUSEKEYS,*LPMOUSEKEYS;

typedef struct tagNONCLIENTMETRICSA {
 UINT cbSize;
 int iBorderWidth;
 int iScrollWidth;
 int iScrollHeight;
 int iCaptionWidth;
 int iCaptionHeight;
 LOGFONTA lfCaptionFont;
 int iSmCaptionWidth;
 int iSmCaptionHeight;
 LOGFONTA lfSmCaptionFont;
 int iMenuWidth;
 int iMenuHeight;
 LOGFONTA lfMenuFont;
 LOGFONTA lfStatusFont;
 LOGFONTA lfMessageFont;
} NONCLIENTMETRICSA,*LPNONCLIENTMETRICSA;
typedef struct tagNONCLIENTMETRICSW {
 UINT cbSize;
 int iBorderWidth;
 int iScrollWidth;
 int iScrollHeight;
 int iCaptionWidth;
 int iCaptionHeight;
 LOGFONTW lfCaptionFont;
 int iSmCaptionWidth;
 int iSmCaptionHeight;
 LOGFONTW lfSmCaptionFont;
 int iMenuWidth;
 int iMenuHeight;
 LOGFONTW lfMenuFont;
 LOGFONTW lfStatusFont;
 LOGFONTW lfMessageFont;
} NONCLIENTMETRICSW,*LPNONCLIENTMETRICSW;

typedef struct tagSERIALKEYSA {
 UINT cbSize;
 DWORD dwFlags;
 LPSTR lpszActivePort;
 LPSTR lpszPort;
 UINT iBaudRate;
 UINT iPortState;
 UINT iActive;
} SERIALKEYSA,*LPSERIALKEYSA;
typedef struct tagSERIALKEYSW {
 UINT cbSize;
 DWORD dwFlags;
 LPWSTR lpszActivePort;
 LPWSTR lpszPort;
 UINT iBaudRate;
 UINT iPortState;
 UINT iActive;
} SERIALKEYSW,*LPSERIALKEYSW;
typedef struct tagSOUNDSENTRYA {
 UINT cbSize;
 DWORD dwFlags;
 DWORD iFSTextEffect;
 DWORD iFSTextEffectMSec;
 DWORD iFSTextEffectColorBits;
 DWORD iFSGrafEffect;
 DWORD iFSGrafEffectMSec;
 DWORD iFSGrafEffectColor;
 DWORD iWindowsEffect;
 DWORD iWindowsEffectMSec;
 LPSTR lpszWindowsEffectDLL;
 DWORD iWindowsEffectOrdinal;
} SOUNDSENTRYA,*LPSOUNDSENTRYA;
typedef struct tagSOUNDSENTRYW {
 UINT cbSize;
 DWORD dwFlags;
 DWORD iFSTextEffect;
 DWORD iFSTextEffectMSec;
 DWORD iFSTextEffectColorBits;
 DWORD iFSGrafEffect;
 DWORD iFSGrafEffectMSec;
 DWORD iFSGrafEffectColor;
 DWORD iWindowsEffect;
 DWORD iWindowsEffectMSec;
 LPWSTR lpszWindowsEffectDLL;
 DWORD iWindowsEffectOrdinal;
} SOUNDSENTRYW,*LPSOUNDSENTRYW;
typedef struct tagSTICKYKEYS {
 DWORD cbSize;
 DWORD dwFlags;
} STICKYKEYS,*LPSTICKYKEYS;
typedef struct tagTOGGLEKEYS {
 DWORD cbSize;
 DWORD dwFlags;
} TOGGLEKEYS;
typedef struct tagMOUSEHOOKSTRUCT {
 POINT pt;
 HWND hwnd;
 UINT wHitTestCode;
 DWORD dwExtraInfo;
} MOUSEHOOKSTRUCT,*LPMOUSEHOOKSTRUCT,*PMOUSEHOOKSTRUCT;
typedef struct tagTRACKMOUSEEVENT {
 DWORD cbSize;
 DWORD dwFlags;
 HWND hwndTrack;
 DWORD dwHoverTime;
} TRACKMOUSEEVENT,*LPTRACKMOUSEEVENT;
typedef struct tagTPMPARAMS {
 UINT cbSize;
 RECT rcExclude;
} TPMPARAMS,*LPTPMPARAMS;
typedef struct tagEVENTMSG {
 UINT message;
 UINT paramL;
 UINT paramH;
 DWORD time;
 HWND hwnd;
} EVENTMSG,*PEVENTMSGMSG,*LPEVENTMSGMSG,*PEVENTMSG,*LPEVENTMSG;
typedef struct _WINDOWPOS {
 HWND hwnd;
 HWND hwndInsertAfter;
 int x;
 int y;
 int cx;
 int cy;
 UINT flags;
} WINDOWPOS,*PWINDOWPOS,*LPWINDOWPOS;
typedef struct tagNCCALCSIZE_PARAMS {
 RECT rgrc[3];
 PWINDOWPOS lppos;
} NCCALCSIZE_PARAMS, *LPNCCALCSIZE_PARAMS;
typedef struct tagMDICREATESTRUCTA {
 LPCSTR szClass;
 LPCSTR szTitle;
 HANDLE hOwner;
 int x;
 int y;
 int cx;
 int cy;
 DWORD style;
 LPARAM lParam;
} MDICREATESTRUCTA,*LPMDICREATESTRUCTA;
typedef struct tagMDICREATESTRUCTW {
 LPCWSTR szClass;
 LPCWSTR szTitle;
 HANDLE hOwner;
 int x;
 int y;
 int cx;
 int cy;
 DWORD style;
 LPARAM lParam;
} MDICREATESTRUCTW,*LPMDICREATESTRUCTW;
typedef struct tagMINMAXINFO {
 POINT ptReserved;
 POINT ptMaxSize;
 POINT ptMaxPosition;
 POINT ptMinTrackSize;
 POINT ptMaxTrackSize;
} MINMAXINFO,*PMINMAXINFO,*LPMINMAXINFO;
typedef struct tagMDINEXTMENU {
 HMENU hmenuIn;
 HMENU hmenuNext;
 HWND hwndNext;
} MDINEXTMENU,*PMDINEXTMENU,*LPMDINEXTMENU;
typedef struct tagMEASUREITEMSTRUCT {
 UINT CtlType;
 UINT CtlID;
 UINT itemID;
 UINT itemWidth;
 UINT itemHeight;
 DWORD itemData;
} MEASUREITEMSTRUCT,*PMEASUREITEMSTRUCT,*LPMEASUREITEMSTRUCT;
typedef struct tagDROPSTRUCT {
 HWND hwndSource;
 HWND hwndSink;
 DWORD wFmt;
 DWORD dwData;
 POINT ptDrop;
 DWORD dwControlData;
} DROPSTRUCT,*PDROPSTRUCT,*LPDROPSTRUCT;
typedef DWORD HELPPOLY;
typedef struct tagMULTIKEYHELPA {
 DWORD mkSize;
 CHAR mkKeylist;
 CHAR szKeyphrase[1];
} MULTIKEYHELPA,*PMULTIKEYHELPA,*LPMULTIKEYHELPA;
typedef struct tagMULTIKEYHELPW {
 DWORD mkSize;
 WCHAR mkKeylist;
 WCHAR szKeyphrase[1];
} MULTIKEYHELPW,*PMULTIKEYHELPW,*LPMULTIKEYHELPW;
typedef struct tagHELPWININFOA {
 int wStructSize;
 int x;
 int y;
 int dx;
 int dy;
 int wMax;
 CHAR rgchMember[2];
} HELPWININFOA,*PHELPWININFOA,*LPHELPWININFOA;
typedef struct tagHELPWININFOW {
 int wStructSize;
 int x;
 int y;
 int dx;
 int dy;
 int wMax;
 WCHAR rgchMember[2];
} HELPWININFOW,*PHELPWININFOW,*LPHELPWININFOW;
typedef struct tagSTYLESTRUCT {
 DWORD styleOld;
 DWORD styleNew;
} STYLESTRUCT,*LPSTYLESTRUCT;
typedef struct tagALTTABINFO {
 DWORD cbSize;
 int cItems;
 int cColumns;
 int cRows;
 int iColFocus;
 int iRowFocus;
 int cxItem;
 int cyItem;
 POINT ptStart;
} ALTTABINFO,*PALTTABINFO,*LPALTTABINFO;
typedef struct tagCOMBOBOXINFO {
 DWORD cbSize;
 RECT rcItem;
 RECT rcButton;
 DWORD stateButton;
 HWND hwndCombo;
 HWND hwndItem;
 HWND hwndList;
} COMBOBOXINFO,*PCOMBOBOXINFO,*LPCOMBOBOXINFO;
typedef struct tagCURSORINFO {
 DWORD cbSize;
 DWORD flags;
 HCURSOR hCursor;
 POINT ptScreenPos;
} CURSORINFO,*PCURSORINFO,*LPCURSORINFO;
typedef struct tagMENUBARINFO {
 DWORD cbSize;
 RECT rcBar;
 HMENU hMenu;
 HWND hwndMenu;
 BOOL fBarFocused:1;
 BOOL fFocused:1;
} MENUBARINFO,*PMENUBARINFO;
typedef struct tagMENUINFO {
 DWORD cbSize;
 DWORD fMask;
 DWORD dwStyle;
 UINT cyMax;
 HBRUSH hbrBack;
 DWORD dwContextHelpID;
 ULONG_PTR dwMenuData;
} MENUINFO,*LPMENUINFO;
typedef MENUINFO const *LPCMENUINFO;

typedef struct tagSCROLLBARINFO {
 DWORD cbSize;
 RECT rcScrollBar;
 int dxyLineButton;
 int xyThumbTop;
 int xyThumbBottom;
 int reserved;
 DWORD rgstate[5 +1];
} SCROLLBARINFO,*PSCROLLBARINFO,*LPSCROLLBARINFO;

typedef struct tagTITLEBARINFO {
 DWORD cbSize;
 RECT rcTitleBar;
 DWORD rgstate[5 +1];
} TITLEBARINFO,*PTITLEBARINFO,*LPTITLEBARINFO;
typedef struct tagWINDOWINFO {
 DWORD cbSize;
 RECT rcWindow;
 RECT rcClient;
 DWORD dwStyle;
 DWORD dwExStyle;
 DWORD dwWindowStatus;
 UINT cxWindowBorders;
 UINT cyWindowBorders;
 ATOM atomWindowType;
 WORD wCreatorVersion;
} WINDOWINFO,*PWINDOWINFO,*LPWINDOWINFO;
typedef struct tagLASTINPUTINFO {
 UINT cbSize;
 DWORD dwTime;
} LASTINPUTINFO,*PLASTINPUTINFO;
typedef struct tagMONITORINFO {
 DWORD cbSize;
 RECT rcMonitor;
 RECT rcWork;
 DWORD dwFlags;
} MONITORINFO,*LPMONITORINFO;


typedef struct tagMONITORINFOEXA : public tagMONITORINFO
{
    CHAR szDevice[32];
} MONITORINFOEXA, *LPMONITORINFOEXA;
typedef struct tagMONITORINFOEXW : public tagMONITORINFO
{
    WCHAR szDevice[32];
} MONITORINFOEXW, *LPMONITORINFOEXW;
# 3084 "H:/CPP/wxdevcpp6.10/include/winuser.h" 3
typedef struct tagKBDLLHOOKSTRUCT {
 DWORD vkCode;
 DWORD scanCode;
 DWORD flags;
 DWORD time;
 DWORD dwExtraInfo;
} KBDLLHOOKSTRUCT,*LPKBDLLHOOKSTRUCT,*PKBDLLHOOKSTRUCT;
# 3214 "H:/CPP/wxdevcpp6.10/include/winuser.h" 3
typedef struct {
 POINT pt;
 DWORD mouseData;
 DWORD flags;
 DWORD time;
 ULONG_PTR dwExtraInfo;
} MSLLHOOKSTRUCT, *PMSLLHOOKSTRUCT;
# 3241 "H:/CPP/wxdevcpp6.10/include/winuser.h" 3
 HKL __attribute__((__stdcall__)) ActivateKeyboardLayout(HKL,UINT);
 BOOL __attribute__((__stdcall__)) AdjustWindowRect(LPRECT,DWORD,BOOL);
 BOOL __attribute__((__stdcall__)) AdjustWindowRectEx(LPRECT,DWORD,BOOL,DWORD);



 BOOL __attribute__((__stdcall__)) AnyPopup(void);
 BOOL __attribute__((__stdcall__)) AppendMenuA(HMENU,UINT,UINT_PTR,LPCSTR);
 BOOL __attribute__((__stdcall__)) AppendMenuW(HMENU,UINT,UINT_PTR,LPCWSTR);
 UINT __attribute__((__stdcall__)) ArrangeIconicWindows(HWND);
 BOOL __attribute__((__stdcall__)) AttachThreadInput(DWORD,DWORD,BOOL);
 HDWP __attribute__((__stdcall__)) BeginDeferWindowPos(int);
 HDC __attribute__((__stdcall__)) BeginPaint(HWND,LPPAINTSTRUCT);
 BOOL __attribute__((__stdcall__)) BringWindowToTop(HWND);
 long __attribute__((__stdcall__)) BroadcastSystemMessage(DWORD,LPDWORD,UINT,WPARAM,LPARAM);

 long __attribute__((__stdcall__)) BroadcastSystemMessageA(DWORD,LPDWORD,UINT,WPARAM,LPARAM);
 long __attribute__((__stdcall__)) BroadcastSystemMessageW(DWORD,LPDWORD,UINT,WPARAM,LPARAM);





 BOOL __attribute__((__stdcall__)) CallMsgFilterA(LPMSG,INT);
 BOOL __attribute__((__stdcall__)) CallMsgFilterW(LPMSG,INT);
 LRESULT __attribute__((__stdcall__)) CallNextHookEx(HHOOK,int,WPARAM,LPARAM);
 LRESULT __attribute__((__stdcall__)) CallWindowProcA(WNDPROC,HWND,UINT,WPARAM,LPARAM);
 LRESULT __attribute__((__stdcall__)) CallWindowProcW(WNDPROC,HWND,UINT,WPARAM,LPARAM);
 WORD __attribute__((__stdcall__)) CascadeWindows(HWND,UINT,LPCRECT,UINT,const HWND*);
 BOOL __attribute__((__stdcall__)) ChangeClipboardChain(HWND,HWND);

 LONG __attribute__((__stdcall__)) ChangeDisplaySettingsA(PDEVMODEA,DWORD);
 LONG __attribute__((__stdcall__)) ChangeDisplaySettingsW(PDEVMODEW,DWORD);
 LONG __attribute__((__stdcall__)) ChangeDisplaySettingsExA(LPCSTR,LPDEVMODEA,HWND,DWORD,LPVOID);
 LONG __attribute__((__stdcall__)) ChangeDisplaySettingsExW(LPCWSTR,LPDEVMODEW,HWND,DWORD,LPVOID);

 BOOL __attribute__((__stdcall__)) ChangeMenuA(HMENU,UINT,LPCSTR,UINT,UINT);
 BOOL __attribute__((__stdcall__)) ChangeMenuW(HMENU,UINT,LPCWSTR,UINT,UINT);
 LPSTR __attribute__((__stdcall__)) CharLowerA(LPSTR);
 LPWSTR __attribute__((__stdcall__)) CharLowerW(LPWSTR);
 DWORD __attribute__((__stdcall__)) CharLowerBuffA(LPSTR,DWORD);
 DWORD __attribute__((__stdcall__)) CharLowerBuffW(LPWSTR,DWORD);
 LPSTR __attribute__((__stdcall__)) CharNextA(LPCSTR);
 LPWSTR __attribute__((__stdcall__)) CharNextW(LPCWSTR);
 LPSTR __attribute__((__stdcall__)) CharNextExA(WORD,LPCSTR,DWORD);
 LPWSTR __attribute__((__stdcall__)) CharNextExW(WORD,LPCWSTR,DWORD);
 LPSTR __attribute__((__stdcall__)) CharPrevA(LPCSTR,LPCSTR);
 LPWSTR __attribute__((__stdcall__)) CharPrevW(LPCWSTR,LPCWSTR);
 LPSTR __attribute__((__stdcall__)) CharPrevExA(WORD,LPCSTR,LPCSTR,DWORD);
 LPWSTR __attribute__((__stdcall__)) CharPrevExW(WORD,LPCWSTR,LPCWSTR,DWORD);
 BOOL __attribute__((__stdcall__)) CharToOemA(LPCSTR,LPSTR);
 BOOL __attribute__((__stdcall__)) CharToOemW(LPCWSTR,LPSTR);
 BOOL __attribute__((__stdcall__)) CharToOemBuffA(LPCSTR,LPSTR,DWORD);
 BOOL __attribute__((__stdcall__)) CharToOemBuffW(LPCWSTR,LPSTR,DWORD);
 LPSTR __attribute__((__stdcall__)) CharUpperA(LPSTR);
 LPWSTR __attribute__((__stdcall__)) CharUpperW(LPWSTR);
 DWORD __attribute__((__stdcall__)) CharUpperBuffA(LPSTR,DWORD);
 DWORD __attribute__((__stdcall__)) CharUpperBuffW(LPWSTR,DWORD);
 BOOL __attribute__((__stdcall__)) CheckDlgButton(HWND,int,UINT);
 DWORD __attribute__((__stdcall__)) CheckMenuItem(HMENU,UINT,UINT);
 BOOL __attribute__((__stdcall__)) CheckMenuRadioItem(HMENU,UINT,UINT,UINT,UINT);
 BOOL __attribute__((__stdcall__)) CheckRadioButton(HWND,int,int,int);
 HWND __attribute__((__stdcall__)) ChildWindowFromPoint(HWND,POINT);
 HWND __attribute__((__stdcall__)) ChildWindowFromPointEx(HWND,POINT,UINT);
 BOOL __attribute__((__stdcall__)) ClientToScreen(HWND,LPPOINT);
 BOOL __attribute__((__stdcall__)) ClipCursor(LPCRECT);
 BOOL __attribute__((__stdcall__)) CloseClipboard(void);
 BOOL __attribute__((__stdcall__)) CloseDesktop(HDESK);
 BOOL __attribute__((__stdcall__)) CloseWindow(HWND);
 BOOL __attribute__((__stdcall__)) CloseWindowStation(HWINSTA);
 int __attribute__((__stdcall__)) CopyAcceleratorTableA(HACCEL,LPACCEL,int);
 int __attribute__((__stdcall__)) CopyAcceleratorTableW(HACCEL,LPACCEL,int);

 HICON __attribute__((__stdcall__)) CopyIcon(HICON);
 HANDLE __attribute__((__stdcall__)) CopyImage(HANDLE,UINT,int,int,UINT);
 BOOL __attribute__((__stdcall__)) CopyRect(LPRECT,LPCRECT);
 int __attribute__((__stdcall__)) CountClipboardFormats(void);
 HACCEL __attribute__((__stdcall__)) CreateAcceleratorTableA(LPACCEL,int);
 HACCEL __attribute__((__stdcall__)) CreateAcceleratorTableW(LPACCEL,int);
 BOOL __attribute__((__stdcall__)) CreateCaret(HWND,HBITMAP,int,int);
 HCURSOR __attribute__((__stdcall__)) CreateCursor(HINSTANCE,int,int,int,int,PCVOID,PCVOID);

 HDESK __attribute__((__stdcall__)) CreateDesktopA(LPCSTR,LPCSTR,LPDEVMODEA,DWORD,ACCESS_MASK,LPSECURITY_ATTRIBUTES);
 HDESK __attribute__((__stdcall__)) CreateDesktopW(LPCWSTR,LPCWSTR,LPDEVMODEW,DWORD,ACCESS_MASK,LPSECURITY_ATTRIBUTES);





 HWND __attribute__((__stdcall__)) CreateDialogIndirectParamA(HINSTANCE,LPCDLGTEMPLATE,HWND,DLGPROC,LPARAM);
 HWND __attribute__((__stdcall__)) CreateDialogIndirectParamW(HINSTANCE,LPCDLGTEMPLATE,HWND,DLGPROC,LPARAM);
 HWND __attribute__((__stdcall__)) CreateDialogParamA(HINSTANCE,LPCSTR,HWND,DLGPROC,LPARAM);
 HWND __attribute__((__stdcall__)) CreateDialogParamW(HINSTANCE,LPCWSTR,HWND,DLGPROC,LPARAM);
 HICON __attribute__((__stdcall__)) CreateIcon(HINSTANCE,int,int,BYTE,BYTE,const BYTE*,const BYTE*);
 HICON __attribute__((__stdcall__)) CreateIconFromResource(PBYTE,DWORD,BOOL,DWORD);
 HICON __attribute__((__stdcall__)) CreateIconFromResourceEx(PBYTE,DWORD,BOOL,DWORD,int,int,UINT);
 HICON __attribute__((__stdcall__)) CreateIconIndirect(PICONINFO);
 HWND __attribute__((__stdcall__)) CreateMDIWindowA(LPCSTR,LPCSTR,DWORD,int,int,int,int,HWND,HINSTANCE,LPARAM);
 HWND __attribute__((__stdcall__)) CreateMDIWindowW(LPCWSTR,LPCWSTR,DWORD,int,int,int,int,HWND,HINSTANCE,LPARAM);
 HMENU __attribute__((__stdcall__)) CreateMenu(void);
 HMENU __attribute__((__stdcall__)) CreatePopupMenu(void);


 HWND __attribute__((__stdcall__)) CreateWindowExA(DWORD,LPCSTR,LPCSTR,DWORD,int,int,int,int,HWND,HMENU,HINSTANCE,LPVOID);
 HWND __attribute__((__stdcall__)) CreateWindowExW(DWORD,LPCWSTR,LPCWSTR,DWORD,int,int,int,int,HWND,HMENU,HINSTANCE,LPVOID);
 HWINSTA __attribute__((__stdcall__)) CreateWindowStationA(LPCSTR,DWORD,DWORD,LPSECURITY_ATTRIBUTES);
 HWINSTA __attribute__((__stdcall__)) CreateWindowStationW(LPCWSTR,DWORD,DWORD,LPSECURITY_ATTRIBUTES);
 LRESULT __attribute__((__stdcall__)) DefDlgProcA(HWND,UINT,WPARAM,LPARAM);
 LRESULT __attribute__((__stdcall__)) DefDlgProcW(HWND,UINT,WPARAM,LPARAM);
 HDWP __attribute__((__stdcall__)) DeferWindowPos(HDWP,HWND,HWND,int,int,int,int,UINT);
 LRESULT __attribute__((__stdcall__)) DefFrameProcA(HWND,HWND,UINT,WPARAM,LPARAM);
 LRESULT __attribute__((__stdcall__)) DefFrameProcW(HWND,HWND,UINT,WPARAM,LPARAM);

 LRESULT __attribute__((__stdcall__)) DefMDIChildProcA(HWND,UINT,WPARAM,LPARAM);
 LRESULT __attribute__((__stdcall__)) DefMDIChildProcW(HWND,UINT,WPARAM,LPARAM);



 LRESULT __attribute__((__stdcall__)) DefWindowProcA(HWND,UINT,WPARAM,LPARAM);
 LRESULT __attribute__((__stdcall__)) DefWindowProcW(HWND,UINT,WPARAM,LPARAM);
 BOOL __attribute__((__stdcall__)) DeleteMenu(HMENU,UINT,UINT);
 BOOL __attribute__((__stdcall__)) DeregisterShellHookWindow(HWND);
 BOOL __attribute__((__stdcall__)) DestroyAcceleratorTable(HACCEL);
 BOOL __attribute__((__stdcall__)) DestroyCaret(void);
 BOOL __attribute__((__stdcall__)) DestroyCursor(HCURSOR);
 BOOL __attribute__((__stdcall__)) DestroyIcon(HICON);
 BOOL __attribute__((__stdcall__)) DestroyMenu(HMENU);
 BOOL __attribute__((__stdcall__)) DestroyWindow(HWND);




 int __attribute__((__stdcall__)) DialogBoxIndirectParamA(HINSTANCE,LPCDLGTEMPLATE,HWND,DLGPROC,LPARAM);
 int __attribute__((__stdcall__)) DialogBoxIndirectParamW(HINSTANCE,LPCDLGTEMPLATE,HWND,DLGPROC,LPARAM);
 int __attribute__((__stdcall__)) DialogBoxParamA(HINSTANCE,LPCSTR,HWND,DLGPROC,LPARAM);
 int __attribute__((__stdcall__)) DialogBoxParamW(HINSTANCE,LPCWSTR,HWND,DLGPROC,LPARAM);
 LONG __attribute__((__stdcall__)) DispatchMessageA(const MSG*);
 LONG __attribute__((__stdcall__)) DispatchMessageW(const MSG*);
 int __attribute__((__stdcall__)) DlgDirListA(HWND,LPSTR,int,int,UINT);
 int __attribute__((__stdcall__)) DlgDirListW(HWND,LPWSTR,int,int,UINT);
 int __attribute__((__stdcall__)) DlgDirListComboBoxA(HWND,LPSTR,int,int,UINT);
 int __attribute__((__stdcall__)) DlgDirListComboBoxW(HWND,LPWSTR,int,int,UINT);
 BOOL __attribute__((__stdcall__)) DlgDirSelectComboBoxExA(HWND,LPSTR,int,int);
 BOOL __attribute__((__stdcall__)) DlgDirSelectComboBoxExW(HWND,LPWSTR,int,int);
 BOOL __attribute__((__stdcall__)) DlgDirSelectExA(HWND,LPSTR,int,int);
 BOOL __attribute__((__stdcall__)) DlgDirSelectExW(HWND,LPWSTR,int,int);
 BOOL __attribute__((__stdcall__)) DragDetect(HWND,POINT);
 DWORD __attribute__((__stdcall__)) DragObject(HWND,HWND,UINT,DWORD,HCURSOR);
 BOOL __attribute__((__stdcall__)) DrawAnimatedRects(HWND,int,LPCRECT,LPCRECT);
 BOOL __attribute__((__stdcall__)) DrawCaption(HWND,HDC,LPCRECT,UINT);
 BOOL __attribute__((__stdcall__)) DrawEdge(HDC,LPRECT,UINT,UINT);
 BOOL __attribute__((__stdcall__)) DrawFocusRect(HDC,LPCRECT);
 BOOL __attribute__((__stdcall__)) DrawFrameControl(HDC,LPRECT,UINT,UINT);
 BOOL __attribute__((__stdcall__)) DrawIcon(HDC,int,int,HICON);
 BOOL __attribute__((__stdcall__)) DrawIconEx(HDC,int,int,HICON,int,int,UINT,HBRUSH,UINT);
 BOOL __attribute__((__stdcall__)) DrawMenuBar(HWND);
 BOOL __attribute__((__stdcall__)) DrawStateA(HDC,HBRUSH,DRAWSTATEPROC,LPARAM,WPARAM,int,int,int,int,UINT);
 BOOL __attribute__((__stdcall__)) DrawStateW(HDC,HBRUSH,DRAWSTATEPROC,LPARAM,WPARAM,int,int,int,int,UINT);
 int __attribute__((__stdcall__)) DrawTextA(HDC,LPCSTR,int,LPRECT,UINT);
 int __attribute__((__stdcall__)) DrawTextW(HDC,LPCWSTR,int,LPRECT,UINT);
 int __attribute__((__stdcall__)) DrawTextExA(HDC,LPSTR,int,LPRECT,UINT,LPDRAWTEXTPARAMS);
 int __attribute__((__stdcall__)) DrawTextExW(HDC,LPWSTR,int,LPRECT,UINT,LPDRAWTEXTPARAMS);
 BOOL __attribute__((__stdcall__)) EmptyClipboard(void);
 BOOL __attribute__((__stdcall__)) EnableMenuItem(HMENU,UINT,UINT);
 BOOL __attribute__((__stdcall__)) EnableScrollBar(HWND,UINT,UINT);
 BOOL __attribute__((__stdcall__)) EnableWindow(HWND,BOOL);
 BOOL __attribute__((__stdcall__)) EndDeferWindowPos(HDWP);
 BOOL __attribute__((__stdcall__)) EndDialog(HWND,int);
 BOOL __attribute__((__stdcall__)) EndMenu(void);
 BOOL __attribute__((__stdcall__)) EndPaint(HWND,const PAINTSTRUCT*);



 BOOL __attribute__((__stdcall__)) EnumChildWindows(HWND,ENUMWINDOWSPROC,LPARAM);
 UINT __attribute__((__stdcall__)) EnumClipboardFormats(UINT);
 BOOL __attribute__((__stdcall__)) EnumDesktopsA(HWINSTA,DESKTOPENUMPROCA,LPARAM);
 BOOL __attribute__((__stdcall__)) EnumDesktopsW(HWINSTA,DESKTOPENUMPROCW,LPARAM);
 BOOL __attribute__((__stdcall__)) EnumDesktopWindows(HDESK,ENUMWINDOWSPROC,LPARAM);
 BOOL __attribute__((__stdcall__)) EnumDisplayMonitors(HDC,LPCRECT,MONITORENUMPROC,LPARAM);

 BOOL __attribute__((__stdcall__)) EnumDisplaySettingsA(LPCSTR,DWORD,PDEVMODEA);
 BOOL __attribute__((__stdcall__)) EnumDisplaySettingsW(LPCWSTR,DWORD,PDEVMODEW);




 BOOL __attribute__((__stdcall__)) EnumDisplayDevicesA(LPCSTR,DWORD,PDISPLAY_DEVICEA,DWORD);
 BOOL __attribute__((__stdcall__)) EnumDisplayDevicesW(LPCWSTR,DWORD,PDISPLAY_DEVICEW,DWORD);

 int __attribute__((__stdcall__)) EnumPropsA(HWND,PROPENUMPROCA);
 int __attribute__((__stdcall__)) EnumPropsW(HWND,PROPENUMPROCW);
 int __attribute__((__stdcall__)) EnumPropsExA(HWND,PROPENUMPROCEXA,LPARAM);
 int __attribute__((__stdcall__)) EnumPropsExW(HWND,PROPENUMPROCEXW,LPARAM);

 BOOL __attribute__((__stdcall__)) EnumThreadWindows(DWORD,WNDENUMPROC,LPARAM);
 BOOL __attribute__((__stdcall__)) EnumWindows(WNDENUMPROC,LPARAM);
 BOOL __attribute__((__stdcall__)) EnumWindowStationsA(WINSTAENUMPROCA,LPARAM);
 BOOL __attribute__((__stdcall__)) EnumWindowStationsW(WINSTAENUMPROCW,LPARAM);
 BOOL __attribute__((__stdcall__)) EqualRect(LPCRECT,LPCRECT);

 BOOL __attribute__((__stdcall__)) ExitWindowsEx(UINT,DWORD);
 HWND __attribute__((__stdcall__)) FindWindowA(LPCSTR,LPCSTR);
 HWND __attribute__((__stdcall__)) FindWindowExA(HWND,HWND,LPCSTR,LPCSTR);
 HWND __attribute__((__stdcall__)) FindWindowExW(HWND,HWND,LPCWSTR,LPCWSTR);
 HWND __attribute__((__stdcall__)) FindWindowW(LPCWSTR,LPCWSTR);
 BOOL __attribute__((__stdcall__)) FlashWindow(HWND,BOOL);



int __attribute__((__stdcall__)) FrameRect(HDC,LPCRECT,HBRUSH);
 BOOL __attribute__((__stdcall__)) FrameRgn(HDC,HRGN,HBRUSH,int,int);
 HWND __attribute__((__stdcall__)) GetActiveWindow(void);
 HWND __attribute__((__stdcall__)) GetAncestor(HWND,UINT);
 SHORT __attribute__((__stdcall__)) GetAsyncKeyState(int);
 HWND __attribute__((__stdcall__)) GetCapture(void);
 UINT __attribute__((__stdcall__)) GetCaretBlinkTime(void);
 BOOL __attribute__((__stdcall__)) GetCaretPos(LPPOINT);
 BOOL __attribute__((__stdcall__)) GetClassInfoA(HINSTANCE,LPCSTR,LPWNDCLASSA);
 BOOL __attribute__((__stdcall__)) GetClassInfoExA(HINSTANCE,LPCSTR,LPWNDCLASSEXA);
 BOOL __attribute__((__stdcall__)) GetClassInfoW(HINSTANCE,LPCWSTR,LPWNDCLASSW);
 BOOL __attribute__((__stdcall__)) GetClassInfoExW(HINSTANCE,LPCWSTR,LPWNDCLASSEXW);
 DWORD __attribute__((__stdcall__)) GetClassLongA(HWND,int);
 DWORD __attribute__((__stdcall__)) GetClassLongW(HWND,int);







 int __attribute__((__stdcall__)) GetClassNameA(HWND,LPSTR,int);
 int __attribute__((__stdcall__)) GetClassNameW(HWND,LPWSTR,int);
 WORD __attribute__((__stdcall__)) GetClassWord(HWND,int);
 BOOL __attribute__((__stdcall__)) GetClientRect(HWND,LPRECT);
 HANDLE __attribute__((__stdcall__)) GetClipboardData(UINT);
 int __attribute__((__stdcall__)) GetClipboardFormatNameA(UINT,LPSTR,int);
 int __attribute__((__stdcall__)) GetClipboardFormatNameW(UINT,LPWSTR,int);
 HWND __attribute__((__stdcall__)) GetClipboardOwner(void);



HWND __attribute__((__stdcall__)) GetClipboardViewer(void);
 BOOL __attribute__((__stdcall__)) GetClipCursor(LPRECT);
 BOOL __attribute__((__stdcall__)) GetCursorPos(LPPOINT);
 HDC __attribute__((__stdcall__)) GetDC(HWND);
 HDC __attribute__((__stdcall__)) GetDCEx(HWND,HRGN,DWORD);
 HWND __attribute__((__stdcall__)) GetDesktopWindow(void);
 long __attribute__((__stdcall__)) GetDialogBaseUnits(void);
 int __attribute__((__stdcall__)) GetDlgCtrlID(HWND);
 HWND __attribute__((__stdcall__)) GetDlgItem(HWND,int);
 UINT __attribute__((__stdcall__)) GetDlgItemInt(HWND,int,PBOOL,BOOL);
 UINT __attribute__((__stdcall__)) GetDlgItemTextA(HWND,int,LPSTR,int);
 UINT __attribute__((__stdcall__)) GetDlgItemTextW(HWND,int,LPWSTR,int);
 UINT __attribute__((__stdcall__)) GetDoubleClickTime(void);
 HWND __attribute__((__stdcall__)) GetFocus(void);
 HWND __attribute__((__stdcall__)) GetForegroundWindow(void);



 BOOL __attribute__((__stdcall__)) GetIconInfo(HICON,PICONINFO);
 BOOL __attribute__((__stdcall__)) GetInputState(void);
 UINT __attribute__((__stdcall__)) GetKBCodePage(void);
 HKL __attribute__((__stdcall__)) GetKeyboardLayout(DWORD);
 UINT __attribute__((__stdcall__)) GetKeyboardLayoutList(int,HKL*);
 BOOL __attribute__((__stdcall__)) GetKeyboardLayoutNameA(LPSTR);
 BOOL __attribute__((__stdcall__)) GetKeyboardLayoutNameW(LPWSTR);
 BOOL __attribute__((__stdcall__)) GetKeyboardState(PBYTE);
 int __attribute__((__stdcall__)) GetKeyboardType(int);
 int __attribute__((__stdcall__)) GetKeyNameTextA(LONG,LPSTR,int);
 int __attribute__((__stdcall__)) GetKeyNameTextW(LONG,LPWSTR,int);
 SHORT __attribute__((__stdcall__)) GetKeyState(int);
 HWND __attribute__((__stdcall__)) GetLastActivePopup(HWND);
 HMENU __attribute__((__stdcall__)) GetMenu(HWND);
 LONG __attribute__((__stdcall__)) GetMenuCheckMarkDimensions(void);
 DWORD __attribute__((__stdcall__)) GetMenuContextHelpId(HMENU);
 UINT __attribute__((__stdcall__)) GetMenuDefaultItem(HMENU,UINT,UINT);
 int __attribute__((__stdcall__)) GetMenuItemCount(HMENU);
 UINT __attribute__((__stdcall__)) GetMenuItemID(HMENU,int);
 BOOL __attribute__((__stdcall__)) GetMenuItemInfoA(HMENU,UINT,BOOL,LPMENUITEMINFOA);
 BOOL __attribute__((__stdcall__)) GetMenuItemInfoW(HMENU,UINT,BOOL,LPMENUITEMINFOW);
 BOOL __attribute__((__stdcall__)) GetMenuItemRect(HWND,HMENU,UINT,LPRECT);
 UINT __attribute__((__stdcall__)) GetMenuState(HMENU,UINT,UINT);
 int __attribute__((__stdcall__)) GetMenuStringA(HMENU,UINT,LPSTR,int,UINT);
 int __attribute__((__stdcall__)) GetMenuStringW(HMENU,UINT,LPWSTR,int,UINT);
 BOOL __attribute__((__stdcall__)) GetMessageA(LPMSG,HWND,UINT,UINT);
 BOOL __attribute__((__stdcall__)) GetMessageW(LPMSG,HWND,UINT,UINT);
 LONG __attribute__((__stdcall__)) GetMessageExtraInfo(void);
 DWORD __attribute__((__stdcall__)) GetMessagePos(void);
 LONG __attribute__((__stdcall__)) GetMessageTime(void);



 HWND __attribute__((__stdcall__)) GetNextDlgGroupItem(HWND,HWND,BOOL);
 HWND __attribute__((__stdcall__)) GetNextDlgTabItem(HWND,HWND,BOOL);

 HWND __attribute__((__stdcall__)) GetOpenClipboardWindow(void);
 HWND __attribute__((__stdcall__)) GetParent(HWND);
 int __attribute__((__stdcall__)) GetPriorityClipboardFormat(UINT*,int);
 HANDLE __attribute__((__stdcall__)) GetPropA(HWND,LPCSTR);
 HANDLE __attribute__((__stdcall__)) GetPropW(HWND,LPCWSTR);
# 3549 "H:/CPP/wxdevcpp6.10/include/winuser.h" 3
 DWORD __attribute__((__stdcall__)) GetQueueStatus(UINT);
 BOOL __attribute__((__stdcall__)) GetScrollInfo(HWND,int,LPSCROLLINFO);
 int __attribute__((__stdcall__)) GetScrollPos(HWND,int);
 BOOL __attribute__((__stdcall__)) GetScrollRange(HWND,int,LPINT,LPINT);



 HMENU __attribute__((__stdcall__)) GetSubMenu(HMENU,int);
 DWORD __attribute__((__stdcall__)) GetSysColor(int);
 HBRUSH __attribute__((__stdcall__)) GetSysColorBrush(int);

 HMENU __attribute__((__stdcall__)) GetSystemMenu(HWND,BOOL);
 int __attribute__((__stdcall__)) GetSystemMetrics(int);
 DWORD __attribute__((__stdcall__)) GetTabbedTextExtentA(HDC,LPCSTR,int,int,LPINT);
 DWORD __attribute__((__stdcall__)) GetTabbedTextExtentW(HDC,LPCWSTR,int,int,LPINT);
 LONG __attribute__((__stdcall__)) GetWindowLongA(HWND,int);
 LONG __attribute__((__stdcall__)) GetWindowLongW(HWND,int);







 HDESK __attribute__((__stdcall__)) GetThreadDesktop(DWORD);
 HWND __attribute__((__stdcall__)) GetTopWindow(HWND);
 BOOL __attribute__((__stdcall__)) GetUpdateRect(HWND,LPRECT,BOOL);
 int __attribute__((__stdcall__)) GetUpdateRgn(HWND,HRGN,BOOL);
 BOOL __attribute__((__stdcall__)) GetUserObjectInformationA(HANDLE,int,PVOID,DWORD,PDWORD);
 BOOL __attribute__((__stdcall__)) GetUserObjectInformationW(HANDLE,int,PVOID,DWORD,PDWORD);
 BOOL __attribute__((__stdcall__)) GetUserObjectSecurity(HANDLE,PSECURITY_INFORMATION,PSECURITY_DESCRIPTOR,DWORD,PDWORD);
 HWND __attribute__((__stdcall__)) GetWindow(HWND,UINT);
 DWORD __attribute__((__stdcall__)) GetWindowContextHelpId(HWND);
 HDC __attribute__((__stdcall__)) GetWindowDC(HWND);
 BOOL __attribute__((__stdcall__)) GetWindowExtEx(HDC,LPSIZE);
 BOOL __attribute__((__stdcall__)) GetWindowPlacement(HWND,WINDOWPLACEMENT*);
 BOOL __attribute__((__stdcall__)) GetWindowRect(HWND,LPRECT);
 int __attribute__((__stdcall__)) GetWindowRgn(HWND,HRGN);

 int __attribute__((__stdcall__)) GetWindowTextA(HWND,LPSTR,int);
 int __attribute__((__stdcall__)) GetWindowTextLengthA(HWND);
 int __attribute__((__stdcall__)) GetWindowTextLengthW(HWND);
 int __attribute__((__stdcall__)) GetWindowTextW(HWND,LPWSTR,int);
 WORD __attribute__((__stdcall__)) GetWindowWord(HWND,int);
 BOOL __attribute__((__stdcall__)) GetAltTabInfoA(HWND,int,PALTTABINFO,LPSTR,UINT);
 BOOL __attribute__((__stdcall__)) GetAltTabInfoW(HWND,int,PALTTABINFO,LPWSTR,UINT);
 BOOL __attribute__((__stdcall__)) GetComboBoxInfo(HWND,PCOMBOBOXINFO);
 BOOL __attribute__((__stdcall__)) GetCursorInfo(PCURSORINFO);



 BOOL __attribute__((__stdcall__)) GetLastInputInfo(PLASTINPUTINFO);
 DWORD __attribute__((__stdcall__)) GetListBoxInfo(HWND);
 BOOL __attribute__((__stdcall__)) GetMenuBarInfo(HWND,LONG,LONG,PMENUBARINFO);
 BOOL __attribute__((__stdcall__)) GetMenuInfo(HMENU,LPMENUINFO);



 BOOL __attribute__((__stdcall__)) GetScrollBarInfo(HWND,LONG,PSCROLLBARINFO);
 BOOL __attribute__((__stdcall__)) GetTitleBarInfo(HWND,PTITLEBARINFO);
 BOOL __attribute__((__stdcall__)) GetWindowInfo(HWND,PWINDOWINFO);
 BOOL __attribute__((__stdcall__)) GetMonitorInfoA(HMONITOR,LPMONITORINFO);
 BOOL __attribute__((__stdcall__)) GetMonitorInfoW(HMONITOR,LPMONITORINFO);
 UINT __attribute__((__stdcall__)) GetWindowModuleFileNameA(HWND,LPSTR,UINT);
 UINT __attribute__((__stdcall__)) GetWindowModuleFileNameW(HWND,LPWSTR,UINT);
 BOOL __attribute__((__stdcall__)) GrayStringA(HDC,HBRUSH,GRAYSTRINGPROC,LPARAM,int,int,int,int,int);
 BOOL __attribute__((__stdcall__)) GrayStringW(HDC,HBRUSH,GRAYSTRINGPROC,LPARAM,int,int,int,int,int);
 BOOL __attribute__((__stdcall__)) HideCaret(HWND);
 BOOL __attribute__((__stdcall__)) HiliteMenuItem(HWND,HMENU,UINT,UINT);
 BOOL __attribute__((__stdcall__)) InflateRect(LPRECT,int,int);
 BOOL __attribute__((__stdcall__)) InSendMessage(void);



 BOOL __attribute__((__stdcall__)) InsertMenuA(HMENU,UINT,UINT,UINT,LPCSTR);
 BOOL __attribute__((__stdcall__)) InsertMenuW(HMENU,UINT,UINT,UINT,LPCWSTR);
 BOOL __attribute__((__stdcall__)) InsertMenuItemA(HMENU,UINT,BOOL,LPCMENUITEMINFOA);
 BOOL __attribute__((__stdcall__)) InsertMenuItemW(HMENU,UINT,BOOL,LPCMENUITEMINFOW);
 INT __attribute__((__stdcall__)) InternalGetWindowText(HWND,LPWSTR,INT);
 BOOL __attribute__((__stdcall__)) IntersectRect(LPRECT,LPCRECT,LPCRECT);
 BOOL __attribute__((__stdcall__)) InvalidateRect(HWND,LPCRECT,BOOL);
 BOOL __attribute__((__stdcall__)) InvalidateRgn(HWND,HRGN,BOOL);
 BOOL __attribute__((__stdcall__)) InvertRect(HDC,LPCRECT);
 BOOL __attribute__((__stdcall__)) IsCharAlphaA(CHAR ch);
 BOOL __attribute__((__stdcall__)) IsCharAlphaNumericA(CHAR);
 BOOL __attribute__((__stdcall__)) IsCharAlphaNumericW(WCHAR);
 BOOL __attribute__((__stdcall__)) IsCharAlphaW(WCHAR);
 BOOL __attribute__((__stdcall__)) IsCharLowerA(CHAR);
 BOOL __attribute__((__stdcall__)) IsCharLowerW(WCHAR);
 BOOL __attribute__((__stdcall__)) IsCharUpperA(CHAR);
 BOOL __attribute__((__stdcall__)) IsCharUpperW(WCHAR);
 BOOL __attribute__((__stdcall__)) IsChild(HWND,HWND);
 BOOL __attribute__((__stdcall__)) IsClipboardFormatAvailable(UINT);
 BOOL __attribute__((__stdcall__)) IsDialogMessageA(HWND,LPMSG);
 BOOL __attribute__((__stdcall__)) IsDialogMessageW(HWND,LPMSG);
 UINT __attribute__((__stdcall__)) IsDlgButtonChecked(HWND,int);






 BOOL __attribute__((__stdcall__)) IsIconic(HWND);
 BOOL __attribute__((__stdcall__)) IsMenu(HMENU);
 BOOL __attribute__((__stdcall__)) IsRectEmpty(LPCRECT);
 BOOL __attribute__((__stdcall__)) IsWindow(HWND);
 BOOL __attribute__((__stdcall__)) IsWindowEnabled(HWND);
 BOOL __attribute__((__stdcall__)) IsWindowUnicode(HWND);
 BOOL __attribute__((__stdcall__)) IsWindowVisible(HWND);



 BOOL __attribute__((__stdcall__)) IsZoomed(HWND);
 void __attribute__((__stdcall__)) keybd_event(BYTE,BYTE,DWORD,DWORD);
 BOOL __attribute__((__stdcall__)) KillTimer(HWND,UINT);
 HACCEL __attribute__((__stdcall__)) LoadAcceleratorsA(HINSTANCE,LPCSTR);
 HACCEL __attribute__((__stdcall__)) LoadAcceleratorsW(HINSTANCE,LPCWSTR);
 HBITMAP __attribute__((__stdcall__)) LoadBitmapA(HINSTANCE,LPCSTR);
 HBITMAP __attribute__((__stdcall__)) LoadBitmapW(HINSTANCE,LPCWSTR);
 HCURSOR __attribute__((__stdcall__)) LoadCursorA(HINSTANCE,LPCSTR);
 HCURSOR __attribute__((__stdcall__)) LoadCursorFromFileA(LPCSTR);
 HCURSOR __attribute__((__stdcall__)) LoadCursorFromFileW(LPCWSTR);
 HCURSOR __attribute__((__stdcall__)) LoadCursorW(HINSTANCE,LPCWSTR);
 HICON __attribute__((__stdcall__)) LoadIconA(HINSTANCE,LPCSTR);
 HICON __attribute__((__stdcall__)) LoadIconW(HINSTANCE,LPCWSTR);
 HANDLE __attribute__((__stdcall__)) LoadImageA(HINSTANCE,LPCSTR,UINT,int,int,UINT);
 HANDLE __attribute__((__stdcall__)) LoadImageW(HINSTANCE,LPCWSTR,UINT,int,int,UINT);
 HKL __attribute__((__stdcall__)) LoadKeyboardLayoutA(LPCSTR,UINT);
 HKL __attribute__((__stdcall__)) LoadKeyboardLayoutW(LPCWSTR,UINT);
 HMENU __attribute__((__stdcall__)) LoadMenuA(HINSTANCE,LPCSTR);
 HMENU __attribute__((__stdcall__)) LoadMenuIndirectA(const MENUTEMPLATE*);
 HMENU __attribute__((__stdcall__)) LoadMenuIndirectW(const MENUTEMPLATE*);
 HMENU __attribute__((__stdcall__)) LoadMenuW(HINSTANCE,LPCWSTR);
 int __attribute__((__stdcall__)) LoadStringA(HINSTANCE,UINT,LPSTR,int);
 int __attribute__((__stdcall__)) LoadStringW(HINSTANCE,UINT,LPWSTR,int);
 BOOL __attribute__((__stdcall__)) LockWindowUpdate(HWND);



 int __attribute__((__stdcall__)) LookupIconIdFromDirectory(PBYTE,BOOL);
 int __attribute__((__stdcall__)) LookupIconIdFromDirectoryEx(PBYTE,BOOL,int,int,UINT);
 BOOL __attribute__((__stdcall__)) MapDialogRect(HWND,LPRECT);
 UINT __attribute__((__stdcall__)) MapVirtualKeyA(UINT,UINT);
 UINT __attribute__((__stdcall__)) MapVirtualKeyExA(UINT,UINT,HKL);
 UINT __attribute__((__stdcall__)) MapVirtualKeyExW(UINT,UINT,HKL);
 UINT __attribute__((__stdcall__)) MapVirtualKeyW(UINT,UINT);
 int __attribute__((__stdcall__)) MapWindowPoints(HWND,HWND,LPPOINT,UINT);
 int __attribute__((__stdcall__)) MenuItemFromPoint(HWND,HMENU,POINT);
 BOOL __attribute__((__stdcall__)) MessageBeep(UINT);
 int __attribute__((__stdcall__)) MessageBoxA(HWND,LPCSTR,LPCSTR,UINT);
 int __attribute__((__stdcall__)) MessageBoxW(HWND,LPCWSTR,LPCWSTR,UINT);
 int __attribute__((__stdcall__)) MessageBoxExA(HWND,LPCSTR,LPCSTR,UINT,WORD);
 int __attribute__((__stdcall__)) MessageBoxExW(HWND,LPCWSTR,LPCWSTR,UINT,WORD);
 int __attribute__((__stdcall__)) MessageBoxIndirectA(const MSGBOXPARAMSA*);
 int __attribute__((__stdcall__)) MessageBoxIndirectW(const MSGBOXPARAMSW*);
 BOOL __attribute__((__stdcall__)) ModifyMenuA(HMENU,UINT,UINT,UINT,LPCSTR);
 BOOL __attribute__((__stdcall__)) ModifyMenuW(HMENU,UINT,UINT,UINT,LPCWSTR);





 void __attribute__((__stdcall__)) mouse_event(DWORD,DWORD,DWORD,DWORD,ULONG_PTR);
 BOOL __attribute__((__stdcall__)) MoveWindow(HWND,int,int,int,int,BOOL);
 DWORD __attribute__((__stdcall__)) MsgWaitForMultipleObjects(DWORD,const HANDLE*,BOOL,DWORD,DWORD);
 DWORD __attribute__((__stdcall__)) MsgWaitForMultipleObjectsEx(DWORD,const HANDLE*,DWORD,DWORD,DWORD);



 DWORD __attribute__((__stdcall__)) OemKeyScan(WORD);
 BOOL __attribute__((__stdcall__)) OemToCharA(LPCSTR,LPSTR);
 BOOL __attribute__((__stdcall__)) OemToCharBuffA(LPCSTR,LPSTR,DWORD);
 BOOL __attribute__((__stdcall__)) OemToCharBuffW(LPCSTR,LPWSTR,DWORD);
 BOOL __attribute__((__stdcall__)) OemToCharW(LPCSTR,LPWSTR);
 BOOL __attribute__((__stdcall__)) OffsetRect(LPRECT,int,int);
 BOOL __attribute__((__stdcall__)) OpenClipboard(HWND);
 HDESK __attribute__((__stdcall__)) OpenDesktopA(LPSTR,DWORD,BOOL,DWORD);
 HDESK __attribute__((__stdcall__)) OpenDesktopW(LPWSTR,DWORD,BOOL,DWORD);
 BOOL __attribute__((__stdcall__)) OpenIcon(HWND);
 HDESK __attribute__((__stdcall__)) OpenInputDesktop(DWORD,BOOL,DWORD);
 HWINSTA __attribute__((__stdcall__)) OpenWindowStationA(LPSTR,BOOL,DWORD);
 HWINSTA __attribute__((__stdcall__)) OpenWindowStationW(LPWSTR,BOOL,DWORD);
 BOOL __attribute__((__stdcall__)) PaintDesktop(HDC);
 BOOL __attribute__((__stdcall__)) PeekMessageA(LPMSG,HWND,UINT,UINT,UINT);
 BOOL __attribute__((__stdcall__)) PeekMessageW(LPMSG,HWND,UINT,UINT,UINT);


 BOOL __attribute__((__stdcall__)) PostMessageA(HWND,UINT,WPARAM,LPARAM);
 BOOL __attribute__((__stdcall__)) PostMessageW(HWND,UINT,WPARAM,LPARAM);
 void __attribute__((__stdcall__)) PostQuitMessage(int);
 BOOL __attribute__((__stdcall__)) PostThreadMessageA(DWORD,UINT,WPARAM,LPARAM);
 BOOL __attribute__((__stdcall__)) PostThreadMessageW(DWORD,UINT,WPARAM,LPARAM);



 BOOL __attribute__((__stdcall__)) PtInRect(LPCRECT,POINT);
 HWND __attribute__((__stdcall__)) RealChildWindowFromPoint(HWND,POINT);
 UINT __attribute__((__stdcall__)) RealGetWindowClassA(HWND,LPSTR,UINT);
 UINT __attribute__((__stdcall__)) RealGetWindowClassW(HWND,LPWSTR,UINT);
 BOOL __attribute__((__stdcall__)) RedrawWindow(HWND,LPCRECT,HRGN,UINT);
 ATOM __attribute__((__stdcall__)) RegisterClassA(const WNDCLASSA*);
 ATOM __attribute__((__stdcall__)) RegisterClassW(const WNDCLASSW*);
 ATOM __attribute__((__stdcall__)) RegisterClassExA(const WNDCLASSEXA*);
 ATOM __attribute__((__stdcall__)) RegisterClassExW(const WNDCLASSEXW*);
 UINT __attribute__((__stdcall__)) RegisterClipboardFormatA(LPCSTR);
 UINT __attribute__((__stdcall__)) RegisterClipboardFormatW(LPCWSTR);




 BOOL __attribute__((__stdcall__)) RegisterHotKey(HWND,int,UINT,UINT);



 UINT __attribute__((__stdcall__)) RegisterWindowMessageA(LPCSTR);
 UINT __attribute__((__stdcall__)) RegisterWindowMessageW(LPCWSTR);
 BOOL __attribute__((__stdcall__)) ReleaseCapture(void);
 int __attribute__((__stdcall__)) ReleaseDC(HWND,HDC);
 BOOL __attribute__((__stdcall__)) RemoveMenu(HMENU,UINT,UINT);
 HANDLE __attribute__((__stdcall__)) RemovePropA(HWND,LPCSTR);
 HANDLE __attribute__((__stdcall__)) RemovePropW(HWND,LPCWSTR);
 BOOL __attribute__((__stdcall__)) ReplyMessage(LRESULT);
 BOOL __attribute__((__stdcall__)) ScreenToClient(HWND,LPPOINT);
 BOOL __attribute__((__stdcall__)) ScrollDC(HDC,int,int,LPCRECT,LPCRECT,HRGN,LPRECT);
 BOOL __attribute__((__stdcall__)) ScrollWindow(HWND,int,int,LPCRECT,LPCRECT);
 int __attribute__((__stdcall__)) ScrollWindowEx(HWND,int,int,LPCRECT,LPCRECT,HRGN,LPRECT,UINT);
 LONG __attribute__((__stdcall__)) SendDlgItemMessageA(HWND,int,UINT,WPARAM,LPARAM);
 LONG __attribute__((__stdcall__)) SendDlgItemMessageW(HWND,int,UINT,WPARAM,LPARAM);



 LRESULT __attribute__((__stdcall__)) SendMessageA(HWND,UINT,WPARAM,LPARAM);
 BOOL __attribute__((__stdcall__)) SendMessageCallbackA(HWND,UINT,WPARAM,LPARAM,SENDASYNCPROC,DWORD);
 BOOL __attribute__((__stdcall__)) SendMessageCallbackW(HWND,UINT,WPARAM,LPARAM,SENDASYNCPROC,DWORD);
 LRESULT __attribute__((__stdcall__)) SendMessageTimeoutA(HWND,UINT,WPARAM,LPARAM,UINT,UINT,PDWORD);
 LRESULT __attribute__((__stdcall__)) SendMessageTimeoutW(HWND,UINT,WPARAM,LPARAM,UINT,UINT,PDWORD);
 LRESULT __attribute__((__stdcall__)) SendMessageW(HWND,UINT,WPARAM,LPARAM);
 BOOL __attribute__((__stdcall__)) SendNotifyMessageA(HWND,UINT,WPARAM,LPARAM);
 BOOL __attribute__((__stdcall__)) SendNotifyMessageW(HWND,UINT,WPARAM,LPARAM);
 HWND __attribute__((__stdcall__)) SetActiveWindow(HWND);
 HWND __attribute__((__stdcall__)) SetCapture(HWND hWnd);
 BOOL __attribute__((__stdcall__)) SetCaretBlinkTime(UINT);
 BOOL __attribute__((__stdcall__)) SetCaretPos(int,int);
 DWORD __attribute__((__stdcall__)) SetClassLongA(HWND,int,LONG);
 DWORD __attribute__((__stdcall__)) SetClassLongW(HWND,int,LONG);







 WORD __attribute__((__stdcall__)) SetClassWord(HWND,int,WORD);
 HANDLE __attribute__((__stdcall__)) SetClipboardData(UINT,HANDLE);
 HWND __attribute__((__stdcall__)) SetClipboardViewer(HWND);
 HCURSOR __attribute__((__stdcall__)) SetCursor(HCURSOR);
 BOOL __attribute__((__stdcall__)) SetCursorPos(int,int);
 void __attribute__((__stdcall__)) SetDebugErrorLevel(DWORD);
 BOOL __attribute__((__stdcall__)) SetDlgItemInt(HWND,int,UINT,BOOL);
 BOOL __attribute__((__stdcall__)) SetDlgItemTextA(HWND,int,LPCSTR);
 BOOL __attribute__((__stdcall__)) SetDlgItemTextW(HWND,int,LPCWSTR);
 BOOL __attribute__((__stdcall__)) SetDoubleClickTime(UINT);
 HWND __attribute__((__stdcall__)) SetFocus(HWND);
 BOOL __attribute__((__stdcall__)) SetForegroundWindow(HWND);
 BOOL __attribute__((__stdcall__)) SetKeyboardState(PBYTE);
 BOOL __attribute__((__stdcall__)) SetMenu(HWND,HMENU);
 BOOL __attribute__((__stdcall__)) SetMenuContextHelpId(HMENU,DWORD);
 BOOL __attribute__((__stdcall__)) SetMenuDefaultItem(HMENU,UINT,UINT);
 BOOL __attribute__((__stdcall__)) SetMenuInfo(HMENU,LPCMENUINFO);
 BOOL __attribute__((__stdcall__)) SetMenuItemBitmaps(HMENU,UINT,UINT,HBITMAP,HBITMAP);
 BOOL __attribute__((__stdcall__)) SetMenuItemInfoA(HMENU,UINT,BOOL,LPCMENUITEMINFOA);
 BOOL __attribute__((__stdcall__)) SetMenuItemInfoW( HMENU,UINT,BOOL,LPCMENUITEMINFOW);
 LPARAM __attribute__((__stdcall__)) SetMessageExtraInfo(LPARAM);
 BOOL __attribute__((__stdcall__)) SetMessageQueue(int);
 HWND __attribute__((__stdcall__)) SetParent(HWND,HWND);



 BOOL __attribute__((__stdcall__)) SetProcessWindowStation(HWINSTA);
 BOOL __attribute__((__stdcall__)) SetPropA(HWND,LPCSTR,HANDLE);
 BOOL __attribute__((__stdcall__)) SetPropW(HWND,LPCWSTR,HANDLE);
 BOOL __attribute__((__stdcall__)) SetRect(LPRECT,int,int,int,int);
 BOOL __attribute__((__stdcall__)) SetRectEmpty(LPRECT);
 int __attribute__((__stdcall__)) SetScrollInfo(HWND,int,LPCSCROLLINFO,BOOL);
 int __attribute__((__stdcall__)) SetScrollPos(HWND,int,int,BOOL);
 BOOL __attribute__((__stdcall__)) SetScrollRange(HWND,int,int,int,BOOL);
 BOOL __attribute__((__stdcall__)) SetSysColors(int,const INT *,const COLORREF *);

 BOOL __attribute__((__stdcall__)) SetSystemCursor(HCURSOR,DWORD);
 BOOL __attribute__((__stdcall__)) SetThreadDesktop(HDESK);
 UINT __attribute__((__stdcall__)) SetTimer(HWND,UINT,UINT,TIMERPROC);
 BOOL __attribute__((__stdcall__)) SetUserObjectInformationA(HANDLE,int,PVOID,DWORD);
 BOOL __attribute__((__stdcall__)) SetUserObjectInformationW(HANDLE,int,PVOID,DWORD);
 BOOL __attribute__((__stdcall__)) SetUserObjectSecurity(HANDLE,PSECURITY_INFORMATION,PSECURITY_DESCRIPTOR);



 BOOL __attribute__((__stdcall__)) SetWindowContextHelpId(HWND,DWORD);
 LONG __attribute__((__stdcall__)) SetWindowLongA(HWND,int,LONG);
 LONG __attribute__((__stdcall__)) SetWindowLongW(HWND,int,LONG);







 BOOL __attribute__((__stdcall__)) SetWindowPlacement(HWND hWnd,const WINDOWPLACEMENT*);
 BOOL __attribute__((__stdcall__)) SetWindowPos(HWND,HWND,int,int,int,int,UINT);
 int __attribute__((__stdcall__)) SetWindowRgn(HWND,HRGN,BOOL);
 HHOOK __attribute__((__stdcall__)) SetWindowsHookA(int,HOOKPROC);
 HHOOK __attribute__((__stdcall__)) SetWindowsHookW(int,HOOKPROC);
 HHOOK __attribute__((__stdcall__)) SetWindowsHookExA(int,HOOKPROC,HINSTANCE,DWORD);
 HHOOK __attribute__((__stdcall__)) SetWindowsHookExW(int,HOOKPROC,HINSTANCE,DWORD);
 BOOL __attribute__((__stdcall__)) SetWindowTextA(HWND,LPCSTR);
 BOOL __attribute__((__stdcall__)) SetWindowTextW(HWND,LPCWSTR);
 WORD __attribute__((__stdcall__)) SetWindowWord(HWND,int,WORD);
 BOOL __attribute__((__stdcall__)) ShowCaret(HWND);
 int __attribute__((__stdcall__)) ShowCursor(BOOL);
 BOOL __attribute__((__stdcall__)) ShowOwnedPopups(HWND,BOOL);
 BOOL __attribute__((__stdcall__)) ShowScrollBar(HWND,int,BOOL);
 BOOL __attribute__((__stdcall__)) ShowWindow(HWND,int);
 BOOL __attribute__((__stdcall__)) ShowWindowAsync(HWND,int);
 BOOL __attribute__((__stdcall__)) SubtractRect(LPRECT,LPCRECT,LPCRECT);
 BOOL __attribute__((__stdcall__)) SwapMouseButton(BOOL);
 BOOL __attribute__((__stdcall__)) SwitchDesktop(HDESK);



 BOOL __attribute__((__stdcall__)) SystemParametersInfoA(UINT,UINT,PVOID,UINT);
 BOOL __attribute__((__stdcall__)) SystemParametersInfoW(UINT,UINT,PVOID,UINT);
 LONG __attribute__((__stdcall__)) TabbedTextOutA(HDC,int,int,LPCSTR,int,int,LPINT,int);
 LONG __attribute__((__stdcall__)) TabbedTextOutW(HDC,int,int,LPCWSTR,int,int,LPINT,int);
 WORD __attribute__((__stdcall__)) TileWindows(HWND,UINT,LPCRECT,UINT,const HWND *);
 int __attribute__((__stdcall__)) ToAscii(UINT,UINT,PBYTE,LPWORD,UINT);
 int __attribute__((__stdcall__)) ToAsciiEx(UINT,UINT,PBYTE,LPWORD,UINT,HKL);
 int __attribute__((__stdcall__)) ToUnicode(UINT,UINT,PBYTE,LPWSTR,int,UINT);
 int __attribute__((__stdcall__)) ToUnicodeEx(UINT,UINT,PBYTE,LPWSTR,int,UINT,HKL);
 BOOL __attribute__((__stdcall__)) TrackMouseEvent(LPTRACKMOUSEEVENT);
 BOOL __attribute__((__stdcall__)) TrackPopupMenu(HMENU,UINT,int,int,int,HWND,LPCRECT);
 BOOL __attribute__((__stdcall__)) TrackPopupMenuEx(HMENU,UINT,int,int,HWND,LPTPMPARAMS);
 int __attribute__((__stdcall__)) TranslateAcceleratorA(HWND,HACCEL,LPMSG);
 int __attribute__((__stdcall__)) TranslateAcceleratorW(HWND,HACCEL,LPMSG);
 BOOL __attribute__((__stdcall__)) TranslateMDISysAccel(HWND,LPMSG);
 BOOL __attribute__((__stdcall__)) TranslateMessage(const MSG*);
 BOOL __attribute__((__stdcall__)) UnhookWindowsHook(int,HOOKPROC);
 BOOL __attribute__((__stdcall__)) UnhookWindowsHookEx(HHOOK);



 BOOL __attribute__((__stdcall__)) UnionRect(LPRECT,LPCRECT,LPCRECT);
 BOOL __attribute__((__stdcall__)) UnloadKeyboardLayout(HKL);
 BOOL __attribute__((__stdcall__)) UnregisterClassA(LPCSTR,HINSTANCE);
 BOOL __attribute__((__stdcall__)) UnregisterClassW(LPCWSTR,HINSTANCE);



 BOOL __attribute__((__stdcall__)) UnregisterHotKey(HWND,int);
 BOOL __attribute__((__stdcall__)) UpdateWindow(HWND);



 BOOL __attribute__((__stdcall__)) ValidateRect(HWND,LPCRECT);
 BOOL __attribute__((__stdcall__)) ValidateRgn(HWND,HRGN);
 SHORT __attribute__((__stdcall__)) VkKeyScanA(CHAR);
 SHORT __attribute__((__stdcall__)) VkKeyScanExA(CHAR,HKL);
 SHORT __attribute__((__stdcall__)) VkKeyScanExW(WCHAR,HKL);
 SHORT __attribute__((__stdcall__)) VkKeyScanW(WCHAR);
 DWORD __attribute__((__stdcall__)) WaitForInputIdle(HANDLE,DWORD);
 BOOL __attribute__((__stdcall__)) WaitMessage(void);
 HWND __attribute__((__stdcall__)) WindowFromDC(HDC hDC);
 HWND __attribute__((__stdcall__)) WindowFromPoint(POINT);
 UINT __attribute__((__stdcall__)) WinExec(LPCSTR,UINT);
 BOOL __attribute__((__stdcall__)) WinHelpA(HWND,LPCSTR,UINT,DWORD);
 BOOL __attribute__((__stdcall__)) WinHelpW(HWND,LPCWSTR,UINT,DWORD);
 int __attribute__((__cdecl__)) wsprintfA(LPSTR,LPCSTR,...);
 int __attribute__((__cdecl__)) wsprintfW(LPWSTR,LPCWSTR,...);
 int __attribute__((__stdcall__)) wvsprintfA(LPSTR,LPCSTR,va_list arglist);
 int __attribute__((__stdcall__)) wvsprintfW(LPWSTR,LPCWSTR,va_list arglist);
# 4117 "H:/CPP/wxdevcpp6.10/include/winuser.h" 3
typedef WNDCLASSA WNDCLASS,*LPWNDCLASS,*PWNDCLASS;
typedef WNDCLASSEXA WNDCLASSEX,*LPWNDCLASSEX,*PWNDCLASSEX;
typedef MENUITEMINFOA MENUITEMINFO,*LPMENUITEMINFO;
typedef LPCMENUITEMINFOA LPCMENUITEMINFO;
typedef MSGBOXPARAMSA MSGBOXPARAMS,*PMSGBOXPARAMS,*LPMSGBOXPARAMS;
typedef HIGHCONTRASTA HIGHCONTRAST,*LPHIGHCONTRAST;
typedef SERIALKEYSA SERIALKEYS,*LPSERIALKEYS;
typedef SOUNDSENTRYA SOUNDSENTRY,*LPSOUNDSENTRY;
typedef CREATESTRUCTA CREATESTRUCT, *LPCREATESTRUCT;
typedef CBT_CREATEWNDA CBT_CREATEWND, *LPCBT_CREATEWND;
typedef MDICREATESTRUCTA MDICREATESTRUCT,*LPMDICREATESTRUCT;
typedef MULTIKEYHELPA MULTIKEYHELP,*PMULTIKEYHELP,*LPMULTIKEYHELP;
typedef MONITORINFOEXA MONITORINFOEX, *LPMONITORINFOEX;
# 4266 "H:/CPP/wxdevcpp6.10/include/winuser.h" 3
typedef ICONMETRICSA ICONMETRICS,*LPICONMETRICS;
typedef NONCLIENTMETRICSA NONCLIENTMETRICS,*LPNONCLIENTMETRICS;
# 4279 "H:/CPP/wxdevcpp6.10/include/winuser.h" 3
}
# 56 "H:/CPP/wxdevcpp6.10/include/windows.h" 2 3


# 1 "H:/CPP/wxdevcpp6.10/include/winnls.h" 1 3



       
# 5 "H:/CPP/wxdevcpp6.10/include/winnls.h" 3
# 16 "H:/CPP/wxdevcpp6.10/include/winnls.h" 3
extern "C" {
# 433 "H:/CPP/wxdevcpp6.10/include/winnls.h" 3
typedef DWORD LCTYPE;
typedef DWORD CALTYPE;
typedef DWORD CALID;
typedef DWORD LGRPID;
typedef DWORD GEOID;
typedef DWORD GEOTYPE;
typedef DWORD GEOCLASS;
typedef BOOL (__attribute__((__stdcall__)) *CALINFO_ENUMPROCA)(LPSTR);
typedef BOOL (__attribute__((__stdcall__)) *CALINFO_ENUMPROCW)(LPWSTR);
typedef BOOL (__attribute__((__stdcall__)) *CALINFO_ENUMPROCEXA)(LPSTR, CALID);
typedef BOOL (__attribute__((__stdcall__)) *CALINFO_ENUMPROCEXW)(LPWSTR, CALID);
typedef BOOL (__attribute__((__stdcall__)) *LANGUAGEGROUP_ENUMPROCA)(LGRPID, LPSTR, LPSTR, DWORD, LONG_PTR);
typedef BOOL (__attribute__((__stdcall__)) *LANGUAGEGROUP_ENUMPROCW)(LGRPID, LPWSTR, LPWSTR, DWORD, LONG_PTR);
typedef BOOL (__attribute__((__stdcall__)) *LANGGROUPLOCALE_ENUMPROCA)(LGRPID, LCID, LPSTR, LONG_PTR);
typedef BOOL (__attribute__((__stdcall__)) *LANGGROUPLOCALE_ENUMPROCW)(LGRPID, LCID, LPWSTR, LONG_PTR);
typedef BOOL (__attribute__((__stdcall__)) *UILANGUAGE_ENUMPROCW)(LPWSTR, LONG_PTR);
typedef BOOL (__attribute__((__stdcall__)) *UILANGUAGE_ENUMPROCA)(LPSTR, LONG_PTR);
typedef BOOL (__attribute__((__stdcall__)) *LOCALE_ENUMPROCA)(LPSTR);
typedef BOOL (__attribute__((__stdcall__)) *LOCALE_ENUMPROCW)(LPWSTR);
typedef BOOL (__attribute__((__stdcall__)) *CODEPAGE_ENUMPROCA)(LPSTR);
typedef BOOL (__attribute__((__stdcall__)) *CODEPAGE_ENUMPROCW)(LPWSTR);
typedef BOOL (__attribute__((__stdcall__)) *DATEFMT_ENUMPROCA)(LPSTR);
typedef BOOL (__attribute__((__stdcall__)) *DATEFMT_ENUMPROCW)(LPWSTR);
typedef BOOL (__attribute__((__stdcall__)) *DATEFMT_ENUMPROCEXA)(LPSTR, CALID);
typedef BOOL (__attribute__((__stdcall__)) *DATEFMT_ENUMPROCEXW)(LPWSTR, CALID);
typedef BOOL (__attribute__((__stdcall__)) *TIMEFMT_ENUMPROCA)(LPSTR);
typedef BOOL (__attribute__((__stdcall__)) *TIMEFMT_ENUMPROCW)(LPWSTR);
typedef BOOL (__attribute__((__stdcall__)) *GEO_ENUMPROC)(GEOID);

enum NLS_FUNCTION {
 COMPARE_STRING = 0x0001
};
typedef enum NLS_FUNCTION NLS_FUNCTION;
enum SYSGEOCLASS {
 GEOCLASS_NATION = 16,
 GEOCLASS_REGION = 14
};
enum SYSGEOTYPE {
 GEO_NATION = 0x0001,
 GEO_LATITUDE = 0x0002,
 GEO_LONGITUDE = 0x0003,
 GEO_ISO2 = 0x0004,
 GEO_ISO3 = 0x0005,
 GEO_RFC1766 = 0x0006,
 GEO_LCID = 0x0007,
 GEO_FRIENDLYNAME = 0x0008,
 GEO_OFFICIALNAME = 0x0009,
 GEO_TIMEZONES = 0x000a,
 GEO_OFFICIALLANGUAGES = 0x000a
};

typedef struct _cpinfo {
 UINT MaxCharSize;
 BYTE DefaultChar[2];
 BYTE LeadByte[12];
} CPINFO,*LPCPINFO;
typedef struct _cpinfoexA {
 UINT MaxCharSize;
 BYTE DefaultChar[2];
 BYTE LeadByte[12];
 WCHAR UnicodeDefaultChar;
 UINT CodePage;
 CHAR CodePageName[260];
} CPINFOEXA,*LPCPINFOEXA;
typedef struct _cpinfoexW {
 UINT MaxCharSize;
 BYTE DefaultChar[2];
 BYTE LeadByte[12];
 WCHAR UnicodeDefaultChar;
 UINT CodePage;
 WCHAR CodePageName[260];
} CPINFOEXW,*LPCPINFOEXW;
typedef struct _currencyfmtA {
 UINT NumDigits;
 UINT LeadingZero;
 UINT Grouping;
 LPSTR lpDecimalSep;
 LPSTR lpThousandSep;
 UINT NegativeOrder;
 UINT PositiveOrder;
 LPSTR lpCurrencySymbol;
} CURRENCYFMTA,*LPCURRENCYFMTA;
typedef struct _currencyfmtW {
 UINT NumDigits;
 UINT LeadingZero;
 UINT Grouping;
 LPWSTR lpDecimalSep;
 LPWSTR lpThousandSep;
 UINT NegativeOrder;
 UINT PositiveOrder;
 LPWSTR lpCurrencySymbol;
} CURRENCYFMTW,*LPCURRENCYFMTW;
typedef struct nlsversioninfo {
 DWORD dwNLSVersionInfoSize;
 DWORD dwNLSVersion;
 DWORD dwDefinedVersion;
} NLSVERSIONINFO,*LPNLSVERSIONINFO;
typedef struct _numberfmtA {
 UINT NumDigits;
 UINT LeadingZero;
 UINT Grouping;
 LPSTR lpDecimalSep;
 LPSTR lpThousandSep;
 UINT NegativeOrder;
} NUMBERFMTA,*LPNUMBERFMTA;
typedef struct _numberfmtW {
 UINT NumDigits;
 UINT LeadingZero;
 UINT Grouping;
 LPWSTR lpDecimalSep;
 LPWSTR lpThousandSep;
 UINT NegativeOrder;
} NUMBERFMTW,*LPNUMBERFMTW;

 int __attribute__((__stdcall__)) CompareStringA(LCID,DWORD,LPCSTR,int,LPCSTR,int);
 int __attribute__((__stdcall__)) CompareStringW(LCID,DWORD,LPCWSTR,int,LPCWSTR,int);
 LCID __attribute__((__stdcall__)) ConvertDefaultLocale(LCID);
 BOOL __attribute__((__stdcall__)) EnumCalendarInfoA(CALINFO_ENUMPROCA,LCID,CALID,CALTYPE);
 BOOL __attribute__((__stdcall__)) EnumCalendarInfoW(CALINFO_ENUMPROCW,LCID,CALID,CALTYPE);
 BOOL __attribute__((__stdcall__)) EnumDateFormatsA(DATEFMT_ENUMPROCA,LCID,DWORD);
 BOOL __attribute__((__stdcall__)) EnumDateFormatsW(DATEFMT_ENUMPROCW,LCID,DWORD);
 BOOL __attribute__((__stdcall__)) EnumSystemCodePagesA(CODEPAGE_ENUMPROCA,DWORD);
 BOOL __attribute__((__stdcall__)) EnumSystemCodePagesW(CODEPAGE_ENUMPROCW,DWORD);
 BOOL __attribute__((__stdcall__)) EnumSystemGeoID(GEOCLASS,GEOID,GEO_ENUMPROC);
 BOOL __attribute__((__stdcall__)) EnumSystemLocalesA(LOCALE_ENUMPROCA,DWORD);
 BOOL __attribute__((__stdcall__)) EnumSystemLocalesW(LOCALE_ENUMPROCW,DWORD);
 BOOL __attribute__((__stdcall__)) EnumTimeFormatsA(TIMEFMT_ENUMPROCA,LCID,DWORD);
 BOOL __attribute__((__stdcall__)) EnumTimeFormatsW(TIMEFMT_ENUMPROCW,LCID,DWORD);
 int __attribute__((__stdcall__)) FoldStringA(DWORD,LPCSTR,int,LPSTR,int);
 int __attribute__((__stdcall__)) FoldStringW(DWORD,LPCWSTR,int,LPWSTR,int);
 UINT __attribute__((__stdcall__)) GetACP(void);
 int __attribute__((__stdcall__)) GetCalendarInfoA(LCID,CALID,CALTYPE,LPSTR,int,LPDWORD);
 int __attribute__((__stdcall__)) GetCalendarInfoW(LCID,CALID,CALTYPE,LPWSTR,int,LPDWORD);
 BOOL __attribute__((__stdcall__)) GetCPInfo(UINT,LPCPINFO);
 BOOL __attribute__((__stdcall__)) GetCPInfoExA(UINT,DWORD,LPCPINFOEXA);
 BOOL __attribute__((__stdcall__)) GetCPInfoExW(UINT,DWORD,LPCPINFOEXW);
 int __attribute__((__stdcall__)) GetCurrencyFormatA(LCID,DWORD,LPCSTR,const CURRENCYFMTA*,LPSTR,int);
 int __attribute__((__stdcall__)) GetCurrencyFormatW(LCID,DWORD,LPCWSTR,const CURRENCYFMTW*,LPWSTR,int);
 int __attribute__((__stdcall__)) GetDateFormatA(LCID,DWORD,const SYSTEMTIME*,LPCSTR,LPSTR,int);
 int __attribute__((__stdcall__)) GetDateFormatW(LCID,DWORD,const SYSTEMTIME*,LPCWSTR,LPWSTR,int);
 int __attribute__((__stdcall__)) GetGeoInfoA(GEOID,GEOTYPE,LPSTR,int,LANGID);
 int __attribute__((__stdcall__)) GetGeoInfoW(GEOID,GEOTYPE,LPWSTR,int,LANGID);
 int __attribute__((__stdcall__)) GetLocaleInfoA(LCID,LCTYPE,LPSTR,int);
 int __attribute__((__stdcall__)) GetLocaleInfoW(LCID,LCTYPE,LPWSTR,int);
 BOOL __attribute__((__stdcall__)) GetNLSVersion(NLS_FUNCTION,LCID,LPNLSVERSIONINFO);
 int __attribute__((__stdcall__)) GetNumberFormatA(LCID,DWORD,LPCSTR,const NUMBERFMTA*,LPSTR,int);
 int __attribute__((__stdcall__)) GetNumberFormatW(LCID,DWORD,LPCWSTR,const NUMBERFMTW*,LPWSTR,int);
 UINT __attribute__((__stdcall__)) GetOEMCP(void);
 BOOL __attribute__((__stdcall__)) GetStringTypeA(LCID,DWORD,LPCSTR,int,LPWORD);
 BOOL __attribute__((__stdcall__)) GetStringTypeW(DWORD,LPCWSTR,int,LPWORD);
 BOOL __attribute__((__stdcall__)) GetStringTypeExA(LCID,DWORD,LPCSTR,int,LPWORD);
 BOOL __attribute__((__stdcall__)) GetStringTypeExW(LCID,DWORD,LPCWSTR,int,LPWORD);
 LANGID __attribute__((__stdcall__)) GetSystemDefaultLangID(void);
 LCID __attribute__((__stdcall__)) GetSystemDefaultLCID(void);
 LCID __attribute__((__stdcall__)) GetThreadLocale(void);
 int __attribute__((__stdcall__)) GetTimeFormatA(LCID,DWORD,const SYSTEMTIME*,LPCSTR,LPSTR,int);
 int __attribute__((__stdcall__)) GetTimeFormatW(LCID,DWORD,const SYSTEMTIME*,LPCWSTR,LPWSTR,int);
 LANGID __attribute__((__stdcall__)) GetUserDefaultLangID(void);
 LCID __attribute__((__stdcall__)) GetUserDefaultLCID(void);
 GEOID __attribute__((__stdcall__)) GetUserGeoID(GEOCLASS);
 BOOL __attribute__((__stdcall__)) IsDBCSLeadByte(BYTE);
 BOOL __attribute__((__stdcall__)) IsDBCSLeadByteEx(UINT,BYTE);
 BOOL __attribute__((__stdcall__)) IsNLSDefinedString(NLS_FUNCTION,DWORD,LPNLSVERSIONINFO,LPCWSTR,int);
 BOOL __attribute__((__stdcall__)) IsValidCodePage(UINT);
 BOOL __attribute__((__stdcall__)) IsValidLocale(LCID,DWORD);
 int __attribute__((__stdcall__)) LCMapStringA(LCID,DWORD,LPCSTR,int,LPSTR,int);
 int __attribute__((__stdcall__)) LCMapStringW(LCID,DWORD,LPCWSTR,int,LPWSTR,int);
 int __attribute__((__stdcall__)) MultiByteToWideChar(UINT,DWORD,LPCSTR,int,LPWSTR,int);
 int __attribute__((__stdcall__)) SetCalendarInfoA(LCID,CALID,CALTYPE,LPCSTR);
 int __attribute__((__stdcall__)) SetCalendarInfoW(LCID,CALID,CALTYPE,LPCWSTR);
 BOOL __attribute__((__stdcall__)) SetLocaleInfoA(LCID,LCTYPE,LPCSTR);
 BOOL __attribute__((__stdcall__)) SetLocaleInfoW(LCID,LCTYPE,LPCWSTR);
 BOOL __attribute__((__stdcall__)) SetThreadLocale(LCID);
 BOOL __attribute__((__stdcall__)) SetUserGeoID(GEOID);
 int __attribute__((__stdcall__)) WideCharToMultiByte(UINT,DWORD,LPCWSTR,int,LPSTR,int,LPCSTR,LPBOOL);
# 677 "H:/CPP/wxdevcpp6.10/include/winnls.h" 3
typedef CPINFOEXA CPINFOEX;
typedef LPCPINFOEXA LPCPINFOEX;
typedef CURRENCYFMTA CURRENCYFMT;
typedef LPCURRENCYFMTA LPCURRENCYFMT;
typedef NUMBERFMTA NUMBERFMT;
typedef LPNUMBERFMTA LPNUMBERFMT;
# 711 "H:/CPP/wxdevcpp6.10/include/winnls.h" 3
}
# 59 "H:/CPP/wxdevcpp6.10/include/windows.h" 2 3


# 1 "H:/CPP/wxdevcpp6.10/include/winver.h" 1 3



       
# 5 "H:/CPP/wxdevcpp6.10/include/winver.h" 3



extern "C" {
# 85 "H:/CPP/wxdevcpp6.10/include/winver.h" 3
typedef struct tagVS_FIXEDFILEINFO {
 DWORD dwSignature;
 DWORD dwStrucVersion;
 DWORD dwFileVersionMS;
 DWORD dwFileVersionLS;
 DWORD dwProductVersionMS;
 DWORD dwProductVersionLS;
 DWORD dwFileFlagsMask;
 DWORD dwFileFlags;
 DWORD dwFileOS;
 DWORD dwFileType;
 DWORD dwFileSubtype;
 DWORD dwFileDateMS;
 DWORD dwFileDateLS;
} VS_FIXEDFILEINFO;
DWORD __attribute__((__stdcall__)) VerFindFileA(DWORD,LPSTR,LPSTR,LPSTR,LPSTR,PUINT,LPSTR,PUINT);
DWORD __attribute__((__stdcall__)) VerFindFileW(DWORD,LPWSTR,LPWSTR,LPWSTR,LPWSTR,PUINT,LPWSTR,PUINT);
DWORD __attribute__((__stdcall__)) VerInstallFileA(DWORD,LPSTR,LPSTR,LPSTR,LPSTR,LPSTR,LPSTR,PUINT);
DWORD __attribute__((__stdcall__)) VerInstallFileW(DWORD,LPWSTR,LPWSTR,LPWSTR,LPWSTR,LPWSTR,LPWSTR,PUINT);
DWORD __attribute__((__stdcall__)) GetFileVersionInfoSizeA(LPSTR,PDWORD);
DWORD __attribute__((__stdcall__)) GetFileVersionInfoSizeW(LPWSTR,PDWORD);
BOOL __attribute__((__stdcall__)) GetFileVersionInfoA(LPSTR,DWORD,DWORD,PVOID);
BOOL __attribute__((__stdcall__)) GetFileVersionInfoW(LPWSTR,DWORD,DWORD,PVOID);
DWORD __attribute__((__stdcall__)) VerLanguageNameA(DWORD,LPSTR,DWORD);
DWORD __attribute__((__stdcall__)) VerLanguageNameW(DWORD,LPWSTR,DWORD);
BOOL __attribute__((__stdcall__)) VerQueryValueA(const LPVOID,LPSTR,LPVOID*,PUINT);
BOOL __attribute__((__stdcall__)) VerQueryValueW(const LPVOID,LPWSTR,LPVOID*,PUINT);
# 131 "H:/CPP/wxdevcpp6.10/include/winver.h" 3
}
# 62 "H:/CPP/wxdevcpp6.10/include/windows.h" 2 3


# 1 "H:/CPP/wxdevcpp6.10/include/winnetwk.h" 1 3



       
# 5 "H:/CPP/wxdevcpp6.10/include/winnetwk.h" 3



extern "C" {
# 160 "H:/CPP/wxdevcpp6.10/include/winnetwk.h" 3
typedef struct _NETRESOURCEA {
 DWORD dwScope;
 DWORD dwType;
 DWORD dwDisplayType;
 DWORD dwUsage;
 LPSTR lpLocalName;
 LPSTR lpRemoteName;
 LPSTR lpComment ;
 LPSTR lpProvider;
}NETRESOURCEA,*LPNETRESOURCEA;
typedef struct _NETRESOURCEW {
 DWORD dwScope;
 DWORD dwType;
 DWORD dwDisplayType;
 DWORD dwUsage;
 LPWSTR lpLocalName;
 LPWSTR lpRemoteName;
 LPWSTR lpComment ;
 LPWSTR lpProvider;
}NETRESOURCEW,*LPNETRESOURCEW;
typedef struct _CONNECTDLGSTRUCTA{
 DWORD cbStructure;
 HWND hwndOwner;
 LPNETRESOURCEA lpConnRes;
 DWORD dwFlags;
 DWORD dwDevNum;
} CONNECTDLGSTRUCTA,*LPCONNECTDLGSTRUCTA;
typedef struct _CONNECTDLGSTRUCTW{
 DWORD cbStructure;
 HWND hwndOwner;
 LPNETRESOURCEW lpConnRes;
 DWORD dwFlags;
 DWORD dwDevNum;
} CONNECTDLGSTRUCTW,*LPCONNECTDLGSTRUCTW;
typedef struct _DISCDLGSTRUCTA{
 DWORD cbStructure;
 HWND hwndOwner;
 LPSTR lpLocalName;
 LPSTR lpRemoteName;
 DWORD dwFlags;
} DISCDLGSTRUCTA,*LPDISCDLGSTRUCTA;
typedef struct _DISCDLGSTRUCTW{
 DWORD cbStructure;
 HWND hwndOwner;
 LPWSTR lpLocalName;
 LPWSTR lpRemoteName;
 DWORD dwFlags;
} DISCDLGSTRUCTW,*LPDISCDLGSTRUCTW;
typedef struct _UNIVERSAL_NAME_INFOA { LPSTR lpUniversalName; }UNIVERSAL_NAME_INFOA,*LPUNIVERSAL_NAME_INFOA;
typedef struct _UNIVERSAL_NAME_INFOW { LPWSTR lpUniversalName; }UNIVERSAL_NAME_INFOW,*LPUNIVERSAL_NAME_INFOW;
typedef struct _REMOTE_NAME_INFOA {
 LPSTR lpUniversalName;
 LPSTR lpConnectionName;
 LPSTR lpRemainingPath;
}REMOTE_NAME_INFOA,*LPREMOTE_NAME_INFOA;
typedef struct _REMOTE_NAME_INFOW {
 LPWSTR lpUniversalName;
 LPWSTR lpConnectionName;
 LPWSTR lpRemainingPath;
}REMOTE_NAME_INFOW,*LPREMOTE_NAME_INFOW;
typedef struct _NETINFOSTRUCT{
 DWORD cbStructure;
 DWORD dwProviderVersion;
 DWORD dwStatus;
 DWORD dwCharacteristics;
 DWORD dwHandle;
 WORD wNetType;
 DWORD dwPrinters;
 DWORD dwDrives;
} NETINFOSTRUCT,*LPNETINFOSTRUCT;
typedef UINT(__attribute__((__stdcall__)) *PFNGETPROFILEPATHA)(LPCSTR,LPSTR,UINT);
typedef UINT(__attribute__((__stdcall__)) *PFNGETPROFILEPATHW)(LPCWSTR,LPWSTR,UINT);
typedef UINT(__attribute__((__stdcall__)) *PFNRECONCILEPROFILEA)(LPCSTR,LPCSTR,DWORD);
typedef UINT(__attribute__((__stdcall__)) *PFNRECONCILEPROFILEW)(LPCWSTR,LPCWSTR,DWORD);
typedef BOOL(__attribute__((__stdcall__)) *PFNPROCESSPOLICIESA)(HWND,LPCSTR,LPCSTR,LPCSTR,DWORD);
typedef BOOL(__attribute__((__stdcall__)) *PFNPROCESSPOLICIESW)(HWND,LPCWSTR,LPCWSTR,LPCWSTR,DWORD);
typedef struct _NETCONNECTINFOSTRUCT{
 DWORD cbStructure;
 DWORD dwFlags;
 DWORD dwSpeed;
 DWORD dwDelay;
 DWORD dwOptDataSize;
} NETCONNECTINFOSTRUCT,*LPNETCONNECTINFOSTRUCT;

DWORD __attribute__((__stdcall__)) WNetAddConnectionA(LPCSTR,LPCSTR,LPCSTR);
DWORD __attribute__((__stdcall__)) WNetAddConnectionW(LPCWSTR,LPCWSTR,LPCWSTR);
DWORD __attribute__((__stdcall__)) WNetAddConnection2A(LPNETRESOURCEA,LPCSTR,LPCSTR,DWORD);
DWORD __attribute__((__stdcall__)) WNetAddConnection2W(LPNETRESOURCEW,LPCWSTR,LPCWSTR,DWORD);
DWORD __attribute__((__stdcall__)) WNetAddConnection3A(HWND,LPNETRESOURCEA,LPCSTR,LPCSTR,DWORD);
DWORD __attribute__((__stdcall__)) WNetAddConnection3W(HWND,LPNETRESOURCEW,LPCWSTR,LPCWSTR,DWORD);
DWORD __attribute__((__stdcall__)) WNetCancelConnectionA(LPCSTR,BOOL);
DWORD __attribute__((__stdcall__)) WNetCancelConnectionW(LPCWSTR,BOOL);
DWORD __attribute__((__stdcall__)) WNetCancelConnection2A(LPCSTR,DWORD,BOOL);
DWORD __attribute__((__stdcall__)) WNetCancelConnection2W(LPCWSTR,DWORD,BOOL);
DWORD __attribute__((__stdcall__)) WNetGetConnectionA(LPCSTR,LPSTR,PDWORD);
DWORD __attribute__((__stdcall__)) WNetGetConnectionW(LPCWSTR,LPWSTR,PDWORD);
DWORD __attribute__((__stdcall__)) WNetUseConnectionA(HWND,LPNETRESOURCEA,LPCSTR,LPCSTR,DWORD,LPSTR,PDWORD,PDWORD);
DWORD __attribute__((__stdcall__)) WNetUseConnectionW(HWND,LPNETRESOURCEW,LPCWSTR,LPCWSTR,DWORD,LPWSTR,PDWORD,PDWORD);
DWORD __attribute__((__stdcall__)) WNetSetConnectionA(LPCSTR,DWORD,PVOID);
DWORD __attribute__((__stdcall__)) WNetSetConnectionW(LPCWSTR,DWORD,PVOID);
DWORD __attribute__((__stdcall__)) WNetConnectionDialog(HWND,DWORD);
DWORD __attribute__((__stdcall__)) WNetDisconnectDialog(HWND,DWORD);
DWORD __attribute__((__stdcall__)) WNetConnectionDialog1A(LPCONNECTDLGSTRUCTA);
DWORD __attribute__((__stdcall__)) WNetConnectionDialog1W(LPCONNECTDLGSTRUCTW);
DWORD __attribute__((__stdcall__)) WNetDisconnectDialog1A(LPDISCDLGSTRUCTA);
DWORD __attribute__((__stdcall__)) WNetDisconnectDialog1W(LPDISCDLGSTRUCTW);
DWORD __attribute__((__stdcall__)) WNetOpenEnumA(DWORD,DWORD,DWORD,LPNETRESOURCEA,LPHANDLE);
DWORD __attribute__((__stdcall__)) WNetOpenEnumW(DWORD,DWORD,DWORD,LPNETRESOURCEW,LPHANDLE);
DWORD __attribute__((__stdcall__)) WNetEnumResourceA(HANDLE,PDWORD,PVOID,PDWORD);
DWORD __attribute__((__stdcall__)) WNetEnumResourceW(HANDLE,PDWORD,PVOID,PDWORD);
DWORD __attribute__((__stdcall__)) WNetCloseEnum(HANDLE);
DWORD __attribute__((__stdcall__)) WNetGetUniversalNameA(LPCSTR,DWORD,PVOID,PDWORD);
DWORD __attribute__((__stdcall__)) WNetGetUniversalNameW(LPCWSTR,DWORD,PVOID,PDWORD);
DWORD __attribute__((__stdcall__)) WNetGetUserA(LPCSTR,LPSTR,PDWORD);
DWORD __attribute__((__stdcall__)) WNetGetUserW(LPCWSTR,LPWSTR,PDWORD);
DWORD __attribute__((__stdcall__)) WNetGetProviderNameA(DWORD,LPSTR,PDWORD);
DWORD __attribute__((__stdcall__)) WNetGetProviderNameW(DWORD,LPWSTR,PDWORD);
DWORD __attribute__((__stdcall__)) WNetGetNetworkInformationA(LPCSTR,LPNETINFOSTRUCT);
DWORD __attribute__((__stdcall__)) WNetGetNetworkInformationW(LPCWSTR,LPNETINFOSTRUCT);
DWORD __attribute__((__stdcall__)) WNetGetResourceInformationA(LPNETRESOURCEA,LPVOID,LPDWORD,LPSTR*);
DWORD __attribute__((__stdcall__)) WNetGetResourceInformationW(LPNETRESOURCEA,LPVOID,LPDWORD,LPWSTR*);
DWORD __attribute__((__stdcall__)) WNetGetResourceParentA(LPNETRESOURCEA,LPVOID,LPDWORD);
DWORD __attribute__((__stdcall__)) WNetGetResourceParentW(LPNETRESOURCEW,LPVOID,LPDWORD);
DWORD __attribute__((__stdcall__)) WNetGetLastErrorA(PDWORD,LPSTR,DWORD,LPSTR,DWORD);
DWORD __attribute__((__stdcall__)) WNetGetLastErrorW(PDWORD,LPWSTR,DWORD,LPWSTR,DWORD);
DWORD __attribute__((__stdcall__)) MultinetGetConnectionPerformanceA(LPNETRESOURCEA,LPNETCONNECTINFOSTRUCT);
DWORD __attribute__((__stdcall__)) MultinetGetConnectionPerformanceW(LPNETRESOURCEW,LPNETCONNECTINFOSTRUCT);
# 320 "H:/CPP/wxdevcpp6.10/include/winnetwk.h" 3
typedef NETRESOURCEA NETRESOURCE,*LPNETRESOURCE;
typedef CONNECTDLGSTRUCTA CONNECTDLGSTRUCT,*LPCONNECTDLGSTRUCT;
typedef DISCDLGSTRUCTA DISCDLGSTRUCT,*LPDISCDLGSTRUCT;
typedef UNIVERSAL_NAME_INFOA UNIVERSAL_NAME_INFO,*LPUNIVERSAL_NAME_INFO;
typedef REMOTE_NAME_INFOA REMOTE_NAME_INFO,*LPREMOTE_NAME_INFO;
# 348 "H:/CPP/wxdevcpp6.10/include/winnetwk.h" 3
}
# 65 "H:/CPP/wxdevcpp6.10/include/windows.h" 2 3


# 1 "H:/CPP/wxdevcpp6.10/include/winreg.h" 1 3



       
# 5 "H:/CPP/wxdevcpp6.10/include/winreg.h" 3







extern "C" {
# 45 "H:/CPP/wxdevcpp6.10/include/winreg.h" 3
typedef ACCESS_MASK REGSAM;
typedef struct value_entA {
 LPSTR ve_valuename;
 DWORD ve_valuelen;
 DWORD ve_valueptr;
 DWORD ve_type;
} VALENTA,*PVALENTA;
typedef struct value_entW {
 LPWSTR ve_valuename;
 DWORD ve_valuelen;
 DWORD ve_valueptr;
 DWORD ve_type;
} VALENTW,*PVALENTW;
 BOOL __attribute__((__stdcall__)) AbortSystemShutdownA(LPCSTR);
 BOOL __attribute__((__stdcall__)) AbortSystemShutdownW(LPCWSTR);
 BOOL __attribute__((__stdcall__)) InitiateSystemShutdownA(LPSTR,LPSTR,DWORD,BOOL,BOOL);
 BOOL __attribute__((__stdcall__)) InitiateSystemShutdownW(LPWSTR,LPWSTR,DWORD,BOOL,BOOL);
 LONG __attribute__((__stdcall__)) RegCloseKey(HKEY);
 LONG __attribute__((__stdcall__)) RegConnectRegistryA(LPCSTR,HKEY,PHKEY);
 LONG __attribute__((__stdcall__)) RegConnectRegistryW(LPCWSTR,HKEY,PHKEY);
 LONG __attribute__((__stdcall__)) RegCreateKeyA(HKEY,LPCSTR,PHKEY);
 LONG __attribute__((__stdcall__)) RegCreateKeyExA(HKEY,LPCSTR,DWORD,LPSTR,DWORD,REGSAM,LPSECURITY_ATTRIBUTES,PHKEY,PDWORD);
 LONG __attribute__((__stdcall__)) RegCreateKeyExW(HKEY,LPCWSTR,DWORD,LPWSTR,DWORD,REGSAM,LPSECURITY_ATTRIBUTES,PHKEY,PDWORD);
 LONG __attribute__((__stdcall__)) RegCreateKeyW(HKEY,LPCWSTR,PHKEY);
 LONG __attribute__((__stdcall__)) RegDeleteKeyA(HKEY,LPCSTR);
 LONG __attribute__((__stdcall__)) RegDeleteKeyW(HKEY,LPCWSTR);
 LONG __attribute__((__stdcall__)) RegDeleteValueA(HKEY,LPCSTR);
 LONG __attribute__((__stdcall__)) RegDeleteValueW(HKEY,LPCWSTR);
 LONG __attribute__((__stdcall__)) RegEnumKeyA(HKEY,DWORD,LPSTR,DWORD);
 LONG __attribute__((__stdcall__)) RegEnumKeyW(HKEY,DWORD,LPWSTR,DWORD);
 LONG __attribute__((__stdcall__)) RegEnumKeyExA(HKEY,DWORD,LPSTR,PDWORD,PDWORD,LPSTR,PDWORD,PFILETIME);
 LONG __attribute__((__stdcall__)) RegEnumKeyExW(HKEY,DWORD,LPWSTR,PDWORD,PDWORD,LPWSTR,PDWORD,PFILETIME);
 LONG __attribute__((__stdcall__)) RegEnumValueA(HKEY,DWORD,LPSTR,PDWORD,PDWORD,PDWORD,LPBYTE,PDWORD);
 LONG __attribute__((__stdcall__)) RegEnumValueW(HKEY,DWORD,LPWSTR,PDWORD,PDWORD,PDWORD,LPBYTE,PDWORD);
 LONG __attribute__((__stdcall__)) RegFlushKey(HKEY);
 LONG __attribute__((__stdcall__)) RegGetKeySecurity(HKEY,SECURITY_INFORMATION,PSECURITY_DESCRIPTOR,PDWORD);
 LONG __attribute__((__stdcall__)) RegLoadKeyA(HKEY,LPCSTR,LPCSTR);
 LONG __attribute__((__stdcall__)) RegLoadKeyW(HKEY,LPCWSTR,LPCWSTR);
 LONG __attribute__((__stdcall__)) RegNotifyChangeKeyValue(HKEY,BOOL,DWORD,HANDLE,BOOL);
 LONG __attribute__((__stdcall__)) RegOpenKeyA(HKEY,LPCSTR,PHKEY);
 LONG __attribute__((__stdcall__)) RegOpenKeyExA(HKEY,LPCSTR,DWORD,REGSAM,PHKEY);
 LONG __attribute__((__stdcall__)) RegOpenKeyExW(HKEY,LPCWSTR,DWORD,REGSAM,PHKEY);
 LONG __attribute__((__stdcall__)) RegOpenKeyW(HKEY,LPCWSTR,PHKEY);
 LONG __attribute__((__stdcall__)) RegQueryInfoKeyA(HKEY,LPSTR,PDWORD,PDWORD,PDWORD,PDWORD,PDWORD,PDWORD,PDWORD,PDWORD,PDWORD,PFILETIME);
 LONG __attribute__((__stdcall__)) RegQueryInfoKeyW(HKEY,LPWSTR,PDWORD,PDWORD,PDWORD,PDWORD,PDWORD,PDWORD,PDWORD,PDWORD,PDWORD,PFILETIME);
 LONG __attribute__((__stdcall__)) RegQueryMultipleValuesA(HKEY,PVALENTA,DWORD,LPSTR,LPDWORD);
 LONG __attribute__((__stdcall__)) RegQueryMultipleValuesW(HKEY,PVALENTW,DWORD,LPWSTR,LPDWORD);
 LONG __attribute__((__stdcall__)) RegQueryValueA(HKEY,LPCSTR,LPSTR,PLONG);
 LONG __attribute__((__stdcall__)) RegQueryValueExA(HKEY,LPCSTR,LPDWORD,LPDWORD,LPBYTE,LPDWORD);
 LONG __attribute__((__stdcall__)) RegQueryValueExW(HKEY,LPCWSTR,LPDWORD,LPDWORD,LPBYTE,LPDWORD);
 LONG __attribute__((__stdcall__)) RegQueryValueW(HKEY,LPCWSTR,LPWSTR,PLONG);
 LONG __attribute__((__stdcall__)) RegReplaceKeyA(HKEY,LPCSTR,LPCSTR,LPCSTR);
 LONG __attribute__((__stdcall__)) RegReplaceKeyW(HKEY,LPCWSTR,LPCWSTR,LPCWSTR);
 LONG __attribute__((__stdcall__)) RegRestoreKeyA(HKEY,LPCSTR,DWORD);
 LONG __attribute__((__stdcall__)) RegRestoreKeyW(HKEY,LPCWSTR,DWORD);
 LONG __attribute__((__stdcall__)) RegSaveKeyA(HKEY,LPCSTR,LPSECURITY_ATTRIBUTES);
 LONG __attribute__((__stdcall__)) RegSaveKeyW(HKEY,LPCWSTR,LPSECURITY_ATTRIBUTES);
 LONG __attribute__((__stdcall__)) RegSetKeySecurity(HKEY,SECURITY_INFORMATION,PSECURITY_DESCRIPTOR);
 LONG __attribute__((__stdcall__)) RegSetValueA(HKEY,LPCSTR,DWORD,LPCSTR,DWORD);
 LONG __attribute__((__stdcall__)) RegSetValueExA(HKEY,LPCSTR,DWORD,DWORD,const BYTE*,DWORD);
 LONG __attribute__((__stdcall__)) RegSetValueExW(HKEY,LPCWSTR,DWORD,DWORD,const BYTE*,DWORD);
 LONG __attribute__((__stdcall__)) RegSetValueW(HKEY,LPCWSTR,DWORD,LPCWSTR,DWORD);
 LONG __attribute__((__stdcall__)) RegUnLoadKeyA(HKEY,LPCSTR);
 LONG __attribute__((__stdcall__)) RegUnLoadKeyW(HKEY,LPCWSTR);
# 136 "H:/CPP/wxdevcpp6.10/include/winreg.h" 3
typedef VALENTA VALENT,*PVALENT;
# 163 "H:/CPP/wxdevcpp6.10/include/winreg.h" 3
}
# 68 "H:/CPP/wxdevcpp6.10/include/windows.h" 2 3


# 1 "H:/CPP/wxdevcpp6.10/include/winsvc.h" 1 3



       
# 5 "H:/CPP/wxdevcpp6.10/include/winsvc.h" 3







extern "C" {
# 74 "H:/CPP/wxdevcpp6.10/include/winsvc.h" 3
typedef struct _SERVICE_STATUS {
 DWORD dwServiceType;
 DWORD dwCurrentState;
 DWORD dwControlsAccepted;
 DWORD dwWin32ExitCode;
 DWORD dwServiceSpecificExitCode;
 DWORD dwCheckPoint;
 DWORD dwWaitHint;
} SERVICE_STATUS,*LPSERVICE_STATUS;
typedef struct _SERVICE_STATUS_PROCESS {
 DWORD dwServiceType;
 DWORD dwCurrentState;
 DWORD dwControlsAccepted;
 DWORD dwWin32ExitCode;
 DWORD dwServiceSpecificExitCode;
 DWORD dwCheckPoint;
 DWORD dwWaitHint;
 DWORD dwProcessId;
 DWORD dwServiceFlags;
} SERVICE_STATUS_PROCESS, *LPSERVICE_STATUS_PROCESS;
typedef enum _SC_STATUS_TYPE {
 SC_STATUS_PROCESS_INFO = 0
} SC_STATUS_TYPE;
typedef enum _SC_ENUM_TYPE {
        SC_ENUM_PROCESS_INFO = 0
} SC_ENUM_TYPE;
typedef struct _ENUM_SERVICE_STATUSA {
 LPSTR lpServiceName;
 LPSTR lpDisplayName;
 SERVICE_STATUS ServiceStatus;
} ENUM_SERVICE_STATUSA,*LPENUM_SERVICE_STATUSA;
typedef struct _ENUM_SERVICE_STATUSW {
 LPWSTR lpServiceName;
 LPWSTR lpDisplayName;
 SERVICE_STATUS ServiceStatus;
} ENUM_SERVICE_STATUSW,*LPENUM_SERVICE_STATUSW;
typedef struct _ENUM_SERVICE_STATUS_PROCESSA {
 LPSTR lpServiceName;
 LPSTR lpDisplayName;
 SERVICE_STATUS_PROCESS ServiceStatusProcess;
} ENUM_SERVICE_STATUS_PROCESSA,*LPENUM_SERVICE_STATUS_PROCESSA;
typedef struct _ENUM_SERVICE_STATUS_PROCESSW {
 LPWSTR lpServiceName;
 LPWSTR lpDisplayName;
 SERVICE_STATUS_PROCESS ServiceStatusProcess;
} ENUM_SERVICE_STATUS_PROCESSW,*LPENUM_SERVICE_STATUS_PROCESSW;
typedef struct _QUERY_SERVICE_CONFIGA {
 DWORD dwServiceType;
 DWORD dwStartType;
 DWORD dwErrorControl;
 LPSTR lpBinaryPathName;
 LPSTR lpLoadOrderGroup;
 DWORD dwTagId;
 LPSTR lpDependencies;
 LPSTR lpServiceStartName;
 LPSTR lpDisplayName;
} QUERY_SERVICE_CONFIGA,*LPQUERY_SERVICE_CONFIGA;
typedef struct _QUERY_SERVICE_CONFIGW {
 DWORD dwServiceType;
 DWORD dwStartType;
 DWORD dwErrorControl;
 LPWSTR lpBinaryPathName;
 LPWSTR lpLoadOrderGroup;
 DWORD dwTagId;
 LPWSTR lpDependencies;
 LPWSTR lpServiceStartName;
 LPWSTR lpDisplayName;
} QUERY_SERVICE_CONFIGW,*LPQUERY_SERVICE_CONFIGW;
typedef struct _QUERY_SERVICE_LOCK_STATUSA {
 DWORD fIsLocked;
 LPSTR lpLockOwner;
 DWORD dwLockDuration;
} QUERY_SERVICE_LOCK_STATUSA,*LPQUERY_SERVICE_LOCK_STATUSA;
typedef struct _QUERY_SERVICE_LOCK_STATUSW {
 DWORD fIsLocked;
 LPWSTR lpLockOwner;
 DWORD dwLockDuration;
} QUERY_SERVICE_LOCK_STATUSW,*LPQUERY_SERVICE_LOCK_STATUSW;
typedef void (__attribute__((__stdcall__)) *LPSERVICE_MAIN_FUNCTIONA)(DWORD,LPSTR*);
typedef void (__attribute__((__stdcall__)) *LPSERVICE_MAIN_FUNCTIONW)(DWORD,LPWSTR*);
typedef struct _SERVICE_TABLE_ENTRYA {
 LPSTR lpServiceName;
 LPSERVICE_MAIN_FUNCTIONA lpServiceProc;
} SERVICE_TABLE_ENTRYA,*LPSERVICE_TABLE_ENTRYA;
typedef struct _SERVICE_TABLE_ENTRYW {
 LPWSTR lpServiceName;
 LPSERVICE_MAIN_FUNCTIONW lpServiceProc;
} SERVICE_TABLE_ENTRYW,*LPSERVICE_TABLE_ENTRYW;
typedef struct SC_HANDLE__{int i;}*SC_HANDLE;
typedef SC_HANDLE *LPSC_HANDLE;
typedef PVOID SC_LOCK;
typedef DWORD SERVICE_STATUS_HANDLE;
typedef void(__attribute__((__stdcall__)) *LPHANDLER_FUNCTION)(DWORD);
typedef DWORD (__attribute__((__stdcall__)) *LPHANDLER_FUNCTION_EX)(DWORD,DWORD,LPVOID,LPVOID);
typedef struct _SERVICE_DESCRIPTIONA {
 LPSTR lpDescription;
} SERVICE_DESCRIPTIONA,*LPSERVICE_DESCRIPTIONA;
typedef struct _SERVICE_DESCRIPTIONW {
 LPWSTR lpDescription;
} SERVICE_DESCRIPTIONW,*LPSERVICE_DESCRIPTIONW;
typedef enum _SC_ACTION_TYPE {
        SC_ACTION_NONE = 0,
        SC_ACTION_RESTART = 1,
        SC_ACTION_REBOOT = 2,
        SC_ACTION_RUN_COMMAND = 3
} SC_ACTION_TYPE;
typedef struct _SC_ACTION {
 SC_ACTION_TYPE Type;
 DWORD Delay;
} SC_ACTION,*LPSC_ACTION;
typedef struct _SERVICE_FAILURE_ACTIONSA {
 DWORD dwResetPeriod;
 LPSTR lpRebootMsg;
 LPSTR lpCommand;
 DWORD cActions;
 SC_ACTION * lpsaActions;
} SERVICE_FAILURE_ACTIONSA,*LPSERVICE_FAILURE_ACTIONSA;
typedef struct _SERVICE_FAILURE_ACTIONSW {
 DWORD dwResetPeriod;
 LPWSTR lpRebootMsg;
 LPWSTR lpCommand;
 DWORD cActions;
 SC_ACTION * lpsaActions;
} SERVICE_FAILURE_ACTIONSW,*LPSERVICE_FAILURE_ACTIONSW;

 BOOL __attribute__((__stdcall__)) ChangeServiceConfigA(SC_HANDLE,DWORD,DWORD,DWORD,LPCSTR,LPCSTR,LPDWORD,LPCSTR,LPCSTR,LPCSTR,LPCSTR);
 BOOL __attribute__((__stdcall__)) ChangeServiceConfigW(SC_HANDLE,DWORD,DWORD,DWORD,LPCWSTR,LPCWSTR,LPDWORD,LPCWSTR,LPCWSTR,LPCWSTR,LPCWSTR);
 BOOL __attribute__((__stdcall__)) ChangeServiceConfig2A(SC_HANDLE,DWORD,LPVOID);
 BOOL __attribute__((__stdcall__)) ChangeServiceConfig2W(SC_HANDLE,DWORD,LPVOID);
 BOOL __attribute__((__stdcall__)) CloseServiceHandle(SC_HANDLE);
 BOOL __attribute__((__stdcall__)) ControlService(SC_HANDLE,DWORD,LPSERVICE_STATUS);
 SC_HANDLE __attribute__((__stdcall__)) CreateServiceA(SC_HANDLE,LPCSTR,LPCSTR,DWORD,DWORD,DWORD,DWORD,LPCSTR,LPCSTR,PDWORD,LPCSTR,LPCSTR,LPCSTR);
 SC_HANDLE __attribute__((__stdcall__)) CreateServiceW(SC_HANDLE,LPCWSTR,LPCWSTR,DWORD,DWORD,DWORD,DWORD,LPCWSTR,LPCWSTR,PDWORD,LPCWSTR,LPCWSTR,LPCWSTR);
 BOOL __attribute__((__stdcall__)) DeleteService(SC_HANDLE);
 BOOL __attribute__((__stdcall__)) EnumDependentServicesA(SC_HANDLE,DWORD,LPENUM_SERVICE_STATUSA,DWORD,PDWORD,PDWORD);
 BOOL __attribute__((__stdcall__)) EnumDependentServicesW(SC_HANDLE,DWORD,LPENUM_SERVICE_STATUSW,DWORD,PDWORD,PDWORD);
 BOOL __attribute__((__stdcall__)) EnumServicesStatusA(SC_HANDLE,DWORD,DWORD,LPENUM_SERVICE_STATUSA,DWORD,PDWORD,PDWORD,PDWORD);
 BOOL __attribute__((__stdcall__)) EnumServicesStatusW(SC_HANDLE,DWORD,DWORD,LPENUM_SERVICE_STATUSW,DWORD,PDWORD,PDWORD,PDWORD);
 BOOL __attribute__((__stdcall__)) EnumServicesStatusExA(SC_HANDLE,SC_ENUM_TYPE,DWORD,DWORD,LPBYTE,DWORD,LPDWORD,LPDWORD,LPDWORD,LPCSTR);
 BOOL __attribute__((__stdcall__)) EnumServicesStatusExW(SC_HANDLE,SC_ENUM_TYPE,DWORD,DWORD,LPBYTE,DWORD,LPDWORD,LPDWORD,LPDWORD,LPCWSTR);
 BOOL __attribute__((__stdcall__)) GetServiceDisplayNameA(SC_HANDLE,LPCSTR,LPSTR,PDWORD);
 BOOL __attribute__((__stdcall__)) GetServiceDisplayNameW(SC_HANDLE,LPCWSTR,LPWSTR,PDWORD);
 BOOL __attribute__((__stdcall__)) GetServiceKeyNameA(SC_HANDLE,LPCSTR,LPSTR,PDWORD);
 BOOL __attribute__((__stdcall__)) GetServiceKeyNameW(SC_HANDLE,LPCWSTR,LPWSTR,PDWORD);
 SC_LOCK __attribute__((__stdcall__)) LockServiceDatabase(SC_HANDLE);
 BOOL __attribute__((__stdcall__)) NotifyBootConfigStatus(BOOL);
 SC_HANDLE __attribute__((__stdcall__)) OpenSCManagerA(LPCSTR,LPCSTR,DWORD);
 SC_HANDLE __attribute__((__stdcall__)) OpenSCManagerW(LPCWSTR,LPCWSTR,DWORD);
 SC_HANDLE __attribute__((__stdcall__)) OpenServiceA(SC_HANDLE,LPCSTR,DWORD);
 SC_HANDLE __attribute__((__stdcall__)) OpenServiceW(SC_HANDLE,LPCWSTR,DWORD);
 BOOL __attribute__((__stdcall__)) QueryServiceConfigA(SC_HANDLE,LPQUERY_SERVICE_CONFIGA,DWORD,PDWORD);
 BOOL __attribute__((__stdcall__)) QueryServiceConfigW(SC_HANDLE,LPQUERY_SERVICE_CONFIGW,DWORD,PDWORD);
 BOOL __attribute__((__stdcall__)) QueryServiceConfig2A(SC_HANDLE,DWORD,LPBYTE,DWORD,LPDWORD);
 BOOL __attribute__((__stdcall__)) QueryServiceConfig2W(SC_HANDLE,DWORD,LPBYTE,DWORD,LPDWORD);
 BOOL __attribute__((__stdcall__)) QueryServiceLockStatusA(SC_HANDLE,LPQUERY_SERVICE_LOCK_STATUSA,DWORD,PDWORD);
 BOOL __attribute__((__stdcall__)) QueryServiceLockStatusW(SC_HANDLE,LPQUERY_SERVICE_LOCK_STATUSW,DWORD,PDWORD);
 BOOL __attribute__((__stdcall__)) QueryServiceObjectSecurity(SC_HANDLE,SECURITY_INFORMATION,PSECURITY_DESCRIPTOR,DWORD,LPDWORD);
 BOOL __attribute__((__stdcall__)) QueryServiceStatus(SC_HANDLE,LPSERVICE_STATUS);
 BOOL __attribute__((__stdcall__)) QueryServiceStatusEx(SC_HANDLE,SC_STATUS_TYPE,LPBYTE,DWORD,LPDWORD);
 SERVICE_STATUS_HANDLE __attribute__((__stdcall__)) RegisterServiceCtrlHandlerA(LPCSTR,LPHANDLER_FUNCTION);
 SERVICE_STATUS_HANDLE __attribute__((__stdcall__)) RegisterServiceCtrlHandlerW(LPCWSTR,LPHANDLER_FUNCTION);
 SERVICE_STATUS_HANDLE __attribute__((__stdcall__)) RegisterServiceCtrlHandlerExA(LPCSTR,LPHANDLER_FUNCTION_EX,LPVOID);
 SERVICE_STATUS_HANDLE __attribute__((__stdcall__)) RegisterServiceCtrlHandlerExW(LPCWSTR,LPHANDLER_FUNCTION_EX,LPVOID);
 BOOL __attribute__((__stdcall__)) SetServiceObjectSecurity(SC_HANDLE,SECURITY_INFORMATION,PSECURITY_DESCRIPTOR);
 BOOL __attribute__((__stdcall__)) SetServiceStatus(SERVICE_STATUS_HANDLE,LPSERVICE_STATUS);
 BOOL __attribute__((__stdcall__)) StartServiceA(SC_HANDLE,DWORD,LPCSTR*);
 BOOL __attribute__((__stdcall__)) StartServiceCtrlDispatcherA(LPSERVICE_TABLE_ENTRYA);
 BOOL __attribute__((__stdcall__)) StartServiceCtrlDispatcherW(LPSERVICE_TABLE_ENTRYW);
 BOOL __attribute__((__stdcall__)) StartServiceW(SC_HANDLE,DWORD,LPCWSTR*);
 BOOL __attribute__((__stdcall__)) UnlockServiceDatabase(SC_LOCK);
# 278 "H:/CPP/wxdevcpp6.10/include/winsvc.h" 3
typedef ENUM_SERVICE_STATUSA ENUM_SERVICE_STATUS,*LPENUM_SERVICE_STATUS;
typedef ENUM_SERVICE_STATUS_PROCESSA ENUM_SERVICE_STATUS_PROCESS;
typedef LPENUM_SERVICE_STATUS_PROCESSA LPENUM_SERVICE_STATUS_PROCESS;
typedef QUERY_SERVICE_CONFIGA QUERY_SERVICE_CONFIG,*LPQUERY_SERVICE_CONFIG;
typedef QUERY_SERVICE_LOCK_STATUSA QUERY_SERVICE_LOCK_STATUS,*LPQUERY_SERVICE_LOCK_STATUS;
typedef SERVICE_TABLE_ENTRYA SERVICE_TABLE_ENTRY,*LPSERVICE_TABLE_ENTRY;
typedef LPSERVICE_MAIN_FUNCTIONA LPSERVICE_MAIN_FUNCTION;
typedef SERVICE_DESCRIPTIONA SERVICE_DESCRIPTION;
typedef LPSERVICE_DESCRIPTIONA LPSERVICE_DESCRIPTION;
typedef SERVICE_FAILURE_ACTIONSA SERVICE_FAILURE_ACTIONS;
typedef LPSERVICE_FAILURE_ACTIONSA LPSERVICE_FAILURE_ACTIONS;
# 311 "H:/CPP/wxdevcpp6.10/include/winsvc.h" 3
}
# 71 "H:/CPP/wxdevcpp6.10/include/windows.h" 2 3



# 1 "H:/CPP/wxdevcpp6.10/include/cderr.h" 1 3



       
# 5 "H:/CPP/wxdevcpp6.10/include/cderr.h" 3
# 75 "H:/CPP/wxdevcpp6.10/include/windows.h" 2 3
# 1 "H:/CPP/wxdevcpp6.10/include/dde.h" 1 3



       
# 5 "H:/CPP/wxdevcpp6.10/include/dde.h" 3



extern "C" {
# 23 "H:/CPP/wxdevcpp6.10/include/dde.h" 3
typedef struct {
 unsigned short bAppReturnCode:8,reserved:6,fBusy:1,fAck:1;
} DDEACK;
typedef struct {
 unsigned short reserved:14,fDeferUpd:1,fAckReq:1;
 short cfFormat;
} DDEADVISE;
typedef struct {
 unsigned short unused:12,fResponse:1,fRelease:1,reserved:1,fAckReq:1;
 short cfFormat;
 BYTE Value[1];
} DDEDATA;
typedef struct {
 unsigned short unused:13,fRelease:1,fReserved:2;
 short cfFormat;
 BYTE Value[1];
} DDEPOKE;
typedef struct {
        unsigned short unused:13,
                 fRelease:1,
                 fDeferUpd:1,
         fAckReq:1;
    short cfFormat;
} DDELN;

typedef struct {
 unsigned short unused:12,fAck:1,fRelease:1,fReserved:1,fAckReq:1;
    short cfFormat;
    BYTE rgb[1];
} DDEUP;
BOOL __attribute__((__stdcall__)) DdeSetQualityOfService(HWND,const SECURITY_QUALITY_OF_SERVICE*,PSECURITY_QUALITY_OF_SERVICE);
BOOL __attribute__((__stdcall__)) ImpersonateDdeClientWindow(HWND,HWND);
LPARAM __attribute__((__stdcall__)) PackDDElParam(UINT,UINT_PTR,UINT_PTR);
BOOL __attribute__((__stdcall__)) UnpackDDElParam(UINT,LPARAM,PUINT_PTR,PUINT_PTR);
BOOL __attribute__((__stdcall__)) FreeDDElParam(UINT,LPARAM);
LPARAM __attribute__((__stdcall__)) ReuseDDElParam(LPARAM,UINT,UINT,UINT_PTR,UINT_PTR);



}
# 76 "H:/CPP/wxdevcpp6.10/include/windows.h" 2 3
# 1 "H:/CPP/wxdevcpp6.10/include/ddeml.h" 1 3



       
# 5 "H:/CPP/wxdevcpp6.10/include/ddeml.h" 3



extern "C" {
# 145 "H:/CPP/wxdevcpp6.10/include/ddeml.h" 3
typedef struct HCONVLIST__{int i;}*HCONVLIST;
typedef struct HCONV__{int i;}*HCONV;
typedef struct HSZ__{int i;}*HSZ;
typedef struct HDDEDATA__{int i;}*HDDEDATA;
typedef HDDEDATA __attribute__((__stdcall__)) FNCALLBACK(UINT,UINT,HCONV,HSZ,HSZ,HDDEDATA,DWORD,DWORD);
typedef HDDEDATA(__attribute__((__stdcall__)) *PFNCALLBACK)(UINT,UINT,HCONV,HSZ,HSZ,HDDEDATA,DWORD,DWORD);
typedef struct tagHSZPAIR {
 HSZ hszSvc;
 HSZ hszTopic;
} HSZPAIR, *PHSZPAIR;
typedef struct tagCONVCONTEXT {
 UINT cb;
 UINT wFlags;
 UINT wCountryID;
 int iCodePage;
 DWORD dwLangID;
 DWORD dwSecurity;
 SECURITY_QUALITY_OF_SERVICE qos;
} CONVCONTEXT,*PCONVCONTEXT;
typedef struct tagCONVINFO {
 DWORD cb;
 DWORD hUser;
 HCONV hConvPartner;
 HSZ hszSvcPartner;
 HSZ hszServiceReq;
 HSZ hszTopic;
 HSZ hszItem;
 UINT wFmt;
 UINT wType;
 UINT wStatus;
 UINT wConvst;
 UINT wLastError;
 HCONVLIST hConvList;
 CONVCONTEXT ConvCtxt;
 HWND hwnd;
 HWND hwndPartner;
} CONVINFO,*PCONVINFO;
typedef struct tagDDEML_MSG_HOOK_DATA {
 UINT uiLo;
 UINT uiHi;
 DWORD cbData;
 DWORD Data[8];
} DDEML_MSG_HOOK_DATA;
typedef struct tagMONHSZSTRUCT {
 UINT cb;
 BOOL fsAction;
 DWORD dwTime;
 HSZ hsz;
 HANDLE hTask;
 TCHAR str[1];
} MONHSZSTRUCT, *PMONHSZSTRUCT;
typedef struct tagMONLINKSTRUCT {
 UINT cb;
 DWORD dwTime;
 HANDLE hTask;
 BOOL fEstablished;
 BOOL fNoData;
 HSZ hszSvc;
 HSZ hszTopic;
 HSZ hszItem;
 UINT wFmt;
 BOOL fServer;
 HCONV hConvServer;
 HCONV hConvClient;
} MONLINKSTRUCT, *PMONLINKSTRUCT;
typedef struct tagMONCONVSTRUCT {
 UINT cb;
 BOOL fConnect;
 DWORD dwTime;
 HANDLE hTask;
 HSZ hszSvc;
 HSZ hszTopic;
 HCONV hConvClient;
 HCONV hConvServer;
} MONCONVSTRUCT, *PMONCONVSTRUCT;
typedef struct tagMONCBSTRUCT {
 UINT cb;
 DWORD dwTime;
 HANDLE hTask;
 DWORD dwRet;
 UINT wType;
 UINT wFmt;
 HCONV hConv;
 HSZ hsz1;
 HSZ hsz2;
 HDDEDATA hData;
 ULONG_PTR dwData1;
 ULONG_PTR dwData2;
 CONVCONTEXT cc;
 DWORD cbData;
 DWORD Data[8];
} MONCBSTRUCT, *PMONCBSTRUCT;
typedef struct tagMONERRSTRUCT {
 UINT cb;
 UINT wLastError;
 DWORD dwTime;
 HANDLE hTask;
} MONERRSTRUCT, *PMONERRSTRUCT;
typedef struct tagMONMSGSTRUCT {
 UINT cb;
 HWND hwndTo;
 DWORD dwTime;
 HANDLE hTask;
 UINT wMsg;
 WPARAM wParam;
 LPARAM lParam;
 DDEML_MSG_HOOK_DATA dmhd;
} MONMSGSTRUCT, *PMONMSGSTRUCT;

BOOL __attribute__((__stdcall__)) DdeAbandonTransaction(DWORD,HCONV,DWORD);
PBYTE __attribute__((__stdcall__)) DdeAccessData(HDDEDATA,PDWORD);
HDDEDATA __attribute__((__stdcall__)) DdeAddData(HDDEDATA,PBYTE,DWORD,DWORD);
HDDEDATA __attribute__((__stdcall__)) DdeClientTransaction(PBYTE,DWORD,HCONV,HSZ,UINT,UINT,DWORD,PDWORD);
int __attribute__((__stdcall__)) DdeCmpStringHandles(HSZ,HSZ);
HCONV __attribute__((__stdcall__)) DdeConnect(DWORD,HSZ,HSZ,PCONVCONTEXT);
HCONVLIST __attribute__((__stdcall__)) DdeConnectList(DWORD,HSZ,HSZ,HCONVLIST,PCONVCONTEXT);
HDDEDATA __attribute__((__stdcall__)) DdeCreateDataHandle(DWORD,PBYTE,DWORD,DWORD,HSZ,UINT,UINT);
HSZ __attribute__((__stdcall__)) DdeCreateStringHandleA(DWORD,LPSTR,int);
HSZ __attribute__((__stdcall__)) DdeCreateStringHandleW(DWORD,LPWSTR,int);
BOOL __attribute__((__stdcall__)) DdeDisconnect(HCONV);
BOOL __attribute__((__stdcall__)) DdeDisconnectList(HCONVLIST);
BOOL __attribute__((__stdcall__)) DdeEnableCallback(DWORD,HCONV,UINT);
BOOL __attribute__((__stdcall__)) DdeFreeDataHandle(HDDEDATA);
BOOL __attribute__((__stdcall__)) DdeFreeStringHandle(DWORD,HSZ);
DWORD __attribute__((__stdcall__)) DdeGetData(HDDEDATA,PBYTE,DWORD,DWORD);
UINT __attribute__((__stdcall__)) DdeGetLastError(DWORD);
BOOL __attribute__((__stdcall__)) DdeImpersonateClient(HCONV);
UINT __attribute__((__stdcall__)) DdeInitializeA(PDWORD,PFNCALLBACK,DWORD,DWORD);
UINT __attribute__((__stdcall__)) DdeInitializeW(PDWORD,PFNCALLBACK,DWORD,DWORD);
BOOL __attribute__((__stdcall__)) DdeKeepStringHandle(DWORD,HSZ);
HDDEDATA __attribute__((__stdcall__)) DdeNameService(DWORD,HSZ,HSZ,UINT);
BOOL __attribute__((__stdcall__)) DdePostAdvise(DWORD,HSZ,HSZ);
UINT __attribute__((__stdcall__)) DdeQueryConvInfo(HCONV,DWORD,PCONVINFO);
HCONV __attribute__((__stdcall__)) DdeQueryNextServer(HCONVLIST,HCONV);
DWORD __attribute__((__stdcall__)) DdeQueryStringA(DWORD,HSZ,LPSTR,DWORD,int);
DWORD __attribute__((__stdcall__)) DdeQueryStringW(DWORD,HSZ,LPWSTR,DWORD,int);
HCONV __attribute__((__stdcall__)) DdeReconnect(HCONV);
BOOL __attribute__((__stdcall__)) DdeSetUserHandle(HCONV,DWORD,DWORD);
BOOL __attribute__((__stdcall__)) DdeUnaccessData(HDDEDATA);
BOOL __attribute__((__stdcall__)) DdeUninitialize(DWORD);
# 312 "H:/CPP/wxdevcpp6.10/include/ddeml.h" 3
}
# 77 "H:/CPP/wxdevcpp6.10/include/windows.h" 2 3
# 1 "H:/CPP/wxdevcpp6.10/include/dlgs.h" 1 3



       
# 5 "H:/CPP/wxdevcpp6.10/include/dlgs.h" 3



extern "C" {
# 176 "H:/CPP/wxdevcpp6.10/include/dlgs.h" 3
typedef struct tagCRGB {
 BYTE bRed;
 BYTE bGreen;
 BYTE bBlue;
 BYTE bExtra;
} CRGB;


}
# 78 "H:/CPP/wxdevcpp6.10/include/windows.h" 2 3
# 1 "H:/CPP/wxdevcpp6.10/include/imm.h" 1 3



       
# 5 "H:/CPP/wxdevcpp6.10/include/imm.h" 3



extern "C" {
# 247 "H:/CPP/wxdevcpp6.10/include/imm.h" 3
typedef DWORD HIMC;
typedef DWORD HIMCC;
typedef HKL *LPHKL;
typedef struct tagCOMPOSITIONFORM {
 DWORD dwStyle;
 POINT ptCurrentPos;
 RECT rcArea;
} COMPOSITIONFORM,*PCOMPOSITIONFORM,*LPCOMPOSITIONFORM;
typedef struct tagCANDIDATEFORM {
 DWORD dwIndex;
 DWORD dwStyle;
 POINT ptCurrentPos;
 RECT rcArea;
} CANDIDATEFORM,*PCANDIDATEFORM,*LPCANDIDATEFORM;
typedef struct tagCANDIDATELIST {
 DWORD dwSize;
 DWORD dwStyle;
 DWORD dwCount;
 DWORD dwSelection;
 DWORD dwPageStart;
 DWORD dwPageSize;
 DWORD dwOffset[1];
} CANDIDATELIST,*PCANDIDATELIST,*LPCANDIDATELIST;
typedef struct tagREGISTERWORDA {
 LPSTR lpReading;
 LPSTR lpWord;
} REGISTERWORDA,*PREGISTERWORDA,*LPREGISTERWORDA;
typedef struct tagREGISTERWORDW {
 LPWSTR lpReading;
 LPWSTR lpWord;
} REGISTERWORDW,*PREGISTERWORDW,*LPREGISTERWORDW;
typedef struct tagSTYLEBUFA {
 DWORD dwStyle;
 CHAR szDescription[32];
} STYLEBUFA,*PSTYLEBUFA,*LPSTYLEBUFA;
typedef struct tagSTYLEBUFW {
 DWORD dwStyle;
 WCHAR szDescription[32];
} STYLEBUFW,*PSTYLEBUFW,*LPSTYLEBUFW;
typedef struct tagIMEMENUITEMINFOA {
 UINT cbSize;
 UINT fType;
 UINT fState;
 UINT wID;
 HBITMAP hbmpChecked;
 HBITMAP hbmpUnchecked;
 DWORD dwItemData;
 CHAR szString[80];
 HBITMAP hbmpItem;
} IMEMENUITEMINFOA,*PIMEMENUITEMINFOA,*LPIMEMENUITEMINFOA;
typedef struct tagIMEMENUITEMINFOW {
 UINT cbSize;
 UINT fType;
 UINT fState;
 UINT wID;
 HBITMAP hbmpChecked;
 HBITMAP hbmpUnchecked;
 DWORD dwItemData;
 WCHAR szString[80];
 HBITMAP hbmpItem;
} IMEMENUITEMINFOW,*PIMEMENUITEMINFOW,*LPIMEMENUITEMINFOW;
typedef int (__attribute__((__stdcall__)) *REGISTERWORDENUMPROCA)(LPCSTR, DWORD, LPCSTR, LPVOID);
typedef int (__attribute__((__stdcall__)) *REGISTERWORDENUMPROCW)(LPCWSTR, DWORD, LPCWSTR, LPVOID);







typedef REGISTERWORDA REGISTERWORD,*PREGISTERWORD,*LPREGISTERWORD;
typedef STYLEBUFA STYLEBUF,*PSTYLEBUF,*LPSTYLEBUF;
typedef IMEMENUITEMINFOA IMEMENUITEMINFO,*PIMEMENUITEMINFO,*LPIMEMENUITEMINFO;

HKL __attribute__((__stdcall__)) ImmInstallIMEA(LPCSTR,LPCSTR);
HKL __attribute__((__stdcall__)) ImmInstallIMEW(LPCWSTR,LPCWSTR);
HWND __attribute__((__stdcall__)) ImmGetDefaultIMEWnd(HWND);
UINT __attribute__((__stdcall__)) ImmGetDescriptionA(HKL,LPSTR,UINT);
UINT __attribute__((__stdcall__)) ImmGetDescriptionW(HKL,LPWSTR,UINT);
UINT __attribute__((__stdcall__)) ImmGetIMEFileNameA(HKL,LPSTR,UINT);
UINT __attribute__((__stdcall__)) ImmGetIMEFileNameW(HKL,LPWSTR,UINT);
DWORD __attribute__((__stdcall__)) ImmGetProperty(HKL,DWORD);
BOOL __attribute__((__stdcall__)) ImmIsIME(HKL);
BOOL __attribute__((__stdcall__)) ImmSimulateHotKey(HWND,DWORD);
HIMC __attribute__((__stdcall__)) ImmCreateContext(void);
BOOL __attribute__((__stdcall__)) ImmDestroyContext(HIMC);
HIMC __attribute__((__stdcall__)) ImmGetContext(HWND);
BOOL __attribute__((__stdcall__)) ImmReleaseContext(HWND,HIMC);
HIMC __attribute__((__stdcall__)) ImmAssociateContext(HWND,HIMC);
LONG __attribute__((__stdcall__)) ImmGetCompositionStringA(HIMC,DWORD,PVOID,DWORD);
LONG __attribute__((__stdcall__)) ImmGetCompositionStringW(HIMC,DWORD,PVOID,DWORD);
BOOL __attribute__((__stdcall__)) ImmSetCompositionStringA(HIMC,DWORD,PCVOID,DWORD,PCVOID,DWORD);
BOOL __attribute__((__stdcall__)) ImmSetCompositionStringW(HIMC,DWORD,PCVOID,DWORD,PCVOID,DWORD);
DWORD __attribute__((__stdcall__)) ImmGetCandidateListCountA(HIMC,PDWORD);
DWORD __attribute__((__stdcall__)) ImmGetCandidateListCountW(HIMC,PDWORD);
DWORD __attribute__((__stdcall__)) ImmGetCandidateListA(HIMC,DWORD,PCANDIDATELIST,DWORD);
DWORD __attribute__((__stdcall__)) ImmGetCandidateListW(HIMC,DWORD,PCANDIDATELIST,DWORD);
DWORD __attribute__((__stdcall__)) ImmGetGuideLineA(HIMC,DWORD,LPSTR,DWORD);
DWORD __attribute__((__stdcall__)) ImmGetGuideLineW(HIMC,DWORD,LPWSTR,DWORD);
BOOL __attribute__((__stdcall__)) ImmGetConversionStatus(HIMC,LPDWORD,PDWORD);
BOOL __attribute__((__stdcall__)) ImmSetConversionStatus(HIMC,DWORD,DWORD);
BOOL __attribute__((__stdcall__)) ImmGetOpenStatus(HIMC);
BOOL __attribute__((__stdcall__)) ImmSetOpenStatus(HIMC,BOOL);

BOOL __attribute__((__stdcall__)) ImmGetCompositionFontA(HIMC,LPLOGFONTA);
BOOL __attribute__((__stdcall__)) ImmGetCompositionFontW(HIMC,LPLOGFONTW);
BOOL __attribute__((__stdcall__)) ImmSetCompositionFontA(HIMC,LPLOGFONTA);
BOOL __attribute__((__stdcall__)) ImmSetCompositionFontW(HIMC,LPLOGFONTW);

BOOL __attribute__((__stdcall__)) ImmConfigureIMEA(HKL,HWND,DWORD,PVOID);
BOOL __attribute__((__stdcall__)) ImmConfigureIMEW(HKL,HWND,DWORD,PVOID);
LRESULT __attribute__((__stdcall__)) ImmEscapeA(HKL,HIMC,UINT,PVOID);
LRESULT __attribute__((__stdcall__)) ImmEscapeW(HKL,HIMC,UINT,PVOID);
DWORD __attribute__((__stdcall__)) ImmGetConversionListA(HKL,HIMC,LPCSTR,PCANDIDATELIST,DWORD,UINT);
DWORD __attribute__((__stdcall__)) ImmGetConversionListW(HKL,HIMC,LPCWSTR,PCANDIDATELIST,DWORD,UINT);
BOOL __attribute__((__stdcall__)) ImmNotifyIME(HIMC,DWORD,DWORD,DWORD);
BOOL __attribute__((__stdcall__)) ImmGetStatusWindowPos(HIMC,LPPOINT);
BOOL __attribute__((__stdcall__)) ImmSetStatusWindowPos(HIMC,LPPOINT);
BOOL __attribute__((__stdcall__)) ImmGetCompositionWindow(HIMC,PCOMPOSITIONFORM);
BOOL __attribute__((__stdcall__)) ImmSetCompositionWindow(HIMC,PCOMPOSITIONFORM);
BOOL __attribute__((__stdcall__)) ImmGetCandidateWindow(HIMC,DWORD,PCANDIDATEFORM);
BOOL __attribute__((__stdcall__)) ImmSetCandidateWindow(HIMC,PCANDIDATEFORM);
BOOL __attribute__((__stdcall__)) ImmIsUIMessageA(HWND,UINT,WPARAM,LPARAM);
BOOL __attribute__((__stdcall__)) ImmIsUIMessageW(HWND,UINT,WPARAM,LPARAM);
UINT __attribute__((__stdcall__)) ImmGetVirtualKey(HWND);
BOOL __attribute__((__stdcall__)) ImmRegisterWordA(HKL,LPCSTR,DWORD,LPCSTR);
BOOL __attribute__((__stdcall__)) ImmRegisterWordW(HKL,LPCWSTR,DWORD,LPCWSTR);
BOOL __attribute__((__stdcall__)) ImmUnregisterWordA(HKL,LPCSTR,DWORD,LPCSTR);
BOOL __attribute__((__stdcall__)) ImmUnregisterWordW(HKL,LPCWSTR,DWORD,LPCWSTR);
UINT __attribute__((__stdcall__)) ImmGetRegisterWordStyleA(HKL,UINT,PSTYLEBUFA);
UINT __attribute__((__stdcall__)) ImmGetRegisterWordStyleW(HKL,UINT,PSTYLEBUFW);
UINT __attribute__((__stdcall__)) ImmEnumRegisterWordA(HKL,REGISTERWORDENUMPROCA,LPCSTR,DWORD,LPCSTR,PVOID);
UINT __attribute__((__stdcall__)) ImmEnumRegisterWordW(HKL,REGISTERWORDENUMPROCW,LPCWSTR,DWORD,LPCWSTR,PVOID);
BOOL __attribute__((__stdcall__)) EnableEUDC(BOOL);
BOOL __attribute__((__stdcall__)) ImmDisableIME(DWORD);
DWORD __attribute__((__stdcall__)) ImmGetImeMenuItemsA(HIMC,DWORD,DWORD,LPIMEMENUITEMINFOA,LPIMEMENUITEMINFOA,DWORD);
DWORD __attribute__((__stdcall__)) ImmGetImeMenuItemsW(HIMC,DWORD,DWORD,LPIMEMENUITEMINFOW,LPIMEMENUITEMINFOW,DWORD);
# 431 "H:/CPP/wxdevcpp6.10/include/imm.h" 3
}
# 79 "H:/CPP/wxdevcpp6.10/include/windows.h" 2 3
# 1 "H:/CPP/wxdevcpp6.10/include/lzexpand.h" 1 3



       
# 5 "H:/CPP/wxdevcpp6.10/include/lzexpand.h" 3



extern "C" {
# 18 "H:/CPP/wxdevcpp6.10/include/lzexpand.h" 3
LONG __attribute__((__stdcall__)) CopyLZFile(INT,INT);
INT __attribute__((__stdcall__)) GetExpandedNameA(LPSTR,LPSTR);
INT __attribute__((__stdcall__)) GetExpandedNameW(LPWSTR,LPWSTR);
void __attribute__((__stdcall__)) LZClose(INT);
LONG __attribute__((__stdcall__)) LZCopy(INT,INT);
void __attribute__((__stdcall__)) LZDone(void);
INT __attribute__((__stdcall__)) LZInit(INT);
INT __attribute__((__stdcall__)) LZOpenFileA(LPSTR,LPOFSTRUCT,WORD);
INT __attribute__((__stdcall__)) LZOpenFileW(LPWSTR,LPOFSTRUCT,WORD);
INT __attribute__((__stdcall__)) LZRead(INT,LPSTR,INT);
LONG __attribute__((__stdcall__)) LZSeek(INT,LONG,INT);
INT __attribute__((__stdcall__)) LZStart(void);
# 38 "H:/CPP/wxdevcpp6.10/include/lzexpand.h" 3
}
# 80 "H:/CPP/wxdevcpp6.10/include/windows.h" 2 3
# 1 "H:/CPP/wxdevcpp6.10/include/mmsystem.h" 1 3




       
# 6 "H:/CPP/wxdevcpp6.10/include/mmsystem.h" 3

#pragma pack(push,1)

extern "C" {
# 904 "H:/CPP/wxdevcpp6.10/include/mmsystem.h" 3
typedef DWORD MCIERROR;
typedef UINT MCIDEVICEID;
typedef UINT(__attribute__((__stdcall__)) *YIELDPROC)(MCIDEVICEID,DWORD);
typedef UINT MMVERSION;
typedef UINT MMRESULT;
typedef struct mmtime_tag {
 UINT wType;
 union {
  DWORD ms;
  DWORD sample;
  DWORD cb;
  DWORD ticks;
  struct {
   BYTE hour;
   BYTE min;
   BYTE sec;
   BYTE frame;
   BYTE fps;
   BYTE dummy;
   BYTE pad[2];
  } smpte;
  struct {
   DWORD songptrpos;
  } midi;
 } u;
} MMTIME,*PMMTIME,*LPMMTIME;
typedef struct HDRVR__{int i;}*HDRVR;
typedef struct tagDRVCONFIGINFO {
 DWORD dwDCISize;
 LPCWSTR lpszDCISectionName;
 LPCWSTR lpszDCIAliasName;
} DRVCONFIGINFO,*PDRVCONFIGINFO,*LPDRVCONFIGINFO;
typedef struct DRVCONFIGINFOEX {
 DWORD dwDCISize;
 LPCWSTR lpszDCISectionName;
 LPCWSTR lpszDCIAliasName;
 DWORD dnDevNode;
} DRVCONFIGINFOEX,*PDRVCONFIGINFOEX,*LPDRVCONFIGINFOEX;
typedef LRESULT(__attribute__((__stdcall__))* DRIVERPROC)(DWORD,HDRVR,UINT,LPARAM,LPARAM);
typedef void (__attribute__((__stdcall__)) DRVCALLBACK)(HDRVR,UINT,DWORD,DWORD,DWORD);
typedef DRVCALLBACK *LPDRVCALLBACK;
typedef DRVCALLBACK *PDRVCALLBACK;
typedef struct HWAVE__{int i;}*HWAVE;
typedef struct HWAVEIN__{int i;}*HWAVEIN;
typedef struct HWAVEOUT__{int i;}*HWAVEOUT;
typedef HWAVEIN *LPHWAVEIN;
typedef HWAVEOUT *LPHWAVEOUT;
typedef DRVCALLBACK WAVECALLBACK;
typedef WAVECALLBACK *LPWAVECALLBACK;
typedef struct wavehdr_tag {
 LPSTR lpData;
 DWORD dwBufferLength;
 DWORD dwBytesRecorded;
 DWORD dwUser;
 DWORD dwFlags;
 DWORD dwLoops;
 struct wavehdr_tag *lpNext;
 DWORD reserved;
} WAVEHDR,*PWAVEHDR,*LPWAVEHDR;
typedef struct tagWAVEOUTCAPSA {
 WORD wMid;
 WORD wPid;
 MMVERSION vDriverVersion;
 CHAR szPname[32];
 DWORD dwFormats;
 WORD wChannels;
 WORD wReserved1;
 DWORD dwSupport;
} WAVEOUTCAPSA,*PWAVEOUTCAPSA,*LPWAVEOUTCAPSA;
typedef struct tagWAVEOUTCAPSW {
 WORD wMid;
 WORD wPid;
 MMVERSION vDriverVersion;
 WCHAR szPname[32];
 DWORD dwFormats;
 WORD wChannels;
 WORD wReserved1;
 DWORD dwSupport;
} WAVEOUTCAPSW,*PWAVEOUTCAPSW,*LPWAVEOUTCAPSW;
typedef struct tagWAVEINCAPSA {
 WORD wMid;
 WORD wPid;
 MMVERSION vDriverVersion;
 CHAR szPname[32];
 DWORD dwFormats;
 WORD wChannels;
 WORD wReserved1;
} WAVEINCAPSA,*PWAVEINCAPSA,*LPWAVEINCAPSA;
typedef struct tagWAVEINCAPSW {
 WORD wMid;
 WORD wPid;
 MMVERSION vDriverVersion;
 WCHAR szPname[32];
 DWORD dwFormats;
 WORD wChannels;
 WORD wReserved1;
} WAVEINCAPSW,*PWAVEINCAPSW,*LPWAVEINCAPSW;
typedef struct waveformat_tag {
 WORD wFormatTag;
 WORD nChannels;
 DWORD nSamplesPerSec;
 DWORD nAvgBytesPerSec;
 WORD nBlockAlign;
} WAVEFORMAT,*PWAVEFORMAT,*LPWAVEFORMAT;
typedef struct pcmwaveformat_tag {
 WAVEFORMAT wf;
 WORD wBitsPerSample;
} PCMWAVEFORMAT, *PPCMWAVEFORMAT,*LPPCMWAVEFORMAT;


typedef struct tWAVEFORMATEX {
 WORD wFormatTag;
 WORD nChannels;
 DWORD nSamplesPerSec;
 DWORD nAvgBytesPerSec;
 WORD nBlockAlign;
 WORD wBitsPerSample;
 WORD cbSize;
} WAVEFORMATEX,*PWAVEFORMATEX,*LPWAVEFORMATEX;
typedef const WAVEFORMATEX *LPCWAVEFORMATEX;

typedef struct HMIDI__{int i;}*HMIDI;
typedef struct HMIDIIN__{int i;}*HMIDIIN;
typedef struct HMIDIOUT__{int i;}*HMIDIOUT;
typedef struct HMIDISTRM__{int i;}*HMIDISTRM;
typedef HMIDI *LPHMIDI;
typedef HMIDIIN *LPHMIDIIN;
typedef HMIDIOUT *LPHMIDIOUT;
typedef HMIDISTRM *LPHMIDISTRM;
typedef DRVCALLBACK MIDICALLBACK;
typedef MIDICALLBACK *LPMIDICALLBACK;
typedef WORD PATCHARRAY[128];
typedef WORD *LPPATCHARRAY;
typedef WORD KEYARRAY[128];
typedef WORD *LPKEYARRAY;
typedef struct tagMIDIOUTCAPSA {
 WORD wMid;
 WORD wPid;
 MMVERSION vDriverVersion;
 CHAR szPname[32];
 WORD wTechnology;
 WORD wVoices;
 WORD wNotes;
 WORD wChannelMask;
 DWORD dwSupport;
} MIDIOUTCAPSA,*PMIDIOUTCAPSA,*LPMIDIOUTCAPSA;
typedef struct tagMIDIOUTCAPSW {
 WORD wMid;
 WORD wPid;
 MMVERSION vDriverVersion;
 WCHAR szPname[32];
 WORD wTechnology;
 WORD wVoices;
 WORD wNotes;
 WORD wChannelMask;
 DWORD dwSupport;
} MIDIOUTCAPSW,*PMIDIOUTCAPSW,*LPMIDIOUTCAPSW;
typedef struct tagMIDIINCAPSA {
 WORD wMid;
 WORD wPid;
 MMVERSION vDriverVersion;
 CHAR szPname[32];
 DWORD dwSupport;
} MIDIINCAPSA,*PMIDIINCAPSA,*LPMIDIINCAPSA;
typedef struct tagMIDIINCAPSW {
 WORD wMid;
 WORD wPid;
 MMVERSION vDriverVersion;
 WCHAR szPname[32];
 DWORD dwSupport;
} MIDIINCAPSW,*PMIDIINCAPSW,*NPMIDIINCAPSW,*LPMIDIINCAPSW;
typedef struct midihdr_tag {
 LPSTR lpData;
 DWORD dwBufferLength;
 DWORD dwBytesRecorded;
 DWORD dwUser;
 DWORD dwFlags;
 struct midihdr_tag *lpNext;
 DWORD reserved;
 DWORD dwOffset;
 DWORD dwReserved[8];
} MIDIHDR,*PMIDIHDR,*LPMIDIHDR;
typedef struct midievent_tag {
 DWORD dwDeltaTime;
 DWORD dwStreamID;
 DWORD dwEvent;
 DWORD dwParms[1];
} MIDIEVENT;
typedef struct midistrmbuffver_tag {
 DWORD dwVersion;
 DWORD dwMid;
 DWORD dwOEMVersion;
} MIDISTRMBUFFVER;
typedef struct midiproptimediv_tag {
 DWORD cbStruct;
 DWORD dwTimeDiv;
} MIDIPROPTIMEDIV,*LPMIDIPROPTIMEDIV;
typedef struct midiproptempo_tag {
 DWORD cbStruct;
 DWORD dwTempo;
} MIDIPROPTEMPO,*LPMIDIPROPTEMPO;
typedef struct tagAUXCAPSA {
 WORD wMid;
 WORD wPid;
 MMVERSION vDriverVersion;
 CHAR szPname[32];
 WORD wTechnology;
 WORD wReserved1;
 DWORD dwSupport;
} AUXCAPSA,*PAUXCAPSA,*LPAUXCAPSA;
typedef struct tagAUXCAPSW {
 WORD wMid;
 WORD wPid;
 MMVERSION vDriverVersion;
 WCHAR szPname[32];
 WORD wTechnology;
 WORD wReserved1;
 DWORD dwSupport;
} AUXCAPSW,*PAUXCAPSW,*LPAUXCAPSW;
typedef struct HMIXEROBJ__{int i;}*HMIXEROBJ;
typedef HMIXEROBJ *LPHMIXEROBJ;
typedef struct HMIXER__{int i;}*HMIXER;
typedef HMIXER *LPHMIXER;
typedef struct tagMIXERCAPSA {
 WORD wMid;
 WORD wPid;
 MMVERSION vDriverVersion;
 CHAR szPname[32];
 DWORD fdwSupport;
 DWORD cDestinations;
} MIXERCAPSA,*PMIXERCAPSA,*LPMIXERCAPSA;
typedef struct tagMIXERCAPSW {
 WORD wMid;
 WORD wPid;
 MMVERSION vDriverVersion;
 WCHAR szPname[32];
 DWORD fdwSupport;
 DWORD cDestinations;
} MIXERCAPSW,*PMIXERCAPSW,*LPMIXERCAPSW;
typedef struct tagMIXERLINEA {
 DWORD cbStruct;
 DWORD dwDestination;
 DWORD dwSource;
 DWORD dwLineID;
 DWORD fdwLine;
 DWORD dwUser;
 DWORD dwComponentType;
 DWORD cChannels;
 DWORD cConnections;
 DWORD cControls;
 CHAR szShortName[16];
 CHAR szName[64];
 struct {
  DWORD dwType;
  DWORD dwDeviceID;
  WORD wMid;
  WORD wPid;
  MMVERSION vDriverVersion;
  CHAR szPname[32];
 } Target;
} MIXERLINEA,*PMIXERLINEA,*LPMIXERLINEA;
typedef struct tagMIXERLINEW {
 DWORD cbStruct;
 DWORD dwDestination;
 DWORD dwSource;
 DWORD dwLineID;
 DWORD fdwLine;
 DWORD dwUser;
 DWORD dwComponentType;
 DWORD cChannels;
 DWORD cConnections;
 DWORD cControls;
 WCHAR szShortName[16];
 WCHAR szName[64];
 struct {
  DWORD dwType;
  DWORD dwDeviceID;
  WORD wMid;
  WORD wPid;
  MMVERSION vDriverVersion;
  WCHAR szPname[32];
 } Target;
} MIXERLINEW,*PMIXERLINEW,*LPMIXERLINEW;
typedef struct tagMIXERCONTROLA {
 DWORD cbStruct;
 DWORD dwControlID;
 DWORD dwControlType;
 DWORD fdwControl;
 DWORD cMultipleItems;
 CHAR szShortName[16];
 CHAR szName[64];
 union {
  __extension__ struct {
   LONG lMinimum;
   LONG lMaximum;
  };
  __extension__ struct {
   DWORD dwMinimum;
   DWORD dwMaximum;
  };
  DWORD dwReserved[6];
 } Bounds;
 union {
  DWORD cSteps;
  DWORD cbCustomData;
  DWORD dwReserved[6];
 } Metrics;
} MIXERCONTROLA,*PMIXERCONTROLA,*LPMIXERCONTROLA;
typedef struct tagMIXERCONTROLW {
 DWORD cbStruct;
 DWORD dwControlID;
 DWORD dwControlType;
 DWORD fdwControl;
 DWORD cMultipleItems;
 WCHAR szShortName[16];
 WCHAR szName[64];
 union {
  __extension__ struct {
   LONG lMinimum;
   LONG lMaximum;
  };
  __extension__ struct {
   DWORD dwMinimum;
   DWORD dwMaximum;
  };
  DWORD dwReserved[6];
 } Bounds;
 union {
  DWORD cSteps;
  DWORD cbCustomData;
  DWORD dwReserved[6];
 } Metrics;
} MIXERCONTROLW,*PMIXERCONTROLW,*LPMIXERCONTROLW;
typedef struct tagMIXERLINECONTROLSA {
 DWORD cbStruct;
 DWORD dwLineID;
 __extension__ union {
  DWORD dwControlID;
  DWORD dwControlType;
 } ;
 DWORD cControls;
 DWORD cbmxctrl;
 LPMIXERCONTROLA pamxctrl;
} MIXERLINECONTROLSA,*PMIXERLINECONTROLSA,*LPMIXERLINECONTROLSA;
typedef struct tagMIXERLINECONTROLSW {
 DWORD cbStruct;
 DWORD dwLineID;
 __extension__ union {
  DWORD dwControlID;
  DWORD dwControlType;
 } ;
 DWORD cControls;
 DWORD cbmxctrl;
 LPMIXERCONTROLW pamxctrl;
} MIXERLINECONTROLSW,*PMIXERLINECONTROLSW,*LPMIXERLINECONTROLSW;
typedef struct tMIXERCONTROLDETAILS {
 DWORD cbStruct;
 DWORD dwControlID;
 DWORD cChannels;
 __extension__ union {
  HWND hwndOwner;
  DWORD cMultipleItems;
 } ;
 DWORD cbDetails;
 PVOID paDetails;
} MIXERCONTROLDETAILS,*PMIXERCONTROLDETAILS,*LPMIXERCONTROLDETAILS;
typedef struct tagMIXERCONTROLDETAILS_LISTTEXTA {
 DWORD dwParam1;
 DWORD dwParam2;
 CHAR szName[64];
} MIXERCONTROLDETAILS_LISTTEXTA,*PMIXERCONTROLDETAILS_LISTTEXTA,*LPMIXERCONTROLDETAILS_LISTTEXTA;
typedef struct tagMIXERCONTROLDETAILS_LISTTEXTW {
 DWORD dwParam1;
 DWORD dwParam2;
 WCHAR szName[64];
} MIXERCONTROLDETAILS_LISTTEXTW,*PMIXERCONTROLDETAILS_LISTTEXTW,*LPMIXERCONTROLDETAILS_LISTTEXTW;
typedef struct tMIXERCONTROLDETAILS_BOOLEAN {
 LONG fValue;
} MIXERCONTROLDETAILS_BOOLEAN,*PMIXERCONTROLDETAILS_BOOLEAN,*LPMIXERCONTROLDETAILS_BOOLEAN;
typedef struct tMIXERCONTROLDETAILS_SIGNED {
 LONG lValue;
} MIXERCONTROLDETAILS_SIGNED,*PMIXERCONTROLDETAILS_SIGNED,*LPMIXERCONTROLDETAILS_SIGNED;
typedef struct tMIXERCONTROLDETAILS_UNSIGNED {
 DWORD dwValue;
} MIXERCONTROLDETAILS_UNSIGNED,*PMIXERCONTROLDETAILS_UNSIGNED,*LPMIXERCONTROLDETAILS_UNSIGNED;
typedef void(__attribute__((__stdcall__)) TIMECALLBACK)(UINT,UINT,DWORD,DWORD,DWORD);
typedef TIMECALLBACK *LPTIMECALLBACK;
typedef struct timecaps_tag {
 UINT wPeriodMin;
 UINT wPeriodMax;
} TIMECAPS,*PTIMECAPS,*LPTIMECAPS;
typedef struct tagJOYCAPSA {
 WORD wMid;
 WORD wPid;
 CHAR szPname[32];
 UINT wXmin;
 UINT wXmax;
 UINT wYmin;
 UINT wYmax;
 UINT wZmin;
 UINT wZmax;
 UINT wNumButtons;
 UINT wPeriodMin;
 UINT wPeriodMax;
 UINT wRmin;
 UINT wRmax;
 UINT wUmin;
 UINT wUmax;
 UINT wVmin;
 UINT wVmax;
 UINT wCaps;
 UINT wMaxAxes;
 UINT wNumAxes;
 UINT wMaxButtons;
 CHAR szRegKey[32];
 CHAR szOEMVxD[260];
} JOYCAPSA,*PJOYCAPSA,*LPJOYCAPSA;
typedef struct tagJOYCAPSW {
 WORD wMid;
 WORD wPid;
 WCHAR szPname[32];
 UINT wXmin;
 UINT wXmax;
 UINT wYmin;
 UINT wYmax;
 UINT wZmin;
 UINT wZmax;
 UINT wNumButtons;
 UINT wPeriodMin;
 UINT wPeriodMax;
 UINT wRmin;
 UINT wRmax;
 UINT wUmin;
 UINT wUmax;
 UINT wVmin;
 UINT wVmax;
 UINT wCaps;
 UINT wMaxAxes;
 UINT wNumAxes;
 UINT wMaxButtons;
 WCHAR szRegKey[32];
 WCHAR szOEMVxD[260];
} JOYCAPSW,*PJOYCAPSW,*LPJOYCAPSW;
typedef struct joyinfo_tag {
 UINT wXpos;
 UINT wYpos;
 UINT wZpos;
 UINT wButtons;
} JOYINFO,*PJOYINFO,*LPJOYINFO;
typedef struct joyinfoex_tag {
 DWORD dwSize;
 DWORD dwFlags;
 DWORD dwXpos;
 DWORD dwYpos;
 DWORD dwZpos;
 DWORD dwRpos;
 DWORD dwUpos;
 DWORD dwVpos;
 DWORD dwButtons;
 DWORD dwButtonNumber;
 DWORD dwPOV;
 DWORD dwReserved1;
 DWORD dwReserved2;
} JOYINFOEX,*PJOYINFOEX,*LPJOYINFOEX;
typedef DWORD FOURCC;
typedef char *HPSTR;
typedef struct HMMIO__{int i;}*HMMIO;
typedef LRESULT (__attribute__((__stdcall__)) MMIOPROC)(LPSTR,UINT,LPARAM,LPARAM);
typedef MMIOPROC *LPMMIOPROC;
typedef struct _MMIOINFO {
 DWORD dwFlags;
 FOURCC fccIOProc;
 LPMMIOPROC pIOProc;
 UINT wErrorRet;
 HTASK htask;
 LONG cchBuffer;
 HPSTR pchBuffer;
 HPSTR pchNext;
 HPSTR pchEndRead;
 HPSTR pchEndWrite;
 LONG lBufOffset;
 LONG lDiskOffset;
 DWORD adwInfo[3];
 DWORD dwReserved1;
 DWORD dwReserved2;
 HMMIO hmmio;
} MMIOINFO,*PMMIOINFO,*LPMMIOINFO;
typedef const MMIOINFO *LPCMMIOINFO;
typedef struct _MMCKINFO {
 FOURCC ckid;
 DWORD cksize;
 FOURCC fccType;
 DWORD dwDataOffset;
 DWORD dwFlags;
} MMCKINFO,*PMMCKINFO,*LPMMCKINFO;
typedef const MMCKINFO *LPCMMCKINFO;
typedef struct tagMCI_GENERIC_PARMS {
 DWORD dwCallback;
} MCI_GENERIC_PARMS,*PMCI_GENERIC_PARMS,*LPMCI_GENERIC_PARMS;
typedef struct tagMCI_OPEN_PARMSA {
 DWORD dwCallback;
 MCIDEVICEID wDeviceID;
 LPCSTR lpstrDeviceType;
 LPCSTR lpstrElementName;
 LPCSTR lpstrAlias;
} MCI_OPEN_PARMSA,*PMCI_OPEN_PARMSA,*LPMCI_OPEN_PARMSA;
typedef struct tagMCI_OPEN_PARMSW {
 DWORD dwCallback;
 MCIDEVICEID wDeviceID;
 LPCWSTR lpstrDeviceType;
 LPCWSTR lpstrElementName;
 LPCWSTR lpstrAlias;
} MCI_OPEN_PARMSW,*PMCI_OPEN_PARMSW,*LPMCI_OPEN_PARMSW;
typedef struct tagMCI_PLAY_PARMS {
 DWORD dwCallback;
 DWORD dwFrom;
 DWORD dwTo;
} MCI_PLAY_PARMS,*PMCI_PLAY_PARMS,*LPMCI_PLAY_PARMS;
typedef struct tagMCI_SEEK_PARMS {
 DWORD dwCallback;
 DWORD dwTo;
} MCI_SEEK_PARMS, *PMCI_SEEK_PARMS,*LPMCI_SEEK_PARMS;
typedef struct tagMCI_STATUS_PARMS {
 DWORD dwCallback;
 DWORD dwReturn;
 DWORD dwItem;
 DWORD dwTrack;
} MCI_STATUS_PARMS,*PMCI_STATUS_PARMS,*LPMCI_STATUS_PARMS;
typedef struct tagMCI_INFO_PARMSA {
 DWORD dwCallback;
 LPSTR lpstrReturn;
 DWORD dwRetSize;
} MCI_INFO_PARMSA,*LPMCI_INFO_PARMSA;
typedef struct tagMCI_INFO_PARMSW {
 DWORD dwCallback;
 LPWSTR lpstrReturn;
 DWORD dwRetSize;
} MCI_INFO_PARMSW,*LPMCI_INFO_PARMSW;
typedef struct tagMCI_GETDEVCAPS_PARMS {
 DWORD dwCallback;
 DWORD dwReturn;
 DWORD dwItem;
} MCI_GETDEVCAPS_PARMS,*PMCI_GETDEVCAPS_PARMS,*LPMCI_GETDEVCAPS_PARMS;
typedef struct tagMCI_SYSINFO_PARMSA {
 DWORD dwCallback;
 LPSTR lpstrReturn;
 DWORD dwRetSize;
 DWORD dwNumber;
 UINT wDeviceType;
} MCI_SYSINFO_PARMSA,*PMCI_SYSINFO_PARMSA,*LPMCI_SYSINFO_PARMSA;
typedef struct tagMCI_SYSINFO_PARMSW {
 DWORD dwCallback;
 LPWSTR lpstrReturn;
 DWORD dwRetSize;
 DWORD dwNumber;
 UINT wDeviceType;
} MCI_SYSINFO_PARMSW,*PMCI_SYSINFO_PARMSW,*LPMCI_SYSINFO_PARMSW;
typedef struct tagMCI_SET_PARMS {
 DWORD dwCallback;
 DWORD dwTimeFormat;
 DWORD dwAudio;
} MCI_SET_PARMS,*PMCI_SET_PARMS,*LPMCI_SET_PARMS;
typedef struct tagMCI_BREAK_PARMS {
 DWORD dwCallback;
 int nVirtKey;
 HWND hwndBreak;
} MCI_BREAK_PARMS,*PMCI_BREAK_PARMS,*LPMCI_BREAK_PARMS;
typedef struct tagMCI_SAVE_PARMSA {
 DWORD dwCallback;
 LPCSTR lpfilename;
} MCI_SAVE_PARMSA,*PMCI_SAVE_PARMSA,*LPMCI_SAVE_PARMSA;
typedef struct tagMCI_SAVE_PARMSW {
 DWORD dwCallback;
 LPCWSTR lpfilename;
} MCI_SAVE_PARMSW,*PMCI_SAVE_PARMSW,*LPMCI_SAVE_PARMSW;
typedef struct tagMCI_LOAD_PARMSA {
 DWORD dwCallback;
 LPCSTR lpfilename;
} MCI_LOAD_PARMSA,*PMCI_LOAD_PARMSA,*LPMCI_LOAD_PARMSA;
typedef struct tagMCI_LOAD_PARMSW {
 DWORD dwCallback;
 LPCWSTR lpfilename;
} MCI_LOAD_PARMSW,*PMCI_LOAD_PARMSW,*LPMCI_LOAD_PARMSW;
typedef struct tagMCI_RECORD_PARMS {
 DWORD dwCallback;
 DWORD dwFrom;
 DWORD dwTo;
} MCI_RECORD_PARMS,*LPMCI_RECORD_PARMS;
typedef struct tagMCI_VD_PLAY_PARMS {
 DWORD dwCallback;
 DWORD dwFrom;
 DWORD dwTo;
 DWORD dwSpeed;
} MCI_VD_PLAY_PARMS,*PMCI_VD_PLAY_PARMS,*LPMCI_VD_PLAY_PARMS;
typedef struct tagMCI_VD_STEP_PARMS {
 DWORD dwCallback;
 DWORD dwFrames;
} MCI_VD_STEP_PARMS,*PMCI_VD_STEP_PARMS,*LPMCI_VD_STEP_PARMS;
typedef struct tagMCI_VD_ESCAPE_PARMSA {
 DWORD dwCallback;
 LPCSTR lpstrCommand;
} MCI_VD_ESCAPE_PARMSA,*PMCI_VD_ESCAPE_PARMSA,*LPMCI_VD_ESCAPE_PARMSA;
typedef struct tagMCI_VD_ESCAPE_PARMSW {
 DWORD dwCallback;
 LPCWSTR lpstrCommand;
} MCI_VD_ESCAPE_PARMSW,*PMCI_VD_ESCAPE_PARMSW,*LPMCI_VD_ESCAPE_PARMSW;
typedef struct tagMCI_WAVE_OPEN_PARMSA {
 DWORD dwCallback;
 MCIDEVICEID wDeviceID;
 LPCSTR lpstrDeviceType;
 LPCSTR lpstrElementName;
 LPCSTR lpstrAlias;
 DWORD dwBufferSeconds;
} MCI_WAVE_OPEN_PARMSA,*PMCI_WAVE_OPEN_PARMSA,*LPMCI_WAVE_OPEN_PARMSA;
typedef struct tagMCI_WAVE_OPEN_PARMSW {
 DWORD dwCallback;
 MCIDEVICEID wDeviceID;
 LPCWSTR lpstrDeviceType;
 LPCWSTR lpstrElementName;
 LPCWSTR lpstrAlias;
 DWORD dwBufferSeconds;
} MCI_WAVE_OPEN_PARMSW,*PMCI_WAVE_OPEN_PARMSW,*LPMCI_WAVE_OPEN_PARMSW;
typedef struct tagMCI_WAVE_DELETE_PARMS {
 DWORD dwCallback;
 DWORD dwFrom;
 DWORD dwTo;
} MCI_WAVE_DELETE_PARMS, *PMCI_WAVE_DELETE_PARMS,*LPMCI_WAVE_DELETE_PARMS;
typedef struct tagMCI_WAVE_SET_PARMS {
 DWORD dwCallback;
 DWORD dwTimeFormat;
 DWORD dwAudio;
 UINT wInput;
 UINT wOutput;
 WORD wFormatTag;
 WORD wReserved2;
 WORD nChannels;
 WORD wReserved3;
 DWORD nSamplesPerSec;
 DWORD nAvgBytesPerSec;
 WORD nBlockAlign;
 WORD wReserved4;
 WORD wBitsPerSample;
 WORD wReserved5;
} MCI_WAVE_SET_PARMS,*PMCI_WAVE_SET_PARMS,*LPMCI_WAVE_SET_PARMS;

LRESULT __attribute__((__stdcall__)) CloseDriver(HDRVR,LONG,LONG);
HDRVR __attribute__((__stdcall__)) OpenDriver(LPCWSTR,LPCWSTR,LONG);
LRESULT __attribute__((__stdcall__)) SendDriverMessage(HDRVR,UINT,LONG,LONG);
HMODULE __attribute__((__stdcall__)) DrvGetModuleHandle(HDRVR);
HMODULE __attribute__((__stdcall__)) GetDriverModuleHandle(HDRVR);
LRESULT __attribute__((__stdcall__)) DefDriverProc(DWORD,HDRVR,UINT,LPARAM,LPARAM);
UINT __attribute__((__stdcall__)) mmsystemGetVersion(void);

BOOL __attribute__((__stdcall__)) sndPlaySoundA(LPCSTR,UINT);
BOOL __attribute__((__stdcall__)) sndPlaySoundW(LPCWSTR,UINT);
BOOL __attribute__((__stdcall__)) PlaySoundA(LPCSTR,HMODULE,DWORD);
BOOL __attribute__((__stdcall__)) PlaySoundW(LPCWSTR,HMODULE,DWORD);
UINT __attribute__((__stdcall__)) waveOutGetNumDevs(void);
MMRESULT __attribute__((__stdcall__)) waveOutGetDevCapsA(UINT,LPWAVEOUTCAPSA,UINT);
MMRESULT __attribute__((__stdcall__)) waveOutGetDevCapsW(UINT,LPWAVEOUTCAPSW,UINT);
MMRESULT __attribute__((__stdcall__)) waveOutGetVolume(HWAVEOUT,PDWORD);
MMRESULT __attribute__((__stdcall__)) waveOutSetVolume(HWAVEOUT,DWORD);
MMRESULT __attribute__((__stdcall__)) waveOutGetErrorTextA(MMRESULT,LPSTR,UINT);
MMRESULT __attribute__((__stdcall__)) waveOutGetErrorTextW(MMRESULT,LPWSTR,UINT);
MMRESULT __attribute__((__stdcall__)) waveOutOpen(LPHWAVEOUT,UINT,LPCWAVEFORMATEX,DWORD,DWORD,DWORD);
MMRESULT __attribute__((__stdcall__)) waveOutClose(HWAVEOUT);
MMRESULT __attribute__((__stdcall__)) waveOutPrepareHeader(HWAVEOUT,LPWAVEHDR,UINT);
MMRESULT __attribute__((__stdcall__)) waveOutUnprepareHeader(HWAVEOUT,LPWAVEHDR,UINT);
MMRESULT __attribute__((__stdcall__)) waveOutWrite(HWAVEOUT,LPWAVEHDR,UINT);
MMRESULT __attribute__((__stdcall__)) waveOutPause(HWAVEOUT);
MMRESULT __attribute__((__stdcall__)) waveOutRestart(HWAVEOUT);
MMRESULT __attribute__((__stdcall__)) waveOutReset(HWAVEOUT);
MMRESULT __attribute__((__stdcall__)) waveOutBreakLoop(HWAVEOUT);
MMRESULT __attribute__((__stdcall__)) waveOutGetPosition(HWAVEOUT,LPMMTIME,UINT);
MMRESULT __attribute__((__stdcall__)) waveOutGetPitch(HWAVEOUT,PDWORD);
MMRESULT __attribute__((__stdcall__)) waveOutSetPitch(HWAVEOUT,DWORD);
MMRESULT __attribute__((__stdcall__)) waveOutGetPlaybackRate(HWAVEOUT,PDWORD);
MMRESULT __attribute__((__stdcall__)) waveOutSetPlaybackRate(HWAVEOUT,DWORD);
MMRESULT __attribute__((__stdcall__)) waveOutGetID(HWAVEOUT,LPUINT);
MMRESULT __attribute__((__stdcall__)) waveOutMessage(HWAVEOUT,UINT,DWORD,DWORD);
UINT __attribute__((__stdcall__)) waveInGetNumDevs(void);
MMRESULT __attribute__((__stdcall__)) waveInGetDevCapsA(UINT,LPWAVEINCAPSA,UINT);
MMRESULT __attribute__((__stdcall__)) waveInGetDevCapsW(UINT,LPWAVEINCAPSW,UINT);
MMRESULT __attribute__((__stdcall__)) waveInGetErrorTextA(MMRESULT,LPSTR,UINT);
MMRESULT __attribute__((__stdcall__)) waveInGetErrorTextW(MMRESULT,LPWSTR,UINT);
MMRESULT __attribute__((__stdcall__)) waveInOpen(LPHWAVEIN,UINT,LPCWAVEFORMATEX,DWORD,DWORD,DWORD);
MMRESULT __attribute__((__stdcall__)) waveInClose(HWAVEIN);
MMRESULT __attribute__((__stdcall__)) waveInPrepareHeader(HWAVEIN,LPWAVEHDR,UINT);
MMRESULT __attribute__((__stdcall__)) waveInUnprepareHeader(HWAVEIN,LPWAVEHDR,UINT);
MMRESULT __attribute__((__stdcall__)) waveInAddBuffer(HWAVEIN,LPWAVEHDR,UINT);
MMRESULT __attribute__((__stdcall__)) waveInStart(HWAVEIN);
MMRESULT __attribute__((__stdcall__)) waveInStop(HWAVEIN);
MMRESULT __attribute__((__stdcall__)) waveInReset(HWAVEIN);
MMRESULT __attribute__((__stdcall__)) waveInGetPosition(HWAVEIN,LPMMTIME,UINT);
MMRESULT __attribute__((__stdcall__)) waveInGetID(HWAVEIN,LPUINT);
MMRESULT __attribute__((__stdcall__)) waveInMessage(HWAVEIN,UINT,DWORD,DWORD);
UINT __attribute__((__stdcall__)) midiOutGetNumDevs(void);
MMRESULT __attribute__((__stdcall__)) midiStreamOpen(LPHMIDISTRM,LPUINT,DWORD,DWORD,DWORD,DWORD);
MMRESULT __attribute__((__stdcall__)) midiStreamClose(HMIDISTRM);
MMRESULT __attribute__((__stdcall__)) midiStreamProperty(HMIDISTRM,LPBYTE,DWORD);
MMRESULT __attribute__((__stdcall__)) midiStreamPosition(HMIDISTRM,LPMMTIME,UINT);
MMRESULT __attribute__((__stdcall__)) midiStreamOut(HMIDISTRM,LPMIDIHDR,UINT);
MMRESULT __attribute__((__stdcall__)) midiStreamPause(HMIDISTRM);
MMRESULT __attribute__((__stdcall__)) midiStreamRestart(HMIDISTRM);
MMRESULT __attribute__((__stdcall__)) midiStreamStop(HMIDISTRM);
MMRESULT __attribute__((__stdcall__)) midiConnect(HMIDI,HMIDIOUT,PVOID);
MMRESULT __attribute__((__stdcall__)) midiDisconnect(HMIDI,HMIDIOUT,PVOID);
MMRESULT __attribute__((__stdcall__)) midiOutGetDevCapsA(UINT,LPMIDIOUTCAPSA,UINT);
MMRESULT __attribute__((__stdcall__)) midiOutGetDevCapsW(UINT,LPMIDIOUTCAPSW,UINT);
MMRESULT __attribute__((__stdcall__)) midiOutGetVolume(HMIDIOUT,PDWORD);
MMRESULT __attribute__((__stdcall__)) midiOutSetVolume(HMIDIOUT,DWORD);
MMRESULT __attribute__((__stdcall__)) midiOutGetErrorTextA(MMRESULT,LPSTR,UINT);
MMRESULT __attribute__((__stdcall__)) midiOutGetErrorTextW(MMRESULT,LPWSTR,UINT);
MMRESULT __attribute__((__stdcall__)) midiOutOpen(LPHMIDIOUT,UINT,DWORD,DWORD,DWORD);
MMRESULT __attribute__((__stdcall__)) midiOutClose(HMIDIOUT);
MMRESULT __attribute__((__stdcall__)) midiOutPrepareHeader(HMIDIOUT,LPMIDIHDR,UINT);
MMRESULT __attribute__((__stdcall__)) midiOutUnprepareHeader(HMIDIOUT,LPMIDIHDR,UINT);
MMRESULT __attribute__((__stdcall__)) midiOutShortMsg(HMIDIOUT,DWORD);
MMRESULT __attribute__((__stdcall__)) midiOutLongMsg(HMIDIOUT,LPMIDIHDR,UINT);
MMRESULT __attribute__((__stdcall__)) midiOutReset(HMIDIOUT);
MMRESULT __attribute__((__stdcall__)) midiOutCachePatches(HMIDIOUT,UINT,LPWORD,UINT);
MMRESULT __attribute__((__stdcall__)) midiOutCacheDrumPatches(HMIDIOUT,UINT,LPWORD,UINT);
MMRESULT __attribute__((__stdcall__)) midiOutGetID(HMIDIOUT,LPUINT);
MMRESULT __attribute__((__stdcall__)) midiOutMessage(HMIDIOUT,UINT,DWORD,DWORD);
UINT __attribute__((__stdcall__)) midiInGetNumDevs(void);
MMRESULT __attribute__((__stdcall__)) midiInGetDevCapsA(UINT,LPMIDIINCAPSA,UINT);
MMRESULT __attribute__((__stdcall__)) midiInGetDevCapsW(UINT,LPMIDIINCAPSW,UINT);
MMRESULT __attribute__((__stdcall__)) midiInGetErrorTextA(MMRESULT,LPSTR,UINT);
MMRESULT __attribute__((__stdcall__)) midiInGetErrorTextW(MMRESULT,LPWSTR,UINT);
MMRESULT __attribute__((__stdcall__)) midiInOpen(LPHMIDIIN,UINT,DWORD,DWORD,DWORD);
MMRESULT __attribute__((__stdcall__)) midiInClose(HMIDIIN);
MMRESULT __attribute__((__stdcall__)) midiInPrepareHeader(HMIDIIN,LPMIDIHDR,UINT);
MMRESULT __attribute__((__stdcall__)) midiInUnprepareHeader(HMIDIIN,LPMIDIHDR,UINT);
MMRESULT __attribute__((__stdcall__)) midiInAddBuffer(HMIDIIN,LPMIDIHDR,UINT);
MMRESULT __attribute__((__stdcall__)) midiInStart(HMIDIIN);
MMRESULT __attribute__((__stdcall__)) midiInStop(HMIDIIN);
MMRESULT __attribute__((__stdcall__)) midiInReset(HMIDIIN);
MMRESULT __attribute__((__stdcall__)) midiInGetID(HMIDIIN,LPUINT);
MMRESULT __attribute__((__stdcall__)) midiInMessage(HMIDIIN,UINT,DWORD,DWORD);
UINT __attribute__((__stdcall__)) auxGetNumDevs(void);
MMRESULT __attribute__((__stdcall__)) auxGetDevCapsA(UINT,LPAUXCAPSA,UINT);
MMRESULT __attribute__((__stdcall__)) auxGetDevCapsW(UINT,LPAUXCAPSW,UINT);
MMRESULT __attribute__((__stdcall__)) auxSetVolume(UINT,DWORD);
MMRESULT __attribute__((__stdcall__)) auxGetVolume(UINT,PDWORD);
MMRESULT __attribute__((__stdcall__)) auxOutMessage(UINT,UINT,DWORD,DWORD);
UINT __attribute__((__stdcall__)) mixerGetNumDevs(void);
MMRESULT __attribute__((__stdcall__)) mixerGetDevCapsA(UINT,LPMIXERCAPSA,UINT);
MMRESULT __attribute__((__stdcall__)) mixerGetDevCapsW(UINT,LPMIXERCAPSW,UINT);
MMRESULT __attribute__((__stdcall__)) mixerOpen(LPHMIXER,UINT,DWORD,DWORD,DWORD);
MMRESULT __attribute__((__stdcall__)) mixerClose(HMIXER);
DWORD __attribute__((__stdcall__)) mixerMessage(HMIXER,UINT,DWORD,DWORD);
MMRESULT __attribute__((__stdcall__)) mixerGetLineInfoA(HMIXEROBJ,LPMIXERLINEA,DWORD);
MMRESULT __attribute__((__stdcall__)) mixerGetLineInfoW(HMIXEROBJ,LPMIXERLINEW,DWORD);
MMRESULT __attribute__((__stdcall__)) mixerGetID(HMIXEROBJ,PUINT,DWORD);
MMRESULT __attribute__((__stdcall__)) mixerGetLineControlsA(HMIXEROBJ,LPMIXERLINECONTROLSA,DWORD);
MMRESULT __attribute__((__stdcall__)) mixerGetLineControlsW(HMIXEROBJ,LPMIXERLINECONTROLSW,DWORD);
MMRESULT __attribute__((__stdcall__)) mixerGetControlDetailsA(HMIXEROBJ,LPMIXERCONTROLDETAILS,DWORD);
MMRESULT __attribute__((__stdcall__)) mixerGetControlDetailsW(HMIXEROBJ,LPMIXERCONTROLDETAILS,DWORD);
MMRESULT __attribute__((__stdcall__)) mixerSetControlDetails(HMIXEROBJ,LPMIXERCONTROLDETAILS,DWORD);
MMRESULT __attribute__((__stdcall__)) timeGetSystemTime(LPMMTIME,UINT);
DWORD __attribute__((__stdcall__)) timeGetTime(void);
MMRESULT __attribute__((__stdcall__)) timeSetEvent(UINT,UINT,LPTIMECALLBACK,DWORD,UINT);
MMRESULT __attribute__((__stdcall__)) timeKillEvent(UINT);
MMRESULT __attribute__((__stdcall__)) timeGetDevCaps(LPTIMECAPS,UINT);
MMRESULT __attribute__((__stdcall__)) timeBeginPeriod(UINT);
MMRESULT __attribute__((__stdcall__)) timeEndPeriod(UINT);
UINT __attribute__((__stdcall__)) joyGetNumDevs(void);
MMRESULT __attribute__((__stdcall__)) joyGetDevCapsA(UINT,LPJOYCAPSA,UINT);
MMRESULT __attribute__((__stdcall__)) joyGetDevCapsW(UINT,LPJOYCAPSW,UINT);
MMRESULT __attribute__((__stdcall__)) joyGetPos(UINT,LPJOYINFO);
MMRESULT __attribute__((__stdcall__)) joyGetPosEx(UINT,LPJOYINFOEX);
MMRESULT __attribute__((__stdcall__)) joyGetThreshold(UINT,LPUINT);
MMRESULT __attribute__((__stdcall__)) joyReleaseCapture(UINT);
MMRESULT __attribute__((__stdcall__)) joySetCapture(HWND,UINT,UINT,BOOL);
MMRESULT __attribute__((__stdcall__)) joySetThreshold(UINT,UINT);
FOURCC __attribute__((__stdcall__)) mmioStringToFOURCCA(LPCSTR,UINT);
FOURCC __attribute__((__stdcall__)) mmioStringToFOURCCW(LPCWSTR,UINT);
LPMMIOPROC __attribute__((__stdcall__)) mmioInstallIOProcA(FOURCC,LPMMIOPROC,DWORD);
LPMMIOPROC __attribute__((__stdcall__)) mmioInstallIOProcW(FOURCC,LPMMIOPROC,DWORD);
HMMIO __attribute__((__stdcall__)) mmioOpenA(LPSTR,LPMMIOINFO,DWORD);
HMMIO __attribute__((__stdcall__)) mmioOpenW(LPWSTR,LPMMIOINFO,DWORD);
MMRESULT __attribute__((__stdcall__)) mmioRenameA(LPCSTR,LPCSTR,LPCMMIOINFO,DWORD);
MMRESULT __attribute__((__stdcall__)) mmioRenameW(LPCWSTR,LPCWSTR,LPCMMIOINFO,DWORD);
MMRESULT __attribute__((__stdcall__)) mmioClose(HMMIO,UINT);
LONG __attribute__((__stdcall__)) mmioRead(HMMIO,HPSTR,LONG);
LONG __attribute__((__stdcall__)) mmioWrite(HMMIO,LPCSTR,LONG);
LONG __attribute__((__stdcall__)) mmioSeek(HMMIO,LONG,int);
MMRESULT __attribute__((__stdcall__)) mmioGetInfo(HMMIO,LPMMIOINFO,UINT);
MMRESULT __attribute__((__stdcall__)) mmioSetInfo(HMMIO,LPCMMIOINFO,UINT);
MMRESULT __attribute__((__stdcall__)) mmioSetBuffer(HMMIO,LPSTR,LONG,UINT);
MMRESULT __attribute__((__stdcall__)) mmioFlush(HMMIO,UINT);
MMRESULT __attribute__((__stdcall__)) mmioAdvance(HMMIO,LPMMIOINFO,UINT);
LRESULT __attribute__((__stdcall__)) mmioSendMessage(HMMIO,UINT,LPARAM,LPARAM);
MMRESULT __attribute__((__stdcall__)) mmioDescend(HMMIO,LPMMCKINFO,const MMCKINFO*,UINT);
MMRESULT __attribute__((__stdcall__)) mmioAscend(HMMIO,LPMMCKINFO,UINT);
MMRESULT __attribute__((__stdcall__)) mmioCreateChunk(HMMIO,LPMMCKINFO,UINT);
MCIERROR __attribute__((__stdcall__)) mciSendCommandA(MCIDEVICEID,UINT,DWORD,DWORD);
MCIERROR __attribute__((__stdcall__)) mciSendCommandW(MCIDEVICEID,UINT,DWORD,DWORD);
MCIERROR __attribute__((__stdcall__)) mciSendStringA(LPCSTR,LPSTR,UINT,HWND);
MCIERROR __attribute__((__stdcall__)) mciSendStringW(LPCWSTR,LPWSTR,UINT,HWND);
MCIDEVICEID __attribute__((__stdcall__)) mciGetDeviceIDA(LPCSTR);
MCIDEVICEID __attribute__((__stdcall__)) mciGetDeviceIDW(LPCWSTR);
MCIDEVICEID __attribute__((__stdcall__)) mciGetDeviceIDFromElementIDA(DWORD,LPCSTR);
MCIDEVICEID __attribute__((__stdcall__)) mciGetDeviceIDFromElementIDW(DWORD,LPCWSTR);
BOOL __attribute__((__stdcall__)) mciGetErrorStringA(MCIERROR,LPSTR,UINT);
BOOL __attribute__((__stdcall__)) mciGetErrorStringW(MCIERROR,LPWSTR,UINT);
BOOL __attribute__((__stdcall__)) mciSetYieldProc(MCIDEVICEID,YIELDPROC,DWORD);
HTASK __attribute__((__stdcall__)) mciGetCreatorTask(MCIDEVICEID);
YIELDPROC __attribute__((__stdcall__)) mciGetYieldProc(MCIDEVICEID,PDWORD);

typedef struct tagMCI_SEQ_SET_PARMS {
 DWORD dwCallback;
 DWORD dwTimeFormat;
 DWORD dwAudio;
 DWORD dwTempo;
 DWORD dwPort;
 DWORD dwSlave;
 DWORD dwMaster;
 DWORD dwOffset;
} MCI_SEQ_SET_PARMS,*PMCI_SEQ_SET_PARMS,*LPMCI_SEQ_SET_PARMS;
typedef struct tagMCI_ANIM_OPEN_PARMSA {
 DWORD dwCallback;
 MCIDEVICEID wDeviceID;
 LPCSTR lpstrDeviceType;
 LPCSTR lpstrElementName;
 LPCSTR lpstrAlias;
 DWORD dwStyle;
 HWND hWndParent;
} MCI_ANIM_OPEN_PARMSA,*PMCI_ANIM_OPEN_PARMSA,*LPMCI_ANIM_OPEN_PARMSA;
typedef struct tagMCI_ANIM_OPEN_PARMSW {
 DWORD dwCallback;
 MCIDEVICEID wDeviceID;
 LPCWSTR lpstrDeviceType;
 LPCWSTR lpstrElementName;
 LPCWSTR lpstrAlias;
 DWORD dwStyle;
 HWND hWndParent;
} MCI_ANIM_OPEN_PARMSW,*PMCI_ANIM_OPEN_PARMSW,*LPMCI_ANIM_OPEN_PARMSW;
typedef struct tagMCI_ANIM_PLAY_PARMS {
 DWORD dwCallback;
 DWORD dwFrom;
 DWORD dwTo;
 DWORD dwSpeed;
} MCI_ANIM_PLAY_PARMS,*PMCI_ANIM_PLAY_PARMS,*LPMCI_ANIM_PLAY_PARMS;
typedef struct tagMCI_ANIM_STEP_PARMS {
 DWORD dwCallback;
 DWORD dwFrames;
} MCI_ANIM_STEP_PARMS,*PMCI_ANIM_STEP_PARMS,*LPMCI_ANIM_STEP_PARMS;
typedef struct tagMCI_ANIM_WINDOW_PARMSA {
 DWORD dwCallback;
 HWND hWnd;
 UINT nCmdShow;
 LPCSTR lpstrText;
} MCI_ANIM_WINDOW_PARMSA,*PMCI_ANIM_WINDOW_PARMSA,*LPMCI_ANIM_WINDOW_PARMSA;
typedef struct tagMCI_ANIM_WINDOW_PARMSW {
 DWORD dwCallback;
 HWND hWnd;
 UINT nCmdShow;
 LPCWSTR lpstrText;
} MCI_ANIM_WINDOW_PARMSW,*PMCI_ANIM_WINDOW_PARMSW,*LPMCI_ANIM_WINDOW_PARMSW;
typedef struct tagMCI_ANIM_RECT_PARMS {
 DWORD dwCallback;




 RECT rc;

} MCI_ANIM_RECT_PARMS,*PMCI_ANIM_RECT_PARMS,*LPMCI_ANIM_RECT_PARMS;
typedef struct tagMCI_ANIM_UPDATE_PARMS {
 DWORD dwCallback;
 RECT rc;
 HDC hDC;
} MCI_ANIM_UPDATE_PARMS,*PMCI_ANIM_UPDATE_PARMS,*LPMCI_ANIM_UPDATE_PARMS;
typedef struct tagMCI_OVLY_OPEN_PARMSA {
 DWORD dwCallback;
 MCIDEVICEID wDeviceID;
 LPCSTR lpstrDeviceType;
 LPCSTR lpstrElementName;
 LPCSTR lpstrAlias;
 DWORD dwStyle;
 HWND hWndParent;
} MCI_OVLY_OPEN_PARMSA,*PMCI_OVLY_OPEN_PARMSA,*LPMCI_OVLY_OPEN_PARMSA;
typedef struct tagMCI_OVLY_OPEN_PARMSW {
 DWORD dwCallback;
 MCIDEVICEID wDeviceID;
 LPCWSTR lpstrDeviceType;
 LPCWSTR lpstrElementName;
 LPCWSTR lpstrAlias;
 DWORD dwStyle;
 HWND hWndParent;
} MCI_OVLY_OPEN_PARMSW,*PMCI_OVLY_OPEN_PARMSW,*LPMCI_OVLY_OPEN_PARMSW;
typedef struct tagMCI_OVLY_WINDOW_PARMSA {
 DWORD dwCallback;
 HWND hWnd;
 UINT nCmdShow;
 LPCSTR lpstrText;
} MCI_OVLY_WINDOW_PARMSA,*PMCI_OVLY_WINDOW_PARMSA,*LPMCI_OVLY_WINDOW_PARMSA;
typedef struct tagMCI_OVLY_WINDOW_PARMSW {
 DWORD dwCallback;
 HWND hWnd;
 UINT nCmdShow;
 LPCWSTR lpstrText;
} MCI_OVLY_WINDOW_PARMSW,*PMCI_OVLY_WINDOW_PARMSW,*LPMCI_OVLY_WINDOW_PARMSW;
typedef struct tagMCI_OVLY_RECT_PARMS {
 DWORD dwCallback;




 RECT rc;

} MCI_OVLY_RECT_PARMS,*PMCI_OVLY_RECT_PARMS,*LPMCI_OVLY_RECT_PARMS;
typedef struct tagMCI_OVLY_SAVE_PARMSA {
 DWORD dwCallback;
 LPCSTR lpfilename;
 RECT rc;
} MCI_OVLY_SAVE_PARMSA,*PMCI_OVLY_SAVE_PARMSA,*LPMCI_OVLY_SAVE_PARMSA;
typedef struct tagMCI_OVLY_SAVE_PARMSW {
 DWORD dwCallback;
 LPCWSTR lpfilename;
 RECT rc;
} MCI_OVLY_SAVE_PARMSW,*PMCI_OVLY_SAVE_PARMSW,*LPMCI_OVLY_SAVE_PARMSW;
typedef struct tagMCI_OVLY_LOAD_PARMSA {
 DWORD dwCallback;
 LPCSTR lpfilename;
 RECT rc;
} MCI_OVLY_LOAD_PARMSA,*PMCI_OVLY_LOAD_PARMSA,*LPMCI_OVLY_LOAD_PARMSA;
typedef struct tagMCI_OVLY_LOAD_PARMSW {
 DWORD dwCallback;
 LPCWSTR lpfilename;
 RECT rc;
} MCI_OVLY_LOAD_PARMSW,*PMCI_OVLY_LOAD_PARMSW,*LPMCI_OVLY_LOAD_PARMSW;
# 1888 "H:/CPP/wxdevcpp6.10/include/mmsystem.h" 3
typedef WAVEOUTCAPSA WAVEOUTCAPS,*PWAVEOUTCAPS,*LPWAVEOUTCAPS;
typedef WAVEINCAPSA WAVEINCAPS,*PWAVEINCAPS,*LPWAVEINCAPS;
typedef MIDIOUTCAPSA MIDIOUTCAPS,*PMIDIOUTCAPS,*LPMIDIOUTCAPS;
typedef MIDIINCAPSA MIDIINCAPS,*PMIDIINCAPS,*LPMIDIINCAPS;
typedef AUXCAPSA AUXCAPS,*PAUXCAPS,*LPAUXCAPS;
typedef MIXERCAPSA MIXERCAPS,*PMIXERCAPS,*LPMIXERCAPS;
typedef MIXERLINEA MIXERLINE,*PMIXERLINE,*LPMIXERLINE;
typedef MIXERCONTROLA MIXERCONTROL,*PMIXERCONTROL,*LPMIXERCONTROL;
typedef MIXERLINECONTROLSA MIXERLINECONTROLS,*PMIXERLINECONTROLS,*LPMIXERLINECONTROLS;
typedef MIXERCONTROLDETAILS_LISTTEXTA MIXERCONTROLDETAILS_LISTTEXT,*PMIXERCONTROLDETAILS_LISTTEXT,*LPMIXERCONTROLDETAILS_LISTTEXT;
typedef JOYCAPSA JOYCAPS,*PJOYCAPS,*LPJOYCAPS;
typedef MCI_OPEN_PARMSA MCI_OPEN_PARMS,*PMCI_OPEN_PARMS,*LPMCI_OPEN_PARMS;
typedef MCI_INFO_PARMSA MCI_INFO_PARMS,*LPMCI_INFO_PARMS;
typedef MCI_SYSINFO_PARMSA MCI_SYSINFO_PARMS,*PMCI_SYSINFO_PARMS,*LPMCI_SYSINFO_PARMS;
typedef MCI_SAVE_PARMSA MCI_SAVE_PARMS,*PMCI_SAVE_PARMS,*LPMCI_SAVE_PARMS;
typedef MCI_LOAD_PARMSA MCI_LOAD_PARMS,*PMCI_LOAD_PARMS,*LPMCI_LOAD_PARMS;
typedef MCI_VD_ESCAPE_PARMSA MCI_VD_ESCAPE_PARMS,*PMCI_VD_ESCAPE_PARMS,*LPMCI_VD_ESCAPE_PARMS;
typedef MCI_WAVE_OPEN_PARMSA MCI_WAVE_OPEN_PARMS,*PMCI_WAVE_OPEN_PARMS,*LPMCI_WAVE_OPEN_PARMS;
typedef MCI_ANIM_OPEN_PARMSA MCI_ANIM_OPEN_PARMS,*PMCI_ANIM_OPEN_PARMS,*LPMCI_ANIM_OPEN_PARMS;
typedef MCI_ANIM_WINDOW_PARMSA MCI_ANIM_WINDOW_PARMS,*PMCI_ANIM_WINDOW_PARMS,*LPMCI_ANIM_WINDOW_PARMS;
typedef MCI_OVLY_OPEN_PARMSA MCI_OVLY_OPEN_PARMS,*PMCI_OVLY_OPEN_PARMS,*LPMCI_OVLY_OPEN_PARMS;
typedef MCI_OVLY_WINDOW_PARMSA MCI_OVLY_WINDOW_PARMS,*PMCI_OVLY_WINDOW_PARMS,*LPMCI_OVLY_WINDOW_PARMS;
typedef MCI_OVLY_SAVE_PARMSA MCI_OVLY_SAVE_PARMS,*PMCI_OVLY_SAVE_PARMS,*LPMCI_OVLY_SAVE_PARMS;
# 1938 "H:/CPP/wxdevcpp6.10/include/mmsystem.h" 3
}

#pragma pack(pop)
# 81 "H:/CPP/wxdevcpp6.10/include/windows.h" 2 3
# 1 "H:/CPP/wxdevcpp6.10/include/nb30.h" 1 3



       
# 5 "H:/CPP/wxdevcpp6.10/include/nb30.h" 3



extern "C" {
# 95 "H:/CPP/wxdevcpp6.10/include/nb30.h" 3
typedef struct _ACTION_HEADER {
 ULONG transport_id;
 USHORT action_code;
 USHORT reserved;
} ACTION_HEADER,*PACTION_HEADER;
typedef struct _ADAPTER_STATUS {
 UCHAR adapter_address[6];
 UCHAR rev_major;
 UCHAR reserved0;
 UCHAR adapter_type;
 UCHAR rev_minor;
 WORD duration;
 WORD frmr_recv;
 WORD frmr_xmit;
 WORD iframe_recv_err;
 WORD xmit_aborts;
 DWORD xmit_success;
 DWORD recv_success;
 WORD iframe_xmit_err;
 WORD recv_buff_unavail;
 WORD t1_timeouts;
 WORD ti_timeouts;
 DWORD reserved1;
 WORD free_ncbs;
 WORD max_cfg_ncbs;
 WORD max_ncbs;
 WORD xmit_buf_unavail;
 WORD max_dgram_size;
 WORD pending_sess;
 WORD max_cfg_sess;
 WORD max_sess;
 WORD max_sess_pkt_size;
 WORD name_count;
} ADAPTER_STATUS,*PADAPTER_STATUS;
typedef struct _FIND_NAME_BUFFER {
 UCHAR length;
 UCHAR access_control;
 UCHAR frame_control;
 UCHAR destination_addr[6];
 UCHAR source_addr[6];
 UCHAR routing_info[18];
} FIND_NAME_BUFFER,*PFIND_NAME_BUFFER;
typedef struct _FIND_NAME_HEADER {
 WORD node_count;
 UCHAR reserved;
 UCHAR unique_group;
} FIND_NAME_HEADER,*PFIND_NAME_HEADER;
typedef struct _LANA_ENUM {
 UCHAR length;
 UCHAR lana[254 +1];
} LANA_ENUM,*PLANA_ENUM;
typedef struct _NAME_BUFFER {
 UCHAR name[16];
 UCHAR name_num;
 UCHAR name_flags;
} NAME_BUFFER,*PNAME_BUFFER;
typedef struct _NCB {
 UCHAR ncb_command;
 UCHAR ncb_retcode;
 UCHAR ncb_lsn;
 UCHAR ncb_num;
 PUCHAR ncb_buffer;
 WORD ncb_length;
 UCHAR ncb_callname[16];
 UCHAR ncb_name[16];
 UCHAR ncb_rto;
 UCHAR ncb_sto;
 void (__attribute__((__stdcall__)) *ncb_post)(struct _NCB*);
 UCHAR ncb_lana_num;
 UCHAR ncb_cmd_cplt;
 UCHAR ncb_reserve[10];
 HANDLE ncb_event;
} NCB,*PNCB;
typedef struct _SESSION_BUFFER {
 UCHAR lsn;
 UCHAR state;
 UCHAR local_name[16];
 UCHAR remote_name[16];
 UCHAR rcvs_outstanding;
 UCHAR sends_outstanding;
} SESSION_BUFFER,*PSESSION_BUFFER;
typedef struct _SESSION_HEADER {
 UCHAR sess_name;
 UCHAR num_sess;
 UCHAR rcv_dg_outstanding;
 UCHAR rcv_any_outstanding;
} SESSION_HEADER,*PSESSION_HEADER;
UCHAR __attribute__((__stdcall__)) Netbios(PNCB);

}
# 82 "H:/CPP/wxdevcpp6.10/include/windows.h" 2 3
# 1 "H:/CPP/wxdevcpp6.10/include/rpc.h" 1 3

# 1 "H:/CPP/wxdevcpp6.10/include/windows.h" 1 3
# 3 "H:/CPP/wxdevcpp6.10/include/rpc.h" 2 3





       
# 9 "H:/CPP/wxdevcpp6.10/include/rpc.h" 3



extern "C" {
# 37 "H:/CPP/wxdevcpp6.10/include/rpc.h" 3
typedef void *I_RPC_HANDLE;
typedef long RPC_STATUS;

# 1 "H:/CPP/wxdevcpp6.10/include/rpcdce.h" 1 3



       
# 5 "H:/CPP/wxdevcpp6.10/include/rpcdce.h" 3



extern "C" {

# 1 "H:/CPP/wxdevcpp6.10/include/basetyps.h" 1 3



       
# 5 "H:/CPP/wxdevcpp6.10/include/basetyps.h" 3
# 118 "H:/CPP/wxdevcpp6.10/include/basetyps.h" 3
typedef GUID UUID;

typedef GUID IID;
typedef GUID CLSID;
typedef CLSID *LPCLSID;
typedef IID *LPIID;
typedef IID *REFIID;
typedef CLSID *REFCLSID;
typedef GUID FMTID;
typedef FMTID *REFFMTID;
typedef unsigned long error_status_t;

typedef unsigned long PROPID;
# 11 "H:/CPP/wxdevcpp6.10/include/rpcdce.h" 2 3
# 91 "H:/CPP/wxdevcpp6.10/include/rpcdce.h" 3
typedef I_RPC_HANDLE RPC_BINDING_HANDLE;
typedef RPC_BINDING_HANDLE handle_t;
typedef struct _RPC_BINDING_VECTOR {
 unsigned long Count;
 RPC_BINDING_HANDLE BindingH[1];
} RPC_BINDING_VECTOR;
typedef struct _UUID_VECTOR {
 unsigned long Count;
 UUID *Uuid[1];
} UUID_VECTOR;
typedef void *RPC_IF_HANDLE;
typedef struct _RPC_IF_ID {
 UUID Uuid;
 unsigned short VersMajor;
 unsigned short VersMinor;
} RPC_IF_ID;
typedef struct _RPC_POLICY {
 unsigned int Length ;
 unsigned long EndpointFlags ;
 unsigned long NICFlags ;
} RPC_POLICY,*PRPC_POLICY ;
typedef void __attribute__((__stdcall__)) RPC_OBJECT_INQ_FN(UUID*,UUID*,RPC_STATUS*);
typedef RPC_STATUS RPC_IF_CALLBACK_FN(RPC_IF_HANDLE,void*);
typedef struct {
 unsigned int Count;
 unsigned long Stats[1];
} RPC_STATS_VECTOR;
typedef struct {
 unsigned long Count;
 RPC_IF_ID*IfId[1];
} RPC_IF_ID_VECTOR;
typedef void *RPC_AUTH_IDENTITY_HANDLE;
typedef void *RPC_AUTHZ_HANDLE;
typedef struct _RPC_SECURITY_QOS {
 unsigned long Version;
 unsigned long Capabilities;
 unsigned long IdentityTracking;
 unsigned long ImpersonationType;
} RPC_SECURITY_QOS,*PRPC_SECURITY_QOS;
typedef struct _SEC_WINNT_AUTH_IDENTITY_W {
 unsigned short *User;
 unsigned long UserLength;
 unsigned short *Domain;
 unsigned long DomainLength;
 unsigned short *Password;
 unsigned long PasswordLength;
 unsigned long Flags;
} SEC_WINNT_AUTH_IDENTITY_W,*PSEC_WINNT_AUTH_IDENTITY_W;
typedef struct _SEC_WINNT_AUTH_IDENTITY_A {
 unsigned char *User;
 unsigned long UserLength;
 unsigned char *Domain;
 unsigned long DomainLength;
 unsigned char *Password;
 unsigned long PasswordLength;
 unsigned long Flags;
} SEC_WINNT_AUTH_IDENTITY_A,*PSEC_WINNT_AUTH_IDENTITY_A;
typedef struct {
 unsigned char *UserName;
 unsigned char *ComputerName;
 unsigned short Privilege;
 unsigned long AuthFlags;
} RPC_CLIENT_INFORMATION1,* PRPC_CLIENT_INFORMATION1;
typedef I_RPC_HANDLE *RPC_EP_INQ_HANDLE;
typedef int(__attribute__((__stdcall__)) *RPC_MGMT_AUTHORIZATION_FN)(RPC_BINDING_HANDLE,unsigned long,RPC_STATUS*);


typedef struct _RPC_PROTSEQ_VECTORA {
 unsigned int Count;
 unsigned char*Protseq[1];
} RPC_PROTSEQ_VECTORA;
typedef struct _RPC_PROTSEQ_VECTORW {
 unsigned int Count;
 unsigned short*Protseq[1];
} RPC_PROTSEQ_VECTORW;
RPC_STATUS __attribute__((__stdcall__)) RpcBindingFromStringBindingA(unsigned char *,RPC_BINDING_HANDLE *);
RPC_STATUS __attribute__((__stdcall__)) RpcBindingFromStringBindingW(unsigned short *,RPC_BINDING_HANDLE *);
RPC_STATUS __attribute__((__stdcall__)) RpcBindingToStringBindingA(RPC_BINDING_HANDLE,unsigned char**);
RPC_STATUS __attribute__((__stdcall__)) RpcBindingToStringBindingW(RPC_BINDING_HANDLE,unsigned short**);
RPC_STATUS __attribute__((__stdcall__)) RpcStringBindingComposeA(unsigned char *,unsigned char *,unsigned char *,unsigned char *,unsigned char *,unsigned char **);
RPC_STATUS __attribute__((__stdcall__)) RpcStringBindingComposeW(unsigned short *,unsigned short *,unsigned short *,unsigned short *,unsigned short *,unsigned short **);
RPC_STATUS __attribute__((__stdcall__)) RpcStringBindingParseA(unsigned char *,unsigned char **,unsigned char **,unsigned char **,unsigned char **,unsigned char **);
RPC_STATUS __attribute__((__stdcall__)) RpcStringBindingParseW(unsigned short *,unsigned short **,unsigned short **,unsigned short **,unsigned short **,unsigned short **);
RPC_STATUS __attribute__((__stdcall__)) RpcStringFreeA(unsigned char**);
RPC_STATUS __attribute__((__stdcall__)) RpcStringFreeW(unsigned short**);
RPC_STATUS __attribute__((__stdcall__)) RpcNetworkIsProtseqValidA(unsigned char*);
RPC_STATUS __attribute__((__stdcall__)) RpcNetworkIsProtseqValidW(unsigned short*);
RPC_STATUS __attribute__((__stdcall__)) RpcNetworkInqProtseqsA(RPC_PROTSEQ_VECTORA**);
RPC_STATUS __attribute__((__stdcall__)) RpcNetworkInqProtseqsW(RPC_PROTSEQ_VECTORW**);
RPC_STATUS __attribute__((__stdcall__)) RpcProtseqVectorFreeA(RPC_PROTSEQ_VECTORA**);
RPC_STATUS __attribute__((__stdcall__)) RpcProtseqVectorFreeW(RPC_PROTSEQ_VECTORW**);
RPC_STATUS __attribute__((__stdcall__)) RpcServerUseProtseqA(unsigned char*,unsigned int,void*);
RPC_STATUS __attribute__((__stdcall__)) RpcServerUseProtseqW(unsigned short*,unsigned int,void*);
RPC_STATUS __attribute__((__stdcall__)) RpcServerUseProtseqExA(unsigned char*,unsigned int MaxCalls,void*,PRPC_POLICY);
RPC_STATUS __attribute__((__stdcall__)) RpcServerUseProtseqExW(unsigned short*,unsigned int,void*,PRPC_POLICY);
RPC_STATUS __attribute__((__stdcall__)) RpcServerUseProtseqEpA(unsigned char*,unsigned int,unsigned char*,void*);
RPC_STATUS __attribute__((__stdcall__)) RpcServerUseProtseqEpExA(unsigned char*,unsigned int,unsigned char*,void*,PRPC_POLICY);
RPC_STATUS __attribute__((__stdcall__)) RpcServerUseProtseqEpW(unsigned short*,unsigned int,unsigned short*,void*);
RPC_STATUS __attribute__((__stdcall__)) RpcServerUseProtseqEpExW(unsigned short*,unsigned int,unsigned short*,void*,PRPC_POLICY);
RPC_STATUS __attribute__((__stdcall__)) RpcServerUseProtseqIfA(unsigned char*,unsigned int,RPC_IF_HANDLE,void*);
RPC_STATUS __attribute__((__stdcall__)) RpcServerUseProtseqIfExA(unsigned char*,unsigned int,RPC_IF_HANDLE,void*,PRPC_POLICY);
RPC_STATUS __attribute__((__stdcall__)) RpcServerUseProtseqIfW(unsigned short*,unsigned int,RPC_IF_HANDLE,void*);
RPC_STATUS __attribute__((__stdcall__)) RpcServerUseProtseqIfExW(unsigned short*,unsigned int,RPC_IF_HANDLE,void*,PRPC_POLICY);
RPC_STATUS __attribute__((__stdcall__)) RpcMgmtInqServerPrincNameA(RPC_BINDING_HANDLE,unsigned long,unsigned char**);
RPC_STATUS __attribute__((__stdcall__)) RpcMgmtInqServerPrincNameW(RPC_BINDING_HANDLE,unsigned long,unsigned short**);
RPC_STATUS __attribute__((__stdcall__)) RpcServerInqDefaultPrincNameA(unsigned long,unsigned char**);
RPC_STATUS __attribute__((__stdcall__)) RpcServerInqDefaultPrincNameW(unsigned long,unsigned short**);
RPC_STATUS __attribute__((__stdcall__)) RpcNsBindingInqEntryNameA(RPC_BINDING_HANDLE,unsigned long,unsigned char**);
RPC_STATUS __attribute__((__stdcall__)) RpcNsBindingInqEntryNameW(RPC_BINDING_HANDLE,unsigned long,unsigned short**);
RPC_STATUS __attribute__((__stdcall__)) RpcBindingInqAuthClientA(RPC_BINDING_HANDLE,RPC_AUTHZ_HANDLE *,unsigned char**,unsigned long*,unsigned long*,unsigned long*);
RPC_STATUS __attribute__((__stdcall__)) RpcBindingInqAuthClientW(RPC_BINDING_HANDLE,RPC_AUTHZ_HANDLE *,unsigned short**,unsigned long*,unsigned long*,unsigned long*);
RPC_STATUS __attribute__((__stdcall__)) RpcBindingInqAuthInfoA(RPC_BINDING_HANDLE,unsigned char**,unsigned long*,unsigned long*,RPC_AUTH_IDENTITY_HANDLE*,unsigned long*);
RPC_STATUS __attribute__((__stdcall__)) RpcBindingInqAuthInfoW(RPC_BINDING_HANDLE,unsigned short**,unsigned long*,unsigned long*,RPC_AUTH_IDENTITY_HANDLE*,unsigned long*);
RPC_STATUS __attribute__((__stdcall__)) RpcBindingSetAuthInfoA(RPC_BINDING_HANDLE,unsigned char*,unsigned long,unsigned long,RPC_AUTH_IDENTITY_HANDLE,unsigned long);
RPC_STATUS __attribute__((__stdcall__)) RpcBindingSetAuthInfoExA(RPC_BINDING_HANDLE,unsigned char*,unsigned long,unsigned long,RPC_AUTH_IDENTITY_HANDLE,unsigned long,RPC_SECURITY_QOS*);
RPC_STATUS __attribute__((__stdcall__)) RpcBindingSetAuthInfoW(RPC_BINDING_HANDLE,unsigned short*,unsigned long,unsigned long,RPC_AUTH_IDENTITY_HANDLE,unsigned long);
RPC_STATUS __attribute__((__stdcall__)) RpcBindingSetAuthInfoExW(RPC_BINDING_HANDLE,unsigned short*,unsigned long,unsigned long,RPC_AUTH_IDENTITY_HANDLE,unsigned long,RPC_SECURITY_QOS*);
RPC_STATUS __attribute__((__stdcall__)) RpcBindingInqAuthInfoExA(RPC_BINDING_HANDLE,unsigned char**,unsigned long*,unsigned long*,RPC_AUTH_IDENTITY_HANDLE*,unsigned long*,unsigned long,RPC_SECURITY_QOS*);
RPC_STATUS __attribute__((__stdcall__)) RpcBindingInqAuthInfoExW(RPC_BINDING_HANDLE,unsigned short ** , unsigned long *, unsigned long *, RPC_AUTH_IDENTITY_HANDLE *, unsigned long *, unsigned long , RPC_SECURITY_QOS *);
typedef void(__attribute__((__stdcall__)) *RPC_AUTH_KEY_RETRIEVAL_FN)(void*,unsigned short*,unsigned long,void**,RPC_STATUS*);
RPC_STATUS __attribute__((__stdcall__)) RpcServerRegisterAuthInfoA(unsigned char*,unsigned long,RPC_AUTH_KEY_RETRIEVAL_FN,void*);
RPC_STATUS __attribute__((__stdcall__)) RpcServerRegisterAuthInfoW(unsigned short*,unsigned long,RPC_AUTH_KEY_RETRIEVAL_FN,void*);
RPC_STATUS __attribute__((__stdcall__)) UuidToStringA(UUID*,unsigned char**);
RPC_STATUS __attribute__((__stdcall__)) UuidFromStringA(unsigned char*,UUID*);
RPC_STATUS __attribute__((__stdcall__)) UuidToStringW(UUID*,unsigned short**);
RPC_STATUS __attribute__((__stdcall__)) UuidFromStringW(unsigned short*,UUID*);
RPC_STATUS __attribute__((__stdcall__)) RpcEpRegisterNoReplaceA(RPC_IF_HANDLE,RPC_BINDING_VECTOR*,UUID_VECTOR*,unsigned char*);
RPC_STATUS __attribute__((__stdcall__)) RpcEpRegisterNoReplaceW(RPC_IF_HANDLE,RPC_BINDING_VECTOR*, UUID_VECTOR*,unsigned short*);
RPC_STATUS __attribute__((__stdcall__)) RpcEpRegisterA(RPC_IF_HANDLE,RPC_BINDING_VECTOR*,UUID_VECTOR*,unsigned char*);
RPC_STATUS __attribute__((__stdcall__)) RpcEpRegisterW(RPC_IF_HANDLE,RPC_BINDING_VECTOR*,UUID_VECTOR*,unsigned short*);
RPC_STATUS __attribute__((__stdcall__)) DceErrorInqTextA(RPC_STATUS,unsigned char*);
RPC_STATUS __attribute__((__stdcall__)) DceErrorInqTextW(RPC_STATUS,unsigned short*);
RPC_STATUS __attribute__((__stdcall__)) RpcMgmtEpEltInqNextA(RPC_EP_INQ_HANDLE,RPC_IF_ID*,RPC_BINDING_HANDLE*,UUID*,unsigned char**);
RPC_STATUS __attribute__((__stdcall__)) RpcMgmtEpEltInqNextW(RPC_EP_INQ_HANDLE,RPC_IF_ID*,RPC_BINDING_HANDLE*,UUID*,unsigned short**);
# 329 "H:/CPP/wxdevcpp6.10/include/rpcdce.h" 3
RPC_STATUS __attribute__((__stdcall__)) RpcBindingCopy(RPC_BINDING_HANDLE,RPC_BINDING_HANDLE*);
RPC_STATUS __attribute__((__stdcall__)) RpcBindingFree(RPC_BINDING_HANDLE*);
RPC_STATUS __attribute__((__stdcall__)) RpcBindingInqObject(RPC_BINDING_HANDLE,UUID *);
RPC_STATUS __attribute__((__stdcall__)) RpcBindingReset(RPC_BINDING_HANDLE);
RPC_STATUS __attribute__((__stdcall__)) RpcBindingSetObject(RPC_BINDING_HANDLE,UUID *);
RPC_STATUS __attribute__((__stdcall__)) RpcMgmtInqDefaultProtectLevel(unsigned long,unsigned long *);
RPC_STATUS __attribute__((__stdcall__)) RpcBindingVectorFree(RPC_BINDING_VECTOR **);
RPC_STATUS __attribute__((__stdcall__)) RpcIfInqId(RPC_IF_HANDLE,RPC_IF_ID *);
RPC_STATUS __attribute__((__stdcall__)) RpcMgmtInqComTimeout(RPC_BINDING_HANDLE,unsigned int*);
RPC_STATUS __attribute__((__stdcall__)) RpcMgmtSetComTimeout(RPC_BINDING_HANDLE,unsigned int);
RPC_STATUS __attribute__((__stdcall__)) RpcMgmtSetCancelTimeout(long Timeout);
RPC_STATUS __attribute__((__stdcall__)) RpcObjectInqType(UUID *,UUID *);
RPC_STATUS __attribute__((__stdcall__)) RpcObjectSetInqFn(RPC_OBJECT_INQ_FN *);
RPC_STATUS __attribute__((__stdcall__)) RpcObjectSetType(UUID *,UUID *);
RPC_STATUS __attribute__((__stdcall__)) RpcProtseqVectorFreeA(RPC_PROTSEQ_VECTORA **);
RPC_STATUS __attribute__((__stdcall__)) RpcServerInqIf(RPC_IF_HANDLE,UUID*,void**);
RPC_STATUS __attribute__((__stdcall__)) RpcServerListen(unsigned int,unsigned int,unsigned int);
RPC_STATUS __attribute__((__stdcall__)) RpcServerRegisterIf(RPC_IF_HANDLE,UUID*,void*);
RPC_STATUS __attribute__((__stdcall__)) RpcServerRegisterIfEx(RPC_IF_HANDLE,UUID*,void*,unsigned int,unsigned int,RPC_IF_CALLBACK_FN*);
RPC_STATUS __attribute__((__stdcall__)) RpcServerRegisterIf2(RPC_IF_HANDLE,UUID*,void*,unsigned int,unsigned int,unsigned int,RPC_IF_CALLBACK_FN*);
RPC_STATUS __attribute__((__stdcall__)) RpcServerUnregisterIf(RPC_IF_HANDLE,UUID*,unsigned int);
RPC_STATUS __attribute__((__stdcall__)) RpcServerUseAllProtseqs(unsigned int,void*);
RPC_STATUS __attribute__((__stdcall__)) RpcServerUseAllProtseqsEx(unsigned int,void*,PRPC_POLICY);
RPC_STATUS __attribute__((__stdcall__)) RpcServerUseAllProtseqsIf(unsigned int,RPC_IF_HANDLE,void*);
RPC_STATUS __attribute__((__stdcall__)) RpcServerUseAllProtseqsIfEx(unsigned int,RPC_IF_HANDLE,void*,PRPC_POLICY);
RPC_STATUS __attribute__((__stdcall__)) RpcMgmtStatsVectorFree(RPC_STATS_VECTOR**);
RPC_STATUS __attribute__((__stdcall__)) RpcMgmtInqStats(RPC_BINDING_HANDLE,RPC_STATS_VECTOR**);
RPC_STATUS __attribute__((__stdcall__)) RpcMgmtIsServerListening(RPC_BINDING_HANDLE);
RPC_STATUS __attribute__((__stdcall__)) RpcMgmtStopServerListening(RPC_BINDING_HANDLE);
RPC_STATUS __attribute__((__stdcall__)) RpcMgmtWaitServerListen(void);
RPC_STATUS __attribute__((__stdcall__)) RpcMgmtSetServerStackSize(unsigned long);
void __attribute__((__stdcall__)) RpcSsDontSerializeContext(void);
RPC_STATUS __attribute__((__stdcall__)) RpcMgmtEnableIdleCleanup(void);
RPC_STATUS __attribute__((__stdcall__)) RpcMgmtInqIfIds(RPC_BINDING_HANDLE,RPC_IF_ID_VECTOR**);
RPC_STATUS __attribute__((__stdcall__)) RpcIfIdVectorFree(RPC_IF_ID_VECTOR**);
RPC_STATUS __attribute__((__stdcall__)) RpcEpResolveBinding(RPC_BINDING_HANDLE,RPC_IF_HANDLE);
RPC_STATUS __attribute__((__stdcall__)) RpcBindingServerFromClient(RPC_BINDING_HANDLE,RPC_BINDING_HANDLE*);
__attribute__((noreturn)) void __attribute__((__stdcall__)) RpcRaiseException(RPC_STATUS);
RPC_STATUS __attribute__((__stdcall__)) RpcTestCancel(void);
RPC_STATUS __attribute__((__stdcall__)) RpcCancelThread(void*);
RPC_STATUS __attribute__((__stdcall__)) UuidCreate(UUID*);
signed int __attribute__((__stdcall__)) UuidCompare(UUID*,UUID*, RPC_STATUS*);
RPC_STATUS __attribute__((__stdcall__)) UuidCreateNil(UUID*);
int __attribute__((__stdcall__)) UuidEqual(UUID*,UUID*, RPC_STATUS*);
unsigned short __attribute__((__stdcall__)) UuidHash(UUID*,RPC_STATUS*);
int __attribute__((__stdcall__)) UuidIsNil(UUID*,RPC_STATUS*);
RPC_STATUS __attribute__((__stdcall__)) RpcEpUnregister(RPC_IF_HANDLE,RPC_BINDING_VECTOR*,UUID_VECTOR*);
RPC_STATUS __attribute__((__stdcall__)) RpcMgmtEpEltInqBegin(RPC_BINDING_HANDLE,unsigned long,RPC_IF_ID*,unsigned long,UUID*,RPC_EP_INQ_HANDLE*);
RPC_STATUS __attribute__((__stdcall__)) RpcMgmtEpEltInqDone(RPC_EP_INQ_HANDLE*);
RPC_STATUS __attribute__((__stdcall__)) RpcMgmtEpUnregister(RPC_BINDING_HANDLE,RPC_IF_ID*,RPC_BINDING_HANDLE,UUID*);
RPC_STATUS __attribute__((__stdcall__)) RpcMgmtSetAuthorizationFn(RPC_MGMT_AUTHORIZATION_FN);
RPC_STATUS __attribute__((__stdcall__)) RpcMgmtInqParameter(unsigned int,unsigned long*);
RPC_STATUS __attribute__((__stdcall__)) RpcMgmtSetParameter(unsigned int,unsigned long);
RPC_STATUS __attribute__((__stdcall__)) RpcMgmtBindingInqParameter(RPC_BINDING_HANDLE,unsigned int,unsigned long*);
RPC_STATUS __attribute__((__stdcall__)) RpcMgmtBindingSetParameter(RPC_BINDING_HANDLE,unsigned int,unsigned long);





# 1 "H:/CPP/wxdevcpp6.10/include/rpcdcep.h" 1 3



       
# 5 "H:/CPP/wxdevcpp6.10/include/rpcdcep.h" 3



extern "C" {
# 22 "H:/CPP/wxdevcpp6.10/include/rpcdcep.h" 3
typedef struct _RPC_VERSION {
 unsigned short MajorVersion;
 unsigned short MinorVersion;
} RPC_VERSION;
typedef struct _RPC_SYNTAX_IDENTIFIER {
 GUID SyntaxGUID;
 RPC_VERSION SyntaxVersion;
} RPC_SYNTAX_IDENTIFIER, *PRPC_SYNTAX_IDENTIFIER;
typedef struct _RPC_MESSAGE {
 HANDLE Handle;
 unsigned long DataRepresentation;
 void *Buffer;
 unsigned int BufferLength;
 unsigned int ProcNum;
 PRPC_SYNTAX_IDENTIFIER TransferSyntax;
 void *RpcInterfaceInformation;
 void *ReservedForRuntime;
 void *ManagerEpv;
 void *ImportContext;
 unsigned long RpcFlags;
} RPC_MESSAGE,*PRPC_MESSAGE;
typedef long __attribute__((__stdcall__)) RPC_FORWARD_FUNCTION(GUID*,RPC_VERSION*,GUID*,unsigned char*,void**);
typedef void(__attribute__((__stdcall__)) *RPC_DISPATCH_FUNCTION) ( PRPC_MESSAGE Message);
typedef struct {
 unsigned int DispatchTableCount;
 RPC_DISPATCH_FUNCTION *DispatchTable;
 int Reserved;
} RPC_DISPATCH_TABLE,*PRPC_DISPATCH_TABLE;
typedef struct _RPC_PROTSEQ_ENDPOINT {
 unsigned char *RpcProtocolSequence;
 unsigned char *Endpoint;
} RPC_PROTSEQ_ENDPOINT,*PRPC_PROTSEQ_ENDPOINT;
typedef struct _RPC_SERVER_INTERFACE {
 unsigned int Length;
 RPC_SYNTAX_IDENTIFIER InterfaceId;
 RPC_SYNTAX_IDENTIFIER TransferSyntax;
 PRPC_DISPATCH_TABLE DispatchTable;
 unsigned int RpcProtseqEndpointCount;
 PRPC_PROTSEQ_ENDPOINT RpcProtseqEndpoint;
 void *DefaultManagerEpv;
 void const *InterpreterInfo;
} RPC_SERVER_INTERFACE,*PRPC_SERVER_INTERFACE;
typedef struct _RPC_CLIENT_INTERFACE {
 unsigned int Length;
 RPC_SYNTAX_IDENTIFIER InterfaceId;
 RPC_SYNTAX_IDENTIFIER TransferSyntax;
 PRPC_DISPATCH_TABLE DispatchTable;
 unsigned int RpcProtseqEndpointCount;
 PRPC_PROTSEQ_ENDPOINT RpcProtseqEndpoint;
 unsigned long Reserved;
 void const *InterpreterInfo;
} RPC_CLIENT_INTERFACE,*PRPC_CLIENT_INTERFACE;
typedef void *I_RPC_MUTEX;
typedef struct _RPC_TRANSFER_SYNTAX {
 GUID Uuid;
 unsigned short VersMajor;
 unsigned short VersMinor;
} RPC_TRANSFER_SYNTAX;
typedef RPC_STATUS (*RPC_BLOCKING_FN)(void*,void*,void*);

long __attribute__((__stdcall__)) I_RpcGetBuffer(RPC_MESSAGE*);
long __attribute__((__stdcall__)) I_RpcSendReceive(RPC_MESSAGE*);
long __attribute__((__stdcall__)) I_RpcSend(RPC_MESSAGE*);
long __attribute__((__stdcall__)) I_RpcFreeBuffer(RPC_MESSAGE*);
void __attribute__((__stdcall__)) I_RpcRequestMutex(I_RPC_MUTEX*);
void __attribute__((__stdcall__)) I_RpcClearMutex(I_RPC_MUTEX);
void __attribute__((__stdcall__)) I_RpcDeleteMutex(I_RPC_MUTEX);
__attribute__((__stdcall__)) void * I_RpcAllocate(unsigned int);
void __attribute__((__stdcall__)) I_RpcFree(void*);
void __attribute__((__stdcall__)) I_RpcPauseExecution(unsigned long);
typedef void(__attribute__((__stdcall__)) *PRPC_RUNDOWN) (void*);
long __attribute__((__stdcall__)) I_RpcMonitorAssociation(HANDLE,PRPC_RUNDOWN,void*);
long __attribute__((__stdcall__)) I_RpcStopMonitorAssociation(HANDLE);
HANDLE __attribute__((__stdcall__)) I_RpcGetCurrentCallHandle(void);
long __attribute__((__stdcall__)) I_RpcGetAssociationContext(void**);
long __attribute__((__stdcall__)) I_RpcSetAssociationContext(void*);

long __attribute__((__stdcall__)) I_RpcNsBindingSetEntryName(HANDLE,unsigned long,unsigned short*);
long __attribute__((__stdcall__)) I_RpcBindingInqDynamicEndpoint(HANDLE, unsigned short**);




long __attribute__((__stdcall__)) I_RpcBindingInqTransportType(HANDLE,unsigned int*);
long __attribute__((__stdcall__)) I_RpcIfInqTransferSyntaxes(HANDLE,RPC_TRANSFER_SYNTAX*,unsigned int,unsigned int*);
long __attribute__((__stdcall__)) I_UuidCreate(GUID*);
long __attribute__((__stdcall__)) I_RpcBindingCopy(HANDLE,HANDLE*);
long __attribute__((__stdcall__)) I_RpcBindingIsClientLocal(HANDLE,unsigned int*);
void __attribute__((__stdcall__)) I_RpcSsDontSerializeContext(void);
long __attribute__((__stdcall__)) I_RpcServerRegisterForwardFunction(RPC_FORWARD_FUNCTION*);
long __attribute__((__stdcall__)) I_RpcConnectionInqSockBuffSize(unsigned long*,unsigned long*);
long __attribute__((__stdcall__)) I_RpcConnectionSetSockBuffSize(unsigned long,unsigned long);
long __attribute__((__stdcall__)) I_RpcBindingSetAsync(HANDLE,RPC_BLOCKING_FN);
long __attribute__((__stdcall__)) I_RpcAsyncSendReceive(RPC_MESSAGE*,void*);
long __attribute__((__stdcall__)) I_RpcGetThreadWindowHandle(void**);
long __attribute__((__stdcall__)) I_RpcServerThreadPauseListening(void);
long __attribute__((__stdcall__)) I_RpcServerThreadContinueListening(void);
long __attribute__((__stdcall__)) I_RpcServerUnregisterEndpointA(unsigned char*,unsigned char*);
long __attribute__((__stdcall__)) I_RpcServerUnregisterEndpointW(unsigned short*,unsigned short*);






}
# 390 "H:/CPP/wxdevcpp6.10/include/rpcdce.h" 2 3

}
# 41 "H:/CPP/wxdevcpp6.10/include/rpc.h" 2 3
# 1 "H:/CPP/wxdevcpp6.10/include/rpcnsi.h" 1 3



       
# 5 "H:/CPP/wxdevcpp6.10/include/rpcnsi.h" 3



extern "C" {

typedef void *RPC_NS_HANDLE;
# 20 "H:/CPP/wxdevcpp6.10/include/rpcnsi.h" 3
RPC_STATUS __attribute__((__stdcall__)) RpcNsBindingExportA(unsigned long,unsigned char*,RPC_IF_HANDLE,RPC_BINDING_VECTOR*,UUID_VECTOR*);
RPC_STATUS __attribute__((__stdcall__)) RpcNsBindingUnexportA(unsigned long,unsigned char*,RPC_IF_HANDLE,UUID_VECTOR*);
RPC_STATUS __attribute__((__stdcall__)) RpcNsBindingLookupBeginA(unsigned long,unsigned char*,RPC_IF_HANDLE,UUID*,unsigned long,RPC_NS_HANDLE*);
RPC_STATUS __attribute__((__stdcall__)) RpcNsBindingLookupNext(RPC_NS_HANDLE,RPC_BINDING_VECTOR**);
RPC_STATUS __attribute__((__stdcall__)) RpcNsBindingLookupDone(RPC_NS_HANDLE*);
RPC_STATUS __attribute__((__stdcall__)) RpcNsGroupDeleteA(unsigned long,unsigned char*);
RPC_STATUS __attribute__((__stdcall__)) RpcNsGroupMbrAddA(unsigned long,unsigned char*,unsigned long,unsigned char*);
RPC_STATUS __attribute__((__stdcall__)) RpcNsGroupMbrRemoveA(unsigned long,unsigned char*,unsigned long,unsigned char*);
RPC_STATUS __attribute__((__stdcall__)) RpcNsGroupMbrInqBeginA(unsigned long,unsigned char*,unsigned long,RPC_NS_HANDLE*);
RPC_STATUS __attribute__((__stdcall__)) RpcNsGroupMbrInqNextA(RPC_NS_HANDLE,unsigned char**);
RPC_STATUS __attribute__((__stdcall__)) RpcNsGroupMbrInqDone(RPC_NS_HANDLE*);
RPC_STATUS __attribute__((__stdcall__)) RpcNsProfileDeleteA(unsigned long,unsigned char*);
RPC_STATUS __attribute__((__stdcall__)) RpcNsProfileEltAddA(unsigned long,unsigned char*,RPC_IF_ID*,unsigned long,unsigned char*,unsigned long,unsigned char*);
RPC_STATUS __attribute__((__stdcall__)) RpcNsProfileEltRemoveA(unsigned long,unsigned char*,RPC_IF_ID*,unsigned long,unsigned char*);
RPC_STATUS __attribute__((__stdcall__)) RpcNsProfileEltInqBeginA(unsigned long,unsigned char*,unsigned long,RPC_IF_ID*,unsigned long,unsigned long,unsigned char*,RPC_NS_HANDLE*);
RPC_STATUS __attribute__((__stdcall__)) RpcNsProfileEltInqNextA(RPC_NS_HANDLE,RPC_IF_ID*,unsigned char**,unsigned long*,unsigned char**);
RPC_STATUS __attribute__((__stdcall__)) RpcNsProfileEltInqDone(RPC_NS_HANDLE*);
RPC_STATUS __attribute__((__stdcall__)) RpcNsEntryObjectInqNext( RPC_NS_HANDLE, UUID*);
RPC_STATUS __attribute__((__stdcall__)) RpcNsEntryObjectInqDone( RPC_NS_HANDLE*);
RPC_STATUS __attribute__((__stdcall__)) RpcNsEntryExpandNameA(unsigned long,unsigned char*,unsigned char**);
RPC_STATUS __attribute__((__stdcall__)) RpcNsMgmtBindingUnexportA(unsigned long,unsigned char*,RPC_IF_ID*,unsigned long,UUID_VECTOR*);
RPC_STATUS __attribute__((__stdcall__)) RpcNsMgmtEntryCreateA(unsigned long,unsigned char*);
RPC_STATUS __attribute__((__stdcall__)) RpcNsMgmtEntryDeleteA(unsigned long,unsigned char*);
RPC_STATUS __attribute__((__stdcall__)) RpcNsMgmtEntryInqIfIdsA(unsigned long,unsigned char*,RPC_IF_ID_VECTOR**);
RPC_STATUS __attribute__((__stdcall__)) RpcNsMgmtHandleSetExpAge(RPC_NS_HANDLE,unsigned long);
RPC_STATUS __attribute__((__stdcall__)) RpcNsMgmtInqExpAge(unsigned long*);
RPC_STATUS __attribute__((__stdcall__)) RpcNsMgmtSetExpAge(unsigned long);
RPC_STATUS __attribute__((__stdcall__)) RpcNsBindingImportNext(RPC_NS_HANDLE,RPC_BINDING_HANDLE*);
RPC_STATUS __attribute__((__stdcall__)) RpcNsBindingImportDone(RPC_NS_HANDLE*);
RPC_STATUS __attribute__((__stdcall__)) RpcNsBindingSelect(RPC_BINDING_VECTOR*,RPC_BINDING_HANDLE*);

RPC_STATUS __attribute__((__stdcall__)) RpcNsEntryObjectInqBeginA(unsigned long,unsigned char*,RPC_NS_HANDLE*);
RPC_STATUS __attribute__((__stdcall__)) RpcNsBindingImportBeginA(unsigned long,unsigned char*,RPC_IF_HANDLE,UUID*,RPC_NS_HANDLE*);


RPC_STATUS __attribute__((__stdcall__)) RpcNsBindingExportW(unsigned long,unsigned short*,RPC_IF_HANDLE,RPC_BINDING_VECTOR*,UUID_VECTOR*);
RPC_STATUS __attribute__((__stdcall__)) RpcNsBindingUnexportW(unsigned long,unsigned short*,RPC_IF_HANDLE,UUID_VECTOR*);
RPC_STATUS __attribute__((__stdcall__)) RpcNsBindingLookupBeginW(unsigned long,unsigned short*,RPC_IF_HANDLE,UUID*,unsigned long,RPC_NS_HANDLE*);
RPC_STATUS __attribute__((__stdcall__)) RpcNsGroupDeleteW(unsigned long,unsigned short*);
RPC_STATUS __attribute__((__stdcall__)) RpcNsGroupMbrAddW(unsigned long,unsigned short*,unsigned long,unsigned short*);
RPC_STATUS __attribute__((__stdcall__)) RpcNsGroupMbrRemoveW(unsigned long,unsigned short*,unsigned long,unsigned short*);
RPC_STATUS __attribute__((__stdcall__)) RpcNsGroupMbrInqBeginW(unsigned long,unsigned short*,unsigned long,RPC_NS_HANDLE*);
RPC_STATUS __attribute__((__stdcall__)) RpcNsGroupMbrInqNextW(RPC_NS_HANDLE,unsigned short**);
RPC_STATUS __attribute__((__stdcall__)) RpcNsProfileDeleteW(unsigned long,unsigned short*);
RPC_STATUS __attribute__((__stdcall__)) RpcNsProfileEltAddW(unsigned long,unsigned short*, RPC_IF_ID*,unsigned long,unsigned short*,unsigned long,unsigned short*);
RPC_STATUS __attribute__((__stdcall__)) RpcNsProfileEltRemoveW(unsigned long,unsigned short*, RPC_IF_ID*,unsigned long,unsigned short*);
RPC_STATUS __attribute__((__stdcall__)) RpcNsProfileEltInqBeginW(unsigned long,unsigned short*, unsigned long,RPC_IF_ID*,unsigned long,unsigned long,unsigned short*, RPC_NS_HANDLE*);
RPC_STATUS __attribute__((__stdcall__)) RpcNsProfileEltInqNextW(RPC_NS_HANDLE,RPC_IF_ID*, unsigned short**,unsigned long*,unsigned short**);
RPC_STATUS __attribute__((__stdcall__)) RpcNsEntryObjectInqBeginW(unsigned long,unsigned short*,RPC_NS_HANDLE*);
RPC_STATUS __attribute__((__stdcall__)) RpcNsEntryExpandNameW(unsigned long,unsigned short*,unsigned short**);
RPC_STATUS __attribute__((__stdcall__)) RpcNsMgmtBindingUnexportW(unsigned long,unsigned short*,RPC_IF_ID*,unsigned long,UUID_VECTOR*);
RPC_STATUS __attribute__((__stdcall__)) RpcNsMgmtEntryCreateW(unsigned long,unsigned short*);
RPC_STATUS __attribute__((__stdcall__)) RpcNsMgmtEntryDeleteW(unsigned long,unsigned short*);
RPC_STATUS __attribute__((__stdcall__)) RpcNsMgmtEntryInqIfIdsW(unsigned long,unsigned short , RPC_IF_ID_VECTOR**);
RPC_STATUS __attribute__((__stdcall__)) RpcNsBindingImportBeginW(unsigned long,unsigned short*,RPC_IF_HANDLE,UUID*,RPC_NS_HANDLE*);
# 120 "H:/CPP/wxdevcpp6.10/include/rpcnsi.h" 3
}
# 42 "H:/CPP/wxdevcpp6.10/include/rpc.h" 2 3
# 1 "H:/CPP/wxdevcpp6.10/include/rpcnterr.h" 1 3



       
# 5 "H:/CPP/wxdevcpp6.10/include/rpcnterr.h" 3
# 43 "H:/CPP/wxdevcpp6.10/include/rpc.h" 2 3
# 59 "H:/CPP/wxdevcpp6.10/include/rpc.h" 3
RPC_STATUS __attribute__((__stdcall__)) RpcImpersonateClient(RPC_BINDING_HANDLE);
RPC_STATUS __attribute__((__stdcall__)) RpcRevertToSelf(void);
long __attribute__((__stdcall__)) I_RpcMapWin32Status(RPC_STATUS);

}
# 83 "H:/CPP/wxdevcpp6.10/include/windows.h" 2 3
# 1 "H:/CPP/wxdevcpp6.10/include/shellapi.h" 1 3



       
# 5 "H:/CPP/wxdevcpp6.10/include/shellapi.h" 3



extern "C" {
# 127 "H:/CPP/wxdevcpp6.10/include/shellapi.h" 3
typedef WORD FILEOP_FLAGS;
typedef WORD PRINTEROP_FLAGS;
# 1 "H:/CPP/wxdevcpp6.10/include/pshpack2.h" 1 3

#pragma pack(push,2)
# 130 "H:/CPP/wxdevcpp6.10/include/shellapi.h" 2 3
typedef struct _AppBarData {
 DWORD cbSize;
 HWND hWnd;
 UINT uCallbackMessage;
 UINT uEdge;
 RECT rc;
 LPARAM lParam;
} APPBARDATA,*PAPPBARDATA;
typedef struct HDROP__{int i;}*HDROP;

typedef struct _NOTIFYICONDATAA {
 DWORD cbSize;
 HWND hWnd;
 UINT uID;
 UINT uFlags;
 UINT uCallbackMessage;
 HICON hIcon;
# 159 "H:/CPP/wxdevcpp6.10/include/shellapi.h" 3
 CHAR szTip[64];




} NOTIFYICONDATAA,*PNOTIFYICONDATAA;

typedef struct _NOTIFYICONDATAW {
 DWORD cbSize;
 HWND hWnd;
 UINT uID;
 UINT uFlags;
 UINT uCallbackMessage;
 HICON hIcon;
# 185 "H:/CPP/wxdevcpp6.10/include/shellapi.h" 3
 WCHAR szTip[64];




} NOTIFYICONDATAW,*PNOTIFYICONDATAW;

typedef struct _SHELLEXECUTEINFOA {
 DWORD cbSize;
 ULONG fMask;
 HWND hwnd;
 LPCSTR lpVerb;
 LPCSTR lpFile;
 LPCSTR lpParameters;
 LPCSTR lpDirectory;
 int nShow;
 HINSTANCE hInstApp;
 PVOID lpIDList;
 LPCSTR lpClass;
 HKEY hkeyClass;
 DWORD dwHotKey;
 HANDLE hIcon;
 HANDLE hProcess;
} SHELLEXECUTEINFOA,*LPSHELLEXECUTEINFOA;
typedef struct _SHELLEXECUTEINFOW {
 DWORD cbSize;
 ULONG fMask;
 HWND hwnd;
 LPCWSTR lpVerb;
 LPCWSTR lpFile;
 LPCWSTR lpParameters;
 LPCWSTR lpDirectory;
 int nShow;
 HINSTANCE hInstApp;
 PVOID lpIDList;
 LPCWSTR lpClass;
 HKEY hkeyClass;
 DWORD dwHotKey;
 HANDLE hIcon;
 HANDLE hProcess;
} SHELLEXECUTEINFOW,*LPSHELLEXECUTEINFOW;
typedef struct _SHFILEOPSTRUCTA {
 HWND hwnd;
 UINT wFunc;
 LPCSTR pFrom;
 LPCSTR pTo;
 FILEOP_FLAGS fFlags;
 BOOL fAnyOperationsAborted;
 PVOID hNameMappings;
 LPCSTR lpszProgressTitle;
} SHFILEOPSTRUCTA,*LPSHFILEOPSTRUCTA;
typedef struct _SHFILEOPSTRUCTW {
 HWND hwnd;
 UINT wFunc;
 LPCWSTR pFrom;
 LPCWSTR pTo;
 FILEOP_FLAGS fFlags;
 BOOL fAnyOperationsAborted;
 PVOID hNameMappings;
 LPCWSTR lpszProgressTitle;
} SHFILEOPSTRUCTW,*LPSHFILEOPSTRUCTW;
typedef struct _SHFILEINFOA {
 HICON hIcon;
 int iIcon;
 DWORD dwAttributes;
 CHAR szDisplayName[260];
 CHAR szTypeName[80];
} SHFILEINFOA;
typedef struct _SHFILEINFOW {
 HICON hIcon;
 int iIcon;
 DWORD dwAttributes;
 WCHAR szDisplayName[260];
 WCHAR szTypeName[80];
} SHFILEINFOW;
typedef struct _SHQUERYRBINFO {
 DWORD cbSize;
 long long i64Size;
 long long i64NumItems;
} SHQUERYRBINFO, *LPSHQUERYRBINFO;
# 1 "H:/CPP/wxdevcpp6.10/include/poppack.h" 1 3

#pragma pack(pop)
# 266 "H:/CPP/wxdevcpp6.10/include/shellapi.h" 2 3

LPWSTR * __attribute__((__stdcall__)) CommandLineToArgvW(LPCWSTR,int*);
void __attribute__((__stdcall__)) DragAcceptFiles(HWND,BOOL);
void __attribute__((__stdcall__)) DragFinish(HDROP);
UINT __attribute__((__stdcall__)) DragQueryFileA(HDROP,UINT,LPSTR,UINT);
UINT __attribute__((__stdcall__)) DragQueryFileW(HDROP,UINT,LPWSTR,UINT);
BOOL __attribute__((__stdcall__)) DragQueryPoint(HDROP,LPPOINT);
HICON __attribute__((__stdcall__)) DuplicateIcon(HINSTANCE,HICON);
HICON __attribute__((__stdcall__)) ExtractAssociatedIconA(HINSTANCE,LPCSTR,PWORD);
HICON __attribute__((__stdcall__)) ExtractAssociatedIconW(HINSTANCE,LPCWSTR,PWORD);
HICON __attribute__((__stdcall__)) ExtractIconA(HINSTANCE,LPCSTR,UINT);
HICON __attribute__((__stdcall__)) ExtractIconW(HINSTANCE,LPCWSTR,UINT);
UINT __attribute__((__stdcall__)) ExtractIconExA(LPCSTR,int,HICON*,HICON*,UINT);
UINT __attribute__((__stdcall__)) ExtractIconExW(LPCWSTR,int,HICON*,HICON*,UINT);
HINSTANCE __attribute__((__stdcall__)) FindExecutableA(LPCSTR,LPCSTR,LPSTR);
HINSTANCE __attribute__((__stdcall__)) FindExecutableW(LPCWSTR,LPCWSTR,LPWSTR);
UINT __attribute__((__stdcall__)) SHAppBarMessage(DWORD,PAPPBARDATA);
BOOL __attribute__((__stdcall__)) Shell_NotifyIconA(DWORD,PNOTIFYICONDATAA);
BOOL __attribute__((__stdcall__)) Shell_NotifyIconW(DWORD,PNOTIFYICONDATAW);
int __attribute__((__stdcall__)) ShellAboutA(HWND,LPCSTR,LPCSTR,HICON);
int __attribute__((__stdcall__)) ShellAboutW(HWND,LPCWSTR,LPCWSTR,HICON);
HINSTANCE __attribute__((__stdcall__)) ShellExecuteA(HWND,LPCSTR,LPCSTR,LPCSTR,LPCSTR,INT);
HINSTANCE __attribute__((__stdcall__)) ShellExecuteW(HWND,LPCWSTR,LPCWSTR,LPCWSTR,LPCWSTR,INT);
BOOL __attribute__((__stdcall__)) ShellExecuteExA(LPSHELLEXECUTEINFOA);
BOOL __attribute__((__stdcall__)) ShellExecuteExW(LPSHELLEXECUTEINFOW);
int __attribute__((__stdcall__)) SHFileOperationA(LPSHFILEOPSTRUCTA);
int __attribute__((__stdcall__)) SHFileOperationW(LPSHFILEOPSTRUCTW);
void __attribute__((__stdcall__)) SHFreeNameMappings(HANDLE);
DWORD __attribute__((__stdcall__)) SHGetFileInfoA(LPCSTR,DWORD,SHFILEINFOA*,UINT,UINT);
DWORD __attribute__((__stdcall__)) SHGetFileInfoW(LPCWSTR,DWORD,SHFILEINFOW*,UINT,UINT);
HRESULT __attribute__((__stdcall__)) SHQueryRecycleBinA(LPCSTR, LPSHQUERYRBINFO);
HRESULT __attribute__((__stdcall__)) SHQueryRecycleBinW(LPCWSTR, LPSHQUERYRBINFO);
HRESULT __attribute__((__stdcall__)) SHEmptyRecycleBinA(HWND,LPCSTR,DWORD);
HRESULT __attribute__((__stdcall__)) SHEmptyRecycleBinW(HWND,LPCWSTR,DWORD);
# 321 "H:/CPP/wxdevcpp6.10/include/shellapi.h" 3
typedef NOTIFYICONDATAA NOTIFYICONDATA,*PNOTIFYICONDATA;
typedef SHELLEXECUTEINFOA SHELLEXECUTEINFO,*LPSHELLEXECUTEINFO;
typedef SHFILEOPSTRUCTA SHFILEOPSTRUCT,*LPSHFILEOPSTRUCT;
typedef SHFILEINFOA SHFILEINFO;
# 340 "H:/CPP/wxdevcpp6.10/include/shellapi.h" 3
}
# 84 "H:/CPP/wxdevcpp6.10/include/windows.h" 2 3
# 1 "H:/CPP/wxdevcpp6.10/include/winperf.h" 1 3



       
# 5 "H:/CPP/wxdevcpp6.10/include/winperf.h" 3



extern "C" {
# 78 "H:/CPP/wxdevcpp6.10/include/winperf.h" 3
typedef struct _PERF_DATA_BLOCK {
 WCHAR Signature[4];
 DWORD LittleEndian;
 DWORD Version;
 DWORD Revision;
 DWORD TotalByteLength;
 DWORD HeaderLength;
 DWORD NumObjectTypes;
 LONG DefaultObject;
 SYSTEMTIME SystemTime;
 LARGE_INTEGER PerfTime;
 LARGE_INTEGER PerfFreq;
 LARGE_INTEGER PerfTime100nSec;
 DWORD SystemNameLength;
 DWORD SystemNameOffset;
} PERF_DATA_BLOCK, *PPERF_DATA_BLOCK;
typedef struct _PERF_OBJECT_TYPE {
 DWORD TotalByteLength;
 DWORD DefinitionLength;
 DWORD HeaderLength;
 DWORD ObjectNameTitleIndex;
 LPWSTR ObjectNameTitle;
 DWORD ObjectHelpTitleIndex;
 LPWSTR ObjectHelpTitle;
 DWORD DetailLevel;
 DWORD NumCounters;
 LONG DefaultCounter;
 LONG NumInstances;
 DWORD CodePage;
 LARGE_INTEGER PerfTime;
 LARGE_INTEGER PerfFreq;
} PERF_OBJECT_TYPE, *PPERF_OBJECT_TYPE;
typedef struct _PERF_COUNTER_DEFINITION {
 DWORD ByteLength;
 DWORD CounterNameTitleIndex;
 LPWSTR CounterNameTitle;
 DWORD CounterHelpTitleIndex;
 LPWSTR CounterHelpTitle;
 LONG DefaultScale;
 DWORD DetailLevel;
 DWORD CounterType;
 DWORD CounterSize;
 DWORD CounterOffset;
} PERF_COUNTER_DEFINITION,*PPERF_COUNTER_DEFINITION;
typedef struct _PERF_INSTANCE_DEFINITION {
 DWORD ByteLength;
 DWORD ParentObjectTitleIndex;
 DWORD ParentObjectInstance;
 LONG UniqueID;
 DWORD NameOffset;
 DWORD NameLength;
} PERF_INSTANCE_DEFINITION,*PPERF_INSTANCE_DEFINITION;
typedef struct _PERF_COUNTER_BLOCK {
 DWORD ByteLength;
} PERF_COUNTER_BLOCK, *PPERF_COUNTER_BLOCK;
typedef DWORD(__attribute__((__stdcall__)) PM_OPEN_PROC)(LPWSTR);
typedef DWORD(__attribute__((__stdcall__)) PM_COLLECT_PROC)(LPWSTR,PVOID*,PDWORD,PDWORD);
typedef DWORD(__attribute__((__stdcall__)) PM_CLOSE_PROC)(void);

}
# 85 "H:/CPP/wxdevcpp6.10/include/windows.h" 2 3

# 1 "H:/CPP/wxdevcpp6.10/include/commdlg.h" 1 3



       
# 5 "H:/CPP/wxdevcpp6.10/include/commdlg.h" 3



extern "C" {

#pragma pack(push,1)
# 219 "H:/CPP/wxdevcpp6.10/include/commdlg.h" 3
typedef UINT (__attribute__((__stdcall__)) *__CDHOOKPROC)(HWND,UINT,WPARAM,LPARAM);
typedef __CDHOOKPROC LPCCHOOKPROC;
typedef __CDHOOKPROC LPCFHOOKPROC;
typedef __CDHOOKPROC LPFRHOOKPROC;
typedef __CDHOOKPROC LPOFNHOOKPROC;
typedef __CDHOOKPROC LPPAGEPAINTHOOK;
typedef __CDHOOKPROC LPPAGESETUPHOOK;
typedef __CDHOOKPROC LPSETUPHOOKPROC;
typedef __CDHOOKPROC LPPRINTHOOKPROC;
typedef struct tagCHOOSECOLORA {
 DWORD lStructSize;
 HWND hwndOwner;
 HWND hInstance;
 COLORREF rgbResult;
 COLORREF* lpCustColors;
 DWORD Flags;
 LPARAM lCustData;
 LPCCHOOKPROC lpfnHook;
 LPCSTR lpTemplateName;
} CHOOSECOLORA,*LPCHOOSECOLORA;
typedef struct tagCHOOSECOLORW {
 DWORD lStructSize;
 HWND hwndOwner;
 HWND hInstance;
 COLORREF rgbResult;
 COLORREF* lpCustColors;
 DWORD Flags;
 LPARAM lCustData;
 LPCCHOOKPROC lpfnHook;
 LPCWSTR lpTemplateName;
} CHOOSECOLORW,*LPCHOOSECOLORW;
typedef struct tagCHOOSEFONTA {
 DWORD lStructSize;
 HWND hwndOwner;
 HDC hDC;
 LPLOGFONTA lpLogFont;
 INT iPointSize;
 DWORD Flags;
 DWORD rgbColors;
 LPARAM lCustData;
 LPCFHOOKPROC lpfnHook;
 LPCSTR lpTemplateName;
 HINSTANCE hInstance;
 LPSTR lpszStyle;
 WORD nFontType;
 WORD ___MISSING_ALIGNMENT__;
 INT nSizeMin;
 INT nSizeMax;
} CHOOSEFONTA,*LPCHOOSEFONTA;
typedef struct tagCHOOSEFONTW {
 DWORD lStructSize;
 HWND hwndOwner;
 HDC hDC;
 LPLOGFONTW lpLogFont;
 INT iPointSize;
 DWORD Flags;
 DWORD rgbColors;
 LPARAM lCustData;
 LPCFHOOKPROC lpfnHook;
 LPCWSTR lpTemplateName;
 HINSTANCE hInstance;
 LPWSTR lpszStyle;
 WORD nFontType;
 WORD ___MISSING_ALIGNMENT__;
 INT nSizeMin;
 INT nSizeMax;
} CHOOSEFONTW,*LPCHOOSEFONTW;
typedef struct tagDEVNAMES {
 WORD wDriverOffset;
 WORD wDeviceOffset;
 WORD wOutputOffset;
 WORD wDefault;
} DEVNAMES,*LPDEVNAMES;
typedef struct {
 DWORD lStructSize;
 HWND hwndOwner;
 HINSTANCE hInstance;
 DWORD Flags;
 LPSTR lpstrFindWhat;
 LPSTR lpstrReplaceWith;
 WORD wFindWhatLen;
 WORD wReplaceWithLen;
 LPARAM lCustData;
 LPFRHOOKPROC lpfnHook;
 LPCSTR lpTemplateName;
} FINDREPLACEA,*LPFINDREPLACEA;
typedef struct {
 DWORD lStructSize;
 HWND hwndOwner;
 HINSTANCE hInstance;
 DWORD Flags;
 LPWSTR lpstrFindWhat;
 LPWSTR lpstrReplaceWith;
 WORD wFindWhatLen;
 WORD wReplaceWithLen;
 LPARAM lCustData;
 LPFRHOOKPROC lpfnHook;
 LPCWSTR lpTemplateName;
} FINDREPLACEW,*LPFINDREPLACEW;
typedef struct tagOFNA {
 DWORD lStructSize;
 HWND hwndOwner;
 HINSTANCE hInstance;
 LPCSTR lpstrFilter;
 LPSTR lpstrCustomFilter;
 DWORD nMaxCustFilter;
 DWORD nFilterIndex;
 LPSTR lpstrFile;
 DWORD nMaxFile;
 LPSTR lpstrFileTitle;
 DWORD nMaxFileTitle;
 LPCSTR lpstrInitialDir;
 LPCSTR lpstrTitle;
 DWORD Flags;
 WORD nFileOffset;
 WORD nFileExtension;
 LPCSTR lpstrDefExt;
 DWORD lCustData;
 LPOFNHOOKPROC lpfnHook;
 LPCSTR lpTemplateName;





} OPENFILENAMEA,*LPOPENFILENAMEA;
typedef struct tagOFNW {
 DWORD lStructSize;
 HWND hwndOwner;
 HINSTANCE hInstance;
 LPCWSTR lpstrFilter;
 LPWSTR lpstrCustomFilter;
 DWORD nMaxCustFilter;
 DWORD nFilterIndex;
 LPWSTR lpstrFile;
 DWORD nMaxFile;
 LPWSTR lpstrFileTitle;
 DWORD nMaxFileTitle;
 LPCWSTR lpstrInitialDir;
 LPCWSTR lpstrTitle;
 DWORD Flags;
 WORD nFileOffset;
 WORD nFileExtension;
 LPCWSTR lpstrDefExt;
 DWORD lCustData;
 LPOFNHOOKPROC lpfnHook;
 LPCWSTR lpTemplateName;





} OPENFILENAMEW,*LPOPENFILENAMEW;
typedef struct _OFNOTIFYA {
 NMHDR hdr;
 LPOPENFILENAMEA lpOFN;
 LPSTR pszFile;
} OFNOTIFYA,*LPOFNOTIFYA;
typedef struct _OFNOTIFYW {
 NMHDR hdr;
 LPOPENFILENAMEW lpOFN;
 LPWSTR pszFile;
} OFNOTIFYW,*LPOFNOTIFYW;
typedef struct tagPSDA {
 DWORD lStructSize;
 HWND hwndOwner;
 HGLOBAL hDevMode;
 HGLOBAL hDevNames;
 DWORD Flags;
 POINT ptPaperSize;
 RECT rtMinMargin;
 RECT rtMargin;
 HINSTANCE hInstance;
 LPARAM lCustData;
 LPPAGESETUPHOOK lpfnPageSetupHook;
 LPPAGEPAINTHOOK lpfnPagePaintHook;
 LPCSTR lpPageSetupTemplateName;
 HGLOBAL hPageSetupTemplate;
} PAGESETUPDLGA,*LPPAGESETUPDLGA;
typedef struct tagPSDW {
 DWORD lStructSize;
 HWND hwndOwner;
 HGLOBAL hDevMode;
 HGLOBAL hDevNames;
 DWORD Flags;
 POINT ptPaperSize;
 RECT rtMinMargin;
 RECT rtMargin;
 HINSTANCE hInstance;
 LPARAM lCustData;
 LPPAGESETUPHOOK lpfnPageSetupHook;
 LPPAGEPAINTHOOK lpfnPagePaintHook;
 LPCWSTR lpPageSetupTemplateName;
 HGLOBAL hPageSetupTemplate;
} PAGESETUPDLGW,*LPPAGESETUPDLGW;
typedef struct tagPDA {
 DWORD lStructSize;
 HWND hwndOwner;
 HANDLE hDevMode;
 HANDLE hDevNames;
 HDC hDC;
 DWORD Flags;
 WORD nFromPage;
 WORD nToPage;
 WORD nMinPage;
 WORD nMaxPage;
 WORD nCopies;
 HINSTANCE hInstance;
 DWORD lCustData;
 LPPRINTHOOKPROC lpfnPrintHook;
 LPSETUPHOOKPROC lpfnSetupHook;
 LPCSTR lpPrintTemplateName;
 LPCSTR lpSetupTemplateName;
 HANDLE hPrintTemplate;
 HANDLE hSetupTemplate;
} PRINTDLGA,*LPPRINTDLGA;
typedef struct tagPDW {
 DWORD lStructSize;
 HWND hwndOwner;
 HANDLE hDevMode;
 HANDLE hDevNames;
 HDC hDC;
 DWORD Flags;
 WORD nFromPage;
 WORD nToPage;
 WORD nMinPage;
 WORD nMaxPage;
 WORD nCopies;
 HINSTANCE hInstance;
 DWORD lCustData;
 LPPRINTHOOKPROC lpfnPrintHook;
 LPSETUPHOOKPROC lpfnSetupHook;
 LPCWSTR lpPrintTemplateName;
 LPCWSTR lpSetupTemplateName;
 HANDLE hPrintTemplate;
 HANDLE hSetupTemplate;
} PRINTDLGW,*LPPRINTDLGW;
# 511 "H:/CPP/wxdevcpp6.10/include/commdlg.h" 3
BOOL __attribute__((__stdcall__)) ChooseColorA(LPCHOOSECOLORA);
BOOL __attribute__((__stdcall__)) ChooseColorW(LPCHOOSECOLORW);
BOOL __attribute__((__stdcall__)) ChooseFontA(LPCHOOSEFONTA);
BOOL __attribute__((__stdcall__)) ChooseFontW(LPCHOOSEFONTW);
DWORD __attribute__((__stdcall__)) CommDlgExtendedError(void);
HWND __attribute__((__stdcall__)) FindTextA(LPFINDREPLACEA);
HWND __attribute__((__stdcall__)) FindTextW(LPFINDREPLACEW);
short __attribute__((__stdcall__)) GetFileTitleA(LPCSTR,LPSTR,WORD);
short __attribute__((__stdcall__)) GetFileTitleW(LPCWSTR,LPWSTR,WORD);
BOOL __attribute__((__stdcall__)) GetOpenFileNameA(LPOPENFILENAMEA);
BOOL __attribute__((__stdcall__)) GetOpenFileNameW(LPOPENFILENAMEW);
BOOL __attribute__((__stdcall__)) GetSaveFileNameA(LPOPENFILENAMEA);
BOOL __attribute__((__stdcall__)) GetSaveFileNameW(LPOPENFILENAMEW);
BOOL __attribute__((__stdcall__)) PageSetupDlgA(LPPAGESETUPDLGA);
BOOL __attribute__((__stdcall__)) PageSetupDlgW(LPPAGESETUPDLGW);
BOOL __attribute__((__stdcall__)) PrintDlgA(LPPRINTDLGA);
BOOL __attribute__((__stdcall__)) PrintDlgW(LPPRINTDLGW);
HWND __attribute__((__stdcall__)) ReplaceTextA(LPFINDREPLACEA);
HWND __attribute__((__stdcall__)) ReplaceTextW(LPFINDREPLACEW);
# 571 "H:/CPP/wxdevcpp6.10/include/commdlg.h" 3
typedef CHOOSECOLORA CHOOSECOLOR,*LPCHOOSECOLOR;
typedef CHOOSEFONTA CHOOSEFONT,*LPCHOOSEFONT;
typedef FINDREPLACEA FINDREPLACE,*LPFINDREPLACE;
typedef OPENFILENAMEA OPENFILENAME,*LPOPENFILENAME;
typedef OFNOTIFYA OFNOTIFY,*LPOFNOTIFY;
typedef PAGESETUPDLGA PAGESETUPDLG,*LPPAGESETUPDLG;
typedef PRINTDLGA PRINTDLG,*LPPRINTDLG;
# 592 "H:/CPP/wxdevcpp6.10/include/commdlg.h" 3
#pragma pack(pop)

}
# 87 "H:/CPP/wxdevcpp6.10/include/windows.h" 2 3
# 1 "H:/CPP/wxdevcpp6.10/include/winspool.h" 1 3



       
# 5 "H:/CPP/wxdevcpp6.10/include/winspool.h" 3



extern "C" {
# 221 "H:/CPP/wxdevcpp6.10/include/winspool.h" 3
typedef struct _ADDJOB_INFO_1A {
 LPSTR Path;
 DWORD JobId;
} ADDJOB_INFO_1A,*PADDJOB_INFO_1A,*LPADDJOB_INFO_1A;
typedef struct _ADDJOB_INFO_1W {
 LPWSTR Path;
 DWORD JobId;
} ADDJOB_INFO_1W,*PADDJOB_INFO_1W,*LPADDJOB_INFO_1W;
typedef struct _DATATYPES_INFO_1A{LPSTR pName;} DATATYPES_INFO_1A,*PDATATYPES_INFO_1A,*LPDATATYPES_INFO_1A;
typedef struct _DATATYPES_INFO_1W{LPWSTR pName;} DATATYPES_INFO_1W,*PDATATYPES_INFO_1W,*LPDATATYPES_INFO_1W;
typedef struct _JOB_INFO_1A {
 DWORD JobId;
 LPSTR pPrinterName;
 LPSTR pMachineName;
 LPSTR pUserName;
 LPSTR pDocument;
 LPSTR pDatatype;
 LPSTR pStatus;
 DWORD Status;
 DWORD Priority;
 DWORD Position;
 DWORD TotalPages;
 DWORD PagesPrinted;
 SYSTEMTIME Submitted;
} JOB_INFO_1A,*PJOB_INFO_1A,*LPJOB_INFO_1A;
typedef struct _JOB_INFO_1W {
 DWORD JobId;
 LPWSTR pPrinterName;
 LPWSTR pMachineName;
 LPWSTR pUserName;
 LPWSTR pDocument;
 LPWSTR pDatatype;
 LPWSTR pStatus;
 DWORD Status;
 DWORD Priority;
 DWORD Position;
 DWORD TotalPages;
 DWORD PagesPrinted;
 SYSTEMTIME Submitted;
} JOB_INFO_1W,*PJOB_INFO_1W,*LPJOB_INFO_1W;
typedef struct _JOB_INFO_2A {
 DWORD JobId;
 LPSTR pPrinterName;
 LPSTR pMachineName;
 LPSTR pUserName;
 LPSTR pDocument;
 LPSTR pNotifyName;
 LPSTR pDatatype;
 LPSTR pPrintProcessor;
 LPSTR pParameters;
 LPSTR pDriverName;
 LPDEVMODEA pDevMode;
 LPSTR pStatus;
 PSECURITY_DESCRIPTOR pSecurityDescriptor;
 DWORD Status;
 DWORD Priority;
 DWORD Position;
 DWORD StartTime;
 DWORD UntilTime;
 DWORD TotalPages;
 DWORD Size;
 SYSTEMTIME Submitted;
 DWORD Time;
 DWORD PagesPrinted;
} JOB_INFO_2A,*PJOB_INFO_2A,*LPJOB_INFO_2A;
typedef struct _JOB_INFO_2W {
 DWORD JobId;
 LPWSTR pPrinterName;
 LPWSTR pMachineName;
 LPWSTR pUserName;
 LPWSTR pDocument;
 LPWSTR pNotifyName;
 LPWSTR pDatatype;
 LPWSTR pPrintProcessor;
 LPWSTR pParameters;
 LPWSTR pDriverName;
 LPDEVMODEW pDevMode;
 LPWSTR pStatus;
 PSECURITY_DESCRIPTOR pSecurityDescriptor;
 DWORD Status;
 DWORD Priority;
 DWORD Position;
 DWORD StartTime;
 DWORD UntilTime;
 DWORD TotalPages;
 DWORD Size;
 SYSTEMTIME Submitted;
 DWORD Time;
 DWORD PagesPrinted;
} JOB_INFO_2W,*PJOB_INFO_2W,*LPJOB_INFO_2W;
typedef struct _DOC_INFO_1A {
 LPSTR pDocName;
 LPSTR pOutputFile;
 LPSTR pDatatype;
} DOC_INFO_1A,*PDOC_INFO_1A,*LPDOC_INFO_1A;
typedef struct _DOC_INFO_1W {
 LPWSTR pDocName;
 LPWSTR pOutputFile;
 LPWSTR pDatatype;
} DOC_INFO_1W,*PDOC_INFO_1W,*LPDOC_INFO_1W;
typedef struct _DOC_INFO_2A {
 LPSTR pDocName;
 LPSTR pOutputFile;
 LPSTR pDatatype;
 DWORD dwMode;
 DWORD JobId;
} DOC_INFO_2A,*PDOC_INFO_2A,*LPDOC_INFO_2A;
typedef struct _DOC_INFO_2W {
 LPWSTR pDocName;
 LPWSTR pOutputFile;
 LPWSTR pDatatype;
 DWORD dwMode;
 DWORD JobId;
} DOC_INFO_2W,*PDOC_INFO_2W,*LPDOC_INFO_2W;
typedef struct _DRIVER_INFO_1A {LPSTR pName;} DRIVER_INFO_1A,*PDRIVER_INFO_1A,*LPDRIVER_INFO_1A;
typedef struct _DRIVER_INFO_1W {LPWSTR pName;} DRIVER_INFO_1W,*PDRIVER_INFO_1W,*LPDRIVER_INFO_1W;
typedef struct _DRIVER_INFO_2A {
 DWORD cVersion;
 LPSTR pName;
 LPSTR pEnvironment;
 LPSTR pDriverPath;
 LPSTR pDataFile;
 LPSTR pConfigFile;
} DRIVER_INFO_2A,*PDRIVER_INFO_2A,*LPDRIVER_INFO_2A;
typedef struct _DRIVER_INFO_2W {
 DWORD cVersion;
 LPWSTR pName;
 LPWSTR pEnvironment;
 LPWSTR pDriverPath;
 LPWSTR pDataFile;
 LPWSTR pConfigFile;
} DRIVER_INFO_2W,*PDRIVER_INFO_2W,*LPDRIVER_INFO_2W;
typedef struct _DRIVER_INFO_3A {
 DWORD cVersion;
 LPSTR pName;
 LPSTR pEnvironment;
 LPSTR pDriverPath;
 LPSTR pDataFile;
 LPSTR pConfigFile;
 LPSTR pHelpFile;
 LPSTR pDependentFiles;
 LPSTR pMonitorName;
 LPSTR pDefaultDataType;
} DRIVER_INFO_3A,*PDRIVER_INFO_3A,*LPDRIVER_INFO_3A;
typedef struct _DRIVER_INFO_3W {
 DWORD cVersion;
 LPWSTR pName;
 LPWSTR pEnvironment;
 LPWSTR pDriverPath;
 LPWSTR pDataFile;
 LPWSTR pConfigFile;
 LPWSTR pHelpFile;
 LPWSTR pDependentFiles;
 LPWSTR pMonitorName;
 LPWSTR pDefaultDataType;
} DRIVER_INFO_3W,*PDRIVER_INFO_3W,*LPDRIVER_INFO_3W;
typedef struct _MONITOR_INFO_1A{LPSTR pName;} MONITOR_INFO_1A,*PMONITOR_INFO_1A,*LPMONITOR_INFO_1A;
typedef struct _MONITOR_INFO_1W{LPWSTR pName;} MONITOR_INFO_1W,*PMONITOR_INFO_1W,*LPMONITOR_INFO_1W;
typedef struct _PORT_INFO_1A {LPSTR pName;} PORT_INFO_1A,*PPORT_INFO_1A,*LPPORT_INFO_1A;
typedef struct _PORT_INFO_1W {LPWSTR pName;} PORT_INFO_1W,*PPORT_INFO_1W,*LPPORT_INFO_1W;
typedef struct _MONITOR_INFO_2A{
 LPSTR pName;
 LPSTR pEnvironment;
 LPSTR pDLLName;
} MONITOR_INFO_2A,*PMONITOR_INFO_2A,*LPMONITOR_INFO_2A;
typedef struct _MONITOR_INFO_2W{
 LPWSTR pName;
 LPWSTR pEnvironment;
 LPWSTR pDLLName;
} MONITOR_INFO_2W,*PMONITOR_INFO_2W,*LPMONITOR_INFO_2W;
typedef struct _PORT_INFO_2A {
 LPSTR pPortName;
 LPSTR pMonitorName;
 LPSTR pDescription;
 DWORD fPortType;
 DWORD Reserved;
} PORT_INFO_2A,*PPORT_INFO_2A,*LPPORT_INFO_2A;
typedef struct _PORT_INFO_2W {
 LPWSTR pPortName;
 LPWSTR pMonitorName;
 LPWSTR pDescription;
 DWORD fPortType;
 DWORD Reserved;
} PORT_INFO_2W,*PPORT_INFO_2W,*LPPORT_INFO_2W;
typedef struct _PORT_INFO_3A {
 DWORD dwStatus;
 LPSTR pszStatus;
 DWORD dwSeverity;
} PORT_INFO_3A,*PPORT_INFO_3A,*LPPORT_INFO_3A;
typedef struct _PORT_INFO_3W {
 DWORD dwStatus;
 LPWSTR pszStatus;
 DWORD dwSeverity;
} PORT_INFO_3W,*PPORT_INFO_3W,*LPPORT_INFO_3W;
typedef struct _PRINTER_INFO_1A {
 DWORD Flags;
 LPSTR pDescription;
 LPSTR pName;
 LPSTR pComment;
} PRINTER_INFO_1A,*PPRINTER_INFO_1A,*LPPRINTER_INFO_1A;
typedef struct _PRINTER_INFO_1W {
 DWORD Flags;
 LPWSTR pDescription;
 LPWSTR pName;
 LPWSTR pComment;
} PRINTER_INFO_1W,*PPRINTER_INFO_1W,*LPPRINTER_INFO_1W;
typedef struct _PRINTER_INFO_2A {
 LPSTR pServerName;
 LPSTR pPrinterName;
 LPSTR pShareName;
 LPSTR pPortName;
 LPSTR pDriverName;
 LPSTR pComment;
 LPSTR pLocation;
 LPDEVMODEA pDevMode;
 LPSTR pSepFile;
 LPSTR pPrintProcessor;
 LPSTR pDatatype;
 LPSTR pParameters;
 PSECURITY_DESCRIPTOR pSecurityDescriptor;
 DWORD Attributes;
 DWORD Priority;
 DWORD DefaultPriority;
 DWORD StartTime;
 DWORD UntilTime;
 DWORD Status;
 DWORD cJobs;
 DWORD AveragePPM;
} PRINTER_INFO_2A,*PPRINTER_INFO_2A,*LPPRINTER_INFO_2A;
typedef struct _PRINTER_INFO_2W {
 LPWSTR pServerName;
 LPWSTR pPrinterName;
 LPWSTR pShareName;
 LPWSTR pPortName;
 LPWSTR pDriverName;
 LPWSTR pComment;
 LPWSTR pLocation;
 LPDEVMODEW pDevMode;
 LPWSTR pSepFile;
 LPWSTR pPrintProcessor;
 LPWSTR pDatatype;
 LPWSTR pParameters;
 PSECURITY_DESCRIPTOR pSecurityDescriptor;
 DWORD Attributes;
 DWORD Priority;
 DWORD DefaultPriority;
 DWORD StartTime;
 DWORD UntilTime;
 DWORD Status;
 DWORD cJobs;
 DWORD AveragePPM;
} PRINTER_INFO_2W,*PPRINTER_INFO_2W,*LPPRINTER_INFO_2W;
typedef struct _PRINTER_INFO_3 {
 PSECURITY_DESCRIPTOR pSecurityDescriptor;
} PRINTER_INFO_3,*PPRINTER_INFO_3,*LPPRINTER_INFO_3;
typedef struct _PRINTER_INFO_4A {
 LPSTR pPrinterName;
 LPSTR pServerName;
 DWORD Attributes;
} PRINTER_INFO_4A,*PPRINTER_INFO_4A,*LPPRINTER_INFO_4A;
typedef struct _PRINTER_INFO_4W {
 LPWSTR pPrinterName;
 LPWSTR pServerName;
 DWORD Attributes;
} PRINTER_INFO_4W,*PPRINTER_INFO_4W,*LPPRINTER_INFO_4W;
typedef struct _PRINTER_INFO_5A {
 LPSTR pPrinterName;
 LPSTR pPortName;
 DWORD Attributes;
 DWORD DeviceNotSelectedTimeout;
 DWORD TransmissionRetryTimeout;
} PRINTER_INFO_5A,*PPRINTER_INFO_5A,*LPPRINTER_INFO_5A;
typedef struct _PRINTER_INFO_5W {
 LPWSTR pPrinterName;
 LPWSTR pPortName;
 DWORD Attributes;
 DWORD DeviceNotSelectedTimeout;
 DWORD TransmissionRetryTimeout;
} PRINTER_INFO_5W,*PPRINTER_INFO_5W,*LPPRINTER_INFO_5W;
typedef struct _PRINTER_INFO_6 {
 DWORD dwStatus;
} PRINTER_INFO_6,*PPRINTER_INFO_6,*LPPRINTER_INFO_6;
typedef struct _PRINTPROCESSOR_INFO_1A {LPSTR pName;} PRINTPROCESSOR_INFO_1A,*PPRINTPROCESSOR_INFO_1A,*LPPRINTPROCESSOR_INFO_1A;
typedef struct _PRINTPROCESSOR_INFO_1W {LPWSTR pName;} PRINTPROCESSOR_INFO_1W,*PPRINTPROCESSOR_INFO_1W,*LPPRINTPROCESSOR_INFO_1W;
typedef struct _PRINTER_NOTIFY_INFO_DATA {
 WORD Type;
 WORD Field;
 DWORD Reserved;
 DWORD Id;
 union {
  DWORD adwData[2];
  struct {
   DWORD cbBuf;
   PVOID pBuf;
  } Data;
 } NotifyData;
} PRINTER_NOTIFY_INFO_DATA,*PPRINTER_NOTIFY_INFO_DATA,*LPPRINTER_NOTIFY_INFO_DATA;
typedef struct _PRINTER_NOTIFY_INFO {
 DWORD Version;
 DWORD Flags;
 DWORD Count;
 PRINTER_NOTIFY_INFO_DATA aData[1];
} PRINTER_NOTIFY_INFO,*PPRINTER_NOTIFY_INFO,*LPPRINTER_NOTIFY_INFO;
typedef struct _FORM_INFO_1A {
 DWORD Flags;
 LPSTR pName;
 SIZEL Size;
 RECTL ImageableArea;
} FORM_INFO_1A,*PFORM_INFO_1A,*LPFORM_INFO_1A;
typedef struct _FORM_INFO_1W {
 DWORD Flags;
 LPWSTR pName;
 SIZEL Size;
 RECTL ImageableArea;
} FORM_INFO_1W,*PFORM_INFO_1W,*LPFORM_INFO_1W;
typedef struct _PRINTER_DEFAULTSA {
 LPSTR pDatatype;
 LPDEVMODE pDevMode;
 ACCESS_MASK DesiredAccess;
} PRINTER_DEFAULTSA,*PPRINTER_DEFAULTSA,*LPPRINTER_DEFAULTSA;
typedef struct _PRINTER_DEFAULTSW {
 LPWSTR pDatatype;
 LPDEVMODE pDevMode;
 ACCESS_MASK DesiredAccess;
} PRINTER_DEFAULTSW,*PPRINTER_DEFAULTSW,*LPPRINTER_DEFAULTSW;

BOOL __attribute__((__stdcall__)) AbortPrinter(HANDLE);
BOOL __attribute__((__stdcall__)) AddFormA(HANDLE,DWORD,PBYTE);
BOOL __attribute__((__stdcall__)) AddFormW(HANDLE,DWORD,PBYTE);
BOOL __attribute__((__stdcall__)) AddJobA(HANDLE,DWORD,PBYTE,DWORD,PDWORD);
BOOL __attribute__((__stdcall__)) AddJobW(HANDLE,DWORD,PBYTE,DWORD,PDWORD);
BOOL __attribute__((__stdcall__)) AddMonitorA(LPSTR,DWORD,PBYTE);
BOOL __attribute__((__stdcall__)) AddMonitorW(LPWSTR,DWORD,PBYTE);
BOOL __attribute__((__stdcall__)) AddPortA(LPSTR,HWND,LPSTR);
BOOL __attribute__((__stdcall__)) AddPortW(LPWSTR,HWND,LPWSTR);
HANDLE __attribute__((__stdcall__)) AddPrinterA(LPSTR,DWORD,PBYTE);
HANDLE __attribute__((__stdcall__)) AddPrinterW(LPWSTR,DWORD,PBYTE);
BOOL __attribute__((__stdcall__)) AddPrinterConnectionA(LPSTR);
BOOL __attribute__((__stdcall__)) AddPrinterConnectionW(LPWSTR);
BOOL __attribute__((__stdcall__)) AddPrinterDriverA(LPSTR,DWORD,PBYTE);
BOOL __attribute__((__stdcall__)) AddPrinterDriverW(LPWSTR,DWORD,PBYTE);
BOOL __attribute__((__stdcall__)) AddPrintProcessorA(LPSTR,LPSTR,LPSTR,LPSTR);
BOOL __attribute__((__stdcall__)) AddPrintProcessorW(LPWSTR,LPWSTR,LPWSTR,LPWSTR);
BOOL __attribute__((__stdcall__)) AddPrintProvidorA(LPSTR,DWORD,PBYTE);
BOOL __attribute__((__stdcall__)) AddPrintProvidorW(LPWSTR,DWORD,PBYTE);
LONG __attribute__((__stdcall__)) AdvancedDocumentPropertiesA(HWND,HANDLE,LPSTR,PDEVMODE,PDEVMODEA);
LONG __attribute__((__stdcall__)) AdvancedDocumentPropertiesW(HWND,HANDLE,LPWSTR,PDEVMODE,PDEVMODEW);
BOOL __attribute__((__stdcall__)) ClosePrinter(HANDLE);
BOOL __attribute__((__stdcall__)) ConfigurePortA(LPSTR,HWND,LPSTR);
BOOL __attribute__((__stdcall__)) ConfigurePortW(LPWSTR,HWND,LPWSTR);
HANDLE __attribute__((__stdcall__)) ConnectToPrinterDlg(HWND,DWORD);
BOOL __attribute__((__stdcall__)) DeleteFormA(HANDLE,LPSTR);
BOOL __attribute__((__stdcall__)) DeleteFormW(HANDLE,LPWSTR);
BOOL __attribute__((__stdcall__)) DeleteMonitorA(LPSTR,LPSTR,LPSTR);
BOOL __attribute__((__stdcall__)) DeleteMonitorW(LPWSTR,LPWSTR,LPWSTR);
BOOL __attribute__((__stdcall__)) DeletePortA(LPSTR,HWND,LPSTR);
BOOL __attribute__((__stdcall__)) DeletePortW(LPWSTR,HWND,LPWSTR);
BOOL __attribute__((__stdcall__)) DeletePrinter(HANDLE);
BOOL __attribute__((__stdcall__)) DeletePrinterConnectionA(LPSTR);
BOOL __attribute__((__stdcall__)) DeletePrinterConnectionW(LPWSTR);
DWORD __attribute__((__stdcall__)) DeletePrinterDataA(HANDLE,LPSTR);
DWORD __attribute__((__stdcall__)) DeletePrinterDataW(HANDLE,LPWSTR);
BOOL __attribute__((__stdcall__)) DeletePrinterDriverA(LPSTR,LPSTR,LPSTR);
BOOL __attribute__((__stdcall__)) DeletePrinterDriverW(LPWSTR,LPWSTR,LPWSTR);
BOOL __attribute__((__stdcall__)) DeletePrintProcessorA(LPSTR,LPSTR,LPSTR);
BOOL __attribute__((__stdcall__)) DeletePrintProcessorW(LPWSTR,LPWSTR,LPWSTR);
BOOL __attribute__((__stdcall__)) DeletePrintProvidorA(LPSTR,LPSTR,LPSTR);
BOOL __attribute__((__stdcall__)) DeletePrintProvidorW(LPWSTR,LPWSTR,LPWSTR);
LONG __attribute__((__stdcall__)) DocumentPropertiesA(HWND,HANDLE,LPSTR,PDEVMODEA,PDEVMODEA,DWORD);
LONG __attribute__((__stdcall__)) DocumentPropertiesW(HWND,HANDLE,LPWSTR,PDEVMODEW,PDEVMODEW,DWORD);
BOOL __attribute__((__stdcall__)) EndDocPrinter(HANDLE);
BOOL __attribute__((__stdcall__)) EndPagePrinter(HANDLE);
BOOL __attribute__((__stdcall__)) EnumFormsA(HANDLE,DWORD,PBYTE,DWORD,PDWORD,PDWORD);
BOOL __attribute__((__stdcall__)) EnumFormsW(HANDLE,DWORD,PBYTE,DWORD,PDWORD,PDWORD);
BOOL __attribute__((__stdcall__)) EnumJobsA(HANDLE,DWORD,DWORD,DWORD,PBYTE,DWORD,PDWORD,PDWORD);
BOOL __attribute__((__stdcall__)) EnumJobsW(HANDLE,DWORD,DWORD,DWORD,PBYTE,DWORD,PDWORD,PDWORD);
BOOL __attribute__((__stdcall__)) EnumMonitorsA(LPSTR,DWORD,PBYTE,DWORD,PDWORD,PDWORD);
BOOL __attribute__((__stdcall__)) EnumMonitorsW(LPWSTR,DWORD,PBYTE,DWORD,PDWORD,PDWORD);
BOOL __attribute__((__stdcall__)) EnumPortsA(LPSTR,DWORD,PBYTE,DWORD,PDWORD,PDWORD);
BOOL __attribute__((__stdcall__)) EnumPortsW(LPWSTR,DWORD,PBYTE,DWORD,PDWORD,PDWORD);
DWORD __attribute__((__stdcall__)) EnumPrinterDataA(HANDLE,DWORD,LPSTR,DWORD,PDWORD,PDWORD,PBYTE,DWORD,PDWORD);
DWORD __attribute__((__stdcall__)) EnumPrinterDataW(HANDLE,DWORD,LPWSTR,DWORD,PDWORD,PDWORD,PBYTE,DWORD,PDWORD);
BOOL __attribute__((__stdcall__)) EnumPrinterDriversA(LPSTR,LPSTR,DWORD,PBYTE,DWORD,PDWORD,PDWORD);
BOOL __attribute__((__stdcall__)) EnumPrinterDriversW(LPWSTR,LPWSTR,DWORD,PBYTE,DWORD,PDWORD,PDWORD);
BOOL __attribute__((__stdcall__)) EnumPrintersA(DWORD,LPSTR,DWORD,PBYTE,DWORD,PDWORD,PDWORD);
BOOL __attribute__((__stdcall__)) EnumPrintersW(DWORD,LPWSTR,DWORD,PBYTE,DWORD,PDWORD,PDWORD);
BOOL __attribute__((__stdcall__)) EnumPrintProcessorDatatypesA(LPSTR,LPSTR,DWORD,PBYTE,DWORD,PDWORD,PDWORD);
BOOL __attribute__((__stdcall__)) EnumPrintProcessorDatatypesW(LPWSTR,LPWSTR,DWORD,PBYTE,DWORD,PDWORD,PDWORD);
BOOL __attribute__((__stdcall__)) EnumPrintProcessorsA(LPSTR,LPSTR,DWORD,PBYTE,DWORD,PDWORD,PDWORD);
BOOL __attribute__((__stdcall__)) EnumPrintProcessorsW(LPWSTR,LPWSTR,DWORD,PBYTE,DWORD,PDWORD,PDWORD);
BOOL __attribute__((__stdcall__)) FindClosePrinterChangeNotification(HANDLE);
HANDLE __attribute__((__stdcall__)) FindFirstPrinterChangeNotification(HANDLE,DWORD,DWORD,PVOID);
HANDLE __attribute__((__stdcall__)) FindNextPrinterChangeNotification(HANDLE,PDWORD,PVOID,PVOID*);
BOOL __attribute__((__stdcall__)) FreePrinterNotifyInfo(PPRINTER_NOTIFY_INFO);




BOOL __attribute__((__stdcall__)) GetFormA(HANDLE,LPSTR,DWORD,PBYTE,DWORD,PDWORD);
BOOL __attribute__((__stdcall__)) GetFormW(HANDLE,LPWSTR,DWORD,PBYTE,DWORD,PDWORD);
BOOL __attribute__((__stdcall__)) GetJobA(HANDLE,DWORD,DWORD,PBYTE,DWORD,PDWORD);
BOOL __attribute__((__stdcall__)) GetJobW(HANDLE,DWORD,DWORD,PBYTE,DWORD,PDWORD);
BOOL __attribute__((__stdcall__)) GetPrinterA(HANDLE,DWORD,PBYTE,DWORD,PDWORD);
BOOL __attribute__((__stdcall__)) GetPrinterW(HANDLE,DWORD,PBYTE,DWORD,PDWORD);
DWORD __attribute__((__stdcall__)) GetPrinterDataA(HANDLE,LPSTR,PDWORD,PBYTE,DWORD,PDWORD);
DWORD __attribute__((__stdcall__)) GetPrinterDataW(HANDLE,LPWSTR,PDWORD,PBYTE,DWORD,PDWORD);
DWORD __attribute__((__stdcall__)) GetPrinterDriverA(HANDLE,LPSTR,DWORD,PBYTE,DWORD,PDWORD);
DWORD __attribute__((__stdcall__)) GetPrinterDriverW(HANDLE,LPWSTR,DWORD,PBYTE,DWORD,PDWORD);
DWORD __attribute__((__stdcall__)) GetPrinterDriverDirectoryA(LPSTR,LPSTR,DWORD,PBYTE,DWORD,PDWORD);
DWORD __attribute__((__stdcall__)) GetPrinterDriverDirectoryW(LPWSTR,LPWSTR,DWORD,PBYTE,DWORD,PDWORD);
DWORD __attribute__((__stdcall__)) GetPrintProcessorDirectoryA(LPSTR,LPSTR,DWORD,PBYTE,DWORD,PDWORD);
DWORD __attribute__((__stdcall__)) GetPrintProcessorDirectoryW(LPWSTR,LPWSTR,DWORD,PBYTE,DWORD,PDWORD);
BOOL __attribute__((__stdcall__)) OpenPrinterA(LPSTR,PHANDLE,LPPRINTER_DEFAULTSA);
BOOL __attribute__((__stdcall__)) OpenPrinterW(LPWSTR,PHANDLE,LPPRINTER_DEFAULTSW);
DWORD __attribute__((__stdcall__)) PrinterMessageBoxA(HANDLE,DWORD,HWND,LPSTR,LPSTR,DWORD);
DWORD __attribute__((__stdcall__)) PrinterMessageBoxW(HANDLE,DWORD,HWND,LPWSTR,LPWSTR,DWORD);
BOOL __attribute__((__stdcall__)) PrinterProperties(HWND,HANDLE);
BOOL __attribute__((__stdcall__)) ReadPrinter(HANDLE,PVOID,DWORD,PDWORD);
BOOL __attribute__((__stdcall__)) ResetPrinterA(HANDLE,LPPRINTER_DEFAULTSA);
BOOL __attribute__((__stdcall__)) ResetPrinterW(HANDLE,LPPRINTER_DEFAULTSW);
BOOL __attribute__((__stdcall__)) ScheduleJob(HANDLE,DWORD);
BOOL __attribute__((__stdcall__)) SetFormA(HANDLE,LPSTR,DWORD,PBYTE);
BOOL __attribute__((__stdcall__)) SetFormW(HANDLE,LPWSTR,DWORD,PBYTE);
BOOL __attribute__((__stdcall__)) SetJobA(HANDLE,DWORD,DWORD,PBYTE,DWORD);
BOOL __attribute__((__stdcall__)) SetJobW(HANDLE,DWORD,DWORD,PBYTE,DWORD);
BOOL __attribute__((__stdcall__)) SetPrinterA(HANDLE,DWORD,PBYTE,DWORD);
BOOL __attribute__((__stdcall__)) SetPrinterW(HANDLE,DWORD,PBYTE,DWORD);
BOOL __attribute__((__stdcall__)) SetPrinterDataA(HANDLE,LPSTR,DWORD,PBYTE,DWORD);
BOOL __attribute__((__stdcall__)) SetPrinterDataW(HANDLE,LPWSTR,DWORD,PBYTE,DWORD);
DWORD __attribute__((__stdcall__)) StartDocPrinterA(HANDLE,DWORD,PBYTE);
DWORD __attribute__((__stdcall__)) StartDocPrinterW(HANDLE,DWORD,PBYTE);
BOOL __attribute__((__stdcall__)) StartPagePrinter(HANDLE);
DWORD __attribute__((__stdcall__)) WaitForPrinterChange(HANDLE,DWORD);
BOOL __attribute__((__stdcall__)) WritePrinter(HANDLE,PVOID,DWORD,PDWORD);
# 722 "H:/CPP/wxdevcpp6.10/include/winspool.h" 3
typedef JOB_INFO_1A JOB_INFO_1,*PJOB_INFO_1,*LPJOB_INFO_1;
typedef JOB_INFO_2A JOB_INFO_2,*PJOB_INFO_2,*LPJOB_INFO_2;
typedef ADDJOB_INFO_1A ADDJOB_INFO_1,*PADDJOB_INFO_1,*LPADDJOB_INFO_1;
typedef DATATYPES_INFO_1A DATATYPES_INFO_1,*PDATATYPES_INFO_1,*LPDATATYPES_INFO_1;
typedef MONITOR_INFO_1A MONITOR_INFO_1,*PMONITOR_INFO_1,*LPMONITOR_INFO_1;
typedef MONITOR_INFO_2A MONITOR_INFO_2,*PMONITOR_INFO_2,*LPMONITOR_INFO_2;
typedef DOC_INFO_1A DOC_INFO_1,*PDOC_INFO_1,*LPDOC_INFO_1;
typedef DOC_INFO_2A DOC_INFO_2,*PDOC_INFO_2,*LPDOC_INFO_2;
typedef PORT_INFO_1A PORT_INFO_1,*PPORT_INFO_1,*LPPORT_INFO_1;
typedef PORT_INFO_2A PORT_INFO_2,*PPORT_INFO_2,*LPPORT_INFO_2;
typedef PORT_INFO_3A PORT_INFO_3,*PPORT_INFO_3,*LPPORT_INFO_3;
typedef DRIVER_INFO_2A DRIVER_INFO_2,*PDRIVER_INFO_2,*LPDRIVER_INFO_2;
typedef PRINTER_INFO_1A PRINTER_INFO_1,*PPRINTER_INFO_1,*LPPRINTER_INFO_1;
typedef PRINTER_INFO_2A PRINTER_INFO_2,*PPRINTER_INFO_2,*LPPRINTER_INFO_2;
typedef PRINTER_INFO_4A PRINTER_INFO_4,*PPRINTER_INFO_4,*LPPRINTER_INFO_4;
typedef PRINTER_INFO_5A PRINTER_INFO_5,*PPRINTER_INFO_5,*LPPRINTER_INFO_5;
typedef PRINTPROCESSOR_INFO_1A PRINTPROCESSOR_INFO_1,*PPRINTPROCESSOR_INFO_1,*LPPRINTPROCESSOR_INFO_1;
typedef FORM_INFO_1A FORM_INFO_1,*PFORM_INFO_1,*LPFORM_INFO_1;
typedef PRINTER_DEFAULTSA PRINTER_DEFAULTS,*PPRINTER_DEFAULTS,*LPPRINTER_DEFAULTS;
# 789 "H:/CPP/wxdevcpp6.10/include/winspool.h" 3
}
# 88 "H:/CPP/wxdevcpp6.10/include/windows.h" 2 3
# 98 "H:/CPP/wxdevcpp6.10/include/windows.h" 3
# 1 "H:/CPP/wxdevcpp6.10/include/winsock2.h" 1 3
# 17 "H:/CPP/wxdevcpp6.10/include/winsock2.h" 3
       
# 18 "H:/CPP/wxdevcpp6.10/include/winsock2.h" 3







extern "C" {




typedef unsigned char u_char;
typedef unsigned short u_short;
typedef unsigned int u_int;
typedef unsigned long u_long;


typedef u_int SOCKET;
# 53 "H:/CPP/wxdevcpp6.10/include/winsock2.h" 3
typedef struct fd_set {
 u_int fd_count;
 SOCKET fd_array[64];
} fd_set;
int __attribute__((__stdcall__)) __WSAFDIsSet(SOCKET,fd_set*);
# 101 "H:/CPP/wxdevcpp6.10/include/winsock2.h" 3
struct timeval {
 long tv_sec;
 long tv_usec;
};







struct hostent {
 char *h_name;
 char **h_aliases;
 short h_addrtype;
 short h_length;
 char **h_addr_list;

};
struct linger {
 u_short l_onoff;
 u_short l_linger;
};
# 147 "H:/CPP/wxdevcpp6.10/include/winsock2.h" 3
struct netent {
 char * n_name;
 char **n_aliases;
 short n_addrtype;
 u_long n_net;
};
struct servent {
 char *s_name;
 char **s_aliases;
 short s_port;
 char *s_proto;
};
struct protoent {
 char *p_name;
 char **p_aliases;
 short p_proto;
};
# 215 "H:/CPP/wxdevcpp6.10/include/winsock2.h" 3
struct in_addr {
 union {
  struct { u_char s_b1,s_b2,s_b3,s_b4; } S_un_b;
  struct { u_short s_w1,s_w2; } S_un_w;
  u_long S_addr;
 } S_un;






};
# 246 "H:/CPP/wxdevcpp6.10/include/winsock2.h" 3
struct sockaddr_in {
 short sin_family;
 u_short sin_port;
 struct in_addr sin_addr;
 char sin_zero[8];
};


typedef struct WSAData {
 WORD wVersion;
 WORD wHighVersion;
 char szDescription[256 +1];
 char szSystemStatus[128 +1];
 unsigned short iMaxSockets;
 unsigned short iMaxUdpDg;
 char * lpVendorInfo;
} WSADATA;
typedef WSADATA *LPWSADATA;
# 328 "H:/CPP/wxdevcpp6.10/include/winsock2.h" 3
struct sockaddr {
 u_short sa_family;
 char sa_data[14];
};
# 348 "H:/CPP/wxdevcpp6.10/include/winsock2.h" 3
struct sockaddr_storage {
    short ss_family;
    char __ss_pad1[((sizeof (long long)) - sizeof (short))];
    long long __ss_align;
    char __ss_pad2[(128 - (sizeof (short) + ((sizeof (long long)) - sizeof (short)) + (sizeof (long long))))];
};


struct sockproto {
 u_short sp_family;
 u_short sp_protocol;
};
# 528 "H:/CPP/wxdevcpp6.10/include/winsock2.h" 3
SOCKET __attribute__((__stdcall__)) accept(SOCKET,struct sockaddr*,int*);
int __attribute__((__stdcall__)) bind(SOCKET,const struct sockaddr*,int);
int __attribute__((__stdcall__)) closesocket(SOCKET);
int __attribute__((__stdcall__)) connect(SOCKET,const struct sockaddr*,int);
int __attribute__((__stdcall__)) ioctlsocket(SOCKET,long,u_long *);
int __attribute__((__stdcall__)) getpeername(SOCKET,struct sockaddr*,int*);
int __attribute__((__stdcall__)) getsockname(SOCKET,struct sockaddr*,int*);
int __attribute__((__stdcall__)) getsockopt(SOCKET,int,int,char*,int*);
unsigned long __attribute__((__stdcall__)) inet_addr(const char*);
__attribute__((__stdcall__)) char * inet_ntoa(struct in_addr);
int __attribute__((__stdcall__)) listen(SOCKET,int);
int __attribute__((__stdcall__)) recv(SOCKET,char*,int,int);
int __attribute__((__stdcall__)) recvfrom(SOCKET,char*,int,int,struct sockaddr*,int*);
int __attribute__((__stdcall__)) send(SOCKET,const char*,int,int);
int __attribute__((__stdcall__)) sendto(SOCKET,const char*,int,int,const struct sockaddr*,int);
int __attribute__((__stdcall__)) setsockopt(SOCKET,int,int,const char*,int);
int __attribute__((__stdcall__)) shutdown(SOCKET,int);
SOCKET __attribute__((__stdcall__)) socket(int,int,int);
__attribute__((__stdcall__)) struct hostent * gethostbyaddr(const char*,int,int);
__attribute__((__stdcall__)) struct hostent * gethostbyname(const char*);
__attribute__((__stdcall__)) struct servent * getservbyport(int,const char*);
__attribute__((__stdcall__)) struct servent * getservbyname(const char*,const char*);
__attribute__((__stdcall__)) struct protoent * getprotobynumber(int);
__attribute__((__stdcall__)) struct protoent * getprotobyname(const char*);
typedef SOCKET (__attribute__((__stdcall__)) * LPFN_ACCEPT)(SOCKET, struct sockaddr*,int *);
typedef int (__attribute__((__stdcall__)) * LPFN_BIND)(SOCKET, const struct sockaddr*,int);
typedef int (__attribute__((__stdcall__)) * LPFN_CLOSESOCKET)(SOCKET);
typedef int (__attribute__((__stdcall__)) * LPFN_CONNECT)(SOCKET, const struct sockaddr*,int);
typedef int (__attribute__((__stdcall__)) * LPFN_IOCTLSOCKET)(SOCKET, long, u_long*);
typedef int (__attribute__((__stdcall__)) * LPFN_GETPEERNAME)(SOCKET, struct sockaddr*, int*);
typedef int(__attribute__((__stdcall__)) * LPFN_GETSOCKNAME)(SOCKET, struct sockaddr*, int*);
typedef int(__attribute__((__stdcall__)) * LPFN_GETSOCKOPT)(SOCKET, int, int, char*, int*);
typedef u_long(__attribute__((__stdcall__)) * LPFN_HTONL)(u_long);
typedef u_short(__attribute__((__stdcall__)) * LPFN_HTONS)(u_short);
typedef unsigned long(__attribute__((__stdcall__)) * LPFN_INET_ADDR)(const char*);
typedef char*(__attribute__((__stdcall__)) * LPFN_INET_NTOA)(struct in_addr);
typedef int(__attribute__((__stdcall__)) * LPFN_LISTEN)(SOCKET, int);
typedef u_long(__attribute__((__stdcall__)) * LPFN_NTOHL)(u_long);
typedef u_short(__attribute__((__stdcall__)) * LPFN_NTOHS)(u_short);
typedef int(__attribute__((__stdcall__)) * LPFN_RECV)(SOCKET, char*, int, int);
typedef int(__attribute__((__stdcall__)) * LPFN_RECVFROM)(SOCKET, char*, int, int, struct sockaddr*, int*);
typedef int(__attribute__((__stdcall__)) * LPFN_SELECT)(int, fd_set*, fd_set*, fd_set*, const struct timeval*);
typedef int(__attribute__((__stdcall__)) * LPFN_SEND)(SOCKET, const char*, int, int);
typedef int(__attribute__((__stdcall__)) * LPFN_SENDTO)(SOCKET, const char*, int, int, const struct sockaddr*, int);
typedef int(__attribute__((__stdcall__)) * LPFN_SETSOCKOPT)(SOCKET, int, int, const char*, int);
typedef int(__attribute__((__stdcall__)) * LPFN_SHUTDOWN)(SOCKET, int);
typedef SOCKET(__attribute__((__stdcall__)) * LPFN_SOCKET)(int, int, int);
typedef struct hostent*(__attribute__((__stdcall__)) * LPFN_GETHOSTBYADDR)( const char*, int, int);
typedef struct hostent*(__attribute__((__stdcall__)) * LPFN_GETHOSTBYNAME)( const char*);
typedef int(__attribute__((__stdcall__)) * LPFN_GETHOSTNAME)(char*, int);
typedef struct servent*(__attribute__((__stdcall__)) * LPFN_GETSERVBYPORT)(int, const char*);
typedef struct servent*(__attribute__((__stdcall__)) * LPFN_GETSERVBYNAME)(const char*, const char*);
typedef struct protoent*(__attribute__((__stdcall__)) * LPFN_GETPROTOBYNUMBER)(int);
typedef struct protoent*(__attribute__((__stdcall__)) * LPFN_GETPROTOBYNAME)(const char*);

int __attribute__((__stdcall__)) WSAStartup(WORD,LPWSADATA);
int __attribute__((__stdcall__)) WSACleanup(void);
void __attribute__((__stdcall__)) WSASetLastError(int);
int __attribute__((__stdcall__)) WSAGetLastError(void);
typedef int(__attribute__((__stdcall__)) * LPFN_WSASTARTUP)(WORD, LPWSADATA);
typedef int(__attribute__((__stdcall__)) * LPFN_WSACLEANUP)(void);
typedef void(__attribute__((__stdcall__)) * LPFN_WSASETLASTERROR)(int);
typedef int(__attribute__((__stdcall__)) * LPFN_WSAGETLASTERROR)(void);




BOOL __attribute__((__stdcall__)) WSAIsBlocking(void);
int __attribute__((__stdcall__)) WSAUnhookBlockingHook(void);
FARPROC __attribute__((__stdcall__)) WSASetBlockingHook(FARPROC);
int __attribute__((__stdcall__)) WSACancelBlockingCall(void);
typedef BOOL(__attribute__((__stdcall__)) * LPFN_WSAISBLOCKING)(void);
typedef int(__attribute__((__stdcall__)) * LPFN_WSAUNHOOKBLOCKINGHOOK)(void);
typedef FARPROC (__attribute__((__stdcall__)) * LPFN_WSASETBLOCKINGHOOK)(FARPROC);
typedef int(__attribute__((__stdcall__)) * LPFN_WSACANCELBLOCKINGCALL)(void);

HANDLE __attribute__((__stdcall__)) WSAAsyncGetServByName(HWND,u_int,const char*,const char*,char*,int);
HANDLE __attribute__((__stdcall__)) WSAAsyncGetServByPort(HWND,u_int,int,const char*,char*,int);
HANDLE __attribute__((__stdcall__)) WSAAsyncGetProtoByName(HWND,u_int,const char*,char*,int);
HANDLE __attribute__((__stdcall__)) WSAAsyncGetProtoByNumber(HWND,u_int,int,char*,int);
HANDLE __attribute__((__stdcall__)) WSAAsyncGetHostByName(HWND,u_int,const char*,char*,int);
HANDLE __attribute__((__stdcall__)) WSAAsyncGetHostByAddr(HWND,u_int,const char*,int,int,char*,int);
int __attribute__((__stdcall__)) WSACancelAsyncRequest(HANDLE);
int __attribute__((__stdcall__)) WSAAsyncSelect(SOCKET,HWND,u_int,long);
typedef HANDLE(__attribute__((__stdcall__)) * LPFN_WSAASYNCGETSERVBYNAME)(HWND, u_int, const char *, const char *, char *, int);
typedef HANDLE(__attribute__((__stdcall__)) * LPFN_WSAASYNCGETSERVBYPORT)(HWND, u_int, int, const char *, char *, int);
typedef HANDLE(__attribute__((__stdcall__)) * LPFN_WSAASYNCGETPROTOBYNAME)(HWND, u_int, const char*, char*, int);
typedef HANDLE(__attribute__((__stdcall__)) * LPFN_WSAASYNCGETPROTOBYNUMBER)(HWND, u_int, int, char*, int);
typedef HANDLE(__attribute__((__stdcall__)) * LPFN_WSAASYNCGETHOSTBYADDR)(HWND, u_int, const char*, int, int, char*, int);
typedef int(__attribute__((__stdcall__)) * LPFN_WSACANCELASYNCREQUEST)(HANDLE);
typedef int(__attribute__((__stdcall__)) * LPFN_WSAASYNCSELECT)(SOCKET, HWND, u_int, long);

u_long __attribute__((__stdcall__)) htonl(u_long);
u_long __attribute__((__stdcall__)) ntohl(u_long);
u_short __attribute__((__stdcall__)) htons(u_short);
u_short __attribute__((__stdcall__)) ntohs(u_short);
int __attribute__((__stdcall__)) select(int nfds,fd_set*,fd_set*,fd_set*,const struct timeval*);


int __attribute__((__stdcall__)) gethostname(char*,int);
# 636 "H:/CPP/wxdevcpp6.10/include/winsock2.h" 3
typedef struct sockaddr SOCKADDR;
typedef struct sockaddr *PSOCKADDR;
typedef struct sockaddr *LPSOCKADDR;
typedef struct sockaddr_storage SOCKADDR_STORAGE, *PSOCKADDR_STORAGE;
typedef struct sockaddr_in SOCKADDR_IN;
typedef struct sockaddr_in *PSOCKADDR_IN;
typedef struct sockaddr_in *LPSOCKADDR_IN;
typedef struct linger LINGER;
typedef struct linger *PLINGER;
typedef struct linger *LPLINGER;
typedef struct in_addr IN_ADDR;
typedef struct in_addr *PIN_ADDR;
typedef struct in_addr *LPIN_ADDR;
typedef struct fd_set FD_SET;
typedef struct fd_set *PFD_SET;
typedef struct fd_set *LPFD_SET;
typedef struct hostent HOSTENT;
typedef struct hostent *PHOSTENT;
typedef struct hostent *LPHOSTENT;
typedef struct servent SERVENT;
typedef struct servent *PSERVENT;
typedef struct servent *LPSERVENT;
typedef struct protoent PROTOENT;
typedef struct protoent *PPROTOENT;
typedef struct protoent *LPPROTOENT;
typedef struct timeval TIMEVAL;
typedef struct timeval *PTIMEVAL;
typedef struct timeval *LPTIMEVAL;
# 696 "H:/CPP/wxdevcpp6.10/include/winsock2.h" 3
typedef struct _OVERLAPPED *LPWSAOVERLAPPED;
# 713 "H:/CPP/wxdevcpp6.10/include/winsock2.h" 3
typedef struct _WSABUF {
 unsigned long len;
 char *buf;
} WSABUF, *LPWSABUF;

typedef enum
{
 BestEffortService,
 ControlledLoadService,
 PredictiveService,
 GuaranteedDelayService,
 GuaranteedService
} GUARANTEE;
# 737 "H:/CPP/wxdevcpp6.10/include/winsock2.h" 3
typedef unsigned int SERVICETYPE;
typedef struct _flowspec
{
 unsigned int TokenRate;
 unsigned int TokenBucketSize;
 unsigned int PeakBandwidth;
 unsigned int Latency;
 unsigned int DelayVariation;
 SERVICETYPE ServiceType;
 unsigned int MaxSduSize;
 unsigned int MinimumPolicedSize;
   } FLOWSPEC, *PFLOWSPEC, *LPFLOWSPEC;

typedef struct _QualityOfService
{
 FLOWSPEC SendingFlowspec;
 FLOWSPEC ReceivingFlowspec;
 WSABUF ProviderSpecific;
} QOS, *LPQOS;







typedef unsigned int GROUP;



typedef struct _WSANETWORKEVENTS {
 long lNetworkEvents;
 int iErrorCode[10];
} WSANETWORKEVENTS, *LPWSANETWORKEVENTS;






typedef enum _WSAESETSERVICEOP
{
 RNRSERVICE_REGISTER=0,
 RNRSERVICE_DEREGISTER,
 RNRSERVICE_DELETE
} WSAESETSERVICEOP, *PWSAESETSERVICEOP, *LPWSAESETSERVICEOP;

typedef struct _AFPROTOCOLS {
 INT iAddressFamily;
 INT iProtocol;
} AFPROTOCOLS, *PAFPROTOCOLS, *LPAFPROTOCOLS;

typedef enum _WSAEcomparator
{
 COMP_EQUAL = 0,
 COMP_NOTLESS
} WSAECOMPARATOR, *PWSAECOMPARATOR, *LPWSAECOMPARATOR;

typedef struct _WSAVersion
{
 DWORD dwVersion;
 WSAECOMPARATOR ecHow;
} WSAVERSION, *PWSAVERSION, *LPWSAVERSION;



typedef struct _SOCKET_ADDRESS {
 LPSOCKADDR lpSockaddr;
 INT iSockaddrLength;
} SOCKET_ADDRESS,*PSOCKET_ADDRESS,*LPSOCKET_ADDRESS;
typedef struct _CSADDR_INFO {
 SOCKET_ADDRESS LocalAddr;
 SOCKET_ADDRESS RemoteAddr;
 INT iSocketType;
 INT iProtocol;
} CSADDR_INFO,*PCSADDR_INFO,*LPCSADDR_INFO;


typedef struct _SOCKET_ADDRESS_LIST {
    INT iAddressCount;
    SOCKET_ADDRESS Address[1];
} SOCKET_ADDRESS_LIST, * LPSOCKET_ADDRESS_LIST;



typedef struct _BLOB {
 ULONG cbSize;
 BYTE *pBlobData;
} BLOB,*PBLOB,*LPBLOB;


typedef struct _WSAQuerySetA
{
 DWORD dwSize;
 LPSTR lpszServiceInstanceName;
 LPGUID lpServiceClassId;
 LPWSAVERSION lpVersion;
 LPSTR lpszComment;
 DWORD dwNameSpace;
 LPGUID lpNSProviderId;
 LPSTR lpszContext;
 DWORD dwNumberOfProtocols;
 LPAFPROTOCOLS lpafpProtocols;
 LPSTR lpszQueryString;
 DWORD dwNumberOfCsAddrs;
 LPCSADDR_INFO lpcsaBuffer;
 DWORD dwOutputFlags;
 LPBLOB lpBlob;
} WSAQUERYSETA, *PWSAQUERYSETA, *LPWSAQUERYSETA;

typedef struct _WSAQuerySetW
{
 DWORD dwSize;
 LPWSTR lpszServiceInstanceName;
 LPGUID lpServiceClassId;
 LPWSAVERSION lpVersion;
 LPWSTR lpszComment;
 DWORD dwNameSpace;
 LPGUID lpNSProviderId;
 LPWSTR lpszContext;
 DWORD dwNumberOfProtocols;
 LPAFPROTOCOLS lpafpProtocols;
 LPWSTR lpszQueryString;
 DWORD dwNumberOfCsAddrs;
 LPCSADDR_INFO lpcsaBuffer;
 DWORD dwOutputFlags;
 LPBLOB lpBlob;
} WSAQUERYSETW, *PWSAQUERYSETW, *LPWSAQUERYSETW;






typedef WSAQUERYSETA WSAQUERYSET;
typedef PWSAQUERYSETA PWSAQUERYSET;
typedef LPWSAQUERYSETA LPWSAQUERYSET;
# 893 "H:/CPP/wxdevcpp6.10/include/winsock2.h" 3
typedef struct _WSANSClassInfoA
{
 LPSTR lpszName;
 DWORD dwNameSpace;
 DWORD dwValueType;
 DWORD dwValueSize;
 LPVOID lpValue;
} WSANSCLASSINFOA, *PWSANSCLASSINFOA, *LPWSANSCLASSINFOA;

typedef struct _WSANSClassInfoW
{
 LPWSTR lpszName;
 DWORD dwNameSpace;
 DWORD dwValueType;
 DWORD dwValueSize;
 LPVOID lpValue;
} WSANSCLASSINFOW, *PWSANSCLASSINFOW, *LPWSANSCLASSINFOW;






typedef WSANSCLASSINFOA WSANSCLASSINFO;
typedef PWSANSCLASSINFOA PWSANSCLASSINFO;
typedef LPWSANSCLASSINFOA LPWSANSCLASSINFO;


typedef struct _WSAServiceClassInfoA
{
 LPGUID lpServiceClassId;
 LPSTR lpszServiceClassName;
 DWORD dwCount;
 LPWSANSCLASSINFOA lpClassInfos;
} WSASERVICECLASSINFOA, *PWSASERVICECLASSINFOA, *LPWSASERVICECLASSINFOA;

typedef struct _WSAServiceClassInfoW
{
 LPGUID lpServiceClassId;
 LPWSTR lpszServiceClassName;
 DWORD dwCount;
 LPWSANSCLASSINFOW lpClassInfos;
} WSASERVICECLASSINFOW, *PWSASERVICECLASSINFOW, *LPWSASERVICECLASSINFOW;






typedef WSASERVICECLASSINFOA WSASERVICECLASSINFO;
typedef PWSASERVICECLASSINFOA PWSASERVICECLASSINFO;
typedef LPWSASERVICECLASSINFOA LPWSASERVICECLASSINFO;


typedef struct _WSANAMESPACE_INFOA {
 GUID NSProviderId;
 DWORD dwNameSpace;
 BOOL fActive;
 DWORD dwVersion;
 LPSTR lpszIdentifier;
} WSANAMESPACE_INFOA, *PWSANAMESPACE_INFOA, *LPWSANAMESPACE_INFOA;

typedef struct _WSANAMESPACE_INFOW {
 GUID NSProviderId;
 DWORD dwNameSpace;
 BOOL fActive;
 DWORD dwVersion;
 LPWSTR lpszIdentifier;
} WSANAMESPACE_INFOW, *PWSANAMESPACE_INFOW, *LPWSANAMESPACE_INFOW;






typedef WSANAMESPACE_INFOA WSANAMESPACE_INFO;
typedef PWSANAMESPACE_INFOA PWSANAMESPACE_INFO;
typedef LPWSANAMESPACE_INFOA LPWSANAMESPACE_INFO;


typedef struct _WSAPROTOCOLCHAIN {
 int ChainLen;
 DWORD ChainEntries[7];
} WSAPROTOCOLCHAIN, *LPWSAPROTOCOLCHAIN;



typedef struct _WSAPROTOCOL_INFOA {
 DWORD dwServiceFlags1;
 DWORD dwServiceFlags2;
 DWORD dwServiceFlags3;
 DWORD dwServiceFlags4;
 DWORD dwProviderFlags;
 GUID ProviderId;
 DWORD dwCatalogEntryId;
 WSAPROTOCOLCHAIN ProtocolChain;
 int iVersion;
 int iAddressFamily;
 int iMaxSockAddr;
 int iMinSockAddr;
 int iSocketType;
 int iProtocol;
 int iProtocolMaxOffset;
 int iNetworkByteOrder;
 int iSecurityScheme;
 DWORD dwMessageSize;
 DWORD dwProviderReserved;
 CHAR szProtocol[255 +1];
} WSAPROTOCOL_INFOA, *LPWSAPROTOCOL_INFOA;

typedef struct _WSAPROTOCOL_INFOW {
 DWORD dwServiceFlags1;
 DWORD dwServiceFlags2;
 DWORD dwServiceFlags3;
 DWORD dwServiceFlags4;
 DWORD dwProviderFlags;
 GUID ProviderId;
 DWORD dwCatalogEntryId;
 WSAPROTOCOLCHAIN ProtocolChain;
 int iVersion;
 int iAddressFamily;
 int iMaxSockAddr;
 int iMinSockAddr;
 int iSocketType;
 int iProtocol;
 int iProtocolMaxOffset;
 int iNetworkByteOrder;
 int iSecurityScheme;
 DWORD dwMessageSize;
 DWORD dwProviderReserved;
 WCHAR szProtocol[255 +1];
} WSAPROTOCOL_INFOW, * LPWSAPROTOCOL_INFOW;

typedef int (__attribute__((__stdcall__)) *LPCONDITIONPROC)(LPWSABUF, LPWSABUF, LPQOS, LPQOS, LPWSABUF, LPWSABUF, GROUP *, DWORD);
typedef void (__attribute__((__stdcall__)) *LPWSAOVERLAPPED_COMPLETION_ROUTINE)(DWORD, DWORD, LPWSAOVERLAPPED, DWORD);






typedef WSAPROTOCOL_INFOA WSAPROTOCOL_INFO;
typedef LPWSAPROTOCOL_INFOA LPWSAPROTOCOL_INFO;



typedef enum _WSACOMPLETIONTYPE {
    NSP_NOTIFY_IMMEDIATELY = 0,
    NSP_NOTIFY_HWND,
    NSP_NOTIFY_EVENT,
    NSP_NOTIFY_PORT,
    NSP_NOTIFY_APC
} WSACOMPLETIONTYPE, * PWSACOMPLETIONTYPE, * LPWSACOMPLETIONTYPE;
typedef struct _WSACOMPLETION {
    WSACOMPLETIONTYPE Type;
    union {
        struct {
            HWND hWnd;
            UINT uMsg;
            WPARAM context;
        } WindowMessage;
        struct {
            LPWSAOVERLAPPED lpOverlapped;
        } Event;
        struct {
            LPWSAOVERLAPPED lpOverlapped;
            LPWSAOVERLAPPED_COMPLETION_ROUTINE lpfnCompletionProc;
        } Apc;
        struct {
            LPWSAOVERLAPPED lpOverlapped;
            HANDLE hPort;
            ULONG_PTR Key;
        } Port;
    } Parameters;
} WSACOMPLETION, *PWSACOMPLETION, *LPWSACOMPLETION;
# 1138 "H:/CPP/wxdevcpp6.10/include/winsock2.h" 3
SOCKET __attribute__((__stdcall__)) WSAAccept(SOCKET, struct sockaddr *, LPINT, LPCONDITIONPROC, DWORD);
INT __attribute__((__stdcall__)) WSAAddressToStringA(LPSOCKADDR, DWORD, LPWSAPROTOCOL_INFOA, LPSTR, LPDWORD);
INT __attribute__((__stdcall__)) WSAAddressToStringW(LPSOCKADDR, DWORD, LPWSAPROTOCOL_INFOW, LPWSTR, LPDWORD);
BOOL __attribute__((__stdcall__)) WSACloseEvent(HANDLE);
int __attribute__((__stdcall__)) WSAConnect(SOCKET, const struct sockaddr *, int, LPWSABUF, LPWSABUF, LPQOS, LPQOS);
HANDLE __attribute__((__stdcall__)) WSACreateEvent(void);
int __attribute__((__stdcall__)) WSADuplicateSocketA(SOCKET, DWORD, LPWSAPROTOCOL_INFOA);
int __attribute__((__stdcall__)) WSADuplicateSocketW(SOCKET, DWORD, LPWSAPROTOCOL_INFOW);
INT __attribute__((__stdcall__)) WSAEnumNameSpaceProvidersA(LPDWORD, LPWSANAMESPACE_INFOA);
INT __attribute__((__stdcall__)) WSAEnumNameSpaceProvidersW(LPDWORD, LPWSANAMESPACE_INFOW);
int __attribute__((__stdcall__)) WSAEnumNetworkEvents(SOCKET, HANDLE, LPWSANETWORKEVENTS);
int __attribute__((__stdcall__)) WSAEnumProtocolsA(LPINT, LPWSAPROTOCOL_INFOA, LPDWORD);
int __attribute__((__stdcall__)) WSAEnumProtocolsW(LPINT, LPWSAPROTOCOL_INFOW, LPDWORD);
int __attribute__((__stdcall__)) WSAEventSelect(SOCKET, HANDLE, long);
BOOL __attribute__((__stdcall__)) WSAGetOverlappedResult(SOCKET, LPWSAOVERLAPPED, LPDWORD, BOOL, LPDWORD);
BOOL __attribute__((__stdcall__)) WSAGetQOSByName(SOCKET, LPWSABUF, LPQOS);
INT __attribute__((__stdcall__)) WSAGetServiceClassInfoA(LPGUID, LPGUID, LPDWORD, LPWSASERVICECLASSINFOA);
INT __attribute__((__stdcall__)) WSAGetServiceClassInfoW(LPGUID, LPGUID, LPDWORD, LPWSASERVICECLASSINFOW);
INT __attribute__((__stdcall__)) WSAGetServiceClassNameByClassIdA(LPGUID, LPSTR, LPDWORD);
INT __attribute__((__stdcall__)) WSAGetServiceClassNameByClassIdW(LPGUID, LPWSTR, LPDWORD);
int __attribute__((__stdcall__)) WSAHtonl(SOCKET, unsigned long, unsigned long *);
int __attribute__((__stdcall__)) WSAHtons(SOCKET, unsigned short, unsigned short *);
INT __attribute__((__stdcall__)) WSAInstallServiceClassA(LPWSASERVICECLASSINFOA);
INT __attribute__((__stdcall__)) WSAInstallServiceClassW(LPWSASERVICECLASSINFOW);
int __attribute__((__stdcall__)) WSAIoctl(SOCKET, DWORD, LPVOID, DWORD, LPVOID, DWORD, LPDWORD, LPWSAOVERLAPPED, LPWSAOVERLAPPED_COMPLETION_ROUTINE);
SOCKET __attribute__((__stdcall__)) WSAJoinLeaf(SOCKET, const struct sockaddr *, int, LPWSABUF, LPWSABUF, LPQOS, LPQOS, DWORD);
INT __attribute__((__stdcall__)) WSALookupServiceBeginA(LPWSAQUERYSETA, DWORD, LPHANDLE);
INT __attribute__((__stdcall__)) WSALookupServiceBeginW(LPWSAQUERYSETW lpqsRestrictions, DWORD, LPHANDLE);
INT __attribute__((__stdcall__)) WSALookupServiceNextA(HANDLE, DWORD, LPDWORD, LPWSAQUERYSETA);
INT __attribute__((__stdcall__)) WSALookupServiceNextW(HANDLE, DWORD, LPDWORD, LPWSAQUERYSETW);
INT __attribute__((__stdcall__)) WSALookupServiceEnd(HANDLE);
int __attribute__((__stdcall__)) WSANSPIoctl(HANDLE,DWORD,LPVOID,DWORD,LPVOID,DWORD,LPDWORD,LPWSACOMPLETION);
int __attribute__((__stdcall__)) WSANtohl(SOCKET, unsigned long, unsigned long *);
int __attribute__((__stdcall__)) WSANtohs(SOCKET, unsigned short, unsigned short *);
int __attribute__((__stdcall__)) WSARecv(SOCKET, LPWSABUF, DWORD, LPDWORD, LPDWORD, LPWSAOVERLAPPED, LPWSAOVERLAPPED_COMPLETION_ROUTINE);
int __attribute__((__stdcall__)) WSARecvDisconnect(SOCKET, LPWSABUF);
int __attribute__((__stdcall__)) WSARecvFrom(SOCKET, LPWSABUF, DWORD, LPDWORD, LPDWORD, struct sockaddr *, LPINT, LPWSAOVERLAPPED, LPWSAOVERLAPPED_COMPLETION_ROUTINE);
INT __attribute__((__stdcall__)) WSARemoveServiceClass(LPGUID);
BOOL __attribute__((__stdcall__)) WSAResetEvent(HANDLE);
int __attribute__((__stdcall__)) WSASend(SOCKET, LPWSABUF, DWORD, LPDWORD, DWORD, LPWSAOVERLAPPED, LPWSAOVERLAPPED_COMPLETION_ROUTINE);
int __attribute__((__stdcall__)) WSASendDisconnect(SOCKET, LPWSABUF);
int __attribute__((__stdcall__)) WSASendTo(SOCKET, LPWSABUF, DWORD, LPDWORD, DWORD, const struct sockaddr *, int, LPWSAOVERLAPPED, LPWSAOVERLAPPED_COMPLETION_ROUTINE);
BOOL __attribute__((__stdcall__)) WSASetEvent(HANDLE);
INT __attribute__((__stdcall__)) WSASetServiceA(LPWSAQUERYSETA, WSAESETSERVICEOP, DWORD);
INT __attribute__((__stdcall__)) WSASetServiceW(LPWSAQUERYSETW, WSAESETSERVICEOP, DWORD);
SOCKET __attribute__((__stdcall__)) WSASocketA(int, int, int, LPWSAPROTOCOL_INFOA, GROUP, DWORD);
SOCKET __attribute__((__stdcall__)) WSASocketW(int, int, int, LPWSAPROTOCOL_INFOW, GROUP, DWORD);
INT __attribute__((__stdcall__)) WSAStringToAddressA(LPSTR, INT, LPWSAPROTOCOL_INFOA, LPSOCKADDR, LPINT);
INT __attribute__((__stdcall__)) WSAStringToAddressW(LPWSTR, INT, LPWSAPROTOCOL_INFOW, LPSOCKADDR, LPINT);
DWORD __attribute__((__stdcall__)) WSAWaitForMultipleEvents(DWORD, const HANDLE *, BOOL, DWORD, BOOL);
typedef SOCKET (__attribute__((__stdcall__)) *LPFN_WSAACCEPT)(SOCKET, struct sockaddr *, LPINT, LPCONDITIONPROC, DWORD);
typedef INT (__attribute__((__stdcall__)) *LPFN_WSAADDRESSTOSTRINGA)(LPSOCKADDR, DWORD, LPWSAPROTOCOL_INFOA, LPSTR, LPDWORD);
typedef INT (__attribute__((__stdcall__)) *LPFN_WSAADDRESSTOSTRINGW)(LPSOCKADDR, DWORD, LPWSAPROTOCOL_INFOW, LPWSTR, LPDWORD);
typedef BOOL (__attribute__((__stdcall__)) *LPFN_WSACLOSEEVENT)(HANDLE);
typedef int (__attribute__((__stdcall__)) *LPFN_WSACONNECT)(SOCKET, const struct sockaddr *, int, LPWSABUF, LPWSABUF, LPQOS, LPQOS);
typedef HANDLE (__attribute__((__stdcall__)) *LPFN_WSACREATEEVENT)(void);
typedef int (__attribute__((__stdcall__)) *LPFN_WSADUPLICATESOCKETA)(SOCKET, DWORD, LPWSAPROTOCOL_INFOA);
typedef int (__attribute__((__stdcall__)) *LPFN_WSADUPLICATESOCKETW)(SOCKET, DWORD, LPWSAPROTOCOL_INFOW);
typedef INT (__attribute__((__stdcall__)) *LPFN_WSAENUMNAMESPACEPROVIDERSA)(LPDWORD, LPWSANAMESPACE_INFOA);
typedef INT (__attribute__((__stdcall__)) *LPFN_WSAENUMNAMESPACEPROVIDERSW)(LPDWORD, LPWSANAMESPACE_INFOW);
typedef int (__attribute__((__stdcall__)) *LPFN_WSAENUMNETWORKEVENTS)(SOCKET, HANDLE, LPWSANETWORKEVENTS);
typedef int (__attribute__((__stdcall__)) *LPFN_WSAENUMPROTOCOLSA)(LPINT, LPWSAPROTOCOL_INFOA, LPDWORD);
typedef int (__attribute__((__stdcall__)) *LPFN_WSAENUMPROTOCOLSW)(LPINT, LPWSAPROTOCOL_INFOW, LPDWORD);
typedef int (__attribute__((__stdcall__)) *LPFN_WSAEVENTSELECT)(SOCKET, HANDLE, long);
typedef BOOL (__attribute__((__stdcall__)) *LPFN_WSAGETOVERLAPPEDRESULT)(SOCKET, LPWSAOVERLAPPED, LPDWORD, BOOL, LPDWORD);
typedef BOOL (__attribute__((__stdcall__)) *LPFN_WSAGETQOSBYNAME)(SOCKET, LPWSABUF, LPQOS);
typedef INT (__attribute__((__stdcall__)) *LPFN_WSAGETSERVICECLASSINFOA)(LPGUID, LPGUID, LPDWORD, LPWSASERVICECLASSINFOA);
typedef INT (__attribute__((__stdcall__)) *LPFN_WSAGETSERVICECLASSINFOW)(LPGUID, LPGUID, LPDWORD, LPWSASERVICECLASSINFOW);
typedef INT (__attribute__((__stdcall__)) *LPFN_WSAGETSERVICECLASSNAMEBYCLASSIDA)(LPGUID, LPSTR, LPDWORD);
typedef INT (__attribute__((__stdcall__)) *LPFN_WSAGETSERVICECLASSNAMEBYCLASSIDW)(LPGUID, LPWSTR, LPDWORD);
typedef int (__attribute__((__stdcall__)) *LPFN_WSAHTONL)(SOCKET, unsigned long, unsigned long *);
typedef int (__attribute__((__stdcall__)) *LPFN_WSAHTONS)(SOCKET, unsigned short, unsigned short *);
typedef INT (__attribute__((__stdcall__)) *LPFN_WSAINSTALLSERVICECLASSA)(LPWSASERVICECLASSINFOA);
typedef INT (__attribute__((__stdcall__)) *LPFN_WSAINSTALLSERVICECLASSW)(LPWSASERVICECLASSINFOW);
typedef int (__attribute__((__stdcall__)) *LPFN_WSAIOCTL)(SOCKET, DWORD, LPVOID, DWORD, LPVOID, DWORD, LPDWORD, LPWSAOVERLAPPED, LPWSAOVERLAPPED_COMPLETION_ROUTINE);
typedef SOCKET (__attribute__((__stdcall__)) *LPFN_WSAJOINLEAF)(SOCKET, const struct sockaddr *, int, LPWSABUF, LPWSABUF, LPQOS, LPQOS, DWORD);
typedef INT (__attribute__((__stdcall__)) *LPFN_WSALOOKUPSERVICEBEGINA)(LPWSAQUERYSETA, DWORD, LPHANDLE);
typedef INT (__attribute__((__stdcall__)) *LPFN_WSALOOKUPSERVICEBEGINW)(LPWSAQUERYSETW, DWORD, LPHANDLE);
typedef INT (__attribute__((__stdcall__)) *LPFN_WSALOOKUPSERVICENEXTA)(HANDLE, DWORD, LPDWORD, LPWSAQUERYSETA);
typedef INT (__attribute__((__stdcall__)) *LPFN_WSALOOKUPSERVICENEXTW)(HANDLE, DWORD, LPDWORD, LPWSAQUERYSETW);
typedef INT (__attribute__((__stdcall__)) *LPFN_WSALOOKUPSERVICEEND)(HANDLE);
typedef int (__attribute__((__stdcall__)) *LPFN_WSANSPIoctl)(HANDLE, DWORD,LPVOID,DWORD,LPVOID,DWORD,LPDWORD,LPWSACOMPLETION);
typedef int (__attribute__((__stdcall__)) *LPFN_WSANTOHL)(SOCKET, unsigned long, unsigned long *);
typedef int (__attribute__((__stdcall__)) *LPFN_WSANTOHS)(SOCKET, unsigned short, unsigned short *);
typedef int (__attribute__((__stdcall__)) *LPFN_WSARECV)(SOCKET, LPWSABUF, DWORD, LPDWORD, LPDWORD, LPWSAOVERLAPPED, LPWSAOVERLAPPED_COMPLETION_ROUTINE);
typedef int (__attribute__((__stdcall__)) *LPFN_WSARECVDISCONNECT)(SOCKET, LPWSABUF);
typedef int (__attribute__((__stdcall__)) *LPFN_WSARECVFROM)(SOCKET, LPWSABUF, DWORD, LPDWORD, LPDWORD, struct sockaddr *, LPINT, LPWSAOVERLAPPED, LPWSAOVERLAPPED_COMPLETION_ROUTINE);
typedef INT (__attribute__((__stdcall__)) *LPFN_WSAREMOVESERVICECLASS)(LPGUID);
typedef BOOL (__attribute__((__stdcall__)) *LPFN_WSARESETEVENT)(HANDLE);
typedef int (__attribute__((__stdcall__)) *LPFN_WSASEND)(SOCKET, LPWSABUF, DWORD, LPDWORD, DWORD, LPWSAOVERLAPPED, LPWSAOVERLAPPED_COMPLETION_ROUTINE);
typedef int (__attribute__((__stdcall__)) *LPFN_WSASENDDISCONNECT)(SOCKET, LPWSABUF);
typedef int (__attribute__((__stdcall__)) *LPFN_WSASENDTO)(SOCKET, LPWSABUF, DWORD, LPDWORD, DWORD, const struct sockaddr *, int, LPWSAOVERLAPPED, LPWSAOVERLAPPED_COMPLETION_ROUTINE);
typedef BOOL (__attribute__((__stdcall__)) *LPFN_WSASETEVENT)(HANDLE);
typedef INT (__attribute__((__stdcall__)) *LPFN_WSASETSERVICEA)(LPWSAQUERYSETA, WSAESETSERVICEOP, DWORD);
typedef INT (__attribute__((__stdcall__)) *LPFN_WSASETSERVICEW)(LPWSAQUERYSETW, WSAESETSERVICEOP, DWORD);
typedef SOCKET (__attribute__((__stdcall__)) *LPFN_WSASOCKETA)(int, int, int, LPWSAPROTOCOL_INFOA, GROUP, DWORD);
typedef SOCKET (__attribute__((__stdcall__)) *LPFN_WSASOCKETW)(int, int, int, LPWSAPROTOCOL_INFOW, GROUP, DWORD);
typedef INT (__attribute__((__stdcall__)) *LPFN_WSASTRINGTOADDRESSA)(LPSTR, INT, LPWSAPROTOCOL_INFOA, LPSOCKADDR, LPINT);
typedef INT (__attribute__((__stdcall__)) *LPFN_WSASTRINGTOADDRESSW)(LPWSTR, INT, LPWSAPROTOCOL_INFOW, LPSOCKADDR, LPINT);
typedef DWORD (__attribute__((__stdcall__)) *LPFN_WSAWAITFORMULTIPLEEVENTS)(DWORD, const HANDLE *, BOOL, DWORD, BOOL);
# 1292 "H:/CPP/wxdevcpp6.10/include/winsock2.h" 3
}
# 99 "H:/CPP/wxdevcpp6.10/include/windows.h" 2 3
# 111 "H:/CPP/wxdevcpp6.10/include/windows.h" 3
# 1 "H:/CPP/wxdevcpp6.10/include/ole2.h" 1 3



       
# 5 "H:/CPP/wxdevcpp6.10/include/ole2.h" 3


#pragma pack(push,8)

# 1 "H:/CPP/wxdevcpp6.10/include/objbase.h" 1 3


# 1 "H:/CPP/wxdevcpp6.10/include/rpc.h" 1 3
# 4 "H:/CPP/wxdevcpp6.10/include/objbase.h" 2 3
# 1 "H:/CPP/wxdevcpp6.10/include/rpcndr.h" 1 3



       
# 5 "H:/CPP/wxdevcpp6.10/include/rpcndr.h" 3





# 1 "H:/CPP/wxdevcpp6.10/include/rpcnsip.h" 1 3



       
# 5 "H:/CPP/wxdevcpp6.10/include/rpcnsip.h" 3



extern "C" {

typedef struct {
 RPC_NS_HANDLE LookupContext;
 RPC_BINDING_HANDLE ProposedHandle;
 RPC_BINDING_VECTOR *Bindings;
} RPC_IMPORT_CONTEXT_P,*PRPC_IMPORT_CONTEXT_P;
RPC_STATUS __attribute__((__stdcall__)) I_RpcNsGetBuffer( PRPC_MESSAGE);
RPC_STATUS __attribute__((__stdcall__)) I_RpcNsSendReceive( PRPC_MESSAGE, RPC_BINDING_HANDLE*);
void __attribute__((__stdcall__)) I_RpcNsRaiseException( PRPC_MESSAGE, RPC_STATUS);
RPC_STATUS __attribute__((__stdcall__)) I_RpcReBindBuffer( PRPC_MESSAGE);
RPC_STATUS __attribute__((__stdcall__)) I_NsServerBindSearch(void);
RPC_STATUS __attribute__((__stdcall__)) I_NsClientBindSearch(void);
void __attribute__((__stdcall__)) I_NsClientBindDone(void);

}
# 11 "H:/CPP/wxdevcpp6.10/include/rpcndr.h" 2 3

extern "C" {

# 1 "H:/CPP/wxdevcpp6.10/include/objfwd.h" 1 3



       
# 5 "H:/CPP/wxdevcpp6.10/include/objfwd.h" 3





extern "C" {

typedef struct IMoniker *LPMONIKER;
typedef struct IStream *LPSTREAM;
typedef struct IMarshal *LPMARSHAL;
typedef struct IMalloc *LPMALLOC;
typedef struct IMallocSpy *LPMALLOCSPY;
typedef struct IMessageFilter *LPMESSAGEFILTER;
typedef struct IPersist *LPPERSIST;
typedef struct IPersistStream *LPPERSISTSTREAM;
typedef struct IRunningObjectTable *LPRUNNINGOBJECTTABLE;
typedef struct IBindCtx *LPBINDCTX,*LPBC;
typedef struct IAdviseSink *LPADVISESINK;
typedef struct IAdviseSink2 *LPADVISESINK2;
typedef struct IDataObject *LPDATAOBJECT;
typedef struct IDataAdviseHolder *LPDATAADVISEHOLDER;
typedef struct IEnumMoniker *LPENUMMONIKER;
typedef struct IEnumFORMATETC *LPENUMFORMATETC;
typedef struct IEnumSTATDATA *LPENUMSTATDATA;
typedef struct IEnumSTATSTG *LPENUMSTATSTG;
typedef struct IEnumSTATPROPSTG LPENUMSTATPROPSTG;
typedef struct IEnumString *LPENUMSTRING;
typedef struct IEnumUnknown *LPENUMUNKNOWN;
typedef struct IStorage *LPSTORAGE;
typedef struct IPersistStorage *LPPERSISTSTORAGE;
typedef struct ILockBytes *LPLOCKBYTES;
typedef struct IStdMarshalInfo *LPSTDMARSHALINFO;
typedef struct IExternalConnection *LPEXTERNALCONNECTION;
typedef struct IRunnableObject *LPRUNNABLEOBJECT;
typedef struct IROTData *LPROTDATA;
typedef struct IPersistFile *LPPERSISTFILE;
typedef struct IRootStorage *LPROOTSTORAGE;
typedef struct IRpcChannelBuffer *LPRPCCHANNELBUFFER;
typedef struct IRpcProxyBuffer *LPRPCPROXYBUFFER;
typedef struct IRpcStubBuffer *LPRPCSTUBBUFFER;
typedef struct IPropertyStorage *LPPROPERTYSTORAGE;
typedef struct IEnumSTATPROPSETSTG *LPENUMSTATPROPSETSTG;
typedef struct IPropertySetStorage *LPPROPERTYSETSTORAGE;
typedef struct IClientSecurity *LPCLIENTSECURITY;
typedef struct IServerSecurity *LPSERVERSECURITY;
typedef struct IClassActivator *LPCLASSACTIVATOR;
typedef struct IFillLockBytes *LPFILLLOCKBYTES;
typedef struct IProgressNotify *LPPROGRESSNOTIFY;
typedef struct ILayoutStorage *LPLAYOUTSTORAGE;

}
# 15 "H:/CPP/wxdevcpp6.10/include/rpcndr.h" 2 3
# 50 "H:/CPP/wxdevcpp6.10/include/rpcndr.h" 3
typedef unsigned char byte;
# 94 "H:/CPP/wxdevcpp6.10/include/rpcndr.h" 3
typedef void *NDR_CCONTEXT;
typedef struct {
 void *pad[2];
 void *userContext;
} *NDR_SCONTEXT;
typedef void (__attribute__((__stdcall__)) *NDR_RUNDOWN)(void*);
typedef struct _SCONTEXT_QUEUE {
 unsigned long NumberOfObjects;
 NDR_SCONTEXT *ArrayOfObjects;
} SCONTEXT_QUEUE,*PSCONTEXT_QUEUE;
struct _MIDL_STUB_MESSAGE;
struct _MIDL_STUB_DESC;
struct _FULL_PTR_XLAT_TABLES;
typedef unsigned char *RPC_BUFPTR;
typedef unsigned long RPC_LENGTH;
typedef void(__attribute__((__stdcall__)) *EXPR_EVAL)(struct _MIDL_STUB_MESSAGE*);
typedef const unsigned char *PFORMAT_STRING;
typedef struct {
 long Dimension;
 unsigned long *BufferConformanceMark;
 unsigned long *BufferVarianceMark;
 unsigned long *MaxCountArray;
 unsigned long *OffsetArray;
 unsigned long *ActualCountArray;
} ARRAY_INFO,*PARRAY_INFO;

RPC_BINDING_HANDLE __attribute__((__stdcall__)) NDRCContextBinding(NDR_CCONTEXT);
void __attribute__((__stdcall__)) NDRCContextMarshall(NDR_CCONTEXT,void*);
void __attribute__((__stdcall__)) NDRCContextUnmarshall(NDR_CCONTEXT*,RPC_BINDING_HANDLE,void*,unsigned long);
void __attribute__((__stdcall__)) NDRSContextMarshall(NDR_SCONTEXT,void*,NDR_RUNDOWN);
NDR_SCONTEXT __attribute__((__stdcall__)) NDRSContextUnmarshall(void*pBuff,unsigned long);
void __attribute__((__stdcall__)) RpcSsDestroyClientContext(void**);
void __attribute__((__stdcall__)) NDRcopy(void*,void*,unsigned int);
unsigned int __attribute__((__stdcall__)) MIDL_wchar_strlen(wchar_t*);
void __attribute__((__stdcall__)) MIDL_wchar_strcpy(void*,wchar_t*);
void __attribute__((__stdcall__)) char_from_ndr(PRPC_MESSAGE,unsigned char*);
void __attribute__((__stdcall__)) char_array_from_ndr(PRPC_MESSAGE,unsigned long,unsigned long,unsigned char*);
void __attribute__((__stdcall__)) short_from_ndr(PRPC_MESSAGE,unsigned short*);
void __attribute__((__stdcall__)) short_array_from_ndr(PRPC_MESSAGE,unsigned long,unsigned long,unsigned short*);
void __attribute__((__stdcall__)) short_from_ndr_temp(unsigned char**,unsigned short*,unsigned long);
void __attribute__((__stdcall__)) long_from_ndr(PRPC_MESSAGE,unsigned long*);
void __attribute__((__stdcall__)) long_array_from_ndr(PRPC_MESSAGE,unsigned long,unsigned long,unsigned long*);
void __attribute__((__stdcall__)) long_from_ndr_temp(unsigned char**,unsigned long*,unsigned long);
void __attribute__((__stdcall__)) enum_from_ndr(PRPC_MESSAGE,unsigned int*);
void __attribute__((__stdcall__)) float_from_ndr(PRPC_MESSAGE,void*);
void __attribute__((__stdcall__)) float_array_from_ndr(PRPC_MESSAGE,unsigned long,unsigned long,void*);
void __attribute__((__stdcall__)) double_from_ndr(PRPC_MESSAGE,void*);
void __attribute__((__stdcall__)) double_array_from_ndr(PRPC_MESSAGE,unsigned long,unsigned long,void*);
void __attribute__((__stdcall__)) hyper_from_ndr(PRPC_MESSAGE,long long*);
void __attribute__((__stdcall__)) hyper_array_from_ndr(PRPC_MESSAGE,unsigned long,unsigned long,long long*);
void __attribute__((__stdcall__)) hyper_from_ndr_temp(unsigned char**,long long*,unsigned long);
void __attribute__((__stdcall__)) data_from_ndr(PRPC_MESSAGE,void*,char*,unsigned char);
void __attribute__((__stdcall__)) data_into_ndr(void*,PRPC_MESSAGE,char*,unsigned char);
void __attribute__((__stdcall__)) tree_into_ndr(void*,PRPC_MESSAGE,char*,unsigned char);
void __attribute__((__stdcall__)) data_size_ndr(void*,PRPC_MESSAGE,char*,unsigned char);
void __attribute__((__stdcall__)) tree_size_ndr(void*,PRPC_MESSAGE,char*,unsigned char);
void __attribute__((__stdcall__)) tree_peek_ndr(PRPC_MESSAGE,unsigned char**,char*,unsigned char);
void *__attribute__((__stdcall__)) midl_allocate(int);

#pragma pack(push,4)
typedef struct _MIDL_STUB_MESSAGE {
 PRPC_MESSAGE RpcMsg;
 unsigned char *Buffer;
 unsigned char *BufferStart;
 unsigned char *BufferEnd;
 unsigned char *BufferMark;
 unsigned long BufferLength;
 unsigned long MemorySize;
 unsigned char *Memory;
 int IsClient;
 int ReuseBuffer;
 unsigned char *AllocAllNodesMemory;
 unsigned char *AllocAllNodesMemoryEnd;
 int IgnoreEmbeddedPointers;
 unsigned char *PointerBufferMark;
 unsigned char fBufferValid;
 unsigned char Unused;
 unsigned long MaxCount;
 unsigned long Offset;
 unsigned long ActualCount;
 void*(__attribute__((__stdcall__)) *pfnAllocate)(unsigned int);
 void(__attribute__((__stdcall__)) *pfnFree)(void*);
 unsigned char *StackTop;
 unsigned char *pPresentedType;
 unsigned char *pTransmitType;
 handle_t SavedHandle;
 const struct _MIDL_STUB_DESC *StubDesc;
 struct _FULL_PTR_XLAT_TABLES *FullPtrXlatTables;
 unsigned long FullPtrRefId;
 int fCheckBounds;
 int fInDontFree :1;
 int fDontCallFreeInst :1;
 int fInOnlyParam :1;
 int fHasReturn :1;
 unsigned long dwDestContext;
 void*pvDestContext;
 NDR_SCONTEXT *SavedContextHandles;
 long ParamNumber;
 struct IRpcChannelBuffer *pRpcChannelBuffer;
 PARRAY_INFO pArrayInfo;
 unsigned long *SizePtrCountArray;
 unsigned long *SizePtrOffsetArray;
 unsigned long *SizePtrLengthArray;
 void*pArgQueue;
 unsigned long dwStubPhase;
 unsigned long w2kReserved[5];
} MIDL_STUB_MESSAGE,*PMIDL_STUB_MESSAGE;
#pragma pack(pop)
typedef void*(__attribute__((__stdcall__)) *GENERIC_BINDING_ROUTINE)(void*);
typedef void (__attribute__((__stdcall__)) *GENERIC_UNBIND_ROUTINE)(void*,unsigned char*);
typedef struct _GENERIC_BINDING_ROUTINE_PAIR {
 GENERIC_BINDING_ROUTINE pfnBind;
 GENERIC_UNBIND_ROUTINE pfnUnbind;
} GENERIC_BINDING_ROUTINE_PAIR,*PGENERIC_BINDING_ROUTINE_PAIR;
typedef struct __GENERIC_BINDING_INFO {
 void *pObj;
 unsigned int Size;
 GENERIC_BINDING_ROUTINE pfnBind;
 GENERIC_UNBIND_ROUTINE pfnUnbind;
} GENERIC_BINDING_INFO,*PGENERIC_BINDING_INFO;
typedef void(__attribute__((__stdcall__)) *XMIT_HELPER_ROUTINE)(PMIDL_STUB_MESSAGE);
typedef struct _XMIT_ROUTINE_QUINTUPLE {
 XMIT_HELPER_ROUTINE pfnTranslateToXmit;
 XMIT_HELPER_ROUTINE pfnTranslateFromXmit;
 XMIT_HELPER_ROUTINE pfnFreeXmit;
 XMIT_HELPER_ROUTINE pfnFreeInst;
} XMIT_ROUTINE_QUINTUPLE,*PXMIT_ROUTINE_QUINTUPLE;
typedef struct _MALLOC_FREE_STRUCT {
void*(__attribute__((__stdcall__)) *pfnAllocate)(unsigned int);
void(__attribute__((__stdcall__)) *pfnFree)(void*);
} MALLOC_FREE_STRUCT;
typedef struct _COMM_FAULT_OFFSETS {
 short CommOffset;
 short FaultOffset;
} COMM_FAULT_OFFSETS;
typedef unsigned long (__attribute__((__stdcall__)) *USER_MARSHAL_SIZING_ROUTINE)(unsigned long *,unsigned long,void *);
typedef unsigned char *(__attribute__((__stdcall__)) *USER_MARSHAL_MARSHALLING_ROUTINE)(unsigned long *,unsigned char *,void *);
typedef unsigned char *(__attribute__((__stdcall__)) *USER_MARSHAL_UNMARSHALLING_ROUTINE)(unsigned long *,unsigned char *,void *);
typedef void (__attribute__((__stdcall__)) *USER_MARSHAL_FREEING_ROUTINE)(unsigned long *,void *);
typedef struct _USER_MARSHAL_ROUTINE_QUADRUPLE {
 USER_MARSHAL_SIZING_ROUTINE pfnBufferSize;
 USER_MARSHAL_MARSHALLING_ROUTINE pfnMarshall;
 USER_MARSHAL_UNMARSHALLING_ROUTINE pfnUnmarshall;
 USER_MARSHAL_FREEING_ROUTINE pfnFree;
} USER_MARSHAL_ROUTINE_QUADRUPLE;
typedef void (__attribute__((__stdcall__)) *NDR_NOTIFY_ROUTINE)(void);
typedef enum _IDL_CS_CONVERT {
 IDL_CS_NO_CONVERT,
 IDL_CS_IN_PLACE_CONVERT,
 IDL_CS_NEW_BUFFER_CONVERT
} IDL_CS_CONVERT;
typedef void (__attribute__((__stdcall__)) *CS_TYPE_NET_SIZE_ROUTINE)(RPC_BINDING_HANDLE,unsigned long,unsigned long,IDL_CS_CONVERT*,unsigned long*,error_status_t*);
typedef void (__attribute__((__stdcall__)) *CS_TYPE_LOCAL_SIZE_ROUTINE)(RPC_BINDING_HANDLE,unsigned long,unsigned long,IDL_CS_CONVERT*,unsigned long*,error_status_t*);
typedef void (__attribute__((__stdcall__)) *CS_TYPE_TO_NETCS_ROUTINE)(RPC_BINDING_HANDLE,unsigned long,void*,unsigned long,byte*,unsigned long*,error_status_t*);
typedef void (__attribute__((__stdcall__)) *CS_TYPE_FROM_NETCS_ROUTINE)(RPC_BINDING_HANDLE,unsigned long,byte*,unsigned long,unsigned long,void*,unsigned long*,error_status_t*);
typedef void (__attribute__((__stdcall__)) *CS_TAG_GETTING_ROUTINE)(RPC_BINDING_HANDLE,int,unsigned long*,unsigned long*,unsigned long*,error_status_t*);
typedef struct _NDR_CS_SIZE_CONVERT_ROUTINES {
 CS_TYPE_NET_SIZE_ROUTINE pfnNetSize;
 CS_TYPE_TO_NETCS_ROUTINE pfnToNetCs;
 CS_TYPE_LOCAL_SIZE_ROUTINE pfnLocalSize;
 CS_TYPE_FROM_NETCS_ROUTINE pfnFromNetCs;
} NDR_CS_SIZE_CONVERT_ROUTINES;
typedef struct _NDR_CS_ROUTINES {
 NDR_CS_SIZE_CONVERT_ROUTINES *pSizeConvertRoutines;
 CS_TAG_GETTING_ROUTINE *pTagGettingRoutines;
} NDR_CS_ROUTINES;
typedef struct _MIDL_STUB_DESC {
 void*RpcInterfaceInformation;
 void*(__attribute__((__stdcall__)) *pfnAllocate)(unsigned int);
 void(__attribute__((__stdcall__)) *pfnFree)(void*);
 union {
  handle_t *pAutoHandle;
  handle_t *pPrimitiveHandle;
  PGENERIC_BINDING_INFO pGenericBindingInfo;
 } IMPLICIT_HANDLE_INFO;
 const NDR_RUNDOWN *apfnNdrRundownRoutines;
 const GENERIC_BINDING_ROUTINE_PAIR *aGenericBindingRoutinePairs;
 const EXPR_EVAL *apfnExprEval;
 const XMIT_ROUTINE_QUINTUPLE *aXmitQuintuple;
 const unsigned char *pFormatTypes;
 int fCheckBounds;
 unsigned long Version;
 MALLOC_FREE_STRUCT *pMallocFreeStruct;
 long MIDLVersion;
 const COMM_FAULT_OFFSETS *CommFaultOffsets;
 const USER_MARSHAL_ROUTINE_QUADRUPLE *aUserMarshalQuadruple;
 const NDR_NOTIFY_ROUTINE *NotifyRoutineTable;
 ULONG_PTR mFlags;
 const NDR_CS_ROUTINES *CsRoutineTables;
 void *Reserved4;
 ULONG_PTR Reserved5;
} MIDL_STUB_DESC;
typedef const MIDL_STUB_DESC *PMIDL_STUB_DESC;
typedef void*PMIDL_XMIT_TYPE;
typedef struct _MIDL_FORMAT_STRING {
 short Pad;
 unsigned char Format[1];
} MIDL_FORMAT_STRING;
typedef void(__attribute__((__stdcall__)) *STUB_THUNK)(PMIDL_STUB_MESSAGE);
typedef long(__attribute__((__stdcall__)) *SERVER_ROUTINE)(void);
typedef struct _MIDL_SERVER_INFO_ {
 PMIDL_STUB_DESC pStubDesc;
 const SERVER_ROUTINE *DispatchTable;
 PFORMAT_STRING ProcString;
 const unsigned short *FmtStringOffset;
 const STUB_THUNK *ThunkTable;
} MIDL_SERVER_INFO,*PMIDL_SERVER_INFO;
typedef struct _MIDL_STUBLESS_PROXY_INFO {
 PMIDL_STUB_DESC pStubDesc;
 PFORMAT_STRING ProcFormatString;
 const unsigned short *FormatStringOffset;
} MIDL_STUBLESS_PROXY_INFO;
typedef MIDL_STUBLESS_PROXY_INFO *PMIDL_STUBLESS_PROXY_INFO;
typedef union _CLIENT_CALL_RETURN {
 void *Pointer;
 long Simple;
} CLIENT_CALL_RETURN;
typedef enum { XLAT_SERVER = 1,XLAT_CLIENT } XLAT_SIDE;
typedef struct _FULL_PTR_TO_REFID_ELEMENT {
 struct _FULL_PTR_TO_REFID_ELEMENT *Next;
 void*Pointer;
 unsigned long RefId;
 unsigned char State;
} FULL_PTR_TO_REFID_ELEMENT,*PFULL_PTR_TO_REFID_ELEMENT;
typedef struct _FULL_PTR_XLAT_TABLES {
 struct {
  void **XlatTable;
  unsigned char *StateTable;
  unsigned long NumberOfEntries;
 } RefIdToPointer;
 struct {
  PFULL_PTR_TO_REFID_ELEMENT *XlatTable;
  unsigned long NumberOfBuckets;
  unsigned long HashMask;
 } PointerToRefId;
 unsigned long NextRefId;
 XLAT_SIDE XlatSide;
} FULL_PTR_XLAT_TABLES,*PFULL_PTR_XLAT_TABLES;
void __attribute__((__stdcall__)) NdrSimpleTypeMarshall(PMIDL_STUB_MESSAGE,unsigned char*,unsigned char);
unsigned char *__attribute__((__stdcall__)) NdrPointerMarshall(PMIDL_STUB_MESSAGE,unsigned char*,PFORMAT_STRING pFormat);
unsigned char *__attribute__((__stdcall__)) NdrSimpleStructMarshall(PMIDL_STUB_MESSAGE,unsigned char*,PFORMAT_STRING);
unsigned char *__attribute__((__stdcall__)) NdrConformantStructMarshall(PMIDL_STUB_MESSAGE,unsigned char*,PFORMAT_STRING);
unsigned char *__attribute__((__stdcall__)) NdrConformantVaryingStructMarshall(PMIDL_STUB_MESSAGE,unsigned char*,PFORMAT_STRING);
unsigned char *__attribute__((__stdcall__)) NdrHardStructMarshall(PMIDL_STUB_MESSAGE,unsigned char*,PFORMAT_STRING);
unsigned char *__attribute__((__stdcall__)) NdrComplexStructMarshall(PMIDL_STUB_MESSAGE,unsigned char*,PFORMAT_STRING);
unsigned char *__attribute__((__stdcall__)) NdrFixedArrayMarshall(PMIDL_STUB_MESSAGE,unsigned char*,PFORMAT_STRING);
unsigned char *__attribute__((__stdcall__)) NdrConformantArrayMarshall(PMIDL_STUB_MESSAGE,unsigned char*,PFORMAT_STRING);
unsigned char *__attribute__((__stdcall__)) NdrConformantVaryingArrayMarshall(PMIDL_STUB_MESSAGE,unsigned char*,PFORMAT_STRING);
unsigned char *__attribute__((__stdcall__)) NdrVaryingArrayMarshall(PMIDL_STUB_MESSAGE,unsigned char*,PFORMAT_STRING);
unsigned char *__attribute__((__stdcall__)) NdrComplexArrayMarshall(PMIDL_STUB_MESSAGE,unsigned char*,PFORMAT_STRING);
unsigned char *__attribute__((__stdcall__)) NdrNonConformantStringMarshall(PMIDL_STUB_MESSAGE,unsigned char*,PFORMAT_STRING);
unsigned char *__attribute__((__stdcall__)) NdrConformantStringMarshall(PMIDL_STUB_MESSAGE,unsigned char*,PFORMAT_STRING);
unsigned char *__attribute__((__stdcall__)) NdrEncapsulatedUnionMarshall(PMIDL_STUB_MESSAGE,unsigned char*,PFORMAT_STRING);
unsigned char *__attribute__((__stdcall__)) NdrNonEncapsulatedUnionMarshall(PMIDL_STUB_MESSAGE,unsigned char*,PFORMAT_STRING);
unsigned char *__attribute__((__stdcall__)) NdrByteCountPointerMarshall(PMIDL_STUB_MESSAGE,unsigned char*,PFORMAT_STRING);
unsigned char *__attribute__((__stdcall__)) NdrXmitOrRepAsMarshall(PMIDL_STUB_MESSAGE,unsigned char*,PFORMAT_STRING);
unsigned char *__attribute__((__stdcall__)) NdrInterfacePointerMarshall(PMIDL_STUB_MESSAGE,unsigned char*,PFORMAT_STRING);
void __attribute__((__stdcall__)) NdrClientContextMarshall(PMIDL_STUB_MESSAGE,NDR_CCONTEXT,int);
void __attribute__((__stdcall__)) NdrServerContextMarshall(PMIDL_STUB_MESSAGE,NDR_SCONTEXT,NDR_RUNDOWN);
void __attribute__((__stdcall__)) NdrSimpleTypeUnmarshall(PMIDL_STUB_MESSAGE,unsigned char*,unsigned char);
unsigned char *__attribute__((__stdcall__)) NdrPointerUnmarshall(PMIDL_STUB_MESSAGE,unsigned char**,PFORMAT_STRING,unsigned char);
unsigned char *__attribute__((__stdcall__)) NdrSimpleStructUnmarshall(PMIDL_STUB_MESSAGE,unsigned char**,PFORMAT_STRING,unsigned char);
unsigned char *__attribute__((__stdcall__)) NdrConformantStructUnmarshall(PMIDL_STUB_MESSAGE,unsigned char**,PFORMAT_STRING,unsigned char);
unsigned char *__attribute__((__stdcall__)) NdrConformantVaryingStructUnmarshall(PMIDL_STUB_MESSAGE,unsigned char**,PFORMAT_STRING,unsigned char);
unsigned char *__attribute__((__stdcall__)) NdrHardStructUnmarshall(PMIDL_STUB_MESSAGE,unsigned char**,PFORMAT_STRING,unsigned char);
unsigned char *__attribute__((__stdcall__)) NdrComplexStructUnmarshall(PMIDL_STUB_MESSAGE,unsigned char**,PFORMAT_STRING,unsigned char);
unsigned char *__attribute__((__stdcall__)) NdrFixedArrayUnmarshall(PMIDL_STUB_MESSAGE,unsigned char**,PFORMAT_STRING,unsigned char);
unsigned char *__attribute__((__stdcall__)) NdrConformantArrayUnmarshall(PMIDL_STUB_MESSAGE,unsigned char**,PFORMAT_STRING,unsigned char);
unsigned char *__attribute__((__stdcall__)) NdrConformantVaryingArrayUnmarshall(PMIDL_STUB_MESSAGE,unsigned char**,PFORMAT_STRING,unsigned char);
unsigned char *__attribute__((__stdcall__)) NdrVaryingArrayUnmarshall(PMIDL_STUB_MESSAGE,unsigned char**,PFORMAT_STRING,unsigned char);
unsigned char *__attribute__((__stdcall__)) NdrComplexArrayUnmarshall(PMIDL_STUB_MESSAGE,unsigned char**,PFORMAT_STRING,unsigned char);
unsigned char *__attribute__((__stdcall__)) NdrNonConformantStringUnmarshall(PMIDL_STUB_MESSAGE,unsigned char**,PFORMAT_STRING,unsigned char);
unsigned char *__attribute__((__stdcall__)) NdrConformantStringUnmarshall(PMIDL_STUB_MESSAGE,unsigned char**,PFORMAT_STRING,unsigned char);
unsigned char *__attribute__((__stdcall__)) NdrEncapsulatedUnionUnmarshall(PMIDL_STUB_MESSAGE,unsigned char**,PFORMAT_STRING,unsigned char);
unsigned char *__attribute__((__stdcall__)) NdrNonEncapsulatedUnionUnmarshall(PMIDL_STUB_MESSAGE,unsigned char**,PFORMAT_STRING,unsigned char);
unsigned char *__attribute__((__stdcall__)) NdrByteCountPointerUnmarshall(PMIDL_STUB_MESSAGE,unsigned char**,PFORMAT_STRING,unsigned char);
unsigned char *__attribute__((__stdcall__)) NdrXmitOrRepAsUnmarshall(PMIDL_STUB_MESSAGE,unsigned char**,PFORMAT_STRING,unsigned char);
unsigned char *__attribute__((__stdcall__)) NdrInterfacePointerUnmarshall(PMIDL_STUB_MESSAGE,unsigned char**,PFORMAT_STRING,unsigned char);
void __attribute__((__stdcall__)) NdrClientContextUnmarshall(PMIDL_STUB_MESSAGE,NDR_CCONTEXT*,RPC_BINDING_HANDLE);
NDR_SCONTEXT __attribute__((__stdcall__)) NdrServerContextUnmarshall(PMIDL_STUB_MESSAGE);
void __attribute__((__stdcall__)) NdrPointerBufferSize(PMIDL_STUB_MESSAGE,unsigned char*,PFORMAT_STRING);
void __attribute__((__stdcall__)) NdrSimpleStructBufferSize(PMIDL_STUB_MESSAGE,unsigned char*,PFORMAT_STRING);
void __attribute__((__stdcall__)) NdrConformantStructBufferSize(PMIDL_STUB_MESSAGE,unsigned char*,PFORMAT_STRING);
void __attribute__((__stdcall__)) NdrConformantVaryingStructBufferSize(PMIDL_STUB_MESSAGE,unsigned char*,PFORMAT_STRING);
void __attribute__((__stdcall__)) NdrHardStructBufferSize(PMIDL_STUB_MESSAGE,unsigned char*,PFORMAT_STRING);
void __attribute__((__stdcall__)) NdrComplexStructBufferSize(PMIDL_STUB_MESSAGE,unsigned char*,PFORMAT_STRING);
void __attribute__((__stdcall__)) NdrFixedArrayBufferSize(PMIDL_STUB_MESSAGE,unsigned char*,PFORMAT_STRING);
void __attribute__((__stdcall__)) NdrConformantArrayBufferSize(PMIDL_STUB_MESSAGE,unsigned char*,PFORMAT_STRING);
void __attribute__((__stdcall__)) NdrConformantVaryingArrayBufferSize(PMIDL_STUB_MESSAGE,unsigned char*,PFORMAT_STRING);
void __attribute__((__stdcall__)) NdrVaryingArrayBufferSize(PMIDL_STUB_MESSAGE,unsigned char*,PFORMAT_STRING);
void __attribute__((__stdcall__)) NdrComplexArrayBufferSize(PMIDL_STUB_MESSAGE,unsigned char*,PFORMAT_STRING);
void __attribute__((__stdcall__)) NdrConformantStringBufferSize(PMIDL_STUB_MESSAGE,unsigned char*,PFORMAT_STRING);
void __attribute__((__stdcall__)) NdrNonConformantStringBufferSize(PMIDL_STUB_MESSAGE,unsigned char*,PFORMAT_STRING);
void __attribute__((__stdcall__)) NdrEncapsulatedUnionBufferSize(PMIDL_STUB_MESSAGE,unsigned char*,PFORMAT_STRING);
void __attribute__((__stdcall__)) NdrNonEncapsulatedUnionBufferSize(PMIDL_STUB_MESSAGE,unsigned char*,PFORMAT_STRING);
void __attribute__((__stdcall__)) NdrByteCountPointerBufferSize(PMIDL_STUB_MESSAGE,unsigned char*,PFORMAT_STRING);
void __attribute__((__stdcall__)) NdrXmitOrRepAsBufferSize(PMIDL_STUB_MESSAGE,unsigned char*,PFORMAT_STRING);
void __attribute__((__stdcall__)) NdrInterfacePointerBufferSize(PMIDL_STUB_MESSAGE,unsigned char*,PFORMAT_STRING);
void __attribute__((__stdcall__)) NdrContextHandleSize(PMIDL_STUB_MESSAGE,unsigned char*,PFORMAT_STRING);
unsigned long __attribute__((__stdcall__)) NdrPointerMemorySize(PMIDL_STUB_MESSAGE,PFORMAT_STRING);
unsigned long __attribute__((__stdcall__)) NdrSimpleStructMemorySize(PMIDL_STUB_MESSAGE,PFORMAT_STRING);
unsigned long __attribute__((__stdcall__)) NdrConformantStructMemorySize(PMIDL_STUB_MESSAGE,PFORMAT_STRING);
unsigned long __attribute__((__stdcall__)) NdrConformantVaryingStructMemorySize(PMIDL_STUB_MESSAGE,PFORMAT_STRING);
unsigned long __attribute__((__stdcall__)) NdrHardStructMemorySize(PMIDL_STUB_MESSAGE,PFORMAT_STRING);
unsigned long __attribute__((__stdcall__)) NdrComplexStructMemorySize(PMIDL_STUB_MESSAGE,PFORMAT_STRING);
unsigned long __attribute__((__stdcall__)) NdrFixedArrayMemorySize(PMIDL_STUB_MESSAGE,PFORMAT_STRING);
unsigned long __attribute__((__stdcall__)) NdrConformantArrayMemorySize(PMIDL_STUB_MESSAGE,PFORMAT_STRING);
unsigned long __attribute__((__stdcall__)) NdrConformantVaryingArrayMemorySize(PMIDL_STUB_MESSAGE,PFORMAT_STRING);
unsigned long __attribute__((__stdcall__)) NdrVaryingArrayMemorySize(PMIDL_STUB_MESSAGE,PFORMAT_STRING);
unsigned long __attribute__((__stdcall__)) NdrComplexArrayMemorySize(PMIDL_STUB_MESSAGE,PFORMAT_STRING);
unsigned long __attribute__((__stdcall__)) NdrConformantStringMemorySize(PMIDL_STUB_MESSAGE,PFORMAT_STRING);
unsigned long __attribute__((__stdcall__)) NdrNonConformantStringMemorySize(PMIDL_STUB_MESSAGE,PFORMAT_STRING);
unsigned long __attribute__((__stdcall__)) NdrEncapsulatedUnionMemorySize(PMIDL_STUB_MESSAGE,PFORMAT_STRING);
unsigned long __attribute__((__stdcall__)) NdrNonEncapsulatedUnionMemorySize(PMIDL_STUB_MESSAGE,PFORMAT_STRING);
unsigned long __attribute__((__stdcall__)) NdrXmitOrRepAsMemorySize(PMIDL_STUB_MESSAGE,PFORMAT_STRING);
unsigned long __attribute__((__stdcall__)) NdrInterfacePointerMemorySize(PMIDL_STUB_MESSAGE,PFORMAT_STRING);
void __attribute__((__stdcall__)) NdrPointerFree(PMIDL_STUB_MESSAGE,unsigned char*,PFORMAT_STRING);
void __attribute__((__stdcall__)) NdrSimpleStructFree(PMIDL_STUB_MESSAGE,unsigned char*,PFORMAT_STRING);
void __attribute__((__stdcall__)) NdrConformantStructFree(PMIDL_STUB_MESSAGE,unsigned char*,PFORMAT_STRING);
void __attribute__((__stdcall__)) NdrConformantVaryingStructFree(PMIDL_STUB_MESSAGE,unsigned char*,PFORMAT_STRING);
void __attribute__((__stdcall__)) NdrHardStructFree(PMIDL_STUB_MESSAGE,unsigned char*,PFORMAT_STRING);
void __attribute__((__stdcall__)) NdrComplexStructFree(PMIDL_STUB_MESSAGE,unsigned char*,PFORMAT_STRING);
void __attribute__((__stdcall__)) NdrFixedArrayFree(PMIDL_STUB_MESSAGE,unsigned char*,PFORMAT_STRING);
void __attribute__((__stdcall__)) NdrConformantArrayFree(PMIDL_STUB_MESSAGE,unsigned char*,PFORMAT_STRING);
void __attribute__((__stdcall__)) NdrConformantVaryingArrayFree(PMIDL_STUB_MESSAGE,unsigned char*,PFORMAT_STRING);
void __attribute__((__stdcall__)) NdrVaryingArrayFree(PMIDL_STUB_MESSAGE,unsigned char*,PFORMAT_STRING);
void __attribute__((__stdcall__)) NdrComplexArrayFree(PMIDL_STUB_MESSAGE,unsigned char*,PFORMAT_STRING);
void __attribute__((__stdcall__)) NdrEncapsulatedUnionFree(PMIDL_STUB_MESSAGE,unsigned char*,PFORMAT_STRING);
void __attribute__((__stdcall__)) NdrNonEncapsulatedUnionFree(PMIDL_STUB_MESSAGE,unsigned char*,PFORMAT_STRING);
void __attribute__((__stdcall__)) NdrByteCountPointerFree(PMIDL_STUB_MESSAGE,unsigned char*,PFORMAT_STRING);
void __attribute__((__stdcall__)) NdrXmitOrRepAsFree(PMIDL_STUB_MESSAGE,unsigned char*,PFORMAT_STRING);
void __attribute__((__stdcall__)) NdrInterfacePointerFree(PMIDL_STUB_MESSAGE,unsigned char*,PFORMAT_STRING);
void __attribute__((__stdcall__)) NdrConvert(PMIDL_STUB_MESSAGE,PFORMAT_STRING);
void __attribute__((__stdcall__)) NdrClientInitializeNew(PRPC_MESSAGE,PMIDL_STUB_MESSAGE,PMIDL_STUB_DESC,unsigned int);
unsigned char *__attribute__((__stdcall__)) NdrServerInitializeNew(PRPC_MESSAGE,PMIDL_STUB_MESSAGE,PMIDL_STUB_DESC);
void __attribute__((__stdcall__)) NdrClientInitialize(PRPC_MESSAGE,PMIDL_STUB_MESSAGE,PMIDL_STUB_DESC,unsigned int);
unsigned char *__attribute__((__stdcall__)) NdrServerInitialize(PRPC_MESSAGE,PMIDL_STUB_MESSAGE,PMIDL_STUB_DESC);
unsigned char *__attribute__((__stdcall__)) NdrServerInitializeUnmarshall(PMIDL_STUB_MESSAGE,PMIDL_STUB_DESC,PRPC_MESSAGE);
void __attribute__((__stdcall__)) NdrServerInitializeMarshall(PRPC_MESSAGE,PMIDL_STUB_MESSAGE);
unsigned char *__attribute__((__stdcall__)) NdrGetBuffer(PMIDL_STUB_MESSAGE,unsigned long,RPC_BINDING_HANDLE);
unsigned char *__attribute__((__stdcall__)) NdrNsGetBuffer(PMIDL_STUB_MESSAGE,unsigned long,RPC_BINDING_HANDLE);
unsigned char *__attribute__((__stdcall__)) NdrSendReceive(PMIDL_STUB_MESSAGE,unsigned char*);
unsigned char *__attribute__((__stdcall__)) NdrNsSendReceive(PMIDL_STUB_MESSAGE,unsigned char*,RPC_BINDING_HANDLE*);
void __attribute__((__stdcall__)) NdrFreeBuffer(PMIDL_STUB_MESSAGE);
CLIENT_CALL_RETURN __attribute__((__cdecl__)) NdrClientCall(PMIDL_STUB_DESC,PFORMAT_STRING,...);
typedef enum {
 STUB_UNMARSHAL,
 STUB_CALL_SERVER,
 STUB_MARSHAL,
 STUB_CALL_SERVER_NO_HRESULT
} STUB_PHASE;
typedef enum {
 PROXY_CALCSIZE,
 PROXY_GETBUFFER,
 PROXY_MARSHAL,
 PROXY_SENDRECEIVE,
 PROXY_UNMARSHAL
} PROXY_PHASE;
long __attribute__((__stdcall__)) NdrStubCall(struct IRpcStubBuffer*,struct IRpcChannelBuffer*,PRPC_MESSAGE,unsigned long*);
void __attribute__((__stdcall__)) NdrServerCall(PRPC_MESSAGE);
int __attribute__((__stdcall__)) NdrServerUnmarshall(struct IRpcChannelBuffer*,PRPC_MESSAGE,PMIDL_STUB_MESSAGE,PMIDL_STUB_DESC,PFORMAT_STRING,void*);
void __attribute__((__stdcall__)) NdrServerMarshall(struct IRpcStubBuffer*,struct IRpcChannelBuffer*,PMIDL_STUB_MESSAGE,PFORMAT_STRING);
RPC_STATUS __attribute__((__stdcall__)) NdrMapCommAndFaultStatus(PMIDL_STUB_MESSAGE,unsigned long*,unsigned long*,RPC_STATUS);
int __attribute__((__stdcall__)) NdrSH_UPDecision(PMIDL_STUB_MESSAGE,unsigned char**,RPC_BUFPTR);
int __attribute__((__stdcall__)) NdrSH_TLUPDecision(PMIDL_STUB_MESSAGE,unsigned char**);
int __attribute__((__stdcall__)) NdrSH_TLUPDecisionBuffer(PMIDL_STUB_MESSAGE,unsigned char**);
int __attribute__((__stdcall__)) NdrSH_IfAlloc(PMIDL_STUB_MESSAGE,unsigned char**,unsigned long);
int __attribute__((__stdcall__)) NdrSH_IfAllocRef(PMIDL_STUB_MESSAGE,unsigned char**,unsigned long);
int __attribute__((__stdcall__)) NdrSH_IfAllocSet(PMIDL_STUB_MESSAGE,unsigned char**,unsigned long);
RPC_BUFPTR __attribute__((__stdcall__)) NdrSH_IfCopy(PMIDL_STUB_MESSAGE,unsigned char**,unsigned long);
RPC_BUFPTR __attribute__((__stdcall__)) NdrSH_IfAllocCopy(PMIDL_STUB_MESSAGE,unsigned char**,unsigned long);
unsigned long __attribute__((__stdcall__)) NdrSH_Copy(unsigned char*,unsigned char*,unsigned long);
void __attribute__((__stdcall__)) NdrSH_IfFree(PMIDL_STUB_MESSAGE,unsigned char*);
RPC_BUFPTR __attribute__((__stdcall__)) NdrSH_StringMarshall(PMIDL_STUB_MESSAGE,unsigned char*,unsigned long,int);
RPC_BUFPTR __attribute__((__stdcall__)) NdrSH_StringUnMarshall(PMIDL_STUB_MESSAGE,unsigned char**,int);
typedef void *RPC_SS_THREAD_HANDLE;
typedef void* __attribute__((__stdcall__)) RPC_CLIENT_ALLOC(unsigned int);
typedef void __attribute__((__stdcall__)) RPC_CLIENT_FREE(void*);
void*__attribute__((__stdcall__)) RpcSsAllocate(unsigned int);
void __attribute__((__stdcall__)) RpcSsDisableAllocate(void);
void __attribute__((__stdcall__)) RpcSsEnableAllocate(void);
void __attribute__((__stdcall__)) RpcSsFree(void*);
RPC_SS_THREAD_HANDLE __attribute__((__stdcall__)) RpcSsGetThreadHandle(void);
void __attribute__((__stdcall__)) RpcSsSetClientAllocFree(RPC_CLIENT_ALLOC*,RPC_CLIENT_FREE*);
void __attribute__((__stdcall__)) RpcSsSetThreadHandle(RPC_SS_THREAD_HANDLE);
void __attribute__((__stdcall__)) RpcSsSwapClientAllocFree(RPC_CLIENT_ALLOC*,RPC_CLIENT_FREE*,RPC_CLIENT_ALLOC**,RPC_CLIENT_FREE**);
void*__attribute__((__stdcall__)) RpcSmAllocate(unsigned int,RPC_STATUS*);
RPC_STATUS __attribute__((__stdcall__)) RpcSmClientFree(void*);
RPC_STATUS __attribute__((__stdcall__)) RpcSmDestroyClientContext(void**);
RPC_STATUS __attribute__((__stdcall__)) RpcSmDisableAllocate(void);
RPC_STATUS __attribute__((__stdcall__)) RpcSmEnableAllocate(void);
RPC_STATUS __attribute__((__stdcall__)) RpcSmFree(void*);
RPC_SS_THREAD_HANDLE __attribute__((__stdcall__)) RpcSmGetThreadHandle(RPC_STATUS*);
RPC_STATUS __attribute__((__stdcall__)) RpcSmSetClientAllocFree(RPC_CLIENT_ALLOC*,RPC_CLIENT_FREE*);
RPC_STATUS __attribute__((__stdcall__)) RpcSmSetThreadHandle(RPC_SS_THREAD_HANDLE);
RPC_STATUS __attribute__((__stdcall__)) RpcSmSwapClientAllocFree(RPC_CLIENT_ALLOC*,RPC_CLIENT_FREE*,RPC_CLIENT_ALLOC**,RPC_CLIENT_FREE**);
void __attribute__((__stdcall__)) NdrRpcSsEnableAllocate(PMIDL_STUB_MESSAGE);
void __attribute__((__stdcall__)) NdrRpcSsDisableAllocate(PMIDL_STUB_MESSAGE);
void __attribute__((__stdcall__)) NdrRpcSmSetClientToOsf(PMIDL_STUB_MESSAGE);
void*__attribute__((__stdcall__)) NdrRpcSmClientAllocate(unsigned int);
void __attribute__((__stdcall__)) NdrRpcSmClientFree(void*);
void*__attribute__((__stdcall__)) NdrRpcSsDefaultAllocate(unsigned int);
void __attribute__((__stdcall__)) NdrRpcSsDefaultFree(void*);
PFULL_PTR_XLAT_TABLES __attribute__((__stdcall__)) NdrFullPointerXlatInit(unsigned long,XLAT_SIDE);
void __attribute__((__stdcall__)) NdrFullPointerXlatFree(PFULL_PTR_XLAT_TABLES);
int __attribute__((__stdcall__)) NdrFullPointerQueryPointer(PFULL_PTR_XLAT_TABLES,void*,unsigned char,unsigned long*);
int __attribute__((__stdcall__)) NdrFullPointerQueryRefId(PFULL_PTR_XLAT_TABLES,unsigned long,unsigned char,void**);
void __attribute__((__stdcall__)) NdrFullPointerInsertRefId(PFULL_PTR_XLAT_TABLES,unsigned long,void*);
int __attribute__((__stdcall__)) NdrFullPointerFree(PFULL_PTR_XLAT_TABLES,void*);
void*__attribute__((__stdcall__)) NdrAllocate(PMIDL_STUB_MESSAGE,unsigned int);
void __attribute__((__stdcall__)) NdrClearOutParameters(PMIDL_STUB_MESSAGE,PFORMAT_STRING,void*);
void*__attribute__((__stdcall__)) NdrOleAllocate(unsigned int);
void __attribute__((__stdcall__)) NdrOleFree(void*);
unsigned char*__attribute__((__stdcall__)) NdrUserMarshalMarshall(PMIDL_STUB_MESSAGE,unsigned char*,PFORMAT_STRING);
unsigned char*__attribute__((__stdcall__)) NdrUserMarshalUnmarshall(PMIDL_STUB_MESSAGE,unsigned char**,PFORMAT_STRING,unsigned char);
void __attribute__((__stdcall__)) NdrUserMarshalBufferSize(PMIDL_STUB_MESSAGE,unsigned char*,PFORMAT_STRING);
unsigned long __attribute__((__stdcall__)) NdrUserMarshalMemorySize(PMIDL_STUB_MESSAGE,PFORMAT_STRING);
void __attribute__((__stdcall__)) NdrUserMarshalFree(PMIDL_STUB_MESSAGE,unsigned char*,PFORMAT_STRING);

}
# 5 "H:/CPP/wxdevcpp6.10/include/objbase.h" 2 3




       
# 10 "H:/CPP/wxdevcpp6.10/include/objbase.h" 3



#pragma pack(push,8)
# 54 "H:/CPP/wxdevcpp6.10/include/objbase.h" 3
typedef enum tagSTGFMT {
 STGFMT_STORAGE = 0,
 STGFMT_FILE = 3,
 STGFMT_ANY = 4,
 STGFMT_DOCFILE = 5
} STGFMT;
typedef struct tagSTGOPTIONS {
 USHORT usVersion;
 USHORT reserved;
 ULONG ulSectorSize;
 const WCHAR *pwcsTemplateFile;
} STGOPTIONS;
typedef enum tagREGCLS {
 REGCLS_SINGLEUSE = 0,
 REGCLS_MULTIPLEUSE = 1,
 REGCLS_MULTI_SEPARATE = 2
} REGCLS;
# 1 "H:/CPP/wxdevcpp6.10/include/wtypes.h" 1 3
# 1 "H:/CPP/wxdevcpp6.10/include/rpc.h" 1 3
# 2 "H:/CPP/wxdevcpp6.10/include/wtypes.h" 2 3





       
# 8 "H:/CPP/wxdevcpp6.10/include/wtypes.h" 3



extern "C" {
# 33 "H:/CPP/wxdevcpp6.10/include/wtypes.h" 3
typedef enum tagDVASPECT {
 DVASPECT_CONTENT=1,
 DVASPECT_THUMBNAIL=2,
 DVASPECT_ICON=4,
 DVASPECT_DOCPRINT=8
} DVASPECT;
typedef enum tagDVASPECT2 {
 DVASPECT_OPAQUE=16,
 DVASPECT_TRANSPARENT=32
} DVASPECT2;
typedef enum tagSTATFLAG {
 STATFLAG_DEFAULT=0,
 STATFLAG_NONAME=1
} STATFLAG;
typedef enum tagMEMCTX {
 MEMCTX_LOCAL=0,
 MEMCTX_TASK,
 MEMCTX_SHARED,
 MEMCTX_MACSYSTEM,
 MEMCTX_UNKNOWN=-1,
 MEMCTX_SAME=-2
} MEMCTX;
typedef enum tagMSHCTX {
 MSHCTX_LOCAL=0,
 MSHCTX_NOSHAREDMEM,
 MSHCTX_DIFFERENTMACHINE,
 MSHCTX_INPROC,
 MSHCTX_CROSSCTX
} MSHCTX;
typedef enum tagCLSCTX {
 CLSCTX_INPROC_SERVER=1,CLSCTX_INPROC_HANDLER=2,CLSCTX_LOCAL_SERVER=4,
 CLSCTX_INPROC_SERVER16=8,CLSCTX_REMOTE_SERVER=16
} CLSCTX;
typedef enum tagMSHLFLAGS {
 MSHLFLAGS_NORMAL,MSHLFLAGS_TABLESTRONG,MSHLFLAGS_TABLEWEAK
} MSHLFLAGS;
typedef struct _FLAGGED_WORD_BLOB {
 unsigned long fFlags;
 unsigned long clSize;
 unsigned short asData[1];
}FLAGGED_WORD_BLOB;


typedef WCHAR OLECHAR;
typedef LPWSTR LPOLESTR;
typedef LPCWSTR LPCOLESTR;







typedef unsigned short VARTYPE;
typedef short VARIANT_BOOL;
typedef VARIANT_BOOL _VARIANT_BOOL;


typedef OLECHAR *BSTR;
typedef FLAGGED_WORD_BLOB *wireBSTR;
typedef BSTR *LPBSTR;
typedef LONG SCODE;
typedef void *HCONTEXT;
typedef union tagCY {
 __extension__ struct {
  unsigned long Lo;
  long Hi;
 };
 LONGLONG int64;
} CY;
typedef double DATE;
typedef struct tagBSTRBLOB {
 ULONG cbSize;
 PBYTE pData;
}BSTRBLOB;
typedef struct tagBSTRBLOB *LPBSTRBLOB;
typedef struct tagCLIPDATA {
 ULONG cbSize;
 long ulClipFmt;
 PBYTE pClipData;
}CLIPDATA;
typedef enum tagSTGC {
 STGC_DEFAULT,STGC_OVERWRITE,STGC_ONLYIFCURRENT,
 STGC_DANGEROUSLYCOMMITMERELYTODISKCACHE
}STGC;
typedef enum tagSTGMOVE {
 STGMOVE_MOVE,STGMOVE_COPY,STGMOVE_SHALLOWCOPY
}STGMOVE;
enum VARENUM {
 VT_EMPTY,VT_NULL,VT_I2,VT_I4,VT_R4,VT_R8,VT_CY,VT_DATE,VT_BSTR,VT_DISPATCH,
 VT_ERROR,VT_BOOL,VT_VARIANT,VT_UNKNOWN,VT_DECIMAL,VT_I1=16,VT_UI1,VT_UI2,VT_UI4,VT_I8,
 VT_UI8,VT_INT,VT_UINT,VT_VOID,VT_HRESULT,VT_PTR,VT_SAFEARRAY,VT_CARRAY,VT_USERDEFINED,
 VT_LPSTR,VT_LPWSTR,VT_RECORD=36,VT_INT_PTR=37,VT_UINT_PTR=38,VT_FILETIME=64,VT_BLOB,VT_STREAM,VT_STORAGE,VT_STREAMED_OBJECT,
 VT_STORED_OBJECT,VT_BLOB_OBJECT,VT_CF,VT_CLSID,VT_BSTR_BLOB=0xfff,VT_VECTOR=0x1000,
 VT_ARRAY=0x2000,VT_BYREF=0x4000,VT_RESERVED=0x8000,VT_ILLEGAL= 0xffff,VT_ILLEGALMASKED=0xfff,
 VT_TYPEMASK=0xfff
};

typedef struct _BYTE_SIZEDARR {
 unsigned long clSize;
 byte *pData;
}BYTE_SIZEDARR;
typedef struct _SHORT_SIZEDARR {
 unsigned long clSize;
 unsigned short *pData;
}WORD_SIZEDARR;
typedef struct _LONG_SIZEDARR {
 unsigned long clSize;
 unsigned long *pData;
}DWORD_SIZEDARR;
typedef struct _HYPER_SIZEDARR {
 unsigned long clSize;
 long long *pData;
}HYPER_SIZEDARR;
typedef double DOUBLE;
typedef struct tagDEC {
 USHORT wReserved;
 __extension__ union {
  __extension__ struct {
   BYTE scale;
   BYTE sign;
  };
  USHORT signscale;
 } ;
 ULONG Hi32;
 __extension__ union {
  __extension__ struct {
   ULONG Lo32;
   ULONG Mid32;
  };
  ULONGLONG Lo64;
 } ;
} DECIMAL;
typedef void *HMETAFILEPICT;

}
# 72 "H:/CPP/wxdevcpp6.10/include/objbase.h" 2 3
# 1 "H:/CPP/wxdevcpp6.10/include/unknwn.h" 1 3







       
# 9 "H:/CPP/wxdevcpp6.10/include/unknwn.h" 3



extern "C"{


# 1 "H:/CPP/wxdevcpp6.10/include/wtypes.h" 1 3
# 1 "H:/CPP/wxdevcpp6.10/include/rpc.h" 1 3
# 2 "H:/CPP/wxdevcpp6.10/include/wtypes.h" 2 3
# 16 "H:/CPP/wxdevcpp6.10/include/unknwn.h" 2 3

void * __attribute__((__stdcall__)) MIDL_user_allocate(size_t);
void __attribute__((__stdcall__)) MIDL_user_free(void*);
extern "C" const IID IID_IUnknown;
extern "C" const IID IID_IClassFactory;




struct IUnknown
{
 virtual HRESULT __attribute__((__stdcall__)) QueryInterface( const IID&,PVOID*) =0;
 virtual ULONG __attribute__((__stdcall__)) AddRef(void) =0;
 virtual ULONG __attribute__((__stdcall__)) Release(void) =0;
};
typedef IUnknown *LPUNKNOWN;





struct IClassFactory : public IUnknown
{
 virtual HRESULT __attribute__((__stdcall__)) QueryInterface( const IID&,PVOID*) =0;
 virtual ULONG __attribute__((__stdcall__)) AddRef(void) =0;
 virtual ULONG __attribute__((__stdcall__)) Release(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) CreateInstance( LPUNKNOWN,const IID&,PVOID*) =0;
 virtual HRESULT __attribute__((__stdcall__)) LockServer( BOOL) =0;
};
typedef IClassFactory *LPCLASSFACTORY;

HRESULT __attribute__((__stdcall__)) IUnknown_QueryInterface_Proxy(IUnknown*,const IID&,void**);
void __attribute__((__stdcall__)) IUnknown_QueryInterface_Stub(LPRPCSTUBBUFFER,LPRPCCHANNELBUFFER,PRPC_MESSAGE,PDWORD);
ULONG __attribute__((__stdcall__)) IUnknown_AddRef_Proxy(IUnknown*);
void __attribute__((__stdcall__)) IUnknown_AddRef_Stub(LPRPCSTUBBUFFER,LPRPCCHANNELBUFFER,PRPC_MESSAGE,PDWORD);
ULONG __attribute__((__stdcall__)) IUnknown_Release_Proxy(IUnknown*);
void __attribute__((__stdcall__)) IUnknown_Release_Stub(LPRPCSTUBBUFFER,LPRPCCHANNELBUFFER,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IClassFactory_RemoteCreateInstance_Proxy(IClassFactory*,const IID&,IUnknown**);
void __attribute__((__stdcall__)) IClassFactory_RemoteCreateInstance_Stub(LPRPCSTUBBUFFER,LPRPCCHANNELBUFFER,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IClassFactory_RemoteLockServer_Proxy(IClassFactory*,BOOL);
void __attribute__((__stdcall__)) IClassFactory_RemoteLockServer_Stub(LPRPCSTUBBUFFER,LPRPCCHANNELBUFFER,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IClassFactory_CreateInstance_Proxy(IClassFactory*,IUnknown*,const IID&,void**);
HRESULT __attribute__((__stdcall__)) IClassFactory_CreateInstance_Stub(IClassFactory*,const IID&,IUnknown**);
HRESULT __attribute__((__stdcall__)) IClassFactory_LockServer_Proxy(IClassFactory*,BOOL);
HRESULT __attribute__((__stdcall__)) IClassFactory_LockServer_Stub(IClassFactory*,BOOL);
# 74 "H:/CPP/wxdevcpp6.10/include/unknwn.h" 3
}
# 73 "H:/CPP/wxdevcpp6.10/include/objbase.h" 2 3
# 1 "H:/CPP/wxdevcpp6.10/include/objidl.h" 1 3



       
# 5 "H:/CPP/wxdevcpp6.10/include/objidl.h" 3




typedef struct tagSTATSTG {
 LPOLESTR pwcsName;
 DWORD type;
 ULARGE_INTEGER cbSize;
 FILETIME mtime;
 FILETIME ctime;
 FILETIME atime;
 DWORD grfMode;
 DWORD grfLocksSupported;
 CLSID clsid;
 DWORD grfStateBits;
 DWORD reserved;
} STATSTG;
typedef enum tagSTGTY {
 STGTY_STORAGE=1,
 STGTY_STREAM,
 STGTY_LOCKBYTES,
 STGTY_PROPERTY
} STGTY;
typedef enum tagSTREAM_SEEK {
 STREAM_SEEK_SET,
 STREAM_SEEK_CUR,
 STREAM_SEEK_END
} STREAM_SEEK;
typedef struct tagINTERFACEINFO {
 LPUNKNOWN pUnk;
 IID iid;
 WORD wMethod;
} INTERFACEINFO,*LPINTERFACEINFO;
typedef enum tagCALLTYPE {
 CALLTYPE_TOPLEVEL=1,
 CALLTYPE_NESTED,
 CALLTYPE_ASYNC,
 CALLTYPE_TOPLEVEL_CALLPENDING,
 CALLTYPE_ASYNC_CALLPENDING
} CALLTYPE;
typedef enum tagPENDINGTYPE {
 PENDINGTYPE_TOPLEVEL=1,
 PENDINGTYPE_NESTED
} PENDINGTYPE;
typedef enum tagPENDINGMSG {
 PENDINGMSG_CANCELCALL=0,
 PENDINGMSG_WAITNOPROCESS,
 PENDINGMSG_WAITDEFPROCESS
} PENDINGMSG;
typedef OLECHAR **SNB;
typedef enum tagDATADIR {
 DATADIR_GET=1,
 DATADIR_SET
} DATADIR;
typedef WORD CLIPFORMAT,*LPCLIPFORMAT;
typedef struct tagDVTARGETDEVICE {
 DWORD tdSize;
 WORD tdDriverNameOffset;
 WORD tdDeviceNameOffset;
 WORD tdPortNameOffset;
 WORD tdExtDevmodeOffset;
 BYTE tdData[1];
} DVTARGETDEVICE;
typedef struct tagFORMATETC {
 CLIPFORMAT cfFormat;
 DVTARGETDEVICE*ptd;
 DWORD dwAspect;
 LONG lindex;
 DWORD tymed;
} FORMATETC,*LPFORMATETC;
typedef struct tagRemSTGMEDIUM {
 DWORD tymed;
 DWORD dwHandleType;
 ULONG pData;
 unsigned long pUnkForRelease;
 unsigned long cbData;
 BYTE data[1];
} RemSTGMEDIUM;
typedef struct tagHLITEM {
 ULONG uHLID;
 LPWSTR pwzFriendlyName;
} HLITEM;
typedef struct tagSTATDATA {
 FORMATETC formatetc;
 DWORD grfAdvf;
 struct IAdviseSink *pAdvSink;
 DWORD dwConnection;
} STATDATA;
typedef struct tagSTATPROPSETSTG {
 FMTID fmtid;
 CLSID clsid;
 DWORD grfFlags;
 FILETIME mtime;
 FILETIME ctime;
 FILETIME atime;
} STATPROPSETSTG;
typedef enum tagEXTCONN {
 EXTCONN_STRONG=1,
 EXTCONN_WEAK=2,
 EXTCONN_CALLABLE=4
} EXTCONN;
typedef struct tagMULTI_QI {
 const IID *pIID;
 IUnknown *pItf;
 HRESULT hr;
} MULTI_QI;
typedef struct _AUTH_IDENTITY {
 USHORT *User;
 ULONG UserLength;
 USHORT *Domain;
 ULONG DomainLength;
 USHORT *Password;
 ULONG PasswordLength;
 ULONG Flags;
} AUTH_IDENTITY;
typedef struct _COAUTHINFO{
 DWORD dwAuthnSvc;
 DWORD dwAuthzSvc;
 LPWSTR pwszServerPrincName;
 DWORD dwAuthnLevel;
 DWORD dwImpersonationLevel;
 AUTH_IDENTITY *pAuthIdentityData;
 DWORD dwCapabilities;
} COAUTHINFO;
typedef struct _COSERVERINFO {
 DWORD dwReserved1;
 LPWSTR pwszName;
 COAUTHINFO *pAuthInfo;
 DWORD dwReserved2;
} COSERVERINFO;
typedef struct tagBIND_OPTS {
 DWORD cbStruct;
 DWORD grfFlags;
 DWORD grfMode;
 DWORD dwTickCountDeadline;
} BIND_OPTS,*LPBIND_OPTS;
typedef struct tagBIND_OPTS2 {
 DWORD cbStruct;
 DWORD grfFlags;
 DWORD grfMode;
 DWORD dwTickCountDeadline;
 DWORD dwTrackFlags;
 DWORD dwClassContext;
 LCID locale;
 COSERVERINFO *pServerInfo;
} BIND_OPTS2,*LPBIND_OPTS2;
typedef enum tagBIND_FLAGS {
 BIND_MAYBOTHERUSER=1,
 BIND_JUSTTESTEXISTENCE
} BIND_FLAGS;
typedef struct tagSTGMEDIUM {
 DWORD tymed;
 __extension__ union {
  HBITMAP hBitmap;
  PVOID hMetaFilePict;
  HENHMETAFILE hEnhMetaFile;
  HGLOBAL hGlobal;
  LPWSTR lpszFileName;
  LPSTREAM pstm;
  LPSTORAGE pstg;
 } ;
 LPUNKNOWN pUnkForRelease;
} STGMEDIUM,*LPSTGMEDIUM;
typedef enum tagLOCKTYPE {
 LOCK_WRITE=1,
 LOCK_EXCLUSIVE=2,
 LOCK_ONLYONCE=4
} LOCKTYPE;
typedef unsigned long RPCOLEDATAREP;
typedef struct tagRPCOLEMESSAGE {
 PVOID reserved1;
 RPCOLEDATAREP dataRepresentation;
 PVOID Buffer;
 ULONG cbBuffer;
 ULONG iMethod;
 PVOID reserved2[5];
 ULONG rpcFlags;
} RPCOLEMESSAGE, *PRPCOLEMESSAGE;
typedef enum tagMKSYS {
 MKSYS_NONE,
 MKSYS_GENERICCOMPOSITE,
 MKSYS_FILEMONIKER,
 MKSYS_ANTIMONIKER,
 MKSYS_ITEMMONIKER,
 MKSYS_POINTERMONIKER
} MKSYS;
typedef enum tagMKREDUCE {
 MKRREDUCE_ALL,
 MKRREDUCE_ONE=196608,
 MKRREDUCE_TOUSER=131072,
 MKRREDUCE_THROUGHUSER=65536
} MKRREDUCE;
typedef struct tagRemSNB {
 unsigned long ulCntStr;
 unsigned long ulCntChar;
 OLECHAR rgString[1];
} RemSNB;
typedef enum tagADVF {
 ADVF_NODATA=1,ADVF_PRIMEFIRST=2,ADVF_ONLYONCE=4,ADVF_DATAONSTOP=64,
 ADVFCACHE_NOHANDLER=8,ADVFCACHE_FORCEBUILTIN=16,ADVFCACHE_ONSAVE=32
} ADVF;
typedef enum tagTYMED {
 TYMED_HGLOBAL=1,TYMED_FILE=2,TYMED_ISTREAM=4,TYMED_ISTORAGE=8,
 TYMED_GDI=16,TYMED_MFPICT=32,TYMED_ENHMF=64,TYMED_NULL=0
} TYMED;
typedef enum tagSERVERCALL {
 SERVERCALL_ISHANDLED,SERVERCALL_REJECTED,SERVERCALL_RETRYLATER
} SERVERCALL;
typedef struct tagCAUB {
 ULONG cElems;
 unsigned char *pElems;
}CAUB;
typedef struct tagCAI {
 ULONG cElems;
 short *pElems;
}CAI;
typedef struct tagCAUI {
 ULONG cElems;
 USHORT *pElems;
}CAUI;
typedef struct tagCAL {
 ULONG cElems;
 long *pElems;
}CAL;
typedef struct tagCAUL {
 ULONG cElems;
 ULONG *pElems;
}CAUL;
typedef struct tagCAFLT {
 ULONG cElems;
 float *pElems;
}CAFLT;
typedef struct tagCADBL {
 ULONG cElems;
 double *pElems;
}CADBL;
typedef struct tagCACY {
 ULONG cElems;
 CY *pElems;
}CACY;
typedef struct tagCADATE {
 ULONG cElems;
 DATE *pElems;
}CADATE;
typedef struct tagCABSTR {
 ULONG cElems;
 BSTR *pElems;
}CABSTR;
typedef struct tagCABSTRBLOB {
 ULONG cElems;
 BSTRBLOB *pElems;
}CABSTRBLOB;
typedef struct tagCABOOL {
 ULONG cElems;
 VARIANT_BOOL *pElems;
}CABOOL;
typedef struct tagCASCODE {
 ULONG cElems;
 SCODE *pElems;
}CASCODE;
typedef struct tagCAH {
 ULONG cElems;
 LARGE_INTEGER *pElems;
}CAH;
typedef struct tagCAUH {
 ULONG cElems;
 ULARGE_INTEGER *pElems;
}CAUH;
typedef struct tagCALPSTR {
 ULONG cElems;
 LPSTR *pElems;
}CALPSTR;
typedef struct tagCALPWSTR {
 ULONG cElems;
 LPWSTR *pElems;
}CALPWSTR;
typedef struct tagCAFILETIME {
 ULONG cElems;
 FILETIME *pElems;
}CAFILETIME;
typedef struct tagCACLIPDATA {
 ULONG cElems;
 CLIPDATA *pElems;
}CACLIPDATA;
typedef struct tagCACLSID {
 ULONG cElems;
 CLSID *pElems;
}CACLSID;
typedef struct tagPROPVARIANT *LPPROPVARIANT;
typedef struct tagCAPROPVARIANT {
 ULONG cElems;
 LPPROPVARIANT pElems;
}CAPROPVARIANT;
typedef struct tagPROPVARIANT {
 VARTYPE vt;
 WORD wReserved1;
 WORD wReserved2;
 WORD wReserved3;
 __extension__ union {
  CHAR cVal;
  UCHAR bVal;
  short iVal;
  USHORT uiVal;
  VARIANT_BOOL boolVal;





  long lVal;
  ULONG ulVal;
  float fltVal;
  SCODE scode;
  LARGE_INTEGER hVal;
  ULARGE_INTEGER uhVal;
  double dblVal;
  CY cyVal;
  DATE date;
  FILETIME filetime;
  CLSID *puuid;
  BLOB blob;
  CLIPDATA *pclipdata;
  LPSTREAM pStream;
  LPSTORAGE pStorage;
  BSTR bstrVal;
  BSTRBLOB bstrblobVal;
  LPSTR pszVal;
  LPWSTR pwszVal;
  CAUB caub;
  CAI cai;
  CAUI caui;
  CABOOL cabool;
  CAL cal;
  CAUL caul;
  CAFLT caflt;
  CASCODE cascode;
  CAH cah;
  CAUH cauh;
  CADBL cadbl;
  CACY cacy;
  CADATE cadate;
  CAFILETIME cafiletime;
  CACLSID cauuid;
  CACLIPDATA caclipdata;
  CABSTR cabstr;
  CABSTRBLOB cabstrblob;
  CALPSTR calpstr;
  CALPWSTR calpwstr;
  CAPROPVARIANT capropvar;
 } ;
} PROPVARIANT;
typedef struct tagPROPSPEC {
 ULONG ulKind;
 __extension__ union {
  PROPID propid;
  LPOLESTR lpwstr;
 } ;
}PROPSPEC;
typedef struct tagSTATPROPSTG {
 LPOLESTR lpwstrName;
 PROPID propid;
 VARTYPE vt;
} STATPROPSTG;
typedef enum PROPSETFLAG {
 PROPSETFLAG_DEFAULT,PROPSETFLAG_NONSIMPLE,PROPSETFLAG_ANSI,
 PROPSETFLAG_UNBUFFERED=4
} PROPSETFLAG;
typedef struct tagSTORAGELAYOUT {
 DWORD LayoutType;
 OLECHAR* pwcsElementName;
 LARGE_INTEGER cOffset;
 LARGE_INTEGER cBytes;
} STORAGELAYOUT;
typedef struct tagSOLE_AUTHENTICATION_SERVICE {
    DWORD dwAuthnSvc;
    DWORD dwAuthzSvc;
    OLECHAR *pPrincipalName;
    HRESULT hr;
} SOLE_AUTHENTICATION_SERVICE;

typedef enum tagEOLE_AUTHENTICATION_CAPABILITIES {
 EOAC_NONE = 0,
 EOAC_MUTUAL_AUTH = 0x1,
 EOAC_STATIC_CLOAKING = 0x20,
 EOAC_DYNAMIC_CLOAKING = 0x40,
 EOAC_ANY_AUTHORITY = 0x80,
 EOAC_MAKE_FULLSIC = 0x100,
 EOAC_DEFAULT = 0x800,
 EOAC_SECURE_REFS = 0x2,
 EOAC_ACCESS_CONTROL = 0x4,
 EOAC_APPID = 0x8,
 EOAC_DYNAMIC = 0x10,
 EOAC_REQUIRE_FULLSIC = 0x200,
 EOAC_AUTO_IMPERSONATE = 0x400,
 EOAC_NO_CUSTOM_MARSHAL = 0x2000,
 EOAC_DISABLE_AAA = 0x1000
} EOLE_AUTHENTICATION_CAPABILITIES;
typedef struct tagSOLE_AUTHENTICATION_INFO {
    DWORD dwAuthnSvc;
    DWORD dwAuthzSvc;
    void* pAuthInfo;
} SOLE_AUTHENTICATION_INFO;

typedef struct tagSOLE_AUTHENTICATION_LIST {
    DWORD cAuthInfo;
    SOLE_AUTHENTICATION_INFO* aAuthInfo;
} SOLE_AUTHENTICATION_LIST;

extern "C" const FMTID FMTID_SummaryInformation;
extern "C" const FMTID FMTID_DocSummaryInformation;
extern "C" const FMTID FMTID_UserDefinedProperties;

struct IEnumFORMATETC : public IUnknown { virtual HRESULT __attribute__((__stdcall__)) QueryInterface( const IID&,PVOID*) =0; virtual ULONG __attribute__((__stdcall__)) AddRef() =0; virtual ULONG __attribute__((__stdcall__)) Release() =0; virtual HRESULT __attribute__((__stdcall__)) Next( ULONG,FORMATETC*,ULONG*) =0; virtual HRESULT __attribute__((__stdcall__)) Skip( ULONG) =0; virtual HRESULT __attribute__((__stdcall__)) Reset() =0; virtual HRESULT __attribute__((__stdcall__)) Clone( IEnumFORMATETC**) =0; };
struct IEnumHLITEM : public IUnknown { virtual HRESULT __attribute__((__stdcall__)) QueryInterface( const IID&,PVOID*) =0; virtual ULONG __attribute__((__stdcall__)) AddRef() =0; virtual ULONG __attribute__((__stdcall__)) Release() =0; virtual HRESULT __attribute__((__stdcall__)) Next( ULONG,HLITEM*,ULONG*) =0; virtual HRESULT __attribute__((__stdcall__)) Skip( ULONG) =0; virtual HRESULT __attribute__((__stdcall__)) Reset() =0; virtual HRESULT __attribute__((__stdcall__)) Clone( IEnumHLITEM**) =0; };
struct IEnumSTATDATA : public IUnknown { virtual HRESULT __attribute__((__stdcall__)) QueryInterface( const IID&,PVOID*) =0; virtual ULONG __attribute__((__stdcall__)) AddRef() =0; virtual ULONG __attribute__((__stdcall__)) Release() =0; virtual HRESULT __attribute__((__stdcall__)) Next( ULONG,STATDATA*,ULONG*) =0; virtual HRESULT __attribute__((__stdcall__)) Skip( ULONG) =0; virtual HRESULT __attribute__((__stdcall__)) Reset() =0; virtual HRESULT __attribute__((__stdcall__)) Clone( IEnumSTATDATA**) =0; };
struct IEnumSTATPROPSETSTG : public IUnknown { virtual HRESULT __attribute__((__stdcall__)) QueryInterface( const IID&,PVOID*) =0; virtual ULONG __attribute__((__stdcall__)) AddRef() =0; virtual ULONG __attribute__((__stdcall__)) Release() =0; virtual HRESULT __attribute__((__stdcall__)) Next( ULONG,STATPROPSETSTG*,ULONG*) =0; virtual HRESULT __attribute__((__stdcall__)) Skip( ULONG) =0; virtual HRESULT __attribute__((__stdcall__)) Reset() =0; virtual HRESULT __attribute__((__stdcall__)) Clone( IEnumSTATPROPSETSTG**) =0; };
struct IEnumSTATPROPSTG : public IUnknown { virtual HRESULT __attribute__((__stdcall__)) QueryInterface( const IID&,PVOID*) =0; virtual ULONG __attribute__((__stdcall__)) AddRef() =0; virtual ULONG __attribute__((__stdcall__)) Release() =0; virtual HRESULT __attribute__((__stdcall__)) Next( ULONG,STATPROPSTG*,ULONG*) =0; virtual HRESULT __attribute__((__stdcall__)) Skip( ULONG) =0; virtual HRESULT __attribute__((__stdcall__)) Reset() =0; virtual HRESULT __attribute__((__stdcall__)) Clone( IEnumSTATPROPSTG**) =0; };
struct IEnumSTATSTG : public IUnknown { virtual HRESULT __attribute__((__stdcall__)) QueryInterface( const IID&,PVOID*) =0; virtual ULONG __attribute__((__stdcall__)) AddRef() =0; virtual ULONG __attribute__((__stdcall__)) Release() =0; virtual HRESULT __attribute__((__stdcall__)) Next( ULONG,STATSTG*,ULONG*) =0; virtual HRESULT __attribute__((__stdcall__)) Skip( ULONG) =0; virtual HRESULT __attribute__((__stdcall__)) Reset() =0; virtual HRESULT __attribute__((__stdcall__)) Clone( IEnumSTATSTG**) =0; };
struct IEnumString : public IUnknown { virtual HRESULT __attribute__((__stdcall__)) QueryInterface( const IID&,PVOID*) =0; virtual ULONG __attribute__((__stdcall__)) AddRef() =0; virtual ULONG __attribute__((__stdcall__)) Release() =0; virtual HRESULT __attribute__((__stdcall__)) Next( ULONG,LPOLESTR*,ULONG*) =0; virtual HRESULT __attribute__((__stdcall__)) Skip( ULONG) =0; virtual HRESULT __attribute__((__stdcall__)) Reset() =0; virtual HRESULT __attribute__((__stdcall__)) Clone( IEnumString**) =0; };
struct IEnumMoniker : public IUnknown { virtual HRESULT __attribute__((__stdcall__)) QueryInterface( const IID&,PVOID*) =0; virtual ULONG __attribute__((__stdcall__)) AddRef() =0; virtual ULONG __attribute__((__stdcall__)) Release() =0; virtual HRESULT __attribute__((__stdcall__)) Next( ULONG,struct IMoniker**,ULONG*) =0; virtual HRESULT __attribute__((__stdcall__)) Skip( ULONG) =0; virtual HRESULT __attribute__((__stdcall__)) Reset() =0; virtual HRESULT __attribute__((__stdcall__)) Clone( IEnumMoniker**) =0; };
struct IEnumUnknown : public IUnknown { virtual HRESULT __attribute__((__stdcall__)) QueryInterface( const IID&,PVOID*) =0; virtual ULONG __attribute__((__stdcall__)) AddRef() =0; virtual ULONG __attribute__((__stdcall__)) Release() =0; virtual HRESULT __attribute__((__stdcall__)) Next( ULONG,IUnknown**,ULONG*) =0; virtual HRESULT __attribute__((__stdcall__)) Skip( ULONG) =0; virtual HRESULT __attribute__((__stdcall__)) Reset() =0; virtual HRESULT __attribute__((__stdcall__)) Clone( IEnumUnknown**) =0; };

extern "C" const IID IID_ISequentialStream;


struct ISequentialStream : public IUnknown
{
 virtual HRESULT __attribute__((__stdcall__)) QueryInterface( const IID&,PVOID*) =0;
 virtual ULONG __attribute__((__stdcall__)) AddRef(void) =0;
 virtual ULONG __attribute__((__stdcall__)) Release(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) Read( void*,ULONG,ULONG*) =0;
 virtual HRESULT __attribute__((__stdcall__)) Write( void const*,ULONG,ULONG*) =0;
};

extern "C" const IID IID_IStream;


struct IStream : public ISequentialStream
{
 virtual HRESULT __attribute__((__stdcall__)) QueryInterface( const IID&,PVOID*) =0;
 virtual ULONG __attribute__((__stdcall__)) AddRef(void) =0;
 virtual ULONG __attribute__((__stdcall__)) Release(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) Read( void*,ULONG,ULONG*) =0;
 virtual HRESULT __attribute__((__stdcall__)) Write( void const*,ULONG,ULONG*) =0;
 virtual HRESULT __attribute__((__stdcall__)) Seek( LARGE_INTEGER,DWORD,ULARGE_INTEGER*) =0;
 virtual HRESULT __attribute__((__stdcall__)) SetSize( ULARGE_INTEGER) =0;
 virtual HRESULT __attribute__((__stdcall__)) CopyTo( IStream*,ULARGE_INTEGER,ULARGE_INTEGER*,ULARGE_INTEGER*) =0;
 virtual HRESULT __attribute__((__stdcall__)) Commit( DWORD) =0;
 virtual HRESULT __attribute__((__stdcall__)) Revert(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) LockRegion( ULARGE_INTEGER,ULARGE_INTEGER,DWORD) =0;
 virtual HRESULT __attribute__((__stdcall__)) UnlockRegion( ULARGE_INTEGER,ULARGE_INTEGER,DWORD) =0;
 virtual HRESULT __attribute__((__stdcall__)) Stat( STATSTG*,DWORD) =0;
 virtual HRESULT __attribute__((__stdcall__)) Clone( LPSTREAM*) =0;
};

extern "C" const IID IID_IMarshal;


struct IMarshal : public IUnknown
{
 virtual HRESULT __attribute__((__stdcall__)) QueryInterface( const IID&,PVOID*) =0;
 virtual ULONG __attribute__((__stdcall__)) AddRef(void) =0;
 virtual ULONG __attribute__((__stdcall__)) Release(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetUnmarshalClass ( const IID&,PVOID,DWORD,PVOID,DWORD,CLSID*) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetMarshalSizeMax ( const IID&,PVOID,DWORD,PVOID,PDWORD,ULONG*) =0;
 virtual HRESULT __attribute__((__stdcall__)) MarshalInterface ( IStream*,const IID&,PVOID,DWORD,PVOID,DWORD) =0;
 virtual HRESULT __attribute__((__stdcall__)) UnmarshalInterface ( IStream*,const IID&,void**) =0;
 virtual HRESULT __attribute__((__stdcall__)) ReleaseMarshalData ( IStream*) =0;
 virtual HRESULT __attribute__((__stdcall__)) DisconnectObject ( DWORD) =0;
};

extern "C" const IID IID_IStdMarshalInfo;


struct IStdMarshalInfo : public IUnknown
{
 virtual HRESULT __attribute__((__stdcall__)) QueryInterface( const IID&,PVOID*) =0;
 virtual ULONG __attribute__((__stdcall__)) AddRef(void) =0;
 virtual ULONG __attribute__((__stdcall__)) Release(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetClassForHandler( DWORD,PVOID,CLSID*) =0;
};

extern "C" const IID IID_IMalloc;


struct IMalloc : public IUnknown
{
 virtual HRESULT __attribute__((__stdcall__)) QueryInterface( const IID&,PVOID*) =0;
 virtual ULONG __attribute__((__stdcall__)) AddRef(void) =0;
 virtual ULONG __attribute__((__stdcall__)) Release(void) =0;
 virtual void* __attribute__((__stdcall__)) Alloc( ULONG) =0;
 virtual void* __attribute__((__stdcall__)) Realloc( void*,ULONG) =0;
 virtual void __attribute__((__stdcall__)) Free( void*) =0;
 virtual ULONG __attribute__((__stdcall__)) GetSize( void*) =0;
 virtual int __attribute__((__stdcall__)) DidAlloc( void*) =0;
 virtual void __attribute__((__stdcall__)) HeapMinimize(void) =0;
};

extern "C" const IID IID_IMallocSpy;


struct IMallocSpy : public IUnknown
{
 virtual HRESULT __attribute__((__stdcall__)) QueryInterface( const IID&,PVOID*) =0;
 virtual ULONG __attribute__((__stdcall__)) AddRef(void) =0;
 virtual ULONG __attribute__((__stdcall__)) Release(void) =0;
 virtual ULONG __attribute__((__stdcall__)) PreAlloc( ULONG) =0;
 virtual void* __attribute__((__stdcall__)) PostAlloc( void*) =0;
 virtual void* __attribute__((__stdcall__)) PreFree( void*,BOOL) =0;
 virtual void __attribute__((__stdcall__)) PostFree( BOOL) =0;
 virtual ULONG __attribute__((__stdcall__)) PreRealloc( void*,ULONG,void**,BOOL) =0;
 virtual void* __attribute__((__stdcall__)) PostRealloc( void*,BOOL) =0;
 virtual void* __attribute__((__stdcall__)) PreGetSize( void*,BOOL) =0;
 virtual ULONG __attribute__((__stdcall__)) PostGetSize( ULONG,BOOL) =0;
 virtual void* __attribute__((__stdcall__)) PreDidAlloc( void*,BOOL) =0;
 virtual int __attribute__((__stdcall__)) PostDidAlloc( void*,BOOL,int) =0;
 virtual void __attribute__((__stdcall__)) PreHeapMinimize(void) =0;
 virtual void __attribute__((__stdcall__)) PostHeapMinimize(void) =0;
};

extern "C" const IID IID_IMessageFilter;


struct IMessageFilter : public IUnknown
{
 virtual HRESULT __attribute__((__stdcall__)) QueryInterface( const IID&,PVOID*) =0;
 virtual ULONG __attribute__((__stdcall__)) AddRef(void) =0;
 virtual ULONG __attribute__((__stdcall__)) Release(void) =0;
 virtual DWORD __attribute__((__stdcall__)) HandleInComingCall( DWORD,HTASK,DWORD,LPINTERFACEINFO) =0;
 virtual DWORD __attribute__((__stdcall__)) RetryRejectedCall( HTASK,DWORD,DWORD) =0;
 virtual DWORD __attribute__((__stdcall__)) MessagePending( HTASK,DWORD,DWORD) =0;
};

extern "C" const IID IID_IPersist;


struct IPersist : public IUnknown
{
 virtual HRESULT __attribute__((__stdcall__)) QueryInterface( const IID&,PVOID*) =0;
 virtual ULONG __attribute__((__stdcall__)) AddRef(void) =0;
 virtual ULONG __attribute__((__stdcall__)) Release(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetClassID( CLSID*) =0;
};

extern "C" const IID IID_IPersistStream;


struct IPersistStream : public IPersist
{
 virtual HRESULT __attribute__((__stdcall__)) QueryInterface( const IID&,PVOID*) =0;
 virtual ULONG __attribute__((__stdcall__)) AddRef(void) =0;
 virtual ULONG __attribute__((__stdcall__)) Release(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetClassID( LPCLSID) =0;
 virtual HRESULT __attribute__((__stdcall__)) IsDirty(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) Load( IStream*) =0;
 virtual HRESULT __attribute__((__stdcall__)) Save( IStream*,BOOL) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetSizeMax( PULARGE_INTEGER) =0;
};

extern "C" const IID IID_IRunningObjectTable;


struct IRunningObjectTable : public IUnknown
{
 virtual HRESULT __attribute__((__stdcall__)) QueryInterface( const IID&,PVOID*) =0;
 virtual ULONG __attribute__((__stdcall__)) AddRef(void) =0;
 virtual ULONG __attribute__((__stdcall__)) Release(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) Register( DWORD,LPUNKNOWN,LPMONIKER,PDWORD) =0;
 virtual HRESULT __attribute__((__stdcall__)) Revoke( DWORD) =0;
 virtual HRESULT __attribute__((__stdcall__)) IsRunning( LPMONIKER) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetObjectA( LPMONIKER,LPUNKNOWN*) =0;
 virtual HRESULT __attribute__((__stdcall__)) NoteChangeTime( DWORD,LPFILETIME) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetTimeOfLastChange( LPMONIKER,LPFILETIME) =0;
 virtual HRESULT __attribute__((__stdcall__)) EnumRunning( IEnumMoniker**) =0;
};

extern "C" const IID IID_IBindCtx;


struct IBindCtx : public IUnknown
{
 virtual HRESULT __attribute__((__stdcall__)) QueryInterface( const IID&,PVOID*) =0;
 virtual ULONG __attribute__((__stdcall__)) AddRef(void) =0;
 virtual ULONG __attribute__((__stdcall__)) Release(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) RegisterObjectBound( LPUNKNOWN) =0;
 virtual HRESULT __attribute__((__stdcall__)) RevokeObjectBound( LPUNKNOWN) =0;
 virtual HRESULT __attribute__((__stdcall__)) ReleaseBoundObjects(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) SetBindOptions( LPBIND_OPTS) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetBindOptions( LPBIND_OPTS) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetRunningObjectTable( IRunningObjectTable**) =0;
 virtual HRESULT __attribute__((__stdcall__)) RegisterObjectParam( LPOLESTR,IUnknown*) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetObjectParam( LPOLESTR,IUnknown**) =0;
 virtual HRESULT __attribute__((__stdcall__)) EnumObjectParam( IEnumString**) =0;
 virtual HRESULT __attribute__((__stdcall__)) RevokeObjectParam( LPOLESTR) =0;
};

extern "C" const IID IID_IMoniker;


struct IMoniker : public IPersistStream
{
 virtual HRESULT __attribute__((__stdcall__)) QueryInterface( const IID&,PVOID*) =0;
 virtual ULONG __attribute__((__stdcall__)) AddRef(void) =0;
 virtual ULONG __attribute__((__stdcall__)) Release(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetClassID( LPCLSID) =0;
 virtual HRESULT __attribute__((__stdcall__)) IsDirty(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) Load( IStream*) =0;
 virtual HRESULT __attribute__((__stdcall__)) Save( IStream*,BOOL) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetSizeMax( PULARGE_INTEGER) =0;
 virtual HRESULT __attribute__((__stdcall__)) BindToObject( IBindCtx*,IMoniker*,const IID&,PVOID*) =0;
 virtual HRESULT __attribute__((__stdcall__)) BindToStorage( IBindCtx*,IMoniker*,const IID&,PVOID*) =0;
 virtual HRESULT __attribute__((__stdcall__)) Reduce( IBindCtx*,DWORD,IMoniker**,IMoniker**) =0;
 virtual HRESULT __attribute__((__stdcall__)) ComposeWith( IMoniker*,BOOL,IMoniker**) =0;
 virtual HRESULT __attribute__((__stdcall__)) Enum( BOOL,IEnumMoniker**) =0;
 virtual HRESULT __attribute__((__stdcall__)) IsEqual( IMoniker*) =0;
 virtual HRESULT __attribute__((__stdcall__)) Hash( PDWORD) =0;
 virtual HRESULT __attribute__((__stdcall__)) IsRunning( IBindCtx*,IMoniker*,IMoniker*) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetTimeOfLastChange( IBindCtx*,IMoniker*,LPFILETIME) =0;
 virtual HRESULT __attribute__((__stdcall__)) Inverse( IMoniker**) =0;
 virtual HRESULT __attribute__((__stdcall__)) CommonPrefixWith( IMoniker*,IMoniker**) =0;
 virtual HRESULT __attribute__((__stdcall__)) RelativePathTo( IMoniker*,IMoniker**) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetDisplayName( IBindCtx*,IMoniker*,LPOLESTR*) =0;
 virtual HRESULT __attribute__((__stdcall__)) ParseDisplayName( IBindCtx*,IMoniker*,LPOLESTR,ULONG*,IMoniker**) =0;
 virtual HRESULT __attribute__((__stdcall__)) IsSystemMoniker( PDWORD) =0;
};

extern "C" const IID IID_IPersistStorage;


struct IPersistStorage : public IPersist
{
 virtual HRESULT __attribute__((__stdcall__)) QueryInterface( const IID&,PVOID*) =0;
 virtual ULONG __attribute__((__stdcall__)) AddRef(void) =0;
 virtual ULONG __attribute__((__stdcall__)) Release(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetClassID( CLSID*) =0;
 virtual HRESULT __attribute__((__stdcall__)) IsDirty(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) InitNew( LPSTORAGE) =0;
 virtual HRESULT __attribute__((__stdcall__)) Load( LPSTORAGE) =0;
 virtual HRESULT __attribute__((__stdcall__)) Save( LPSTORAGE,BOOL) =0;
 virtual HRESULT __attribute__((__stdcall__)) SaveCompleted( LPSTORAGE) =0;
 virtual HRESULT __attribute__((__stdcall__)) HandsOffStorage(void) =0;
};

extern "C" const IID IID_IPersistFile;


struct IPersistFile : public IPersist
{
 virtual HRESULT __attribute__((__stdcall__)) QueryInterface( const IID&,PVOID*) =0;
 virtual ULONG __attribute__((__stdcall__)) AddRef(void) =0;
 virtual ULONG __attribute__((__stdcall__)) Release(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetClassID( CLSID*) =0;
 virtual HRESULT __attribute__((__stdcall__)) IsDirty(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) Load( LPCOLESTR,DWORD) =0;
 virtual HRESULT __attribute__((__stdcall__)) Save( LPCOLESTR,BOOL) =0;
 virtual HRESULT __attribute__((__stdcall__)) SaveCompleted( LPCOLESTR) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetCurFile( LPOLESTR*) =0;
};

extern "C" const IID IID_IAdviseSink;


struct IAdviseSink : public IUnknown
{
 virtual HRESULT __attribute__((__stdcall__)) QueryInterface( const IID&,PVOID*) =0;
 virtual ULONG __attribute__((__stdcall__)) AddRef(void) =0;
 virtual ULONG __attribute__((__stdcall__)) Release(void) =0;
 virtual void __attribute__((__stdcall__)) OnDataChange( FORMATETC*,STGMEDIUM*) =0;
 virtual void __attribute__((__stdcall__)) OnViewChange( DWORD,LONG) =0;
 virtual void __attribute__((__stdcall__)) OnRename( IMoniker*) =0;
 virtual void __attribute__((__stdcall__)) OnSave(void) =0;
 virtual void __attribute__((__stdcall__)) OnClose(void) =0;
};

extern "C" const IID IID_IAdviseSink2;


struct IAdviseSink2 : public IAdviseSink
{
 virtual HRESULT __attribute__((__stdcall__)) QueryInterface( const IID&,PVOID*) =0;
 virtual ULONG __attribute__((__stdcall__)) AddRef(void) =0;
 virtual ULONG __attribute__((__stdcall__)) Release(void) =0;
 virtual void __attribute__((__stdcall__)) OnDataChange( FORMATETC*,STGMEDIUM*) =0;
 virtual void __attribute__((__stdcall__)) OnViewChange( DWORD,LONG) =0;
 virtual void __attribute__((__stdcall__)) OnRename( IMoniker*) =0;
 virtual void __attribute__((__stdcall__)) OnSave(void) =0;
 virtual void __attribute__((__stdcall__)) OnClose(void) =0;
 virtual void __attribute__((__stdcall__)) OnLinkSrcChange( IMoniker*);
};

extern "C" const IID IID_IDataObject;


struct IDataObject : public IUnknown
{
 virtual HRESULT __attribute__((__stdcall__)) QueryInterface( const IID&,PVOID*) =0;
 virtual ULONG __attribute__((__stdcall__)) AddRef(void) =0;
 virtual ULONG __attribute__((__stdcall__)) Release(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetData( FORMATETC*,STGMEDIUM*) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetDataHere( FORMATETC*,STGMEDIUM*) =0;
 virtual HRESULT __attribute__((__stdcall__)) QueryGetData( FORMATETC*) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetCanonicalFormatEtc( FORMATETC*,FORMATETC*) =0;
 virtual HRESULT __attribute__((__stdcall__)) SetData( FORMATETC*,STGMEDIUM*,BOOL) =0;
 virtual HRESULT __attribute__((__stdcall__)) EnumFormatEtc( DWORD,IEnumFORMATETC**) =0;
 virtual HRESULT __attribute__((__stdcall__)) DAdvise( FORMATETC*,DWORD,IAdviseSink*,PDWORD) =0;
 virtual HRESULT __attribute__((__stdcall__)) DUnadvise( DWORD) =0;
 virtual HRESULT __attribute__((__stdcall__)) EnumDAdvise( IEnumSTATDATA**) =0;
};

extern "C" const IID IID_IDataAdviseHolder;


struct IDataAdviseHolder : public IUnknown
{
 virtual HRESULT __attribute__((__stdcall__)) QueryInterface( const IID&,PVOID*) =0;
 virtual ULONG __attribute__((__stdcall__)) AddRef(void) =0;
 virtual ULONG __attribute__((__stdcall__)) Release(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) Advise( IDataObject*,FORMATETC*,DWORD,IAdviseSink*,PDWORD) =0;
 virtual HRESULT __attribute__((__stdcall__)) Unadvise( DWORD) =0;
 virtual HRESULT __attribute__((__stdcall__)) EnumAdvise( IEnumSTATDATA**) =0;
 virtual HRESULT __attribute__((__stdcall__)) SendOnDataChange( IDataObject*,DWORD,DWORD) =0;
};

extern "C" const IID IID_IStorage;


struct IStorage : public IUnknown
{
 virtual HRESULT __attribute__((__stdcall__)) QueryInterface( const IID&,PVOID*) =0;
 virtual ULONG __attribute__((__stdcall__)) AddRef(void) =0;
 virtual ULONG __attribute__((__stdcall__)) Release(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) CreateStream( LPCWSTR,DWORD,DWORD,DWORD,IStream**) =0;
 virtual HRESULT __attribute__((__stdcall__)) OpenStream( LPCWSTR,PVOID,DWORD,DWORD,IStream**) =0;
 virtual HRESULT __attribute__((__stdcall__)) CreateStorage( LPCWSTR,DWORD,DWORD,DWORD,IStorage**) =0;
 virtual HRESULT __attribute__((__stdcall__)) OpenStorage( LPCWSTR,IStorage*,DWORD,SNB,DWORD,IStorage**) =0;
 virtual HRESULT __attribute__((__stdcall__)) CopyTo( DWORD,IID const*,SNB,IStorage*) =0;
 virtual HRESULT __attribute__((__stdcall__)) MoveElementTo( LPCWSTR,IStorage*,LPCWSTR,DWORD) =0;
 virtual HRESULT __attribute__((__stdcall__)) Commit( DWORD) =0;
 virtual HRESULT __attribute__((__stdcall__)) Revert(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) EnumElements( DWORD,PVOID,DWORD,IEnumSTATSTG**) =0;
 virtual HRESULT __attribute__((__stdcall__)) DestroyElement( LPCWSTR) =0;
 virtual HRESULT __attribute__((__stdcall__)) RenameElement( LPCWSTR,LPCWSTR) =0;
 virtual HRESULT __attribute__((__stdcall__)) SetElementTimes( LPCWSTR,FILETIME const*,FILETIME const*,FILETIME const*) =0;
 virtual HRESULT __attribute__((__stdcall__)) SetClass( const CLSID&) =0;
 virtual HRESULT __attribute__((__stdcall__)) SetStateBits( DWORD,DWORD) =0;
 virtual HRESULT __attribute__((__stdcall__)) Stat( STATSTG*,DWORD) =0;
};

extern "C" const IID IID_IRootStorage;


struct IRootStorage : public IPersist
{
 virtual HRESULT __attribute__((__stdcall__)) QueryInterface( const IID&,PVOID*) =0;
 virtual ULONG __attribute__((__stdcall__)) AddRef(void) =0;
 virtual ULONG __attribute__((__stdcall__)) Release(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) SwitchToFile( LPOLESTR) =0;
};

extern "C" const IID IID_IRpcChannelBuffer;


struct IRpcChannelBuffer : public IUnknown
{
 virtual HRESULT __attribute__((__stdcall__)) QueryInterface( const IID&,PVOID*) =0;
 virtual ULONG __attribute__((__stdcall__)) AddRef(void) =0;
 virtual ULONG __attribute__((__stdcall__)) Release(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetBuffer( RPCOLEMESSAGE*,const IID&) =0;
 virtual HRESULT __attribute__((__stdcall__)) SendReceive( RPCOLEMESSAGE*,PULONG) =0;
 virtual HRESULT __attribute__((__stdcall__)) FreeBuffer( RPCOLEMESSAGE*) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetDestCtx( PDWORD,PVOID*) =0;
 virtual HRESULT __attribute__((__stdcall__)) IsConnected(void) =0;
};

extern "C" const IID IID_IRpcProxyBuffer;


struct IRpcProxyBuffer : public IUnknown
{
 virtual HRESULT __attribute__((__stdcall__)) QueryInterface( const IID&,PVOID*) =0;
 virtual ULONG __attribute__((__stdcall__)) AddRef(void) =0;
 virtual ULONG __attribute__((__stdcall__)) Release(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) Connect( IRpcChannelBuffer*) =0;
 virtual void __attribute__((__stdcall__)) Disconnect(void) =0;

};

extern "C" const IID IID_IRpcStubBuffer;


struct IRpcStubBuffer : public IUnknown
{
 virtual HRESULT __attribute__((__stdcall__)) QueryInterface( const IID&,PVOID*) =0;
 virtual ULONG __attribute__((__stdcall__)) AddRef(void) =0;
 virtual ULONG __attribute__((__stdcall__)) Release(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) Connect( LPUNKNOWN) =0;
 virtual void __attribute__((__stdcall__)) Disconnect(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) Invoke( RPCOLEMESSAGE*,LPRPCSTUBBUFFER) =0;
 virtual LPRPCSTUBBUFFER __attribute__((__stdcall__)) IsIIDSupported( const IID&) =0;
 virtual ULONG __attribute__((__stdcall__)) CountRefs(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) DebugServerQueryInterface( PVOID*) =0;
 virtual HRESULT __attribute__((__stdcall__)) DebugServerRelease( PVOID) =0;
};

extern "C" const IID IID_IPSFactoryBuffer;


struct IPSFactoryBuffer : public IUnknown
{
 virtual HRESULT __attribute__((__stdcall__)) QueryInterface( const IID&,PVOID*) =0;
 virtual ULONG __attribute__((__stdcall__)) AddRef(void) =0;
 virtual ULONG __attribute__((__stdcall__)) Release(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) CreateProxy( LPUNKNOWN,const IID&,LPRPCPROXYBUFFER*,PVOID*) =0;
 virtual HRESULT __attribute__((__stdcall__)) CreateStub( const IID&,LPUNKNOWN,LPRPCSTUBBUFFER*) =0;
};
typedef struct IPSFactoryBuffer *LPPSFACTORYBUFFER;

extern "C" const IID IID_ILockBytes;


struct ILockBytes : public IUnknown
{
 virtual HRESULT __attribute__((__stdcall__)) QueryInterface( const IID&,PVOID*) =0;
 virtual ULONG __attribute__((__stdcall__)) AddRef(void) =0;
 virtual ULONG __attribute__((__stdcall__)) Release(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) ReadAt( ULARGE_INTEGER,PVOID,ULONG,ULONG*) =0;
 virtual HRESULT __attribute__((__stdcall__)) WriteAt( ULARGE_INTEGER,PCVOID,ULONG,ULONG*) =0;
 virtual HRESULT __attribute__((__stdcall__)) Flush(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) SetSize( ULARGE_INTEGER) =0;
 virtual HRESULT __attribute__((__stdcall__)) LockRegion( ULARGE_INTEGER,ULARGE_INTEGER,DWORD) =0;
 virtual HRESULT __attribute__((__stdcall__)) UnlockRegion( ULARGE_INTEGER,ULARGE_INTEGER,DWORD) =0;
 virtual HRESULT __attribute__((__stdcall__)) Stat( STATSTG*,DWORD) =0;
};

extern "C" const IID IID_IExternalConnection;


struct IExternalConnection : public IUnknown
{
 virtual HRESULT __attribute__((__stdcall__)) QueryInterface( const IID&,PVOID*) =0;
 virtual ULONG __attribute__((__stdcall__)) AddRef(void) =0;
 virtual ULONG __attribute__((__stdcall__)) Release(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) AddConnection( DWORD,DWORD) =0;
 virtual HRESULT __attribute__((__stdcall__)) ReleaseConnection( DWORD,DWORD,BOOL) =0;
};

extern "C" const IID IID_IRunnableObject;


struct IRunnableObject : public IUnknown
{
 virtual HRESULT __attribute__((__stdcall__)) QueryInterface( const IID&,PVOID*) =0;
 virtual ULONG __attribute__((__stdcall__)) AddRef(void) =0;
 virtual ULONG __attribute__((__stdcall__)) Release(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetRunningClass( LPCLSID) =0;
 virtual HRESULT __attribute__((__stdcall__)) Run( LPBC) =0;
 virtual BOOL __attribute__((__stdcall__)) IsRunning(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) LockRunning( BOOL,BOOL) =0;
 virtual HRESULT __attribute__((__stdcall__)) SetContainedObject( BOOL) =0;
};

extern "C" const IID IID_IROTData;


struct IROTData : public IUnknown
{
 virtual HRESULT __attribute__((__stdcall__)) QueryInterface( const IID&,PVOID*) =0;
 virtual ULONG __attribute__((__stdcall__)) AddRef(void) =0;
 virtual ULONG __attribute__((__stdcall__)) Release(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetComparisonData( PVOID,ULONG,PULONG) =0;
};

extern "C" const IID IID_IChannelHook;


struct IChannelHook : public IUnknown
{
 virtual HRESULT __attribute__((__stdcall__)) QueryInterface( const IID&,PVOID*) =0;
 virtual ULONG __attribute__((__stdcall__)) AddRef(void) =0;
 virtual ULONG __attribute__((__stdcall__)) Release(void) =0;
 virtual void __attribute__((__stdcall__)) ClientGetSize( const GUID&,const IID&,PULONG) =0;
 virtual void __attribute__((__stdcall__)) ClientFillBuffer( const GUID&,const IID&,PULONG,PVOID) =0;
 virtual void __attribute__((__stdcall__)) ClientNotify( const GUID&,const IID&,ULONG,PVOID,DWORD,HRESULT) =0;
 virtual void __attribute__((__stdcall__)) ServerNotify( const GUID&,const IID&,ULONG,PVOID,DWORD) =0;
 virtual void __attribute__((__stdcall__)) ServerGetSize( const GUID&,const IID&,HRESULT,PULONG) =0;
 virtual void __attribute__((__stdcall__)) ServerFillBuffer( const GUID&,const IID&,PULONG,PVOID,HRESULT) =0;
};

extern "C" const IID IID_IPropertyStorage;


struct IPropertyStorage : public IUnknown
{
 virtual HRESULT __attribute__((__stdcall__)) QueryInterface( const IID&,PVOID*) =0;
 virtual ULONG __attribute__((__stdcall__)) AddRef(void) =0;
 virtual ULONG __attribute__((__stdcall__)) Release(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) ReadMultiple( ULONG,PROPSPEC const*,PROPVARIANT*) =0;
 virtual HRESULT __attribute__((__stdcall__)) WriteMultiple( ULONG,PROPSPEC const*,PROPVARIANT*,PROPID) =0;
 virtual HRESULT __attribute__((__stdcall__)) DeleteMultiple( ULONG,PROPSPEC const*) =0;
 virtual HRESULT __attribute__((__stdcall__)) ReadPropertyNames( ULONG,PROPID const*,LPWSTR*) =0;
 virtual HRESULT __attribute__((__stdcall__)) WritePropertyNames( ULONG,PROPID const*,LPWSTR const*) =0;
 virtual HRESULT __attribute__((__stdcall__)) DeletePropertyNames( ULONG,PROPID const*) =0;
 virtual HRESULT __attribute__((__stdcall__)) SetClass( const CLSID&) =0;
 virtual HRESULT __attribute__((__stdcall__)) Commit( DWORD) =0;
 virtual HRESULT __attribute__((__stdcall__)) Revert(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) Enum( IEnumSTATPROPSTG**) =0;
 virtual HRESULT __attribute__((__stdcall__)) Stat( STATPROPSTG*) =0;
 virtual HRESULT __attribute__((__stdcall__)) SetTimes( FILETIME const*,FILETIME const*,FILETIME const*) =0;
};

extern "C" const IID IID_IPropertySetStorage;


struct IPropertySetStorage : public IUnknown
{
 virtual HRESULT __attribute__((__stdcall__)) QueryInterface( const IID&,PVOID*) =0;
 virtual ULONG __attribute__((__stdcall__)) AddRef(void) =0;
 virtual ULONG __attribute__((__stdcall__)) Release(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) Create( REFFMTID,CLSID*,DWORD,DWORD,LPPROPERTYSTORAGE*) =0;
 virtual HRESULT __attribute__((__stdcall__)) Open( REFFMTID,DWORD,LPPROPERTYSTORAGE*) =0;
 virtual HRESULT __attribute__((__stdcall__)) Delete( REFFMTID) =0;
 virtual HRESULT __attribute__((__stdcall__)) Enum( IEnumSTATPROPSETSTG**) =0;
};

extern "C" const IID IID_IClientSecurity;


struct IClientSecurity : public IUnknown
{
 virtual HRESULT __attribute__((__stdcall__)) QueryInterface( const IID&,PVOID*) =0;
 virtual ULONG __attribute__((__stdcall__)) AddRef(void) =0;
 virtual ULONG __attribute__((__stdcall__)) Release(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) QueryBlanket( PVOID,PDWORD,PDWORD,OLECHAR**,PDWORD,PDWORD,RPC_AUTH_IDENTITY_HANDLE**,PDWORD*) =0;
 virtual HRESULT __attribute__((__stdcall__)) SetBlanket( PVOID,DWORD,DWORD,LPWSTR,DWORD,DWORD,RPC_AUTH_IDENTITY_HANDLE*,DWORD) =0;
 virtual HRESULT __attribute__((__stdcall__)) CopyProxy( LPUNKNOWN,LPUNKNOWN*) =0;
};

extern "C" const IID IID_IServerSecurity;


struct IServerSecurity : public IUnknown
{
 virtual HRESULT __attribute__((__stdcall__)) QueryInterface( const IID&,PVOID*) =0;
 virtual ULONG __attribute__((__stdcall__)) AddRef(void) =0;
 virtual ULONG __attribute__((__stdcall__)) Release(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) QueryBlanket( PDWORD,PDWORD,OLECHAR**,PDWORD,PDWORD,RPC_AUTHZ_HANDLE*,PDWORD*) =0;
 virtual HRESULT __attribute__((__stdcall__)) ImpersonateClient(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) RevertToSelf(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) IsImpersonating(void) =0;
};

extern "C" const IID IID_IClassActivator;


struct IClassActivator : public IUnknown
{
 virtual HRESULT __attribute__((__stdcall__)) QueryInterface( const IID&,PVOID*) =0;
 virtual ULONG __attribute__((__stdcall__)) AddRef(void) =0;
 virtual ULONG __attribute__((__stdcall__)) Release(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetClassObject( const CLSID&,DWORD,LCID,const IID&,PVOID*) =0;
};

extern "C" const IID IID_IFillLockBytes;


struct IFillLockBytes : public IUnknown
{
 virtual HRESULT __attribute__((__stdcall__)) QueryInterface( const IID&,PVOID*) =0;
 virtual ULONG __attribute__((__stdcall__)) AddRef(void) =0;
 virtual ULONG __attribute__((__stdcall__)) Release(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) FillAppend( void const*,ULONG,PULONG) =0;
 virtual HRESULT __attribute__((__stdcall__)) FillAt( ULARGE_INTEGER,void const*,ULONG,PULONG) =0;
 virtual HRESULT __attribute__((__stdcall__)) SetFillSize( ULARGE_INTEGER) =0;
 virtual HRESULT __attribute__((__stdcall__)) Terminate( BOOL) =0;
};

extern "C" const IID IID_IProgressNotify;


struct IProgressNotify : public IUnknown
{
 virtual HRESULT __attribute__((__stdcall__)) QueryInterface( const IID&,PVOID*) =0;
 virtual ULONG __attribute__((__stdcall__)) AddRef(void) =0;
 virtual ULONG __attribute__((__stdcall__)) Release(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) OnProgress( DWORD,DWORD,BOOL,BOOL) =0;
};

extern "C" const IID IID_ILayoutStorage;


struct ILayoutStorage : public IUnknown
{
 virtual HRESULT __attribute__((__stdcall__)) QueryInterface( const IID&,PVOID*) =0;
 virtual ULONG __attribute__((__stdcall__)) AddRef(void) =0;
 virtual ULONG __attribute__((__stdcall__)) Release(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) LayoutScript( STORAGELAYOUT*,DWORD,DWORD) =0;
 virtual HRESULT __attribute__((__stdcall__)) BeginMonitor(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) EndMonitor(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) ReLayoutDocfile( OLECHAR*) =0;
};

extern "C" const IID IID_IGlobalInterfaceTable;


struct IGlobalInterfaceTable : public IUnknown
{
 virtual HRESULT __attribute__((__stdcall__)) QueryInterface( const IID&,PVOID*) =0;
 virtual ULONG __attribute__((__stdcall__)) AddRef(void) =0;
 virtual ULONG __attribute__((__stdcall__)) Release(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) RegisterInterfaceInGlobal( IUnknown*,const IID&,DWORD*) =0;
 virtual HRESULT __attribute__((__stdcall__)) RevokeInterfaceFromGlobal( DWORD) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetInterfaceFromGlobal( DWORD,const IID&,void**) =0;
};
# 1028 "H:/CPP/wxdevcpp6.10/include/objidl.h" 3
HRESULT __attribute__((__stdcall__)) IMarshal_GetUnmarshalClass_Proxy(IMarshal*,const IID&,void*,DWORD,void*,DWORD,CLSID*);
void __attribute__((__stdcall__)) IMarshal_GetUnmarshalClass_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IMarshal_GetMarshalSizeMax_Proxy(IMarshal*,const IID&,void*,DWORD,void*,DWORD,DWORD*);
void __attribute__((__stdcall__)) IMarshal_GetMarshalSizeMax_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IMarshal_MarshalInterface_Proxy(IMarshal*,IStream*,const IID&,void*,DWORD,void*,DWORD);
void __attribute__((__stdcall__)) IMarshal_MarshalInterface_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IMarshal_UnmarshalInterface_Proxy(IMarshal*,IStream*,const IID&,void**);
void __attribute__((__stdcall__)) IMarshal_UnmarshalInterface_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IMarshal_ReleaseMarshalData_Proxy(IMarshal*,IStream*);
void __attribute__((__stdcall__)) IMarshal_ReleaseMarshalData_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IMarshal_DisconnectObject_Proxy(IMarshal*,DWORD);
void __attribute__((__stdcall__)) IMarshal_DisconnectObject_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
void* __attribute__((__stdcall__)) IMalloc_Alloc_Proxy(IMalloc*,ULONG);
void __attribute__((__stdcall__)) IMalloc_Alloc_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
void* __attribute__((__stdcall__)) IMalloc_Realloc_Proxy(IMalloc*,void*,ULONG);
void __attribute__((__stdcall__)) IMalloc_Realloc_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
void __attribute__((__stdcall__)) IMalloc_Free_Proxy(IMalloc*,void*);
void __attribute__((__stdcall__)) IMalloc_Free_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
ULONG __attribute__((__stdcall__)) IMalloc_GetSize_Proxy(IMalloc*,void*);
void __attribute__((__stdcall__)) IMalloc_GetSize_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
int __attribute__((__stdcall__)) IMalloc_DidAlloc_Proxy(IMalloc*,void*);
void __attribute__((__stdcall__)) IMalloc_DidAlloc_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
void __attribute__((__stdcall__)) IMalloc_HeapMinimize_Proxy(IMalloc*);
void __attribute__((__stdcall__)) IMalloc_HeapMinimize_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
ULONG __attribute__((__stdcall__)) IMallocSpy_PreAlloc_Proxy(IMallocSpy*,ULONG cbRequest);
void __attribute__((__stdcall__)) IMallocSpy_PreAlloc_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
void* __attribute__((__stdcall__)) IMallocSpy_PostAlloc_Proxy(IMallocSpy*,void*);
void __attribute__((__stdcall__)) IMallocSpy_PostAlloc_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
void* __attribute__((__stdcall__)) IMallocSpy_PreFree_Proxy(IMallocSpy*,void*,BOOL);
void __attribute__((__stdcall__)) IMallocSpy_PreFree_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
void __attribute__((__stdcall__)) IMallocSpy_PostFree_Proxy(IMallocSpy*,BOOL);
void __attribute__((__stdcall__)) IMallocSpy_PostFree_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
ULONG __attribute__((__stdcall__)) IMallocSpy_PreRealloc_Proxy(IMallocSpy*,void*,ULONG,void**,BOOL);
void __attribute__((__stdcall__)) IMallocSpy_PreRealloc_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
void* __attribute__((__stdcall__)) IMallocSpy_PostRealloc_Proxy(IMallocSpy*,void*,BOOL);
void __attribute__((__stdcall__)) IMallocSpy_PostRealloc_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
void* __attribute__((__stdcall__)) IMallocSpy_PreGetSize_Proxy(IMallocSpy*,void*,BOOL);
void __attribute__((__stdcall__)) IMallocSpy_PreGetSize_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
ULONG __attribute__((__stdcall__)) IMallocSpy_PostGetSize_Proxy(IMallocSpy*,ULONG,BOOL);
void __attribute__((__stdcall__)) IMallocSpy_PostGetSize_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
void* __attribute__((__stdcall__)) IMallocSpy_PreDidAlloc_Proxy(IMallocSpy*,void*,BOOL);
void __attribute__((__stdcall__)) IMallocSpy_PreDidAlloc_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
int __attribute__((__stdcall__)) IMallocSpy_PostDidAlloc_Proxy(IMallocSpy*,void*,BOOL,int);
void __attribute__((__stdcall__)) IMallocSpy_PostDidAlloc_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
void __attribute__((__stdcall__)) IMallocSpy_PreHeapMinimize_Proxy(IMallocSpy* );
void __attribute__((__stdcall__)) IMallocSpy_PreHeapMinimize_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
void __attribute__((__stdcall__)) IMallocSpy_PostHeapMinimize_Proxy(IMallocSpy*);
void __attribute__((__stdcall__)) IMallocSpy_PostHeapMinimize_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IStdMarshalInfo_GetClassForHandler_Proxy(IStdMarshalInfo*,DWORD,void*,CLSID*);
void __attribute__((__stdcall__)) IStdMarshalInfo_GetClassForHandler_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
DWORD __attribute__((__stdcall__)) IExternalConnection_AddConnection_Proxy(IExternalConnection*,DWORD,DWORD);
void __attribute__((__stdcall__)) IExternalConnection_AddConnection_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
DWORD __attribute__((__stdcall__)) IExternalConnection_ReleaseConnection_Proxy(IExternalConnection*,DWORD,DWORD,BOOL);
void __attribute__((__stdcall__)) IExternalConnection_ReleaseConnection_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IEnumUnknown_RemoteNext_Proxy(IEnumUnknown*,ULONG,IUnknown**,ULONG*);
void __attribute__((__stdcall__)) IEnumUnknown_RemoteNext_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IEnumUnknown_Skip_Proxy(IEnumUnknown*,ULONG);
void __attribute__((__stdcall__)) IEnumUnknown_Skip_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IEnumUnknown_Reset_Proxy(IEnumUnknown* );
void __attribute__((__stdcall__)) IEnumUnknown_Reset_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IEnumUnknown_Clone_Proxy(IEnumUnknown*,IEnumUnknown**);
void __attribute__((__stdcall__)) IEnumUnknown_Clone_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IBindCtx_RegisterObjectBound_Proxy(IBindCtx*,IUnknown*punk);
void __attribute__((__stdcall__)) IBindCtx_RegisterObjectBound_Stub(IRpcStubBuffer*,IRpcChannelBuffer*_pRpcChannelBuffer,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IBindCtx_RevokeObjectBound_Proxy(IBindCtx*,IUnknown*punk);
void __attribute__((__stdcall__)) IBindCtx_RevokeObjectBound_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IBindCtx_ReleaseBoundObjects_Proxy(IBindCtx*);
void __attribute__((__stdcall__)) IBindCtx_ReleaseBoundObjects_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IBindCtx_SetBindOptions_Proxy(IBindCtx*,BIND_OPTS*);
void __attribute__((__stdcall__)) IBindCtx_SetBindOptions_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IBindCtx_GetBindOptions_Proxy(IBindCtx*,BIND_OPTS*pbindopts);
void __attribute__((__stdcall__)) IBindCtx_GetBindOptions_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IBindCtx_GetRunningObjectTable_Proxy(IBindCtx*,IRunningObjectTable**);
void __attribute__((__stdcall__)) IBindCtx_GetRunningObjectTable_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IBindCtx_RegisterObjectParam_Proxy(IBindCtx*,LPCSTR,IUnknown*);
void __attribute__((__stdcall__)) IBindCtx_RegisterObjectParam_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IBindCtx_GetObjectParam_Proxy(IBindCtx*,LPCSTR,IUnknown**);
void __attribute__((__stdcall__)) IBindCtx_GetObjectParam_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IBindCtx_EnumObjectParam_Proxy(IBindCtx*,IEnumString**);
void __attribute__((__stdcall__)) IBindCtx_EnumObjectParam_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IBindCtx_RevokeObjectParam_Proxy(IBindCtx*,LPCSTR);
void __attribute__((__stdcall__)) IBindCtx_RevokeObjectParam_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IEnumMoniker_RemoteNext_Proxy(IEnumMoniker*,ULONG,IMoniker**,ULONG*);
void __attribute__((__stdcall__)) IEnumMoniker_RemoteNext_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IEnumMoniker_Skip_Proxy(IEnumMoniker*,ULONG);
void __attribute__((__stdcall__)) IEnumMoniker_Skip_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IEnumMoniker_Reset_Proxy(IEnumMoniker*);
void __attribute__((__stdcall__)) IEnumMoniker_Reset_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IEnumMoniker_Clone_Proxy(IEnumMoniker*,IEnumMoniker**);
void __attribute__((__stdcall__)) IEnumMoniker_Clone_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IRunnableObject_GetRunningClass_Proxy(IRunnableObject*,LPCLSID);
void __attribute__((__stdcall__)) IRunnableObject_GetRunningClass_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IRunnableObject_Run_Proxy(IRunnableObject*,LPBINDCTX);
void __attribute__((__stdcall__)) IRunnableObject_Run_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
BOOL __attribute__((__stdcall__)) IRunnableObject_IsRunning_Proxy(IRunnableObject*);
void __attribute__((__stdcall__)) IRunnableObject_IsRunning_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IRunnableObject_LockRunning_Proxy(IRunnableObject*,BOOL,BOOL);
void __attribute__((__stdcall__)) IRunnableObject_LockRunning_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IRunnableObject_SetContainedObject_Proxy(IRunnableObject*,BOOL);
void __attribute__((__stdcall__)) IRunnableObject_SetContainedObject_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IRunningObjectTable_Register_Proxy(IRunningObjectTable*,DWORD,IUnknown*,IMoniker*,DWORD*);
void __attribute__((__stdcall__)) IRunningObjectTable_Register_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IRunningObjectTable_Revoke_Proxy(IRunningObjectTable*,DWORD);
void __attribute__((__stdcall__)) IRunningObjectTable_Revoke_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IRunningObjectTable_IsRunning_Proxy(IRunningObjectTable*,IMoniker*);
void __attribute__((__stdcall__)) IRunningObjectTable_IsRunning_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IRunningObjectTable_GetObject_Proxy(IRunningObjectTable*,IMoniker*,IUnknown**);
void __attribute__((__stdcall__)) IRunningObjectTable_GetObject_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IRunningObjectTable_NoteChangeTime_Proxy(IRunningObjectTable*,DWORD,FILETIME*);
void __attribute__((__stdcall__)) IRunningObjectTable_NoteChangeTime_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IRunningObjectTable_GetTimeOfLastChange_Proxy(IRunningObjectTable*,IMoniker*,FILETIME*);
void __attribute__((__stdcall__)) IRunningObjectTable_GetTimeOfLastChange_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IRunningObjectTable_EnumRunning_Proxy(IRunningObjectTable*,IEnumMoniker**);
void __attribute__((__stdcall__)) IRunningObjectTable_EnumRunning_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IPersist_GetClassID_Proxy(IPersist*,CLSID*);
void __attribute__((__stdcall__)) IPersist_GetClassID_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IPersistStream_IsDirty_Proxy(IPersistStream*);
void __attribute__((__stdcall__)) IPersistStream_IsDirty_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IPersistStream_Load_Proxy(IPersistStream*,IStream*);
void __attribute__((__stdcall__)) IPersistStream_Load_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IPersistStream_Save_Proxy(IPersistStream*,IStream*,BOOL);
void __attribute__((__stdcall__)) IPersistStream_Save_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IPersistStream_GetSizeMax_Proxy(IPersistStream*,ULARGE_INTEGER*);
void __attribute__((__stdcall__)) IPersistStream_GetSizeMax_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IMoniker_RemoteBindToObject_Proxy(IMoniker*,IBindCtx*,IMoniker*,const IID&,IUnknown**);
void __attribute__((__stdcall__)) IMoniker_RemoteBindToObject_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IMoniker_RemoteBindToStorage_Proxy(IMoniker*,IBindCtx*,IMoniker*,const IID&,IUnknown**);
void __attribute__((__stdcall__)) IMoniker_RemoteBindToStorage_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IMoniker_Reduce_Proxy(IMoniker*,IBindCtx*,DWORD,IMoniker**,IMoniker**);
void __attribute__((__stdcall__)) IMoniker_Reduce_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IMoniker_ComposeWith_Proxy(IMoniker*,IMoniker*,BOOL,IMoniker**);
void __attribute__((__stdcall__)) IMoniker_ComposeWith_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IMoniker_Enum_Proxy(IMoniker*,BOOL,IEnumMoniker**);
void __attribute__((__stdcall__)) IMoniker_Enum_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IMoniker_IsEqual_Proxy(IMoniker*,IMoniker*);
void __attribute__((__stdcall__)) IMoniker_IsEqual_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IMoniker_Hash_Proxy(IMoniker*,DWORD*);
void __attribute__((__stdcall__)) IMoniker_Hash_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IMoniker_IsRunning_Proxy(IMoniker*,IBindCtx*,IMoniker*,IMoniker*);
void __attribute__((__stdcall__)) IMoniker_IsRunning_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IMoniker_GetTimeOfLastChange_Proxy(IMoniker*,IBindCtx*,IMoniker*,FILETIME*);
void __attribute__((__stdcall__)) IMoniker_GetTimeOfLastChange_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IMoniker_Inverse_Proxy(IMoniker*,IMoniker**);
void __attribute__((__stdcall__)) IMoniker_Inverse_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IMoniker_CommonPrefixWith_Proxy(IMoniker*,IMoniker*,IMoniker**);
void __attribute__((__stdcall__)) IMoniker_CommonPrefixWith_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IMoniker_RelativePathTo_Proxy(IMoniker*,IMoniker*,IMoniker**);
void __attribute__((__stdcall__)) IMoniker_RelativePathTo_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IMoniker_GetDisplayName_Proxy(IMoniker*,IBindCtx*,IMoniker*,LPCSTR*);
void __attribute__((__stdcall__)) IMoniker_GetDisplayName_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IMoniker_ParseDisplayName_Proxy(IMoniker*,IBindCtx*,IMoniker*,LPCSTR,ULONG*,IMoniker**);
void __attribute__((__stdcall__)) IMoniker_ParseDisplayName_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IMoniker_IsSystemMoniker_Proxy(IMoniker*,DWORD*);
void __attribute__((__stdcall__)) IMoniker_IsSystemMoniker_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IROTData_GetComparisonData_Proxy(IROTData*,BYTE*,ULONG cbMax,ULONG*);
void __attribute__((__stdcall__)) IROTData_GetComparisonData_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IEnumString_RemoteNext_Proxy(IEnumString*,ULONG,LPCSTR*rgelt,ULONG*);
void __attribute__((__stdcall__)) IEnumString_RemoteNext_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IEnumString_Skip_Proxy(IEnumString*,ULONG);
void __attribute__((__stdcall__)) IEnumString_Skip_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IEnumString_Reset_Proxy(IEnumString*);
void __attribute__((__stdcall__)) IEnumString_Reset_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IEnumString_Clone_Proxy(IEnumString*,IEnumString**);
void __attribute__((__stdcall__)) IEnumString_Clone_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IStream_RemoteRead_Proxy(IStream*,BYTE*,ULONG,ULONG*);
void __attribute__((__stdcall__)) IStream_RemoteRead_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IStream_RemoteWrite_Proxy(IStream*,BYTE*pv,ULONG,ULONG*);
void __attribute__((__stdcall__)) IStream_RemoteWrite_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IStream_RemoteSeek_Proxy(IStream*,LARGE_INTEGER,DWORD,ULARGE_INTEGER*);
void __attribute__((__stdcall__)) IStream_RemoteSeek_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IStream_SetSize_Proxy(IStream*,ULARGE_INTEGER);
void __attribute__((__stdcall__)) IStream_SetSize_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IStream_RemoteCopyTo_Proxy(IStream*,IStream*,ULARGE_INTEGER,ULARGE_INTEGER*,ULARGE_INTEGER*);
void __attribute__((__stdcall__)) IStream_RemoteCopyTo_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IStream_Commit_Proxy(IStream*,DWORD);
void __attribute__((__stdcall__)) IStream_Commit_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IStream_Revert_Proxy(IStream*);
void __attribute__((__stdcall__)) IStream_Revert_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IStream_LockRegion_Proxy(IStream*,ULARGE_INTEGER,ULARGE_INTEGER,DWORD);
void __attribute__((__stdcall__)) IStream_LockRegion_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IStream_UnlockRegion_Proxy(IStream*,ULARGE_INTEGER,ULARGE_INTEGER,DWORD);
void __attribute__((__stdcall__)) IStream_UnlockRegion_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IStream_Stat_Proxy(IStream*,STATSTG*,DWORD);
void __attribute__((__stdcall__)) IStream_Stat_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IStream_Clone_Proxy(IStream*,IStream**);
void __attribute__((__stdcall__)) IStream_Clone_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IEnumSTATSTG_RemoteNext_Proxy(IEnumSTATSTG*,ULONG,STATSTG*,ULONG*);
void __attribute__((__stdcall__)) IEnumSTATSTG_RemoteNext_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IEnumSTATSTG_Skip_Proxy(IEnumSTATSTG*,ULONG celt);
void __attribute__((__stdcall__)) IEnumSTATSTG_Skip_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IEnumSTATSTG_Reset_Proxy(IEnumSTATSTG*);
void __attribute__((__stdcall__)) IEnumSTATSTG_Reset_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IEnumSTATSTG_Clone_Proxy(IEnumSTATSTG*,IEnumSTATSTG**);
void __attribute__((__stdcall__)) IEnumSTATSTG_Clone_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IStorage_CreateStream_Proxy(IStorage*,OLECHAR*,DWORD,DWORD,DWORD,IStream**);
void __attribute__((__stdcall__)) IStorage_CreateStream_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IStorage_RemoteOpenStream_Proxy(IStorage*,const OLECHAR*,unsigned long,BYTE*,DWORD,DWORD,IStream**);
void __attribute__((__stdcall__)) IStorage_RemoteOpenStream_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IStorage_CreateStorage_Proxy(IStorage*,OLECHAR*,DWORD,DWORD,DWORD,IStorage**);
void __attribute__((__stdcall__)) IStorage_CreateStorage_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IStorage_OpenStorage_Proxy(IStorage*,OLECHAR*,IStorage*,DWORD,SNB,DWORD,IStorage**);
void __attribute__((__stdcall__)) IStorage_OpenStorage_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IStorage_CopyTo_Proxy(IStorage*,DWORD,const IID*,SNB,IStorage*);
void __attribute__((__stdcall__)) IStorage_CopyTo_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IStorage_MoveElementTo_Proxy(IStorage*,const OLECHAR*,IStorage*,const OLECHAR*,DWORD);
void __attribute__((__stdcall__)) IStorage_MoveElementTo_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IStorage_Commit_Proxy(IStorage*,DWORD);
void __attribute__((__stdcall__)) IStorage_Commit_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IStorage_Revert_Proxy(IStorage*);
void __attribute__((__stdcall__)) IStorage_Revert_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IStorage_RemoteEnumElements_Proxy(IStorage*,DWORD,unsigned long,BYTE*,DWORD,IEnumSTATSTG**);
void __attribute__((__stdcall__)) IStorage_RemoteEnumElements_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IStorage_DestroyElement_Proxy(IStorage*,OLECHAR*);
void __attribute__((__stdcall__)) IStorage_DestroyElement_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IStorage_RenameElement_Proxy(IStorage*,const OLECHAR*,const OLECHAR*);
void __attribute__((__stdcall__)) IStorage_RenameElement_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IStorage_SetElementTimes_Proxy(IStorage*,const OLECHAR*,const FILETIME*,const FILETIME*,const FILETIME*);
void __attribute__((__stdcall__)) IStorage_SetElementTimes_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IStorage_SetClass_Proxy(IStorage*,const CLSID&);
void __attribute__((__stdcall__)) IStorage_SetClass_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IStorage_SetStateBits_Proxy(IStorage*,DWORD,DWORD);
void __attribute__((__stdcall__)) IStorage_SetStateBits_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IStorage_Stat_Proxy(IStorage*,STATSTG*,DWORD);
void __attribute__((__stdcall__)) IStorage_Stat_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IPersistFile_IsDirty_Proxy(IPersistFile*);
void __attribute__((__stdcall__)) IPersistFile_IsDirty_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IPersistFile_Load_Proxy(IPersistFile*,LPCOLESTR,DWORD);
void __attribute__((__stdcall__)) IPersistFile_Load_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IPersistFile_Save_Proxy(IPersistFile*,LPCOLESTR pszFileName,BOOL);
void __attribute__((__stdcall__)) IPersistFile_Save_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IPersistFile_SaveCompleted_Proxy(IPersistFile*,LPCOLESTR);
void __attribute__((__stdcall__)) IPersistFile_SaveCompleted_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IPersistFile_GetCurFile_Proxy(IPersistFile*,LPCSTR*);
void __attribute__((__stdcall__)) IPersistFile_GetCurFile_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IPersistStorage_IsDirty_Proxy(IPersistStorage*);
void __attribute__((__stdcall__)) IPersistStorage_IsDirty_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IPersistStorage_InitNew_Proxy(IPersistStorage*,IStorage*);
void __attribute__((__stdcall__)) IPersistStorage_InitNew_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IPersistStorage_Load_Proxy(IPersistStorage*,IStorage*);
void __attribute__((__stdcall__)) IPersistStorage_Load_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IPersistStorage_Save_Proxy(IPersistStorage*,IStorage*,BOOL);
void __attribute__((__stdcall__)) IPersistStorage_Save_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IPersistStorage_SaveCompleted_Proxy(IPersistStorage*,IStorage*);
void __attribute__((__stdcall__)) IPersistStorage_SaveCompleted_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IPersistStorage_HandsOffStorage_Proxy(IPersistStorage*);
void __attribute__((__stdcall__)) IPersistStorage_HandsOffStorage_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) ILockBytes_RemoteReadAt_Proxy(ILockBytes*,ULARGE_INTEGER,BYTE*,ULONG,ULONG*);
void __attribute__((__stdcall__)) ILockBytes_RemoteReadAt_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) ILockBytes_RemoteWriteAt_Proxy(ILockBytes*,ULARGE_INTEGER,BYTE*pv,ULONG,ULONG*);
void __attribute__((__stdcall__)) ILockBytes_RemoteWriteAt_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) ILockBytes_Flush_Proxy(ILockBytes*);
void __attribute__((__stdcall__)) ILockBytes_Flush_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) ILockBytes_SetSize_Proxy(ILockBytes*,ULARGE_INTEGER);
void __attribute__((__stdcall__)) ILockBytes_SetSize_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) ILockBytes_LockRegion_Proxy(ILockBytes*,ULARGE_INTEGER,ULARGE_INTEGER,DWORD);
void __attribute__((__stdcall__)) ILockBytes_LockRegion_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) ILockBytes_UnlockRegion_Proxy(ILockBytes*,ULARGE_INTEGER,ULARGE_INTEGER,DWORD);
void __attribute__((__stdcall__)) ILockBytes_UnlockRegion_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) ILockBytes_Stat_Proxy(ILockBytes*,STATSTG*,DWORD);
void __attribute__((__stdcall__)) ILockBytes_Stat_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IEnumFORMATETC_RemoteNext_Proxy(IEnumFORMATETC*,ULONG,FORMATETC*,ULONG*);
void __attribute__((__stdcall__)) IEnumFORMATETC_RemoteNext_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IEnumFORMATETC_Skip_Proxy(IEnumFORMATETC*,ULONG);
void __attribute__((__stdcall__)) IEnumFORMATETC_Skip_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IEnumFORMATETC_Reset_Proxy(IEnumFORMATETC*);
void __attribute__((__stdcall__)) IEnumFORMATETC_Reset_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IEnumFORMATETC_Clone_Proxy(IEnumFORMATETC*,IEnumFORMATETC**);
void __attribute__((__stdcall__)) IEnumFORMATETC_Clone_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IEnumFORMATETC_Next_Proxy(IEnumFORMATETC*,ULONG,FORMATETC*,ULONG*);
HRESULT __attribute__((__stdcall__)) IEnumFORMATETC_Next_Stub(IEnumFORMATETC*,ULONG,FORMATETC*,ULONG*);
HRESULT __attribute__((__stdcall__)) IEnumSTATDATA_RemoteNext_Proxy(IEnumSTATDATA*,ULONG,STATDATA*,ULONG*);
void __attribute__((__stdcall__)) IEnumSTATDATA_RemoteNext_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IEnumSTATDATA_Skip_Proxy(IEnumSTATDATA*,ULONG);
void __attribute__((__stdcall__)) IEnumSTATDATA_Skip_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IEnumSTATDATA_Reset_Proxy(IEnumSTATDATA*);
void __attribute__((__stdcall__)) IEnumSTATDATA_Reset_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IEnumSTATDATA_Clone_Proxy(IEnumSTATDATA*,IEnumSTATDATA**);
void __attribute__((__stdcall__)) IEnumSTATDATA_Clone_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IEnumSTATDATA_Next_Proxy(IEnumSTATDATA*,ULONG,STATDATA*,ULONG*);
HRESULT __attribute__((__stdcall__)) IEnumSTATDATA_Next_Stub(IEnumSTATDATA*,ULONG,STATDATA*,ULONG*);
HRESULT __attribute__((__stdcall__)) IRootStorage_SwitchToFile_Proxy(IRootStorage*,LPCSTR);
void __attribute__((__stdcall__)) IRootStorage_SwitchToFile_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
void __attribute__((__stdcall__)) IAdviseSink_RemoteOnDataChange_Proxy(IAdviseSink*,FORMATETC*,RemSTGMEDIUM*);
void __attribute__((__stdcall__)) IAdviseSink_RemoteOnDataChange_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
void __attribute__((__stdcall__)) IAdviseSink_RemoteOnViewChange_Proxy(IAdviseSink*,DWORD,LONG);
void __attribute__((__stdcall__)) IAdviseSink_RemoteOnViewChange_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
void __attribute__((__stdcall__)) IAdviseSink_RemoteOnRename_Proxy(IAdviseSink*,IMoniker*);
void __attribute__((__stdcall__)) IAdviseSink_RemoteOnRename_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
void __attribute__((__stdcall__)) IAdviseSink_RemoteOnSave_Proxy(IAdviseSink*);
void __attribute__((__stdcall__)) IAdviseSink_RemoteOnSave_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IAdviseSink_RemoteOnClose_Proxy(IAdviseSink*);
void __attribute__((__stdcall__)) IAdviseSink_RemoteOnClose_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
void __attribute__((__stdcall__)) IAdviseSink_OnDataChange_Proxy(IAdviseSink*,FORMATETC*,STGMEDIUM*);
void __attribute__((__stdcall__)) IAdviseSink_OnDataChange_Stub(IAdviseSink*,FORMATETC*,RemSTGMEDIUM*);
void __attribute__((__stdcall__)) IAdviseSink_OnViewChange_Proxy(IAdviseSink*,DWORD,LONG);
void __attribute__((__stdcall__)) IAdviseSink_OnViewChange_Stub(IAdviseSink*,DWORD,LONG);
void __attribute__((__stdcall__)) IAdviseSink_OnRename_Proxy(IAdviseSink*,IMoniker*);
void __attribute__((__stdcall__)) IAdviseSink_OnRename_Stub(IAdviseSink*,IMoniker*);
void __attribute__((__stdcall__)) IAdviseSink_OnSave_Proxy(IAdviseSink*);
void __attribute__((__stdcall__)) IAdviseSink_OnSave_Stub(IAdviseSink*);
void __attribute__((__stdcall__)) IAdviseSink_OnClose_Proxy(IAdviseSink*);
HRESULT __attribute__((__stdcall__)) IAdviseSink_OnClose_Stub(IAdviseSink*);
void __attribute__((__stdcall__)) IAdviseSink2_RemoteOnLinkSrcChange_Proxy(IAdviseSink2*,IMoniker*);
void __attribute__((__stdcall__)) IAdviseSink2_RemoteOnLinkSrcChange_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
void __attribute__((__stdcall__)) IAdviseSink2_OnLinkSrcChange_Proxy(IAdviseSink2*,IMoniker*);
void __attribute__((__stdcall__)) IAdviseSink2_OnLinkSrcChange_Stub(IAdviseSink2*,IMoniker*);
HRESULT __attribute__((__stdcall__)) IDataObject_RemoteGetData_Proxy(IDataObject*,FORMATETC*,RemSTGMEDIUM**);
void __attribute__((__stdcall__)) IDataObject_RemoteGetData_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IDataObject_RemoteGetDataHere_Proxy(IDataObject*,FORMATETC*,RemSTGMEDIUM**);
void __attribute__((__stdcall__)) IDataObject_RemoteGetDataHere_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IDataObject_QueryGetData_Proxy(IDataObject*,FORMATETC*);
void __attribute__((__stdcall__)) IDataObject_QueryGetData_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IDataObject_GetCanonicalFormatEtc_Proxy(IDataObject*,FORMATETC*,FORMATETC*);
void __attribute__((__stdcall__)) IDataObject_GetCanonicalFormatEtc_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IDataObject_RemoteSetData_Proxy(IDataObject*,FORMATETC*,RemSTGMEDIUM*,BOOL);
void __attribute__((__stdcall__)) IDataObject_RemoteSetData_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IDataObject_EnumFormatEtc_Proxy(IDataObject*,DWORD,IEnumFORMATETC**);
void __attribute__((__stdcall__)) IDataObject_EnumFormatEtc_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IDataObject_DAdvise_Proxy(IDataObject*,FORMATETC*,DWORD,IAdviseSink*,DWORD*);
void __attribute__((__stdcall__)) IDataObject_DAdvise_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IDataObject_DUnadvise_Proxy(IDataObject*,DWORD);
void __attribute__((__stdcall__)) IDataObject_DUnadvise_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IDataObject_EnumDAdvise_Proxy(IDataObject*,IEnumSTATDATA**);
void __attribute__((__stdcall__)) IDataObject_EnumDAdvise_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IDataObject_GetData_Proxy(IDataObject*,FORMATETC*,STGMEDIUM*);
HRESULT __attribute__((__stdcall__)) IDataObject_GetData_Stub(IDataObject*,FORMATETC*,RemSTGMEDIUM**);
HRESULT __attribute__((__stdcall__)) IDataObject_GetDataHere_Proxy(IDataObject*,FORMATETC*,STGMEDIUM*);
HRESULT __attribute__((__stdcall__)) IDataObject_GetDataHere_Stub(IDataObject*,FORMATETC*,RemSTGMEDIUM**);
HRESULT __attribute__((__stdcall__)) IDataObject_SetData_Proxy(IDataObject*,FORMATETC*,STGMEDIUM*,BOOL);
HRESULT __attribute__((__stdcall__)) IDataObject_SetData_Stub(IDataObject*,FORMATETC*,RemSTGMEDIUM*,BOOL);
HRESULT __attribute__((__stdcall__)) IDataAdviseHolder_Advise_Proxy(IDataAdviseHolder*,IDataObject*,FORMATETC*,DWORD,IAdviseSink*,DWORD*);
void __attribute__((__stdcall__)) IDataAdviseHolder_Advise_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IDataAdviseHolder_Unadvise_Proxy(IDataAdviseHolder*,DWORD);
void __attribute__((__stdcall__)) IDataAdviseHolder_Unadvise_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IDataAdviseHolder_EnumAdvise_Proxy(IDataAdviseHolder*,IEnumSTATDATA**);
void __attribute__((__stdcall__)) IDataAdviseHolder_EnumAdvise_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IDataAdviseHolder_SendOnDataChange_Proxy(IDataAdviseHolder*,IDataObject*,DWORD,DWORD);
void __attribute__((__stdcall__)) IDataAdviseHolder_SendOnDataChange_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
DWORD __attribute__((__stdcall__)) IMessageFilter_HandleInComingCall_Proxy(IMessageFilter*,DWORD,HTASK,DWORD,LPINTERFACEINFO);
void __attribute__((__stdcall__)) IMessageFilter_HandleInComingCall_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
DWORD __attribute__((__stdcall__)) IMessageFilter_RetryRejectedCall_Proxy(IMessageFilter*,HTASK,DWORD,DWORD);
void __attribute__((__stdcall__)) IMessageFilter_RetryRejectedCall_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
DWORD __attribute__((__stdcall__)) IMessageFilter_MessagePending_Proxy(IMessageFilter*,HTASK,DWORD,DWORD);
void __attribute__((__stdcall__)) IMessageFilter_MessagePending_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IRpcChannelBuffer_GetBuffer_Proxy(IRpcChannelBuffer*,RPCOLEMESSAGE*,const IID&);
void __attribute__((__stdcall__)) IRpcChannelBuffer_GetBuffer_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IRpcChannelBuffer_SendReceive_Proxy(IRpcChannelBuffer*,RPCOLEMESSAGE*,ULONG*);
void __attribute__((__stdcall__)) IRpcChannelBuffer_SendReceive_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IRpcChannelBuffer_FreeBuffer_Proxy(IRpcChannelBuffer*,RPCOLEMESSAGE*);
void __attribute__((__stdcall__)) IRpcChannelBuffer_FreeBuffer_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IRpcChannelBuffer_GetDestCtx_Proxy(IRpcChannelBuffer*,DWORD*,void**);
void __attribute__((__stdcall__)) IRpcChannelBuffer_GetDestCtx_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IRpcChannelBuffer_IsConnected_Proxy(IRpcChannelBuffer*);
void __attribute__((__stdcall__)) IRpcChannelBuffer_IsConnected_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IRpcProxyBuffer_Connect_Proxy(IRpcProxyBuffer*,IRpcChannelBuffer*pRpcChannelBuffer);
void __attribute__((__stdcall__)) IRpcProxyBuffer_Connect_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
void __attribute__((__stdcall__)) IRpcProxyBuffer_Disconnect_Proxy(IRpcProxyBuffer*);
void __attribute__((__stdcall__)) IRpcProxyBuffer_Disconnect_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IRpcStubBuffer_Connect_Proxy(IRpcStubBuffer*,IUnknown*);
void __attribute__((__stdcall__)) IRpcStubBuffer_Connect_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
void __attribute__((__stdcall__)) IRpcStubBuffer_Disconnect_Proxy(IRpcStubBuffer*);
void __attribute__((__stdcall__)) IRpcStubBuffer_Disconnect_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IRpcStubBuffer_Invoke_Proxy(IRpcStubBuffer*,RPCOLEMESSAGE*,IRpcChannelBuffer*);
void __attribute__((__stdcall__)) IRpcStubBuffer_Invoke_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
IRpcStubBuffer*__attribute__((__stdcall__)) IRpcStubBuffer_IsIIDSupported_Proxy(IRpcStubBuffer*,const IID&);
void __attribute__((__stdcall__)) IRpcStubBuffer_IsIIDSupported_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
ULONG __attribute__((__stdcall__)) IRpcStubBuffer_CountRefs_Proxy(IRpcStubBuffer*);
void __attribute__((__stdcall__)) IRpcStubBuffer_CountRefs_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IRpcStubBuffer_DebugServerQueryInterface_Proxy(IRpcStubBuffer*,void**);
void __attribute__((__stdcall__)) IRpcStubBuffer_DebugServerQueryInterface_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
void __attribute__((__stdcall__)) IRpcStubBuffer_DebugServerRelease_Proxy(IRpcStubBuffer*,void*);
void __attribute__((__stdcall__)) IRpcStubBuffer_DebugServerRelease_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IPSFactoryBuffer_CreateProxy_Proxy(IPSFactoryBuffer*,IUnknown*,const IID&,IRpcProxyBuffer**,void**);
void __attribute__((__stdcall__)) IPSFactoryBuffer_CreateProxy_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
HRESULT __attribute__((__stdcall__)) IPSFactoryBuffer_CreateStub_Proxy(IPSFactoryBuffer*,const IID&,IUnknown*,IRpcStubBuffer**);
void __attribute__((__stdcall__)) IPSFactoryBuffer_CreateStub_Stub(IRpcStubBuffer*,IRpcChannelBuffer*,PRPC_MESSAGE,PDWORD);
void __attribute__((__stdcall__)) SNB_to_xmit(SNB*,RemSNB**);
void __attribute__((__stdcall__)) SNB_from_xmit(RemSNB*,SNB*);
void __attribute__((__stdcall__)) SNB_free_inst(SNB*);
void __attribute__((__stdcall__)) SNB_free_xmit(RemSNB*);
HRESULT __attribute__((__stdcall__)) IEnumUnknown_Next_Proxy(IEnumUnknown*,ULONG,IUnknown**,ULONG*);
HRESULT __attribute__((__stdcall__)) IEnumUnknown_Next_Stub(IEnumUnknown*,ULONG,IUnknown**,ULONG*);
HRESULT __attribute__((__stdcall__)) IEnumMoniker_Next_Proxy(IEnumMoniker*,ULONG,IMoniker**,ULONG*);
HRESULT __attribute__((__stdcall__)) IEnumMoniker_Next_Stub(IEnumMoniker*,ULONG,IMoniker**,ULONG*);
HRESULT __attribute__((__stdcall__)) IMoniker_BindToObject_Proxy(IMoniker*,IBindCtx*,IMoniker*,const IID&,void**);
HRESULT __attribute__((__stdcall__)) IMoniker_BindToObject_Stub(IMoniker*,IBindCtx*,IMoniker*,const IID&,IUnknown**);
HRESULT __attribute__((__stdcall__)) IMoniker_BindToStorage_Proxy(IMoniker*,IBindCtx*,IMoniker*,const IID&,void**);
HRESULT __attribute__((__stdcall__)) IMoniker_BindToStorage_Stub(IMoniker*,IBindCtx*,IMoniker*,const IID&,IUnknown**);
HRESULT __attribute__((__stdcall__)) IEnumString_Next_Proxy(IEnumString*,ULONG,LPCSTR*,ULONG*);
HRESULT __attribute__((__stdcall__)) IEnumString_Next_Stub(IEnumString*,ULONG,LPCSTR*,ULONG*);
HRESULT __attribute__((__stdcall__)) IStream_Read_Proxy(IStream*,void*,ULONG,ULONG*);
HRESULT __attribute__((__stdcall__)) IStream_Read_Stub(IStream*,BYTE*,ULONG,ULONG*);
HRESULT __attribute__((__stdcall__)) IStream_Write_Proxy(IStream*,void*,ULONG,ULONG*);
HRESULT __attribute__((__stdcall__)) IStream_Write_Stub(IStream*,BYTE*,ULONG,ULONG*);
HRESULT __attribute__((__stdcall__)) IStream_Seek_Proxy(IStream*,LARGE_INTEGER,DWORD,ULARGE_INTEGER*);
HRESULT __attribute__((__stdcall__)) IStream_Seek_Stub(IStream*,LARGE_INTEGER,DWORD,ULARGE_INTEGER*);
HRESULT __attribute__((__stdcall__)) IStream_CopyTo_Proxy(IStream*,IStream*,ULARGE_INTEGER,ULARGE_INTEGER*,ULARGE_INTEGER*);
HRESULT __attribute__((__stdcall__)) IStream_CopyTo_Stub(IStream*,IStream*,ULARGE_INTEGER,ULARGE_INTEGER*,ULARGE_INTEGER*);
HRESULT __attribute__((__stdcall__)) IEnumSTATSTG_Next_Proxy(IEnumSTATSTG*,ULONG,STATSTG*,ULONG*);
HRESULT __attribute__((__stdcall__)) IEnumSTATSTG_Next_Stub(IEnumSTATSTG*,ULONG,STATSTG*,ULONG*);
HRESULT __attribute__((__stdcall__)) IStorage_OpenStream_Proxy(IStorage*,OLECHAR*,void*,DWORD,DWORD,IStream**);
HRESULT __attribute__((__stdcall__)) IStorage_OpenStream_Stub(IStorage*,OLECHAR*,unsigned long,BYTE*,DWORD,DWORD,IStream** );
HRESULT __attribute__((__stdcall__)) IStorage_EnumElements_Proxy(IStorage*,DWORD,void*,DWORD,IEnumSTATSTG**);
HRESULT __attribute__((__stdcall__)) IStorage_EnumElements_Stub(IStorage*,DWORD,unsigned long,BYTE*,DWORD,IEnumSTATSTG**);
HRESULT __attribute__((__stdcall__)) ILockBytes_ReadAt_Proxy(ILockBytes*,ULARGE_INTEGER,void*,ULONG,ULONG*);
HRESULT __attribute__((__stdcall__)) ILockBytes_ReadAt_Stub(ILockBytes*,ULARGE_INTEGER,BYTE*,ULONG,ULONG*);
HRESULT __attribute__((__stdcall__)) ILockBytes_WriteAt_Proxy(ILockBytes*,ULARGE_INTEGER,const void*,ULONG,ULONG*);
HRESULT __attribute__((__stdcall__)) ILockBytes_WriteAt_Stub(ILockBytes*,ULARGE_INTEGER,BYTE*,ULONG,ULONG*);
# 74 "H:/CPP/wxdevcpp6.10/include/objbase.h" 2 3


inline BOOL IsEqualGUID(const GUID& rguid1, const GUID& rguid2)
 { return !memcmp(&rguid1, &rguid2, sizeof(GUID)); }
inline BOOL operator==(const GUID& guidOne, const GUID& guidOther)
 { return !memcmp(&guidOne,&guidOther,sizeof(GUID)); }
inline BOOL operator!=(const GUID& g1, const GUID& g2)
 { return !(g1 == g2); }





# 1 "H:/CPP/wxdevcpp6.10/include/cguid.h" 1 3



       
# 5 "H:/CPP/wxdevcpp6.10/include/cguid.h" 3



extern "C" {

extern const IID GUID_NULL;
extern const IID IID_IRpcChannel;
extern const IID IID_IRpcStub;
extern const IID IID_IStubManager;
extern const IID IID_IRpcProxy;
extern const IID IID_IProxyManager;
extern const IID IID_IPSFactory;
extern const IID IID_IInternalMoniker;
extern const IID IID_IDfReserved1;
extern const IID IID_IDfReserved2;
extern const IID IID_IDfReserved3;
extern const CLSID CLSID_StdMarshal;
extern const IID IID_IStub;
extern const IID IID_IProxy;
extern const IID IID_IEnumGeneric;
extern const IID IID_IEnumHolder;
extern const IID IID_IEnumCallback;
extern const IID IID_IOleManager;
extern const IID IID_IOlePresObj;
extern const IID IID_IDebug;
extern const IID IID_IDebugStream;
extern const CLSID CLSID_PSGenObject;
extern const CLSID CLSID_PSClientSite;
extern const CLSID CLSID_PSClassObject;
extern const CLSID CLSID_PSInPlaceActive;
extern const CLSID CLSID_PSInPlaceFrame;
extern const CLSID CLSID_PSDragDrop;
extern const CLSID CLSID_PSBindCtx;
extern const CLSID CLSID_PSEnumerators;
extern const CLSID CLSID_StaticMetafile;
extern const CLSID CLSID_StaticDib;
extern const CLSID CID_CDfsVolume;
extern const CLSID CLSID_CCDFormKrnl;
extern const CLSID CLSID_CCDPropertyPage;
extern const CLSID CLSID_CCDFormDialog;
extern const CLSID CLSID_CCDCommandButton;
extern const CLSID CLSID_CCDComboBox;
extern const CLSID CLSID_CCDTextBox;
extern const CLSID CLSID_CCDCheckBox;
extern const CLSID CLSID_CCDLabel;
extern const CLSID CLSID_CCDOptionButton;
extern const CLSID CLSID_CCDListBox;
extern const CLSID CLSID_CCDScrollBar;
extern const CLSID CLSID_CCDGroupBox;
extern const CLSID CLSID_CCDGeneralPropertyPage;
extern const CLSID CLSID_CCDGenericPropertyPage;
extern const CLSID CLSID_CCDFontPropertyPage;
extern const CLSID CLSID_CCDColorPropertyPage;
extern const CLSID CLSID_CCDLabelPropertyPage;
extern const CLSID CLSID_CCDCheckBoxPropertyPage;
extern const CLSID CLSID_CCDTextBoxPropertyPage;
extern const CLSID CLSID_CCDOptionButtonPropertyPage;
extern const CLSID CLSID_CCDListBoxPropertyPage;
extern const CLSID CLSID_CCDCommandButtonPropertyPage;
extern const CLSID CLSID_CCDComboBoxPropertyPage;
extern const CLSID CLSID_CCDScrollBarPropertyPage;
extern const CLSID CLSID_CCDGroupBoxPropertyPage;
extern const CLSID CLSID_CCDXObjectPropertyPage;
extern const CLSID CLSID_CStdPropertyFrame;
extern const CLSID CLSID_CFormPropertyPage;
extern const CLSID CLSID_CGridPropertyPage;
extern const CLSID CLSID_CWSJArticlePage;
extern const CLSID CLSID_CSystemPage;
extern const CLSID CLSID_IdentityUnmarshal;
extern const CLSID CLSID_InProcFreeMarshaler;
extern const CLSID CLSID_Picture_Metafile;
extern const CLSID CLSID_Picture_EnhMetafile;
extern const CLSID CLSID_Picture_Dib;
extern const CLSID CLSID_StdGlobalInterfaceTable;
extern const GUID GUID_TRISTATE;

}
# 88 "H:/CPP/wxdevcpp6.10/include/objbase.h" 2 3

typedef enum tagCOINIT {
 COINIT_APARTMENTTHREADED = 0x2,
 COINIT_MULTITHREADED = 0x0,
 COINIT_DISABLE_OLE1DDE = 0x4,
 COINIT_SPEED_OVER_MEMORY = 0x8
} COINIT;
typedef enum tagSTDMSHLFLAGS {
    SMEXF_SERVER = 0x01,
    SMEXF_HANDLER = 0x02
} STDMSHLFLAGS;

extern "C" DWORD __attribute__((__stdcall__)) CoBuildVersion(void);
extern "C" HRESULT __attribute__((__stdcall__)) CoInitialize(PVOID);
extern "C" HRESULT __attribute__((__stdcall__)) CoInitializeEx(LPVOID,DWORD);
extern "C" void __attribute__((__stdcall__)) CoUninitialize(void);
extern "C" HRESULT __attribute__((__stdcall__)) CoGetMalloc(DWORD,LPMALLOC*);
extern "C" DWORD __attribute__((__stdcall__)) CoGetCurrentProcess(void);
extern "C" HRESULT __attribute__((__stdcall__)) CoRegisterMallocSpy(LPMALLOCSPY);
extern "C" HRESULT __attribute__((__stdcall__)) CoRevokeMallocSpy(void);
extern "C" HRESULT __attribute__((__stdcall__)) CoCreateStandardMalloc(DWORD,IMalloc**);




extern "C" HRESULT __attribute__((__stdcall__)) CoGetClassObject(const CLSID&,DWORD,COSERVERINFO*,const IID&,PVOID*);
extern "C" HRESULT __attribute__((__stdcall__)) CoRegisterClassObject(const CLSID&,LPUNKNOWN,DWORD,DWORD,PDWORD);
extern "C" HRESULT __attribute__((__stdcall__)) CoRevokeClassObject(DWORD);
extern "C" HRESULT __attribute__((__stdcall__)) CoGetMarshalSizeMax(ULONG*,const IID&,LPUNKNOWN,DWORD,PVOID,DWORD);
extern "C" HRESULT __attribute__((__stdcall__)) CoMarshalInterface(LPSTREAM,const IID&,LPUNKNOWN,DWORD,PVOID,DWORD);
extern "C" HRESULT __attribute__((__stdcall__)) CoUnmarshalInterface(LPSTREAM,const IID&,PVOID*);
extern "C" HRESULT __attribute__((__stdcall__)) CoMarshalHresult(LPSTREAM,HRESULT);
extern "C" HRESULT __attribute__((__stdcall__)) CoUnmarshalHresult(LPSTREAM,HRESULT*);
extern "C" HRESULT __attribute__((__stdcall__)) CoReleaseMarshalData(LPSTREAM);
extern "C" HRESULT __attribute__((__stdcall__)) CoDisconnectObject(LPUNKNOWN,DWORD);
extern "C" HRESULT __attribute__((__stdcall__)) CoLockObjectExternal(LPUNKNOWN,BOOL,BOOL);
extern "C" HRESULT __attribute__((__stdcall__)) CoGetStandardMarshal(const IID&,LPUNKNOWN,DWORD,PVOID,DWORD,LPMARSHAL*);
extern "C" HRESULT __attribute__((__stdcall__)) CoGetStdMarshalEx(LPUNKNOWN,DWORD,LPUNKNOWN*);
extern "C" BOOL __attribute__((__stdcall__)) CoIsHandlerConnected(LPUNKNOWN);
extern "C" BOOL __attribute__((__stdcall__)) CoHasStrongExternalConnections(LPUNKNOWN);
extern "C" HRESULT __attribute__((__stdcall__)) CoMarshalInterThreadInterfaceInStream(const IID&,LPUNKNOWN,LPSTREAM*);
extern "C" HRESULT __attribute__((__stdcall__)) CoGetInterfaceAndReleaseStream(LPSTREAM,const IID&,PVOID*);
extern "C" HRESULT __attribute__((__stdcall__)) CoCreateFreeThreadedMarshaler(LPUNKNOWN,LPUNKNOWN*);
extern "C" HINSTANCE __attribute__((__stdcall__)) CoLoadLibrary(LPOLESTR,BOOL);
extern "C" void __attribute__((__stdcall__)) CoFreeLibrary(HINSTANCE);
extern "C" void __attribute__((__stdcall__)) CoFreeAllLibraries(void);
extern "C" void __attribute__((__stdcall__)) CoFreeUnusedLibraries(void);
extern "C" HRESULT __attribute__((__stdcall__)) CoCreateInstance(const CLSID&,LPUNKNOWN,DWORD,const IID&,PVOID*);
extern "C" HRESULT __attribute__((__stdcall__)) CoCreateInstanceEx(const CLSID&,IUnknown*,DWORD,COSERVERINFO*,DWORD,MULTI_QI*);
extern "C" HRESULT __attribute__((__stdcall__)) StringFromCLSID(const CLSID&,LPOLESTR*);
extern "C" HRESULT __attribute__((__stdcall__)) CLSIDFromString(LPOLESTR,LPCLSID);
extern "C" HRESULT __attribute__((__stdcall__)) StringFromIID(const IID&,LPOLESTR*);
extern "C" HRESULT __attribute__((__stdcall__)) IIDFromString(LPOLESTR,LPIID);
extern "C" BOOL __attribute__((__stdcall__)) CoIsOle1Class(const CLSID&);
extern "C" HRESULT __attribute__((__stdcall__)) ProgIDFromCLSID(const CLSID&,LPOLESTR*);
extern "C" HRESULT __attribute__((__stdcall__)) CLSIDFromProgID(LPCOLESTR,LPCLSID);
extern "C" int __attribute__((__stdcall__)) StringFromGUID2(const GUID&,LPOLESTR,int);
extern "C" HRESULT __attribute__((__stdcall__)) CoCreateGuid(GUID*);
extern "C" BOOL __attribute__((__stdcall__)) CoFileTimeToDosDateTime(FILETIME*,LPWORD,LPWORD);
extern "C" BOOL __attribute__((__stdcall__)) CoDosDateTimeToFileTime(WORD,WORD,FILETIME*);
extern "C" HRESULT __attribute__((__stdcall__)) CoFileTimeNow(FILETIME*);
extern "C" HRESULT __attribute__((__stdcall__)) CoRegisterMessageFilter(LPMESSAGEFILTER,LPMESSAGEFILTER*);
extern "C" HRESULT __attribute__((__stdcall__)) CoGetTreatAsClass(const CLSID&,LPCLSID);
extern "C" HRESULT __attribute__((__stdcall__)) CoTreatAsClass(const CLSID&,const CLSID&);
typedef HRESULT (__attribute__((__stdcall__)) *LPFNGETCLASSOBJECT)(const CLSID&,const IID&,PVOID*);
typedef HRESULT (__attribute__((__stdcall__)) *LPFNCANUNLOADNOW)(void);
extern "C" HRESULT __attribute__((__stdcall__)) DllGetClassObject(const CLSID&,const IID&,PVOID*);
extern "C" HRESULT __attribute__((__stdcall__)) DllCanUnloadNow(void);
extern "C" PVOID __attribute__((__stdcall__)) CoTaskMemAlloc(ULONG);
extern "C" PVOID __attribute__((__stdcall__)) CoTaskMemRealloc(PVOID,ULONG);
extern "C" void __attribute__((__stdcall__)) CoTaskMemFree(PVOID);
extern "C" HRESULT __attribute__((__stdcall__)) CreateDataAdviseHolder(LPDATAADVISEHOLDER*);
extern "C" HRESULT __attribute__((__stdcall__)) CreateDataCache(LPUNKNOWN,const CLSID&,const IID&,PVOID*);
extern "C" HRESULT __attribute__((__stdcall__)) StgCreateDocfile(const OLECHAR*,DWORD,DWORD,IStorage**);
extern "C" HRESULT __attribute__((__stdcall__)) StgCreateDocfileOnILockBytes(ILockBytes*,DWORD,DWORD,IStorage**);
extern "C" HRESULT __attribute__((__stdcall__)) StgOpenStorage(const OLECHAR*,IStorage*,DWORD,SNB,DWORD,IStorage**);
extern "C" HRESULT __attribute__((__stdcall__)) StgOpenStorageOnILockBytes(ILockBytes*,IStorage*,DWORD,SNB,DWORD,IStorage**);
extern "C" HRESULT __attribute__((__stdcall__)) StgIsStorageFile(const OLECHAR*);
extern "C" HRESULT __attribute__((__stdcall__)) StgIsStorageILockBytes(ILockBytes*);
extern "C" HRESULT __attribute__((__stdcall__)) StgSetTimes(OLECHAR const*,FILETIME const*,FILETIME const*,FILETIME const*);
extern "C" HRESULT __attribute__((__stdcall__)) StgCreateStorageEx(const WCHAR*,DWORD,DWORD,DWORD,STGOPTIONS*,void*,const IID&,void**);
extern "C" HRESULT __attribute__((__stdcall__)) StgOpenStorageEx(const WCHAR*,DWORD,DWORD,DWORD,STGOPTIONS*,void*,const IID&,void**);
extern "C" HRESULT __attribute__((__stdcall__)) BindMoniker(LPMONIKER,DWORD,const IID&,PVOID*);
extern "C" HRESULT __attribute__((__stdcall__)) CoGetObject(LPCWSTR,BIND_OPTS*,const IID&,void**);
extern "C" HRESULT __attribute__((__stdcall__)) MkParseDisplayName(LPBC,LPCOLESTR,ULONG*,LPMONIKER*);
extern "C" HRESULT __attribute__((__stdcall__)) MonikerRelativePathTo(LPMONIKER,LPMONIKER,LPMONIKER*,BOOL);
extern "C" HRESULT __attribute__((__stdcall__)) MonikerCommonPrefixWith(LPMONIKER,LPMONIKER,LPMONIKER*);
extern "C" HRESULT __attribute__((__stdcall__)) CreateBindCtx(DWORD,LPBC*);
extern "C" HRESULT __attribute__((__stdcall__)) CreateGenericComposite(LPMONIKER,LPMONIKER,LPMONIKER*);
extern "C" HRESULT __attribute__((__stdcall__)) GetClassFile (LPCOLESTR,CLSID*);
extern "C" HRESULT __attribute__((__stdcall__)) CreateFileMoniker(LPCOLESTR,LPMONIKER*);
extern "C" HRESULT __attribute__((__stdcall__)) CreateItemMoniker(LPCOLESTR,LPCOLESTR,LPMONIKER*);
extern "C" HRESULT __attribute__((__stdcall__)) CreateAntiMoniker(LPMONIKER*);
extern "C" HRESULT __attribute__((__stdcall__)) CreatePointerMoniker(LPUNKNOWN,LPMONIKER*);
extern "C" HRESULT __attribute__((__stdcall__)) GetRunningObjectTable(DWORD,LPRUNNINGOBJECTTABLE*);
extern "C" HRESULT __attribute__((__stdcall__)) CoInitializeSecurity(PSECURITY_DESCRIPTOR,LONG,SOLE_AUTHENTICATION_SERVICE*, void*,DWORD,DWORD,void*,DWORD,void*);
extern "C" HRESULT __attribute__((__stdcall__)) CoGetCallContext(const IID&,void**);
extern "C" HRESULT __attribute__((__stdcall__)) CoQueryProxyBlanket(IUnknown*, DWORD*,DWORD*,OLECHAR**,DWORD*,DWORD*,RPC_AUTH_IDENTITY_HANDLE*,DWORD*);
extern "C" HRESULT __attribute__((__stdcall__)) CoSetProxyBlanket(IUnknown*,DWORD,DWORD,OLECHAR*,DWORD,DWORD,RPC_AUTH_IDENTITY_HANDLE, DWORD);
extern "C" HRESULT __attribute__((__stdcall__)) CoCopyProxy(IUnknown*,IUnknown**);
extern "C" HRESULT __attribute__((__stdcall__)) CoQueryClientBlanket(DWORD*,DWORD*,OLECHAR**, DWORD*,DWORD*,RPC_AUTHZ_HANDLE*,DWORD*);
extern "C" HRESULT __attribute__((__stdcall__)) CoImpersonateClient(void);
extern "C" HRESULT __attribute__((__stdcall__)) CoRevertToSelf(void);
extern "C" HRESULT __attribute__((__stdcall__)) CoQueryAuthenticationServices(DWORD*, SOLE_AUTHENTICATION_SERVICE**);
extern "C" HRESULT __attribute__((__stdcall__)) CoSwitchCallContext(IUnknown*,IUnknown**);
extern "C" HRESULT __attribute__((__stdcall__)) CoGetInstanceFromFile(COSERVERINFO*, CLSID*,IUnknown*,DWORD,DWORD,OLECHAR*,DWORD,MULTI_QI*);
extern "C" HRESULT __attribute__((__stdcall__)) CoGetInstanceFromIStorage(COSERVERINFO*,CLSID*, IUnknown*,DWORD,struct IStorage*, DWORD,MULTI_QI*);
extern "C" ULONG __attribute__((__stdcall__)) CoAddRefServerProcess(void);
extern "C" ULONG __attribute__((__stdcall__)) CoReleaseServerProcess(void);
extern "C" HRESULT __attribute__((__stdcall__)) CoResumeClassObjects(void);
extern "C" HRESULT __attribute__((__stdcall__)) CoSuspendClassObjects(void);
extern "C" HRESULT __attribute__((__stdcall__)) CoGetPSClsid(const IID&,CLSID*);
extern "C" HRESULT __attribute__((__stdcall__)) CoRegisterPSClsid(const IID&,const CLSID&);

#pragma pack(pop)
# 10 "H:/CPP/wxdevcpp6.10/include/ole2.h" 2 3
# 1 "H:/CPP/wxdevcpp6.10/include/olectlid.h" 1 3



       
# 5 "H:/CPP/wxdevcpp6.10/include/olectlid.h" 3



extern "C" {


extern const GUID IID_IDispatch;
extern const GUID IID_IPropertyNotifySink;
extern const GUID IID_IClassFactory2;
extern const GUID IID_IProvideClassInfo;
extern const GUID IID_IProvideClassInfo2;
extern const GUID IID_IConnectionPointContainer;
extern const GUID IID_IEnumConnectionPoints;
extern const GUID IID_IConnectionPoint;
extern const GUID IID_IEnumConnections;
extern const GUID IID_IOleControl;
extern const GUID IID_IOleControlSite;
extern const GUID IID_ISimpleFrameSite;
extern const GUID IID_IPersistStreamInit;
extern const GUID IID_IPersistMemory;
extern const GUID IID_IPersistPropertyBag;
extern const GUID IID_IPropertyBag;
extern const GUID IID_IErrorLog;
extern const GUID IID_IPropertyFrame;
extern const GUID IID_ISpecifyPropertyPages;
extern const GUID IID_IPerPropertyBrowsing;
extern const GUID IID_IPropertyPageSite;
extern const GUID IID_IPropertyPage;
extern const GUID IID_IPropertyPage2;
extern const GUID CLSID_CFontPropPage;
extern const GUID CLSID_CColorPropPage;
extern const GUID CLSID_CPicturePropPage;
extern const GUID CLSID_PersistPropset;
extern const GUID CLSID_ConvertVBX;
extern const GUID CLSID_StdFont;
extern const GUID CLSID_StdPicture;
extern const GUID IID_IFont;
extern const GUID IID_IFontDisp;
extern const GUID IID_IPicture;
extern const GUID IID_IPictureDisp;
extern const GUID GUID_HIMETRIC;
extern const GUID GUID_COLOR;
extern const GUID GUID_XPOSPIXEL;
extern const GUID GUID_YPOSPIXEL;
extern const GUID GUID_XSIZEPIXEL;
extern const GUID GUID_YSIZEPIXEL;
extern const GUID GUID_XPOS;
extern const GUID GUID_YPOS;
extern const GUID GUID_XSIZE;
extern const GUID GUID_YSIZE;
extern const GUID GUID_TRISTATE;
extern const GUID GUID_OPTIONVALUEEXCLUSIVE;
extern const GUID GUID_CHECKVALUEEXCLUSIVE;
extern const GUID GUID_FONTNAME;
extern const GUID GUID_FONTSIZE;
extern const GUID GUID_FONTBOLD;
extern const GUID GUID_FONTITALIC;
extern const GUID GUID_FONTUNDERSCORE;
extern const GUID GUID_FONTSTRIKETHROUGH;
extern const GUID GUID_HANDLE;
extern const GUID IID_IEnumUnknown;
extern const GUID IID_IEnumString;
extern const GUID IID_IEnumMoniker;
extern const GUID IID_IEnumFORMATETC;
extern const GUID IID_IEnumOLEVERB;
extern const GUID IID_IEnumSTATDATA;
extern const GUID IID_IEnumSTATSTG;
extern const GUID IID_IEnumGeneric;
extern const GUID IID_IEnumHolder;
extern const GUID IID_IEnumCallback;
extern const GUID IID_IPersistStream;
extern const GUID IID_IPersistStorage;
extern const GUID IID_IPersistFile;
extern const GUID IID_IPersist;
extern const GUID IID_IViewObject;
extern const GUID IID_IDataObject;
extern const GUID IID_IAdviseSink;
extern const GUID IID_IDataAdviseHolder;
extern const GUID IID_IOleAdviseHolder;
extern const GUID IID_IOleObject;
extern const GUID IID_IOleInPlaceObject;
extern const GUID IID_IOleWindow;
extern const GUID IID_IOleInPlaceUIWindow;
extern const GUID IID_IOleInPlaceFrame;
extern const GUID IID_IOleInPlaceActiveObject;
extern const GUID IID_IOleClientSite;
extern const GUID IID_IOleInPlaceSite;
extern const GUID IID_IParseDisplayName;
extern const GUID IID_IOleContainer;
extern const GUID IID_IOleItemContainer;
extern const GUID IID_IOleLink;
extern const GUID IID_IOleCache;
extern const GUID IID_IOleManager;
extern const GUID IID_IOlePresObj;
extern const GUID IID_IDropSource;
extern const GUID IID_IDropTarget;
extern const GUID IID_IDebug;
extern const GUID IID_IDebugStream;
extern const GUID IID_IAdviseSink2;
extern const GUID IID_IRunnableObject;
extern const GUID IID_IViewObject2;
extern const GUID IID_IOleCache2;
extern const GUID IID_IOleCacheControl;
extern const GUID CLSID_Picture_Metafile;
extern const GUID CLSID_Picture_Dib;


}
# 11 "H:/CPP/wxdevcpp6.10/include/ole2.h" 2 3
# 1 "H:/CPP/wxdevcpp6.10/include/oleauto.h" 1 3



       
# 5 "H:/CPP/wxdevcpp6.10/include/oleauto.h" 3


#pragma pack(push,8)
# 158 "H:/CPP/wxdevcpp6.10/include/oleauto.h" 3
# 1 "H:/CPP/wxdevcpp6.10/include/oaidl.h" 1 3



       
# 5 "H:/CPP/wxdevcpp6.10/include/oaidl.h" 3



extern "C" {
# 61 "H:/CPP/wxdevcpp6.10/include/oaidl.h" 3
typedef struct ITypeLib *LPTYPELIB;
typedef struct ITypeLib2 *LPTYPELIB2;
typedef struct ICreateTypeInfo *LPCREATETYPEINFO;
typedef struct ICreateTypeInfo2 *LPCREATETYPEINFO2;
typedef struct ICreateTypeLib *LPCREATETYPELIB;
typedef struct ICreateTypeLib2 *LPCREATETYPELIB2;
typedef struct ITypeComp *LPTYPECOMP;
typedef struct ITypeInfo *LPTYPEINFO;
typedef struct ITypeInfo2 *LPTYPEINFO2;
typedef struct IErrorInfo *LPERRORINFO;
typedef struct IDispatch *LPDISPATCH;
typedef struct IEnumVARIANT *LPENUMVARIANT;
typedef struct ICreateErrorInfo *LPCREATEERRORINFO;
typedef struct ISupportErrorInfo *LPSUPPORTERRORINFO;
typedef struct IRecordInfo *LPRECORDINFO;

extern const IID IID_ITypeLib;
extern const IID IID_ITypeLib2;
extern const IID IID_ICreateTypeInfo;
extern const IID IID_ICreateTypeInfo2;
extern const IID IID_ICreateTypeLib;
extern const IID IID_ICreateTypeLib2;
extern const IID IID_ITypeInfo;
extern const IID IID_ITypeInfo2;
extern const IID IID_IErrorInfo;
extern const IID IID_IDispatch;
extern const IID IID_IEnumVARIANT;
extern const IID IID_ICreateErrorInfo;
extern const IID IID_ISupportErrorInfo;
extern const IID IID_IRecordInfo;
extern const IID IID_ITypeMarshal;

typedef enum tagSYSKIND {
 SYS_WIN16,SYS_WIN32,SYS_MAC
} SYSKIND;
typedef enum tagLIBFLAGS {
 LIBFLAG_FRESTRICTED=1,LIBFLAG_FCONTROL=2,LIBFLAG_FHIDDEN=4,
 LIBFLAG_FHASDISKIMAGE=8
} LIBFLAGS;
typedef struct tagTLIBATTR {
 GUID guid;
 LCID lcid;
 SYSKIND syskind;
 WORD wMajorVerNum;
 WORD wMinorVerNum;
 WORD wLibFlags;
} TLIBATTR,*LPTLIBATTR;
typedef CY CURRENCY;
typedef struct tagSAFEARRAYBOUND {
 ULONG cElements;
 LONG lLbound;
}SAFEARRAYBOUND,*LPSAFEARRAYBOUND;
typedef struct _wireSAFEARR_BSTR
{
 ULONG Size;
 wireBSTR *aBstr;
}SAFEARR_BSTR;
typedef struct _wireSAFEARR_UNKNOWN {
 ULONG Size;
 IUnknown **apUnknown;
}SAFEARR_UNKNOWN;
typedef struct _wireSAFEARR_DISPATCH {
 ULONG Size;
 LPDISPATCH *apDispatch;
}SAFEARR_DISPATCH;
typedef struct _wireSAFEARR_VARIANT {
 ULONG Size;
 struct _wireVARIANT *aVariant;
}SAFEARR_VARIANT;
typedef enum tagSF_TYPE {
 SF_ERROR=VT_ERROR,
 SF_I1=VT_I1,
 SF_I2=VT_I2,
 SF_I4=VT_I4,
 SF_I8=VT_I8,
 SF_BSTR=VT_BSTR,
 SF_UNKNOWN=VT_UNKNOWN,
 SF_DISPATCH=VT_DISPATCH,
 SF_VARIANT=VT_VARIANT
}SF_TYPE;
typedef struct _wireBRECORD {
 ULONG fFlags;
 ULONG clSize;
 LPRECORDINFO* pRecInfo;
 byte* pRecord;
} *wireBRECORD;
typedef struct _wireSAFEARR_BRECORD {
    ULONG Size;
    wireBRECORD* aRecord;
    } SAFEARR_BRECORD;
typedef struct _wireSAFEARR_HAVEIID {
 ULONG Size;
 IUnknown** apUnknown;
 IID iid;
 } SAFEARR_HAVEIID;
typedef struct _wireSAFEARRAY_UNION {
 ULONG sfType;
 union {
  SAFEARR_BSTR BstrStr;
  SAFEARR_UNKNOWN UnknownStr;
  SAFEARR_DISPATCH DispatchStr;
  SAFEARR_VARIANT VariantStr;
  SAFEARR_BRECORD RecordStr;
  SAFEARR_HAVEIID HaveIidStr;
  BYTE_SIZEDARR ByteStr;
  WORD_SIZEDARR WordStr;
  DWORD_SIZEDARR LongStr;
  HYPER_SIZEDARR HyperStr;
 }u;
}SAFEARRAYUNION;
typedef struct _wireSAFEARRAY {
 USHORT cDims;
 USHORT fFeatures;
 ULONG cbElements;
 ULONG cLocks;
 SAFEARRAYUNION uArrayStructs;
 SAFEARRAYBOUND rgsabound[1];
}*wireSAFEARRAY;
typedef wireSAFEARRAY *wirePSAFEARRAY;
typedef struct tagSAFEARRAY {
 USHORT cDims;
 USHORT fFeatures;
 ULONG cbElements;
 ULONG cLocks;
 PVOID pvData;
 SAFEARRAYBOUND rgsabound[1];
}SAFEARRAY,*LPSAFEARRAY;

__extension__

typedef struct tagVARIANT {
  __extension__ union {
 struct {
 VARTYPE vt;
 WORD wReserved1;
 WORD wReserved2;
 WORD wReserved3;
 __extension__ union {
  long lVal;
  LONGLONG llVal;
  unsigned char bVal;
  short iVal;
  float fltVal;
  double dblVal;
  VARIANT_BOOL boolVal;
  SCODE scode;
  CY cyVal;
  DATE date;
  BSTR bstrVal;
  IUnknown *punkVal;
  LPDISPATCH pdispVal;
  SAFEARRAY *parray;
  unsigned char *pbVal;
  short *piVal;
  long *plVal;
  float *pfltVal;
  double *pdblVal;
  VARIANT_BOOL *pboolVal;
  _VARIANT_BOOL *pbool;
  SCODE *pscode;
  CY *pcyVal;
  DATE *pdate;
  BSTR *pbstrVal;
  IUnknown **ppunkVal;
  LPDISPATCH *ppdispVal;
  SAFEARRAY **pparray;
  struct tagVARIANT *pvarVal;
  void *byref;
  CHAR cVal;
  USHORT uiVal;
  ULONG ulVal;
  ULONGLONG ullVal;
  INT intVal;
  UINT uintVal;
  DECIMAL *pdecVal;
  CHAR *pcVal;
  USHORT *puiVal;
  ULONG *pulVal;
  INT *pintVal;
  UINT *puintVal;
  __extension__ struct {
   PVOID pvRecord;
   struct IRecordInfo *pRecInfo;
  } ;
 } ;
    } ;
    DECIMAL decVal;
  } ;
} VARIANT,*LPVARIANT;
typedef VARIANT VARIANTARG;
typedef VARIANT *LPVARIANTARG;
typedef struct _wireVARIANT {
 DWORD clSize;
 DWORD rpcReserved;
 USHORT vt;
 USHORT wReserved1;
 USHORT wReserved2;
 USHORT wReserved3;
 __extension__ union {
  LONG lVal;
  LONGLONG llVal;
  BYTE bVal;
  SHORT iVal;
  FLOAT fltVal;
  DOUBLE dblVal;
  VARIANT_BOOL boolVal;
  SCODE scode;
  CY cyVal;
  DATE date;
  wireBSTR bstrVal;
  IUnknown *punkVal;
  LPDISPATCH pdispVal;
  wirePSAFEARRAY parray;
  wireBRECORD brecVal;
  BYTE *pbVal;
  SHORT *piVal;
  LONG *plVal;
  FLOAT *pfltVal;
  DOUBLE *pdblVal;
  VARIANT_BOOL *pboolVal;
  SCODE *pscode;
  CY *pcyVal;
  DATE *pdate;
  wireBSTR *pbstrVal;
  IUnknown **ppunkVal;
  LPDISPATCH *ppdispVal;
  wirePSAFEARRAY *pparray;
  struct _wireVARIANT *pvarVal;
  CHAR cVal;
  USHORT uiVal;
  ULONG ulVal;
  ULONGLONG ullVal;
  INT intVal;
  UINT uintVal;
  DECIMAL decVal;
  DECIMAL *pdecVal;
  CHAR *pcVal;
  USHORT *puiVal;
  ULONG *pulVal;
  INT *pintVal;
  UINT *puintVal;
 } ;
} *wireVARIANT;
typedef LONG DISPID;
typedef DISPID MEMBERID;
typedef DWORD HREFTYPE;
typedef enum tagTYPEKIND {
 TKIND_ENUM,TKIND_RECORD,TKIND_MODULE,TKIND_INTERFACE,TKIND_DISPATCH,
 TKIND_COCLASS,TKIND_ALIAS,TKIND_UNION,TKIND_MAX
}TYPEKIND;
typedef struct tagTYPEDESC {
 __extension__ union {
  struct tagTYPEDESC *lptdesc;
  struct tagARRAYDESC *lpadesc;
  HREFTYPE hreftype;
 } ;
 VARTYPE vt;
}TYPEDESC;
typedef struct tagARRAYDESC {
 TYPEDESC tdescElem;
 USHORT cDims;
 SAFEARRAYBOUND rgbounds[1];
}ARRAYDESC;
typedef struct tagPARAMDESCEX {
 ULONG cBytes;
 VARIANTARG varDefaultValue;
}PARAMDESCEX,*LPPARAMDESCEX;
typedef struct tagPARAMDESC {
 LPPARAMDESCEX pparamdescex;
 USHORT wParamFlags;
}PARAMDESC,*LPPARAMDESC;
typedef struct tagIDLDESC {
 ULONG dwReserved;
 USHORT wIDLFlags;
}IDLDESC,*LPIDLDESC;
typedef struct tagELEMDESC {
 TYPEDESC tdesc;
 __extension__ union {
  IDLDESC idldesc;
  PARAMDESC paramdesc;
 } ;
} ELEMDESC,*LPELEMDESC;
typedef struct tagTYPEATTR {
 GUID guid;
 LCID lcid;
 DWORD dwReserved;
 MEMBERID memidConstructor;
 MEMBERID memidDestructor;
 LPOLESTR lpstrSchema;
 ULONG cbSizeInstance;
 TYPEKIND typekind;
 WORD cFuncs;
 WORD cVars;
 WORD cImplTypes;
 WORD cbSizeVft;
 WORD cbAlignment;
 WORD wTypeFlags;
 WORD wMajorVerNum;
 WORD wMinorVerNum;
 TYPEDESC tdescAlias;
 IDLDESC idldescType;
}TYPEATTR,*LPTYPEATTR;
typedef struct tagDISPPARAMS {
 VARIANTARG *rgvarg;
 DISPID *rgdispidNamedArgs;
 UINT cArgs;
 UINT cNamedArgs;
}DISPPARAMS;
typedef struct tagEXCEPINFO {
 WORD wCode;
 WORD wReserved;
 BSTR bstrSource;
 BSTR bstrDescription;
 BSTR bstrHelpFile;
 DWORD dwHelpContext;
 PVOID pvReserved;
 HRESULT(__attribute__((__stdcall__)) * pfnDeferredFillIn)(struct tagEXCEPINFO*);
 SCODE scode;
} EXCEPINFO,*LPEXCEPINFO;
typedef enum tagCALLCONV {
 CC_FASTCALL,CC_CDECL,CC_MSCPASCAL,CC_PASCAL=CC_MSCPASCAL,
 CC_MACPASCAL,CC_STDCALL,CC_FPFASTCALL,CC_SYSCALL,CC_MPWCDECL,
 CC_MPWPASCAL,CC_MAX=CC_MPWPASCAL
}CALLCONV;
typedef enum tagFUNCKIND {
 FUNC_VIRTUAL,FUNC_PUREVIRTUAL,FUNC_NONVIRTUAL,
 FUNC_STATIC,FUNC_DISPATCH
}FUNCKIND;
typedef enum tagINVOKEKIND {
 INVOKE_FUNC=1,INVOKE_PROPERTYGET,INVOKE_PROPERTYPUT=4,
 INVOKE_PROPERTYPUTREF=8
}INVOKEKIND;
typedef struct tagFUNCDESC {
 MEMBERID memid;
 SCODE *lprgscode;
 ELEMDESC *lprgelemdescParam;
 FUNCKIND funckind;
 INVOKEKIND invkind;
 CALLCONV callconv;
 SHORT cParams;
 SHORT cParamsOpt;
 SHORT oVft;
 SHORT cScodes;
 ELEMDESC elemdescFunc;
 WORD wFuncFlags;
}FUNCDESC,*LPFUNCDESC;
typedef enum tagVARKIND {
 VAR_PERINSTANCE,VAR_STATIC,VAR_CONST,VAR_DISPATCH
} VARKIND;
typedef struct tagVARDESC {
 MEMBERID memid;
 LPOLESTR lpstrSchema;
 __extension__ union {
  ULONG oInst;
  VARIANT *lpvarValue;
 } ;
 ELEMDESC elemdescVar;
 WORD wVarFlags;
 VARKIND varkind;
} VARDESC,*LPVARDESC;
typedef enum tagTYPEFLAGS {
 TYPEFLAG_FAPPOBJECT=1,TYPEFLAG_FCANCREATE=2,TYPEFLAG_FLICENSED=4,
 TYPEFLAG_FPREDECLID=8,TYPEFLAG_FHIDDEN=16,TYPEFLAG_FCONTROL=32,
 TYPEFLAG_FDUAL=64,TYPEFLAG_FNONEXTENSIBLE=128,
 TYPEFLAG_FOLEAUTOMATION=256,TYPEFLAG_FRESTRICTED=512,
 TYPEFLAG_FAGGREGATABLE=1024,TYPEFLAG_FREPLACEABLE=2048,
 TYPEFLAG_FDISPATCHABLE=4096,TYPEFLAG_FREVERSEBIND=8192
} TYPEFLAGS;
typedef enum tagFUNCFLAGS {
 FUNCFLAG_FRESTRICTED=1,FUNCFLAG_FSOURCE=2,FUNCFLAG_FBINDABLE=4,
 FUNCFLAG_FREQUESTEDIT=8,FUNCFLAG_FDISPLAYBIND=16,FUNCFLAG_FDEFAULTBIND=32,
 FUNCFLAG_FHIDDEN=64,FUNCFLAG_FUSESGETLASTERROR=128,FUNCFLAG_FDEFAULTCOLLELEM=256,
 FUNCFLAG_FUIDEFAULT=512,FUNCFLAG_FNONBROWSABLE=1024,FUNCFLAG_FREPLACEABLE=2048,
 FUNCFLAG_FIMMEDIATEBIND=4096
} FUNCFLAGS;
typedef enum tagVARFLAGS {
 VARFLAG_FREADONLY=1,VARFLAG_FSOURCE=2,VARFLAG_FBINDABLE=4,VARFLAG_FREQUESTEDIT=8,
 VARFLAG_FDISPLAYBIND=16,VARFLAG_FDEFAULTBIND=32,VARFLAG_FHIDDEN=64,VARFLAG_FRESTRICTED=128,
 VARFLAG_FDEFAULTCOLLELEM=256,VARFLAG_FUIDEFAULT=512,VARFLAG_FNONBROWSABLE=1024,
 VARFLAG_FREPLACEABLE=2048,VARFLAG_FIMMEDIATEBIND=4096
} VARFLAGS;
typedef struct tagCLEANLOCALSTORAGE {
 IUnknown *pInterface;
 PVOID pStorage;
 DWORD flags;
} CLEANLOCALSTORAGE;
typedef struct tagCUSTDATAITEM {
 GUID guid;
 VARIANTARG varValue;
} CUSTDATAITEM,*LPCUSTDATAITEM;
typedef struct tagCUSTDATA {
 DWORD cCustData;
 LPCUSTDATAITEM prgCustData;
} CUSTDATA,*LPCUSTDATA;

typedef enum tagDESCKIND {
        DESCKIND_NONE=0,DESCKIND_FUNCDESC=DESCKIND_NONE+1,
        DESCKIND_VARDESC=DESCKIND_FUNCDESC+1,DESCKIND_TYPECOMP=DESCKIND_VARDESC+1,
        DESCKIND_IMPLICITAPPOBJ=DESCKIND_TYPECOMP+1,
        DESCKIND_MAX=DESCKIND_IMPLICITAPPOBJ+1
} DESCKIND;

typedef union tagBINDPTR {
        LPFUNCDESC lpfuncdesc;
        LPVARDESC lpvardesc;
        LPTYPECOMP lptcomp;
} BINDPTR,*LPBINDPTR;



struct IDispatch : public IUnknown
{
 virtual HRESULT __attribute__((__stdcall__)) QueryInterface( const IID&,PVOID*) =0;
 virtual ULONG __attribute__((__stdcall__)) AddRef(void) =0;
 virtual ULONG __attribute__((__stdcall__)) Release(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetTypeInfoCount( UINT*) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetTypeInfo( UINT,LCID,LPTYPEINFO*) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetIDsOfNames( const IID&,LPOLESTR*,UINT,LCID,DISPID*) =0;
 virtual HRESULT __attribute__((__stdcall__)) Invoke( DISPID,const IID&,LCID,WORD,DISPPARAMS*,VARIANT*,EXCEPINFO*,UINT*) =0;
};
# 494 "H:/CPP/wxdevcpp6.10/include/oaidl.h" 3
struct IEnumVARIANT : public IUnknown
{
 virtual HRESULT __attribute__((__stdcall__)) QueryInterface( const IID&,PVOID*) =0;
 virtual ULONG __attribute__((__stdcall__)) AddRef(void) =0;
 virtual ULONG __attribute__((__stdcall__)) Release(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) Next( ULONG,VARIANT*,ULONG*) =0;
 virtual HRESULT __attribute__((__stdcall__)) Skip( ULONG) =0;
 virtual HRESULT __attribute__((__stdcall__)) Reset(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) Clone( IEnumVARIANT**) =0;
};



struct ITypeComp : public IUnknown
{
 virtual HRESULT __attribute__((__stdcall__)) QueryInterface( const IID&,PVOID*) =0;
 virtual ULONG __attribute__((__stdcall__)) AddRef(void) =0;
 virtual ULONG __attribute__((__stdcall__)) Release(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) Bind( LPOLESTR,ULONG,WORD,LPTYPEINFO*,DESCKIND*,LPBINDPTR) =0;
 virtual HRESULT __attribute__((__stdcall__)) BindType( LPOLESTR,ULONG,LPTYPEINFO*,LPTYPECOMP*) =0;
};



struct ITypeInfo : public IUnknown
{
 virtual HRESULT __attribute__((__stdcall__)) QueryInterface( const IID&,PVOID*) =0;
 virtual ULONG __attribute__((__stdcall__)) AddRef(void) =0;
 virtual ULONG __attribute__((__stdcall__)) Release(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetTypeAttr( LPTYPEATTR*) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetTypeComp( LPTYPECOMP*) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetFuncDesc( UINT,LPFUNCDESC*) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetVarDesc( UINT,LPVARDESC*) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetNames( MEMBERID,BSTR*,UINT,UINT*) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetRefTypeOfImplType( UINT,HREFTYPE*) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetImplTypeFlags( UINT,INT*) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetIDsOfNames( LPOLESTR*,UINT,MEMBERID*) =0;
 virtual HRESULT __attribute__((__stdcall__)) Invoke( PVOID,MEMBERID,WORD,DISPPARAMS*,VARIANT*,EXCEPINFO*,UINT*) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetDocumentation( MEMBERID,BSTR*,BSTR*,DWORD*,BSTR*) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetDllEntry( MEMBERID,INVOKEKIND,BSTR*,BSTR*,WORD*) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetRefTypeInfo( HREFTYPE,LPTYPEINFO*) =0;
 virtual HRESULT __attribute__((__stdcall__)) AddressOfMember( MEMBERID,INVOKEKIND,PVOID*) =0;
 virtual HRESULT __attribute__((__stdcall__)) CreateInstance( LPUNKNOWN,const IID&,PVOID*) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetMops( MEMBERID,BSTR*) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetContainingTypeLib( LPTYPELIB*,UINT*) =0;
 virtual void __attribute__((__stdcall__)) ReleaseTypeAttr( LPTYPEATTR) =0;
 virtual void __attribute__((__stdcall__)) ReleaseFuncDesc( LPFUNCDESC) =0;
 virtual void __attribute__((__stdcall__)) ReleaseVarDesc( LPVARDESC) =0;
};
# 571 "H:/CPP/wxdevcpp6.10/include/oaidl.h" 3
struct ITypeInfo2 : public ITypeInfo
{
 virtual HRESULT __attribute__((__stdcall__)) QueryInterface( const IID&,PVOID*) =0;
 virtual ULONG __attribute__((__stdcall__)) AddRef(void) =0;
 virtual ULONG __attribute__((__stdcall__)) Release(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetTypeAttr( LPTYPEATTR*) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetTypeComp( LPTYPECOMP*) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetFuncDesc( UINT,LPFUNCDESC*) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetVarDesc( UINT,LPVARDESC*) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetNames( MEMBERID,BSTR*,UINT,UINT*) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetRefTypeOfImplType( UINT,HREFTYPE*) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetImplTypeFlags( UINT,INT*) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetIDsOfNames( LPOLESTR*,UINT,MEMBERID*) =0;
 virtual HRESULT __attribute__((__stdcall__)) Invoke( PVOID,MEMBERID,WORD,DISPPARAMS*,VARIANT*,EXCEPINFO*,UINT*) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetDocumentation( MEMBERID,BSTR*,BSTR*,DWORD*,BSTR*) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetDllEntry( MEMBERID,INVOKEKIND,BSTR*,BSTR*,WORD*) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetRefTypeInfo( HREFTYPE,LPTYPEINFO*) =0;
 virtual HRESULT __attribute__((__stdcall__)) AddressOfMember( MEMBERID,INVOKEKIND,PVOID*) =0;
 virtual HRESULT __attribute__((__stdcall__)) CreateInstance( LPUNKNOWN,const IID&,PVOID*) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetMops( MEMBERID,BSTR*) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetContainingTypeLib( LPTYPELIB*,UINT*) =0;
 virtual void __attribute__((__stdcall__)) ReleaseTypeAttr( LPTYPEATTR) =0;
 virtual void __attribute__((__stdcall__)) ReleaseFuncDesc( LPFUNCDESC) =0;
 virtual void __attribute__((__stdcall__)) ReleaseVarDesc( LPVARDESC) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetTypeKind( TYPEKIND*) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetTypeFlags( ULONG*) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetFuncIndexOfMemId( MEMBERID,INVOKEKIND,UINT*) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetVarIndexOfMemId( MEMBERID,UINT*) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetCustData( const GUID&,VARIANT*) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetFuncCustData( UINT,const GUID&,VARIANT*) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetParamCustData( UINT,UINT,const GUID&,VARIANT*) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetVarCustData( UINT,const GUID&,VARIANT*) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetImplTypeCustData( UINT,const GUID&,VARIANT*) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetDocumentation2( MEMBERID,LCID,BSTR*,DWORD*,BSTR*) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetAllCustData( CUSTDATA*) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetAllFuncCustData( UINT,CUSTDATA*) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetAllParamCustData( UINT,UINT,CUSTDATA*) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetAllVarCustData( UINT,CUSTDATA*) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetAllImplTypeCustData( UINT,CUSTDATA*) =0;
};



struct ITypeLib : public IUnknown
{
 virtual HRESULT __attribute__((__stdcall__)) QueryInterface( const IID&,PVOID*) =0;
 virtual ULONG __attribute__((__stdcall__)) AddRef(void) =0;
 virtual ULONG __attribute__((__stdcall__)) Release(void) =0;
 virtual UINT __attribute__((__stdcall__)) GetTypeInfoCount(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetTypeInfo( UINT,ITypeInfo**) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetTypeInfoType( UINT,TYPEKIND*) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetTypeInfoOfGuid( const GUID&,ITypeInfo**) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetLibAttr( TLIBATTR**) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetTypeComp( ITypeComp*) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetDocumentation( INT,BSTR*,BSTR*,DWORD*,BSTR*) =0;
 virtual HRESULT __attribute__((__stdcall__)) IsName( LPOLESTR,ULONG,BOOL*) =0;
 virtual HRESULT __attribute__((__stdcall__)) FindName( LPOLESTR,ULONG,ITypeInfo**,MEMBERID*,USHORT*) =0;
 virtual void __attribute__((__stdcall__)) ReleaseTLibAttr( TLIBATTR*) =0;
};



struct ITypeLib2 : public ITypeLib
{
 virtual HRESULT __attribute__((__stdcall__)) QueryInterface( const IID&,PVOID*) =0;
 virtual ULONG __attribute__((__stdcall__)) AddRef(void) =0;
 virtual ULONG __attribute__((__stdcall__)) Release(void) =0;
 virtual UINT __attribute__((__stdcall__)) GetTypeInfoCount(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetTypeInfo( UINT,ITypeInfo**) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetTypeInfoType( UINT,TYPEKIND*) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetTypeInfoOfGuid( const GUID&,ITypeInfo**) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetLibAttr( TLIBATTR**) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetTypeComp( ITypeComp*) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetDocumentation( INT,BSTR*,BSTR*,DWORD*,BSTR*) =0;
 virtual HRESULT __attribute__((__stdcall__)) IsName( LPOLESTR,ULONG,BOOL*) =0;
 virtual HRESULT __attribute__((__stdcall__)) FindName( LPOLESTR,ULONG,ITypeInfo**,MEMBERID*,USHORT*) =0;
 virtual void __attribute__((__stdcall__)) ReleaseTLibAttr( TLIBATTR*) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetCustData( const GUID&,VARIANT*) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetLibStatistics( ULONG*,ULONG*) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetDocumentation2( INT,LCID,BSTR*,DWORD*,BSTR*) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetAllCustData( CUSTDATA*) =0;
};

extern "C" const IID IID_IErrorInfo;


struct IErrorInfo : public IUnknown
{
 virtual HRESULT __attribute__((__stdcall__)) QueryInterface( const IID&,PVOID*) =0;
 virtual ULONG __attribute__((__stdcall__)) AddRef(void) =0;
 virtual ULONG __attribute__((__stdcall__)) Release(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetGUID( GUID*) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetSource( BSTR*) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetDescription( BSTR*) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetHelpFile( BSTR*) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetHelpContext( DWORD*) =0;
};
# 680 "H:/CPP/wxdevcpp6.10/include/oaidl.h" 3
extern "C" const IID IID_ICreateErrorInfo;


struct ICreateErrorInfo : public IUnknown
{
 virtual HRESULT __attribute__((__stdcall__)) QueryInterface( const IID&,PVOID*)=0;
 virtual ULONG __attribute__((__stdcall__)) AddRef(void) =0;
 virtual ULONG __attribute__((__stdcall__)) Release(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) SetGUID( const GUID&) =0;
 virtual HRESULT __attribute__((__stdcall__)) SetSource( LPOLESTR) =0;
 virtual HRESULT __attribute__((__stdcall__)) SetDescription( LPOLESTR) =0;
 virtual HRESULT __attribute__((__stdcall__)) SetHelpFile( LPOLESTR) =0;
 virtual HRESULT __attribute__((__stdcall__)) SetHelpContext( DWORD) =0;
};

extern "C" const IID IID_ISupportErrorInfo;


struct ISupportErrorInfo : public IUnknown
{
 virtual HRESULT __attribute__((__stdcall__)) QueryInterface( const IID&,PVOID*) =0;
 virtual ULONG __attribute__((__stdcall__)) AddRef(void) =0;
 virtual ULONG __attribute__((__stdcall__)) Release(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) InterfaceSupportsErrorInfo( const IID&) =0;
};

extern "C" const IID IID_IRecordInfo;


struct IRecordInfo : public IUnknown
{
 virtual HRESULT __attribute__((__stdcall__)) QueryInterface( const IID&,PVOID*) =0;
 virtual ULONG __attribute__((__stdcall__)) AddRef(void) =0;
 virtual ULONG __attribute__((__stdcall__)) Release(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) RecordInit( PVOID) =0;
 virtual HRESULT __attribute__((__stdcall__)) RecordClear( PVOID) =0;
 virtual HRESULT __attribute__((__stdcall__)) RecordCopy( PVOID, PVOID) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetGuid( GUID*) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetName( BSTR*) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetSize( ULONG*) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetTypeInfo( ITypeInfo**) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetField( PVOID,LPCOLESTR,VARIANT*) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetFieldNoCopy( PVOID,LPCOLESTR,VARIANT*,PVOID*) =0;
 virtual HRESULT __attribute__((__stdcall__)) PutField( ULONG,PVOID,LPCOLESTR, VARIANT*) =0;
 virtual HRESULT __attribute__((__stdcall__)) PutFieldNoCopy( ULONG,PVOID,LPCOLESTR,VARIANT*) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetFieldNames( ULONG*,BSTR*) =0;
 virtual BOOL __attribute__((__stdcall__)) IsMatchingType( void) =0;
 virtual PVOID __attribute__((__stdcall__)) RecordCreate(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) RecordCreateCopy( PVOID,PVOID*) =0;
 virtual HRESULT __attribute__((__stdcall__)) RecordDestroy( PVOID) =0;
};
# 754 "H:/CPP/wxdevcpp6.10/include/oaidl.h" 3
extern "C" const IID IID_ITypeMarshal;


struct ITypeMarshal : public IUnknown
{
 virtual HRESULT __attribute__((__stdcall__)) QueryInterface( const IID&,PVOID*) =0;
 virtual ULONG __attribute__((__stdcall__)) AddRef(void) =0;
 virtual ULONG __attribute__((__stdcall__)) Release(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) Size( PVOID,DWORD,PVOID,ULONG*) =0;
 virtual HRESULT __attribute__((__stdcall__)) Marshal( PVOID,DWORD,PVOID,ULONG,BYTE*,ULONG*) =0;
 virtual HRESULT __attribute__((__stdcall__)) Unmarshal( PVOID,DWORD,ULONG,BYTE*,ULONG*) =0;
 virtual HRESULT __attribute__((__stdcall__)) Free( PVOID) =0;
};


}
# 159 "H:/CPP/wxdevcpp6.10/include/oleauto.h" 2 3

typedef enum tagREGKIND {
 REGKIND_DEFAULT,
 REGKIND_REGISTER,
 REGKIND_NONE
} REGKIND;
typedef struct tagPARAMDATA {
 OLECHAR *szName;
 VARTYPE vt;
} PARAMDATA,*LPPARAMDATA;
typedef struct tagMETHODDATA {
 OLECHAR *szName;
 PARAMDATA *ppdata;
 DISPID dispid;
 UINT iMeth;
 CALLCONV cc;
 UINT cArgs;
 WORD wFlags;
 VARTYPE vtReturn;
} METHODDATA,*LPMETHODDATA;
typedef struct tagINTERFACEDATA {
 METHODDATA *pmethdata;
 UINT cMembers;
} INTERFACEDATA,*LPINTERFACEDATA;

typedef struct {
 SYSTEMTIME st;
 USHORT wDayOfYear;
} UDATE;

typedef struct {
 int cDig;
 unsigned long dwInFlags;
 unsigned long dwOutFlags;
 int cchUsed;
 int nBaseShift;
 int nPwr10;
} NUMPARSE;

extern "C" BSTR __attribute__((__stdcall__)) SysAllocString(const OLECHAR*);
extern "C" int __attribute__((__stdcall__)) SysReAllocString(BSTR*,const OLECHAR*);
extern "C" BSTR __attribute__((__stdcall__)) SysAllocStringLen(const OLECHAR*,unsigned int);
extern "C" int __attribute__((__stdcall__)) SysReAllocStringLen(BSTR*,const OLECHAR*,unsigned int);
extern "C" void __attribute__((__stdcall__)) SysFreeString(BSTR);
extern "C" unsigned int __attribute__((__stdcall__)) SysStringLen(BSTR);
extern "C" unsigned int __attribute__((__stdcall__)) SysStringByteLen(BSTR);
extern "C" BSTR __attribute__((__stdcall__)) SysAllocStringByteLen(const char*,unsigned int);
extern "C" int __attribute__((__stdcall__)) DosDateTimeToVariantTime(unsigned short,unsigned short,double*);
extern "C" int __attribute__((__stdcall__)) VariantTimeToDosDateTime(double,unsigned short*,unsigned short*);
extern "C" int __attribute__((__stdcall__)) VariantTimeToSystemTime(double,LPSYSTEMTIME);
extern "C" int __attribute__((__stdcall__)) SystemTimeToVariantTime(LPSYSTEMTIME, double*);
extern "C" HRESULT __attribute__((__stdcall__)) VarDateFromUdate(UDATE*,ULONG,DATE*);
extern "C" HRESULT __attribute__((__stdcall__)) VarDateFromUdateEx(UDATE*,LCID,ULONG,DATE*);
extern "C" HRESULT __attribute__((__stdcall__)) VarUdateFromDate(DATE,ULONG,UDATE*);
extern "C" HRESULT __attribute__((__stdcall__)) SafeArrayAllocDescriptor(unsigned int,SAFEARRAY**);
extern "C" HRESULT __attribute__((__stdcall__)) SafeArrayAllocData(SAFEARRAY*);
extern "C" SAFEARRAY* __attribute__((__stdcall__)) SafeArrayCreate(VARTYPE,unsigned int,SAFEARRAYBOUND*);
extern "C" HRESULT __attribute__((__stdcall__)) SafeArrayDestroyDescriptor(SAFEARRAY*);
extern "C" HRESULT __attribute__((__stdcall__)) SafeArrayDestroyData(SAFEARRAY*);
extern "C" HRESULT __attribute__((__stdcall__)) SafeArrayDestroy(SAFEARRAY*);
extern "C" HRESULT __attribute__((__stdcall__)) SafeArrayRedim(SAFEARRAY*,SAFEARRAYBOUND*);
extern "C" unsigned int __attribute__((__stdcall__)) SafeArrayGetDim(SAFEARRAY*);
extern "C" unsigned int __attribute__((__stdcall__)) SafeArrayGetElemsize(SAFEARRAY*);
extern "C" HRESULT __attribute__((__stdcall__)) SafeArrayGetUBound(SAFEARRAY*,unsigned int,long*);
extern "C" HRESULT __attribute__((__stdcall__)) SafeArrayGetLBound(SAFEARRAY*,unsigned int,long*);
extern "C" HRESULT __attribute__((__stdcall__)) SafeArrayLock(SAFEARRAY*);
extern "C" HRESULT __attribute__((__stdcall__)) SafeArrayUnlock(SAFEARRAY*);
extern "C" HRESULT __attribute__((__stdcall__)) SafeArrayAccessData(SAFEARRAY*,void**);
extern "C" HRESULT __attribute__((__stdcall__)) SafeArrayUnaccessData(SAFEARRAY*);
extern "C" HRESULT __attribute__((__stdcall__)) SafeArrayGetElement(SAFEARRAY*,long*,void*);
extern "C" HRESULT __attribute__((__stdcall__)) SafeArrayPutElement(SAFEARRAY*,long*,void*);
extern "C" HRESULT __attribute__((__stdcall__)) SafeArrayCopy(SAFEARRAY*,SAFEARRAY**);
extern "C" HRESULT __attribute__((__stdcall__)) SafeArrayPtrOfIndex(SAFEARRAY*,long*,void**);
extern "C" SAFEARRAY* __attribute__((__stdcall__)) SafeArrayCreateVector(VARTYPE,LONG,ULONG);
extern "C" SAFEARRAY* __attribute__((__stdcall__)) SafeArrayCreateVectorEx(VARTYPE,LONG,ULONG,LPVOID);
extern "C" HRESULT __attribute__((__stdcall__)) SafeArrayAllocDescriptorEx(VARTYPE,UINT,SAFEARRAY**);
extern "C" HRESULT __attribute__((__stdcall__)) SafeArrayGetVartype(SAFEARRAY*,VARTYPE*);
extern "C" HRESULT __attribute__((__stdcall__)) SafeArraySetRecordInfo(SAFEARRAY*,IRecordInfo*);
extern "C" HRESULT __attribute__((__stdcall__)) SafeArrayGetRecordInfo(SAFEARRAY*,IRecordInfo**);
extern "C" HRESULT __attribute__((__stdcall__)) SafeArraySetIID(SAFEARRAY*,const GUID&);
extern "C" HRESULT __attribute__((__stdcall__)) SafeArrayGetIID(SAFEARRAY*,GUID*);
extern "C" void __attribute__((__stdcall__)) VariantInit(VARIANTARG*);
extern "C" HRESULT __attribute__((__stdcall__)) VariantClear(VARIANTARG*);
extern "C" HRESULT __attribute__((__stdcall__)) VariantCopy(VARIANTARG*,VARIANTARG*);
extern "C" HRESULT __attribute__((__stdcall__)) VariantCopyInd(VARIANT*,VARIANTARG*);
extern "C" HRESULT __attribute__((__stdcall__)) VariantChangeType(VARIANTARG*,VARIANTARG*,unsigned short,VARTYPE);
extern "C" HRESULT __attribute__((__stdcall__)) VariantChangeTypeEx(VARIANTARG*,VARIANTARG*,LCID,unsigned short,VARTYPE);
extern "C" HRESULT __attribute__((__stdcall__)) VarUI1FromI2(short,unsigned char*);
extern "C" HRESULT __attribute__((__stdcall__)) VarUI1FromI4(long,unsigned char*);
extern "C" HRESULT __attribute__((__stdcall__)) VarUI1FromR4(float,unsigned char*);
extern "C" HRESULT __attribute__((__stdcall__)) VarUI1FromR8(double,unsigned char*);
extern "C" HRESULT __attribute__((__stdcall__)) VarUI1FromCy(CY,unsigned char*);
extern "C" HRESULT __attribute__((__stdcall__)) VarUI1FromDate(DATE,unsigned char*);
extern "C" HRESULT __attribute__((__stdcall__)) VarUI1FromStr(OLECHAR*,LCID,unsigned long,unsigned char*);
extern "C" HRESULT __attribute__((__stdcall__)) VarUI1FromDisp(LPDISPATCH,LCID,unsigned char*);
extern "C" HRESULT __attribute__((__stdcall__)) VarUI1FromBool(VARIANT_BOOL,unsigned char*);
extern "C" HRESULT __attribute__((__stdcall__)) VarI2FromUI1(unsigned char,short*);
extern "C" HRESULT __attribute__((__stdcall__)) VarI2FromI4(long,short*);
extern "C" HRESULT __attribute__((__stdcall__)) VarI2FromR4(float,short*);
extern "C" HRESULT __attribute__((__stdcall__)) VarI2FromR8(double,short*);
extern "C" HRESULT __attribute__((__stdcall__)) VarI2FromCy(CY cyIn,short*);
extern "C" HRESULT __attribute__((__stdcall__)) VarI2FromDate(DATE,short*);
extern "C" HRESULT __attribute__((__stdcall__)) VarI2FromStr(OLECHAR*,LCID,unsigned long,short*);
extern "C" HRESULT __attribute__((__stdcall__)) VarI2FromDisp(LPDISPATCH,LCID,short*);
extern "C" HRESULT __attribute__((__stdcall__)) VarI2FromBool(VARIANT_BOOL,short*);
extern "C" HRESULT __attribute__((__stdcall__)) VarI4FromUI1(unsigned char,long*);
extern "C" HRESULT __attribute__((__stdcall__)) VarI4FromI2(short,long*);
extern "C" HRESULT __attribute__((__stdcall__)) VarI4FromR4(float,long*);
extern "C" HRESULT __attribute__((__stdcall__)) VarI4FromR8(double,long*);
extern "C" HRESULT __attribute__((__stdcall__)) VarI4FromCy(CY,long*);
extern "C" HRESULT __attribute__((__stdcall__)) VarI4FromDate(DATE,long*);
extern "C" HRESULT __attribute__((__stdcall__)) VarI4FromStr(OLECHAR*,LCID,unsigned long,long*);
extern "C" HRESULT __attribute__((__stdcall__)) VarI4FromDisp(LPDISPATCH,LCID,long*);
extern "C" HRESULT __attribute__((__stdcall__)) VarI4FromBool(VARIANT_BOOL,long*);
extern "C" HRESULT __attribute__((__stdcall__)) VarR4FromUI1(unsigned char,float*);
extern "C" HRESULT __attribute__((__stdcall__)) VarR4FromI2(short,float*);
extern "C" HRESULT __attribute__((__stdcall__)) VarR4FromI4(long,float*);
extern "C" HRESULT __attribute__((__stdcall__)) VarR4FromR8(double,float*);
extern "C" HRESULT __attribute__((__stdcall__)) VarR4FromCy(CY,float*);
extern "C" HRESULT __attribute__((__stdcall__)) VarR4FromDate(DATE,float*);
extern "C" HRESULT __attribute__((__stdcall__)) VarR4FromStr(OLECHAR*,LCID,unsigned long,float*);
extern "C" HRESULT __attribute__((__stdcall__)) VarR4FromDisp(LPDISPATCH,LCID,float*);
extern "C" HRESULT __attribute__((__stdcall__)) VarR4FromBool(VARIANT_BOOL,float*);
extern "C" HRESULT __attribute__((__stdcall__)) VarR8FromUI1(unsigned char,double*);
extern "C" HRESULT __attribute__((__stdcall__)) VarR8FromI2(short,double*);
extern "C" HRESULT __attribute__((__stdcall__)) VarR8FromI4(long,double*);
extern "C" HRESULT __attribute__((__stdcall__)) VarR8FromR4(float,double*);
extern "C" HRESULT __attribute__((__stdcall__)) VarR8FromCy(CY,double*);
extern "C" HRESULT __attribute__((__stdcall__)) VarR8FromDate(DATE,double*);
extern "C" HRESULT __attribute__((__stdcall__)) VarR8FromStr(OLECHAR*,LCID,unsigned long,double*);
extern "C" HRESULT __attribute__((__stdcall__)) VarR8FromDisp(LPDISPATCH,LCID,double*);
extern "C" HRESULT __attribute__((__stdcall__)) VarR8FromBool(VARIANT_BOOL,double*);
extern "C" HRESULT __attribute__((__stdcall__)) VarR8FromDec(DECIMAL*,double*);
extern "C" HRESULT __attribute__((__stdcall__)) VarDateFromUI1(unsigned char,DATE*);
extern "C" HRESULT __attribute__((__stdcall__)) VarDateFromI2(short,DATE*);
extern "C" HRESULT __attribute__((__stdcall__)) VarDateFromI4(long,DATE*);
extern "C" HRESULT __attribute__((__stdcall__)) VarDateFromR4(float,DATE*);
extern "C" HRESULT __attribute__((__stdcall__)) VarDateFromR8(double,DATE*);
extern "C" HRESULT __attribute__((__stdcall__)) VarDateFromCy(CY,DATE*);
extern "C" HRESULT __attribute__((__stdcall__)) VarDateFromStr(OLECHAR*,LCID,unsigned long,DATE*);
extern "C" HRESULT __attribute__((__stdcall__)) VarDateFromDisp(LPDISPATCH,LCID,DATE*);
extern "C" HRESULT __attribute__((__stdcall__)) VarDateFromBool(VARIANT_BOOL,DATE*);
extern "C" HRESULT __attribute__((__stdcall__)) VarCyFromUI1(unsigned char,CY*);
extern "C" HRESULT __attribute__((__stdcall__)) VarCyFromI2(short,CY*);
extern "C" HRESULT __attribute__((__stdcall__)) VarCyFromI4(long,CY*);
extern "C" HRESULT __attribute__((__stdcall__)) VarCyFromR4(float,CY*);
extern "C" HRESULT __attribute__((__stdcall__)) VarCyFromR8(double,CY*);
extern "C" HRESULT __attribute__((__stdcall__)) VarCyFromDate(DATE,CY*);
extern "C" HRESULT __attribute__((__stdcall__)) VarCyFromStr(OLECHAR*,LCID,unsigned long,CY*);
extern "C" HRESULT __attribute__((__stdcall__)) VarCyFromDisp(LPDISPATCH,LCID,CY*);
extern "C" HRESULT __attribute__((__stdcall__)) VarCyFromBool(VARIANT_BOOL,CY*);
extern "C" HRESULT __attribute__((__stdcall__)) VarBstrFromUI1(unsigned char,LCID,unsigned long,BSTR*);
extern "C" HRESULT __attribute__((__stdcall__)) VarBstrFromI2(short,LCID,unsigned long,BSTR*);
extern "C" HRESULT __attribute__((__stdcall__)) VarBstrFromI4(long,LCID,unsigned long,BSTR*);
extern "C" HRESULT __attribute__((__stdcall__)) VarBstrFromR4(float,LCID,unsigned long,BSTR*);
extern "C" HRESULT __attribute__((__stdcall__)) VarBstrFromR8(double,LCID,unsigned long,BSTR*);
extern "C" HRESULT __attribute__((__stdcall__)) VarBstrFromCy(CY,LCID,unsigned long,BSTR*);
extern "C" HRESULT __attribute__((__stdcall__)) VarBstrFromDate(DATE,LCID,unsigned long,BSTR*);
extern "C" HRESULT __attribute__((__stdcall__)) VarBstrFromDisp(LPDISPATCH,LCID,unsigned long,BSTR*);
extern "C" HRESULT __attribute__((__stdcall__)) VarBstrFromBool(VARIANT_BOOL,LCID,unsigned long,BSTR*);
extern "C" HRESULT __attribute__((__stdcall__)) VarBoolFromUI1(unsigned char,VARIANT_BOOL*);
extern "C" HRESULT __attribute__((__stdcall__)) VarBoolFromI2(short,VARIANT_BOOL*);
extern "C" HRESULT __attribute__((__stdcall__)) VarBoolFromI4(long,VARIANT_BOOL*);
extern "C" HRESULT __attribute__((__stdcall__)) VarBoolFromR4(float,VARIANT_BOOL*);
extern "C" HRESULT __attribute__((__stdcall__)) VarBoolFromR8(double,VARIANT_BOOL*);
extern "C" HRESULT __attribute__((__stdcall__)) VarBoolFromDate(DATE,VARIANT_BOOL*);
extern "C" HRESULT __attribute__((__stdcall__)) VarBoolFromCy(CY,VARIANT_BOOL*);
extern "C" HRESULT __attribute__((__stdcall__)) VarBoolFromStr(OLECHAR*,LCID,unsigned long,VARIANT_BOOL*);
extern "C" HRESULT __attribute__((__stdcall__)) VarBoolFromDisp(LPDISPATCH,LCID,VARIANT_BOOL*);
extern "C" HRESULT __attribute__((__stdcall__)) VarDecFromR8(double,DECIMAL*);
extern "C" ULONG __attribute__((__stdcall__)) LHashValOfNameSysA(SYSKIND,LCID,const char*);
extern "C" ULONG __attribute__((__stdcall__)) LHashValOfNameSys(SYSKIND,LCID,const OLECHAR*);
extern "C" HRESULT __attribute__((__stdcall__)) LoadTypeLib(const OLECHAR*,LPTYPELIB*);
extern "C" HRESULT __attribute__((__stdcall__)) LoadTypeLibEx(LPCOLESTR,REGKIND,LPTYPELIB*);
extern "C" HRESULT __attribute__((__stdcall__)) LoadRegTypeLib(const GUID&,WORD,WORD,LCID,LPTYPELIB*);
extern "C" HRESULT __attribute__((__stdcall__)) QueryPathOfRegTypeLib(const GUID&,unsigned short,unsigned short,LCID,LPBSTR);
extern "C" HRESULT __attribute__((__stdcall__)) RegisterTypeLib(LPTYPELIB,OLECHAR*,OLECHAR*);
extern "C" HRESULT __attribute__((__stdcall__)) UnRegisterTypeLib(const GUID&,WORD,WORD,LCID,SYSKIND);
extern "C" HRESULT __attribute__((__stdcall__)) CreateTypeLib(SYSKIND,const OLECHAR*,LPCREATETYPELIB*);
extern "C" HRESULT __attribute__((__stdcall__)) DispGetParam(DISPPARAMS*,UINT,VARTYPE,VARIANT*,UINT*);
extern "C" HRESULT __attribute__((__stdcall__)) DispGetIDsOfNames(LPTYPEINFO,OLECHAR**,UINT,DISPID*);
extern "C" HRESULT __attribute__((__stdcall__)) DispInvoke(void*,LPTYPEINFO,DISPID,WORD,DISPPARAMS*,VARIANT*,EXCEPINFO*,UINT*);
extern "C" HRESULT __attribute__((__stdcall__)) CreateDispTypeInfo(INTERFACEDATA*,LCID,LPTYPEINFO*);
extern "C" HRESULT __attribute__((__stdcall__)) CreateStdDispatch(IUnknown*,void*,LPTYPEINFO,IUnknown**);
extern "C" HRESULT __attribute__((__stdcall__)) RegisterActiveObject(IUnknown*,const CLSID&,DWORD,DWORD*);
extern "C" HRESULT __attribute__((__stdcall__)) RevokeActiveObject(DWORD,void*);
extern "C" HRESULT __attribute__((__stdcall__)) GetActiveObject(const CLSID&,void*,IUnknown**);
extern "C" HRESULT __attribute__((__stdcall__)) SetErrorInfo(unsigned long,LPERRORINFO);
extern "C" HRESULT __attribute__((__stdcall__)) GetErrorInfo(unsigned long,LPERRORINFO*);
extern "C" HRESULT __attribute__((__stdcall__)) CreateErrorInfo(LPCREATEERRORINFO*);
extern "C" unsigned long __attribute__((__stdcall__)) OaBuildVersion(void);
extern "C" HRESULT __attribute__((__stdcall__)) VectorFromBstr (BSTR, SAFEARRAY **);
extern "C" HRESULT __attribute__((__stdcall__)) BstrFromVector (SAFEARRAY *, BSTR *);
extern "C" HRESULT __attribute__((__stdcall__)) VarParseNumFromStr(OLECHAR*,LCID,ULONG,NUMPARSE*,BYTE*);
extern "C" HRESULT __attribute__((__stdcall__)) VarNumFromParseNum(NUMPARSE*,BYTE*,ULONG,VARIANT*);

extern "C" HRESULT __attribute__((__stdcall__)) VarAdd(LPVARIANT, LPVARIANT, LPVARIANT);
extern "C" HRESULT __attribute__((__stdcall__)) VarSub(LPVARIANT, LPVARIANT, LPVARIANT);
extern "C" HRESULT __attribute__((__stdcall__)) VarMul(LPVARIANT, LPVARIANT, LPVARIANT);
extern "C" HRESULT __attribute__((__stdcall__)) VarDiv(LPVARIANT, LPVARIANT, LPVARIANT);

extern "C" HRESULT __attribute__((__stdcall__)) VarUI1FromI2(SHORT,BYTE*);
extern "C" HRESULT __attribute__((__stdcall__)) VarUI1FromI4(LONG,BYTE*);
extern "C" HRESULT __attribute__((__stdcall__)) VarUI1FromI8(LONG64,BYTE*);
extern "C" HRESULT __attribute__((__stdcall__)) VarUI1FromR4(FLOAT,BYTE*);
extern "C" HRESULT __attribute__((__stdcall__)) VarUI1FromR8(DOUBLE,BYTE*);
extern "C" HRESULT __attribute__((__stdcall__)) VarUI1FromDate(DATE,BYTE*);
extern "C" HRESULT __attribute__((__stdcall__)) VarUI1FromBool(VARIANT_BOOL,BYTE*);
extern "C" HRESULT __attribute__((__stdcall__)) VarUI1FromI1(signed char,BYTE*);
extern "C" HRESULT __attribute__((__stdcall__)) VarUI1FromUI2(USHORT,BYTE*);
extern "C" HRESULT __attribute__((__stdcall__)) VarUI1FromUI4(ULONG,BYTE*);
extern "C" HRESULT __attribute__((__stdcall__)) VarUI1FromUI8(ULONG64,BYTE*);
extern "C" HRESULT __attribute__((__stdcall__)) VarUI1FromStr(OLECHAR*,LCID,ULONG,BYTE*);
extern "C" HRESULT __attribute__((__stdcall__)) VarUI1FromCy(CY,BYTE*);
extern "C" HRESULT __attribute__((__stdcall__)) VarUI1FromDec(DECIMAL*,BYTE*);
extern "C" HRESULT __attribute__((__stdcall__)) VarUI1FromDisp(IDispatch*,LCID,BYTE*);

extern "C" HRESULT __attribute__((__stdcall__)) VarI2FromUI1(BYTE,SHORT*);
extern "C" HRESULT __attribute__((__stdcall__)) VarI2FromI4(LONG,SHORT*);
extern "C" HRESULT __attribute__((__stdcall__)) VarI2FromI8(LONG64,SHORT*);
extern "C" HRESULT __attribute__((__stdcall__)) VarI2FromR4(FLOAT,SHORT*);
extern "C" HRESULT __attribute__((__stdcall__)) VarI2FromR8(DOUBLE,SHORT*);
extern "C" HRESULT __attribute__((__stdcall__)) VarI2FromDate(DATE,SHORT*);
extern "C" HRESULT __attribute__((__stdcall__)) VarI2FromBool(VARIANT_BOOL,SHORT*);
extern "C" HRESULT __attribute__((__stdcall__)) VarI2FromI1(signed char,SHORT*);
extern "C" HRESULT __attribute__((__stdcall__)) VarI2FromUI2(USHORT,SHORT*);
extern "C" HRESULT __attribute__((__stdcall__)) VarI2FromUI4(ULONG,SHORT*);
extern "C" HRESULT __attribute__((__stdcall__)) VarI2FromUI8(ULONG64,SHORT*);
extern "C" HRESULT __attribute__((__stdcall__)) VarI2FromStr(OLECHAR*,LCID,ULONG,SHORT*);
extern "C" HRESULT __attribute__((__stdcall__)) VarI2FromCy(CY,SHORT*);
extern "C" HRESULT __attribute__((__stdcall__)) VarI2FromDec(DECIMAL*,SHORT*);
extern "C" HRESULT __attribute__((__stdcall__)) VarI2FromDisp(IDispatch*,LCID,SHORT*);

extern "C" HRESULT __attribute__((__stdcall__)) VarI4FromUI1(BYTE,LONG*);
extern "C" HRESULT __attribute__((__stdcall__)) VarI4FromI2(SHORT,LONG*);
extern "C" HRESULT __attribute__((__stdcall__)) VarI4FromI8(LONG64,LONG*);
extern "C" HRESULT __attribute__((__stdcall__)) VarI4FromR4(FLOAT,LONG*);
extern "C" HRESULT __attribute__((__stdcall__)) VarI4FromR8(DOUBLE,LONG*);
extern "C" HRESULT __attribute__((__stdcall__)) VarI4FromDate(DATE,LONG*);
extern "C" HRESULT __attribute__((__stdcall__)) VarI4FromBool(VARIANT_BOOL,LONG*);
extern "C" HRESULT __attribute__((__stdcall__)) VarI4FromI1(signed char,LONG*);
extern "C" HRESULT __attribute__((__stdcall__)) VarI4FromUI2(USHORT,LONG*);
extern "C" HRESULT __attribute__((__stdcall__)) VarI4FromUI4(ULONG,LONG*);
extern "C" HRESULT __attribute__((__stdcall__)) VarI4FromUI8(ULONG64,LONG*);
extern "C" HRESULT __attribute__((__stdcall__)) VarI4FromStr(OLECHAR*,LCID,ULONG,LONG*);
extern "C" HRESULT __attribute__((__stdcall__)) VarI4FromCy(CY,LONG*);
extern "C" HRESULT __attribute__((__stdcall__)) VarI4FromDec(DECIMAL*,LONG*);
extern "C" HRESULT __attribute__((__stdcall__)) VarI4FromDisp(IDispatch*,LCID,LONG*);

extern "C" HRESULT __attribute__((__stdcall__)) VarI8FromUI1(BYTE,LONG64*);
extern "C" HRESULT __attribute__((__stdcall__)) VarI8FromI2(SHORT,LONG64*);
extern "C" HRESULT __attribute__((__stdcall__)) VarI8FromI4(LONG,LONG64*);
extern "C" HRESULT __attribute__((__stdcall__)) VarI8FromR4(FLOAT,LONG64*);
extern "C" HRESULT __attribute__((__stdcall__)) VarI8FromR8(DOUBLE,LONG64*);
extern "C" HRESULT __attribute__((__stdcall__)) VarI8FromDate(DATE,LONG64*);
extern "C" HRESULT __attribute__((__stdcall__)) VarI8FromStr(OLECHAR*,LCID,ULONG,LONG64*);
extern "C" HRESULT __attribute__((__stdcall__)) VarI8FromBool(VARIANT_BOOL,LONG64*);
extern "C" HRESULT __attribute__((__stdcall__)) VarI8FromI1(signed char,LONG64*);
extern "C" HRESULT __attribute__((__stdcall__)) VarI8FromUI2(USHORT,LONG64*);
extern "C" HRESULT __attribute__((__stdcall__)) VarI8FromUI4(ULONG,LONG64*);
extern "C" HRESULT __attribute__((__stdcall__)) VarI8FromUI8(ULONG64,LONG64*);
extern "C" HRESULT __attribute__((__stdcall__)) VarI8FromDec(DECIMAL *pdecIn,LONG64*);
extern "C" HRESULT __attribute__((__stdcall__)) VarI8FromInt(INT intIn,LONG64*);
extern "C" HRESULT __attribute__((__stdcall__)) VarI8FromCy(CY,LONG64*);
extern "C" HRESULT __attribute__((__stdcall__)) VarI8FromDisp(IDispatch*,LCID,LONG64*);

extern "C" HRESULT __attribute__((__stdcall__)) VarR4FromUI1(BYTE,FLOAT*);
extern "C" HRESULT __attribute__((__stdcall__)) VarR4FromI2(SHORT,FLOAT*);
extern "C" HRESULT __attribute__((__stdcall__)) VarR4FromI4(LONG,FLOAT*);
extern "C" HRESULT __attribute__((__stdcall__)) VarR4FromI8(LONG64,FLOAT*);
extern "C" HRESULT __attribute__((__stdcall__)) VarR4FromR8(DOUBLE,FLOAT*);
extern "C" HRESULT __attribute__((__stdcall__)) VarR4FromDate(DATE,FLOAT*);
extern "C" HRESULT __attribute__((__stdcall__)) VarR4FromBool(VARIANT_BOOL,FLOAT*);
extern "C" HRESULT __attribute__((__stdcall__)) VarR4FromI1(signed char,FLOAT*);
extern "C" HRESULT __attribute__((__stdcall__)) VarR4FromUI2(USHORT,FLOAT*);
extern "C" HRESULT __attribute__((__stdcall__)) VarR4FromUI4(ULONG,FLOAT*);
extern "C" HRESULT __attribute__((__stdcall__)) VarR4FromUI8(ULONG64,FLOAT*);
extern "C" HRESULT __attribute__((__stdcall__)) VarR4FromStr(OLECHAR*,LCID,ULONG,FLOAT*);
extern "C" HRESULT __attribute__((__stdcall__)) VarR4FromCy(CY,FLOAT*);
extern "C" HRESULT __attribute__((__stdcall__)) VarR4FromDec(DECIMAL*,FLOAT*);
extern "C" HRESULT __attribute__((__stdcall__)) VarR4FromDisp(IDispatch*,LCID,FLOAT*);

extern "C" HRESULT __attribute__((__stdcall__)) VarR8FromUI1(BYTE,double*);
extern "C" HRESULT __attribute__((__stdcall__)) VarR8FromI2(SHORT,double*);
extern "C" HRESULT __attribute__((__stdcall__)) VarR8FromI4(LONG,double*);
extern "C" HRESULT __attribute__((__stdcall__)) VarR8FromI8(LONG64,double*);
extern "C" HRESULT __attribute__((__stdcall__)) VarR8FromR4(FLOAT,double*);
extern "C" HRESULT __attribute__((__stdcall__)) VarR8FromDate(DATE,double*);
extern "C" HRESULT __attribute__((__stdcall__)) VarR8FromBool(VARIANT_BOOL,double*);
extern "C" HRESULT __attribute__((__stdcall__)) VarR8FromI1(signed char,double*);
extern "C" HRESULT __attribute__((__stdcall__)) VarR8FromUI2(USHORT,double*);
extern "C" HRESULT __attribute__((__stdcall__)) VarR8FromUI4(ULONG,double*);
extern "C" HRESULT __attribute__((__stdcall__)) VarR8FromUI8(ULONG64,double*);
extern "C" HRESULT __attribute__((__stdcall__)) VarR8FromStr(OLECHAR*,LCID,ULONG,double*);
extern "C" HRESULT __attribute__((__stdcall__)) VarR8FromCy(CY,double*);
extern "C" HRESULT __attribute__((__stdcall__)) VarR8FromDec(DECIMAL*,double*);
extern "C" HRESULT __attribute__((__stdcall__)) VarR8FromDisp(IDispatch*,LCID,double*);

extern "C" HRESULT __attribute__((__stdcall__)) VarDateFromUI1(BYTE,DATE*);
extern "C" HRESULT __attribute__((__stdcall__)) VarDateFromI2(SHORT,DATE*);
extern "C" HRESULT __attribute__((__stdcall__)) VarDateFromI4(LONG,DATE*);
extern "C" HRESULT __attribute__((__stdcall__)) VarDateFromI8(LONG64,DATE*);
extern "C" HRESULT __attribute__((__stdcall__)) VarDateFromR4(FLOAT,DATE*);
extern "C" HRESULT __attribute__((__stdcall__)) VarDateFromR8(DOUBLE,DATE*);
extern "C" HRESULT __attribute__((__stdcall__)) VarDateFromStr(OLECHAR*,LCID,ULONG,DATE*);
extern "C" HRESULT __attribute__((__stdcall__)) VarDateFromI1(signed char,DATE*);
extern "C" HRESULT __attribute__((__stdcall__)) VarDateFromUI2(USHORT,DATE*);
extern "C" HRESULT __attribute__((__stdcall__)) VarDateFromUI4(ULONG,DATE*);
extern "C" HRESULT __attribute__((__stdcall__)) VarDateFromUI8(ULONG64,DATE*);
extern "C" HRESULT __attribute__((__stdcall__)) VarDateFromBool(VARIANT_BOOL,DATE*);
extern "C" HRESULT __attribute__((__stdcall__)) VarDateFromCy(CY,DATE*);
extern "C" HRESULT __attribute__((__stdcall__)) VarDateFromDec(DECIMAL*,DATE*);
extern "C" HRESULT __attribute__((__stdcall__)) VarDateFromDisp(IDispatch*,LCID,DATE*);

extern "C" HRESULT __attribute__((__stdcall__)) VarCyFromUI1(BYTE,CY*);
extern "C" HRESULT __attribute__((__stdcall__)) VarCyFromI2(SHORT sIn,CY*);
extern "C" HRESULT __attribute__((__stdcall__)) VarCyFromI4(LONG,CY*);
extern "C" HRESULT __attribute__((__stdcall__)) VarCyFromI8(LONG64,CY*);
extern "C" HRESULT __attribute__((__stdcall__)) VarCyFromR4(FLOAT,CY*);
extern "C" HRESULT __attribute__((__stdcall__)) VarCyFromR8(DOUBLE,CY*);
extern "C" HRESULT __attribute__((__stdcall__)) VarCyFromDate(DATE,CY*);
extern "C" HRESULT __attribute__((__stdcall__)) VarCyFromStr(OLECHAR*,LCID,ULONG,CY*);
extern "C" HRESULT __attribute__((__stdcall__)) VarCyFromBool(VARIANT_BOOL,CY*);
extern "C" HRESULT __attribute__((__stdcall__)) VarCyFromI1(signed char,CY*);
extern "C" HRESULT __attribute__((__stdcall__)) VarCyFromUI2(USHORT,CY*);
extern "C" HRESULT __attribute__((__stdcall__)) VarCyFromUI4(ULONG,CY*);
extern "C" HRESULT __attribute__((__stdcall__)) VarCyFromUI8(ULONG64,CY*);
extern "C" HRESULT __attribute__((__stdcall__)) VarCyFromDec(DECIMAL*,CY*);
extern "C" HRESULT __attribute__((__stdcall__)) VarCyFromStr(OLECHAR*,LCID,ULONG,CY*);
extern "C" HRESULT __attribute__((__stdcall__)) VarCyFromDisp(IDispatch*,LCID,CY*);

extern "C" HRESULT __attribute__((__stdcall__)) VarBstrFromUI1(BYTE,LCID,ULONG,BSTR*);
extern "C" HRESULT __attribute__((__stdcall__)) VarBstrFromI2(SHORT,LCID,ULONG,BSTR*);
extern "C" HRESULT __attribute__((__stdcall__)) VarBstrFromI4(LONG,LCID,ULONG,BSTR*);
extern "C" HRESULT __attribute__((__stdcall__)) VarBstrFromI8(LONG64,LCID,ULONG,BSTR*);
extern "C" HRESULT __attribute__((__stdcall__)) VarBstrFromR4(FLOAT,LCID,ULONG,BSTR*);
extern "C" HRESULT __attribute__((__stdcall__)) VarBstrFromR8(DOUBLE,LCID,ULONG,BSTR*);
extern "C" HRESULT __attribute__((__stdcall__)) VarBstrFromDate(DATE,LCID,ULONG,BSTR*);
extern "C" HRESULT __attribute__((__stdcall__)) VarBstrFromBool(VARIANT_BOOL,LCID,ULONG,BSTR*);
extern "C" HRESULT __attribute__((__stdcall__)) VarBstrFromI1(signed char,LCID,ULONG,BSTR*);
extern "C" HRESULT __attribute__((__stdcall__)) VarBstrFromUI2(USHORT,LCID,ULONG,BSTR*);
extern "C" HRESULT __attribute__((__stdcall__)) VarBstrFromUI8(ULONG64,LCID,ULONG,BSTR*);
extern "C" HRESULT __attribute__((__stdcall__)) VarBstrFromUI4(ULONG,LCID,ULONG,BSTR*);
extern "C" HRESULT __attribute__((__stdcall__)) VarBstrFromCy(CY,LCID,ULONG,BSTR*);
extern "C" HRESULT __attribute__((__stdcall__)) VarBstrFromDec(DECIMAL*,LCID,ULONG,BSTR*);
extern "C" HRESULT __attribute__((__stdcall__)) VarBstrFromDisp(IDispatch*,LCID,ULONG,BSTR*);

extern "C" HRESULT __attribute__((__stdcall__)) VarBoolFromUI1(BYTE,VARIANT_BOOL*);
extern "C" HRESULT __attribute__((__stdcall__)) VarBoolFromI2(SHORT,VARIANT_BOOL*);
extern "C" HRESULT __attribute__((__stdcall__)) VarBoolFromI4(LONG,VARIANT_BOOL*);
extern "C" HRESULT __attribute__((__stdcall__)) VarBoolFromI8(LONG64,VARIANT_BOOL*);
extern "C" HRESULT __attribute__((__stdcall__)) VarBoolFromR4(FLOAT,VARIANT_BOOL*);
extern "C" HRESULT __attribute__((__stdcall__)) VarBoolFromR8(DOUBLE,VARIANT_BOOL*);
extern "C" HRESULT __attribute__((__stdcall__)) VarBoolFromDate(DATE,VARIANT_BOOL*);
extern "C" HRESULT __attribute__((__stdcall__)) VarBoolFromStr(OLECHAR*,LCID,ULONG,VARIANT_BOOL*);
extern "C" HRESULT __attribute__((__stdcall__)) VarBoolFromI1(signed char,VARIANT_BOOL*);
extern "C" HRESULT __attribute__((__stdcall__)) VarBoolFromUI2(USHORT,VARIANT_BOOL*);
extern "C" HRESULT __attribute__((__stdcall__)) VarBoolFromUI4(ULONG,VARIANT_BOOL*);
extern "C" HRESULT __attribute__((__stdcall__)) VarBoolFromUI8(ULONG64,VARIANT_BOOL*);
extern "C" HRESULT __attribute__((__stdcall__)) VarBoolFromCy(CY,VARIANT_BOOL*);
extern "C" HRESULT __attribute__((__stdcall__)) VarBoolFromDec(DECIMAL*,VARIANT_BOOL*);
extern "C" HRESULT __attribute__((__stdcall__)) VarBoolFromDisp(IDispatch*,LCID,VARIANT_BOOL*);

extern "C" HRESULT __attribute__((__stdcall__)) VarI1FromUI1(BYTE,signed char*);
extern "C" HRESULT __attribute__((__stdcall__)) VarI1FromI2(SHORT,signed char*);
extern "C" HRESULT __attribute__((__stdcall__)) VarI1FromI4(LONG,signed char*);
extern "C" HRESULT __attribute__((__stdcall__)) VarI1FromI8(LONG64,signed char*);
extern "C" HRESULT __attribute__((__stdcall__)) VarI1FromR4(FLOAT,signed char*);
extern "C" HRESULT __attribute__((__stdcall__)) VarI1FromR8(DOUBLE,signed char*);
extern "C" HRESULT __attribute__((__stdcall__)) VarI1FromDate(DATE,signed char*);
extern "C" HRESULT __attribute__((__stdcall__)) VarI1FromStr(OLECHAR*,LCID,ULONG,signed char*);
extern "C" HRESULT __attribute__((__stdcall__)) VarI1FromBool(VARIANT_BOOL,signed char*);
extern "C" HRESULT __attribute__((__stdcall__)) VarI1FromUI2(USHORT,signed char*);
extern "C" HRESULT __attribute__((__stdcall__)) VarI1FromUI4(ULONG,signed char*);
extern "C" HRESULT __attribute__((__stdcall__)) VarI1FromUI8(ULONG64,signed char*);
extern "C" HRESULT __attribute__((__stdcall__)) VarI1FromCy(CY,signed char*);
extern "C" HRESULT __attribute__((__stdcall__)) VarI1FromDec(DECIMAL*,signed char*);
extern "C" HRESULT __attribute__((__stdcall__)) VarI1FromDisp(IDispatch*,LCID,signed char*);

extern "C" HRESULT __attribute__((__stdcall__)) VarUI2FromUI1(BYTE,USHORT*);
extern "C" HRESULT __attribute__((__stdcall__)) VarUI2FromI2(SHORT,USHORT*);
extern "C" HRESULT __attribute__((__stdcall__)) VarUI2FromI4(LONG,USHORT*);
extern "C" HRESULT __attribute__((__stdcall__)) VarUI2FromI8(LONG64,USHORT*);
extern "C" HRESULT __attribute__((__stdcall__)) VarUI2FromR4(FLOAT,USHORT*);
extern "C" HRESULT __attribute__((__stdcall__)) VarUI2FromR8(DOUBLE,USHORT*);
extern "C" HRESULT __attribute__((__stdcall__)) VarUI2FromDate(DATE,USHORT*);
extern "C" HRESULT __attribute__((__stdcall__)) VarUI2FromStr(OLECHAR*,LCID,ULONG,USHORT*);
extern "C" HRESULT __attribute__((__stdcall__)) VarUI2FromBool(VARIANT_BOOL,USHORT*);
extern "C" HRESULT __attribute__((__stdcall__)) VarUI2FromI1(signed char,USHORT*);
extern "C" HRESULT __attribute__((__stdcall__)) VarUI2FromUI4(ULONG,USHORT*);
extern "C" HRESULT __attribute__((__stdcall__)) VarUI2FromUI8(ULONG64,USHORT*);
extern "C" HRESULT __attribute__((__stdcall__)) VarUI2FromCy(CY,USHORT*);
extern "C" HRESULT __attribute__((__stdcall__)) VarUI2FromDec(DECIMAL*,USHORT*);
extern "C" HRESULT __attribute__((__stdcall__)) VarUI2FromDisp(IDispatch*,LCID,USHORT*);

extern "C" HRESULT __attribute__((__stdcall__)) VarUI4FromStr(OLECHAR*,LCID,ULONG,ULONG*);
extern "C" HRESULT __attribute__((__stdcall__)) VarUI4FromUI1(BYTE,ULONG*);
extern "C" HRESULT __attribute__((__stdcall__)) VarUI4FromI2(SHORT,ULONG*);
extern "C" HRESULT __attribute__((__stdcall__)) VarUI4FromI4(LONG,ULONG*);
extern "C" HRESULT __attribute__((__stdcall__)) VarUI4FromI8(LONG64,ULONG*);
extern "C" HRESULT __attribute__((__stdcall__)) VarUI4FromR4(FLOAT,ULONG*);
extern "C" HRESULT __attribute__((__stdcall__)) VarUI4FromR8(DOUBLE,ULONG*);
extern "C" HRESULT __attribute__((__stdcall__)) VarUI4FromDate(DATE,ULONG*);
extern "C" HRESULT __attribute__((__stdcall__)) VarUI4FromBool(VARIANT_BOOL,ULONG*);
extern "C" HRESULT __attribute__((__stdcall__)) VarUI4FromI1(signed char,ULONG*);
extern "C" HRESULT __attribute__((__stdcall__)) VarUI4FromUI2(USHORT,ULONG*);
extern "C" HRESULT __attribute__((__stdcall__)) VarUI4FromUI8(ULONG64,ULONG*);
extern "C" HRESULT __attribute__((__stdcall__)) VarUI4FromCy(CY,ULONG*);
extern "C" HRESULT __attribute__((__stdcall__)) VarUI4FromDec(DECIMAL*,ULONG*);
extern "C" HRESULT __attribute__((__stdcall__)) VarUI4FromDisp(IDispatch*,LCID,ULONG*);

extern "C" HRESULT __attribute__((__stdcall__)) VarUI8FromUI1(BYTE,ULONG64*);
extern "C" HRESULT __attribute__((__stdcall__)) VarUI8FromI2(SHORT,ULONG64*);
extern "C" HRESULT __attribute__((__stdcall__)) VarUI8FromI4(LONG,ULONG64*);
extern "C" HRESULT __attribute__((__stdcall__)) VarUI8FromI8(LONG64,ULONG64*);
extern "C" HRESULT __attribute__((__stdcall__)) VarUI8FromR4(FLOAT,ULONG64*);
extern "C" HRESULT __attribute__((__stdcall__)) VarUI8FromR8(DOUBLE,ULONG64*);
extern "C" HRESULT __attribute__((__stdcall__)) VarUI8FromDate(DATE,ULONG64*);
extern "C" HRESULT __attribute__((__stdcall__)) VarUI8FromStr(OLECHAR*,LCID,ULONG,ULONG64*);
extern "C" HRESULT __attribute__((__stdcall__)) VarUI8FromBool(VARIANT_BOOL,ULONG64*);
extern "C" HRESULT __attribute__((__stdcall__)) VarUI8FromI1(signed char,ULONG64*);
extern "C" HRESULT __attribute__((__stdcall__)) VarUI8FromUI2(USHORT,ULONG64*);
extern "C" HRESULT __attribute__((__stdcall__)) VarUI8FromUI4(ULONG,ULONG64*);
extern "C" HRESULT __attribute__((__stdcall__)) VarUI8FromDec(DECIMAL*,ULONG64*);
extern "C" HRESULT __attribute__((__stdcall__)) VarUI8FromInt(INT,ULONG64*);
extern "C" HRESULT __attribute__((__stdcall__)) VarUI8FromCy(CY,ULONG64*);
extern "C" HRESULT __attribute__((__stdcall__)) VarUI8FromDisp(IDispatch*,LCID,ULONG64*);

extern "C" HRESULT __attribute__((__stdcall__)) VarDecFromUI1(BYTE,DECIMAL*);
extern "C" HRESULT __attribute__((__stdcall__)) VarDecFromI2(SHORT,DECIMAL*);
extern "C" HRESULT __attribute__((__stdcall__)) VarDecFromI4(LONG,DECIMAL*);
extern "C" HRESULT __attribute__((__stdcall__)) VarDecFromI8(LONG64,DECIMAL*);
extern "C" HRESULT __attribute__((__stdcall__)) VarDecFromR4(FLOAT,DECIMAL*);
extern "C" HRESULT __attribute__((__stdcall__)) VarDecFromR8(DOUBLE,DECIMAL*);
extern "C" HRESULT __attribute__((__stdcall__)) VarDecFromDate(DATE,DECIMAL*);
extern "C" HRESULT __attribute__((__stdcall__)) VarDecFromStr(OLECHAR*,LCID,ULONG,DECIMAL*);
extern "C" HRESULT __attribute__((__stdcall__)) VarDecFromBool(VARIANT_BOOL,DECIMAL*);
extern "C" HRESULT __attribute__((__stdcall__)) VarDecFromI1(signed char,DECIMAL*);
extern "C" HRESULT __attribute__((__stdcall__)) VarDecFromUI2(USHORT,DECIMAL*);
extern "C" HRESULT __attribute__((__stdcall__)) VarDecFromUI4(ULONG,DECIMAL*);
extern "C" HRESULT __attribute__((__stdcall__)) VarDecFromUI8(ULONG64,DECIMAL*);
extern "C" HRESULT __attribute__((__stdcall__)) VarDecFromCy(CY,DECIMAL*);
extern "C" HRESULT __attribute__((__stdcall__)) VarDecFromDisp(IDispatch*,LCID,DECIMAL*);

extern "C" HRESULT __attribute__((__stdcall__)) VarDecNeg(const DECIMAL*,DECIMAL*);
extern "C" HRESULT __attribute__((__stdcall__)) VarR4CmpR8(float,double);
extern "C" HRESULT __attribute__((__stdcall__)) VarR8Pow(double,double,double*);
extern "C" HRESULT __attribute__((__stdcall__)) VarR8Round(double,int,double*);
extern "C" HRESULT __attribute__((__stdcall__)) VarDecAbs(const DECIMAL*,DECIMAL*);
extern "C" HRESULT __attribute__((__stdcall__)) VarDecAdd(const DECIMAL*,const DECIMAL*,DECIMAL*);
extern "C" HRESULT __attribute__((__stdcall__)) VarDecCmp(const DECIMAL*,const DECIMAL*);
extern "C" HRESULT __attribute__((__stdcall__)) VarDecCmpR8(const DECIMAL*,DOUBLE);
extern "C" HRESULT __attribute__((__stdcall__)) VarDecDiv(const DECIMAL*,const DECIMAL*,DECIMAL*);
extern "C" HRESULT __attribute__((__stdcall__)) VarDecFix(const DECIMAL*,DECIMAL*);
extern "C" HRESULT __attribute__((__stdcall__)) VarDecInt(const DECIMAL*,DECIMAL*);
extern "C" HRESULT __attribute__((__stdcall__)) VarDecMul(const DECIMAL*,const DECIMAL*,DECIMAL*);
extern "C" HRESULT __attribute__((__stdcall__)) VarDecRound(const DECIMAL*,int,DECIMAL*);
extern "C" HRESULT __attribute__((__stdcall__)) VarDecSub(const DECIMAL*,const DECIMAL*,DECIMAL*);
extern "C" HRESULT __attribute__((__stdcall__)) VarCyAbs(const CY,CY*);
extern "C" HRESULT __attribute__((__stdcall__)) VarCyAdd(const CY,const CY,CY*);
extern "C" HRESULT __attribute__((__stdcall__)) VarCyCmp(const CY,const CY);
extern "C" HRESULT __attribute__((__stdcall__)) VarCyCmpR8(const CY,DOUBLE);
extern "C" HRESULT __attribute__((__stdcall__)) VarCyFix(const CY,CY*);
extern "C" HRESULT __attribute__((__stdcall__)) VarCyInt(const CY,CY*);
extern "C" HRESULT __attribute__((__stdcall__)) VarCyMul(const CY,CY,CY*);
extern "C" HRESULT __attribute__((__stdcall__)) VarCyMulI4(const CY,LONG,CY*);
extern "C" HRESULT __attribute__((__stdcall__)) VarCyMulI8(const CY,LONG64,CY*);
extern "C" HRESULT __attribute__((__stdcall__)) VarCyNeg(const CY,CY*);
extern "C" HRESULT __attribute__((__stdcall__)) VarCyRound(const CY,INT,CY*);
extern "C" HRESULT __attribute__((__stdcall__)) VarCySub(const CY,const CY,CY*);
extern "C" HRESULT __attribute__((__stdcall__)) VarAdd(LPVARIANT,LPVARIANT,LPVARIANT);
extern "C" HRESULT __attribute__((__stdcall__)) VarAnd(LPVARIANT,LPVARIANT,LPVARIANT);
extern "C" HRESULT __attribute__((__stdcall__)) VarCat(LPVARIANT,LPVARIANT,LPVARIANT);
extern "C" HRESULT __attribute__((__stdcall__)) VarDiv(LPVARIANT,LPVARIANT,LPVARIANT);
extern "C" HRESULT __attribute__((__stdcall__)) VarEqv(LPVARIANT,LPVARIANT,LPVARIANT);
extern "C" HRESULT __attribute__((__stdcall__)) VarIdiv(LPVARIANT,LPVARIANT,LPVARIANT);
extern "C" HRESULT __attribute__((__stdcall__)) VarImp(LPVARIANT,LPVARIANT,LPVARIANT);
extern "C" HRESULT __attribute__((__stdcall__)) VarMod(LPVARIANT,LPVARIANT,LPVARIANT);
extern "C" HRESULT __attribute__((__stdcall__)) VarMul(LPVARIANT,LPVARIANT,LPVARIANT);
extern "C" HRESULT __attribute__((__stdcall__)) VarOr(LPVARIANT,LPVARIANT,LPVARIANT);
extern "C" HRESULT __attribute__((__stdcall__)) VarPow(LPVARIANT,LPVARIANT,LPVARIANT);
extern "C" HRESULT __attribute__((__stdcall__)) VarSub(LPVARIANT,LPVARIANT,LPVARIANT);
extern "C" HRESULT __attribute__((__stdcall__)) VarXor(LPVARIANT,LPVARIANT,LPVARIANT);
extern "C" HRESULT __attribute__((__stdcall__)) VarAbs(LPVARIANT,LPVARIANT);
extern "C" HRESULT __attribute__((__stdcall__)) VarFix(LPVARIANT,LPVARIANT);
extern "C" HRESULT __attribute__((__stdcall__)) VarInt(LPVARIANT,LPVARIANT);
extern "C" HRESULT __attribute__((__stdcall__)) VarNeg(LPVARIANT,LPVARIANT);
extern "C" HRESULT __attribute__((__stdcall__)) VarNot(LPVARIANT,LPVARIANT);
extern "C" HRESULT __attribute__((__stdcall__)) VarRound(LPVARIANT,int,LPVARIANT);
extern "C" HRESULT __attribute__((__stdcall__)) VarCmp(LPVARIANT,LPVARIANT,LCID,ULONG);
extern "C" HRESULT __attribute__((__stdcall__)) VarBstrCmp(BSTR,BSTR,LCID,ULONG);
extern "C" HRESULT __attribute__((__stdcall__)) VarBstrCat(BSTR,BSTR,BSTR*);

#pragma pack(pop)
# 12 "H:/CPP/wxdevcpp6.10/include/ole2.h" 2 3


extern "C" {
# 29 "H:/CPP/wxdevcpp6.10/include/ole2.h" 3
# 1 "H:/CPP/wxdevcpp6.10/include/oleidl.h" 1 3



       
# 5 "H:/CPP/wxdevcpp6.10/include/oleidl.h" 3



extern "C" {






typedef struct IParseDisplayName *LPPARSEDISPLAYNAME;
typedef struct IOleContainer *LPOLECONTAINER;
typedef struct IOleClientSite *LPOLECLIENTSITE;
typedef struct IOleObject *LPOLEOBJECT;
typedef struct IDropTarget *LPDROPTARGET;
typedef struct IDropSource *LPDROPSOURCE;
typedef struct IEnumOleUndoUnits *LPENUMOLEUNDOUNITS;
typedef struct IEnumOLEVERB *LPENUMOLEVERB;
typedef struct IOleWindow *LPOLEWINDOW;
typedef struct IOleInPlaceUIWindow *LPOLEINPLACEUIWINDOW;
typedef struct IOleInPlaceActiveObject *LPOLEINPLACEACTIVEOBJECT;
typedef struct IOleInPlaceFrame *LPOLEINPLACEFRAME;
typedef struct IOleAdviseHolder *LPOLEADVISEHOLDER;
typedef struct IViewObject *LPVIEWOBJECT;
typedef struct IViewObject2 *LPVIEWOBJECT2;
typedef struct IOleCache *LPOLECACHE;
typedef struct IOleCache2 *LPOLECACHE2;
typedef struct IOleCacheControl *LPOLECACHECONTROL;

typedef enum tagBINDSPEED
{
 BINDSPEED_INDEFINITE=1,
 BINDSPEED_MODERATE,
 BINDSPEED_IMMEDIATE
} BINDSPEED;
typedef enum tagOLEWHICHMK {
 OLEWHICHMK_CONTAINER=1,
 OLEWHICHMK_OBJREL,
 OLEWHICHMK_OBJFULL
} OLEWHICHMK;
typedef enum tagOLEGETMONIKER {
 OLEGETMONIKER_ONLYIFTHERE=1,
 OLEGETMONIKER_FORCEASSIGN,
 OLEGETMONIKER_UNASSIGN,
 OLEGETMONIKER_TEMPFORUSER
} OLEGETMONIKER;
typedef enum tagUSERCLASSTYPE {
 USERCLASSTYPE_FULL=1,
 USERCLASSTYPE_SHORT,
 USERCLASSTYPE_APPNAME
} USERCLASSTYPE;


__extension__

typedef enum tagDROPEFFECT {
 DROPEFFECT_NONE=0,
 DROPEFFECT_COPY=1,
 DROPEFFECT_MOVE=2,
 DROPEFFECT_LINK=4,
 DROPEFFECT_SCROLL=0x80000000
} DROPEFFECT;
typedef struct tagOleMenuGroupWidths {
 LONG width[6];
} OLEMENUGROUPWIDTHS,*LPOLEMENUGROUPWIDTHS;
typedef HGLOBAL HOLEMENU;
typedef enum tagOLECLOSE {
 OLECLOSE_SAVEIFDIRTY,
 OLECLOSE_NOSAVE,
 OLECLOSE_PROMPTSAVE
} OLECLOSE;
typedef struct tagOLEVERB {
 LONG lVerb;
 LPWSTR lpszVerbName;
 DWORD fuFlags;
 DWORD grfAttribs;
} OLEVERB,*LPOLEVERB;
typedef RECT BORDERWIDTHS;
typedef LPRECT LPBORDERWIDTHS;
typedef LPCRECT LPCBORDERWIDTHS;
typedef struct tagOIFI {
 UINT cb;
 BOOL fMDIApp;
 HWND hwndFrame;
 HACCEL haccel;
 UINT cAccelEntries;
}OLEINPLACEFRAMEINFO,*LPOLEINPLACEFRAMEINFO;

struct IEnumOLEVERB : public IUnknown { virtual HRESULT __attribute__((__stdcall__)) QueryInterface( const IID&,PVOID*) =0; virtual ULONG __attribute__((__stdcall__)) AddRef() =0; virtual ULONG __attribute__((__stdcall__)) Release() =0; virtual HRESULT __attribute__((__stdcall__)) Next( ULONG,OLEVERB*,ULONG*) =0; virtual HRESULT __attribute__((__stdcall__)) Skip( ULONG) =0; virtual HRESULT __attribute__((__stdcall__)) Reset() =0; virtual HRESULT __attribute__((__stdcall__)) Clone( IEnumOLEVERB**) =0; };
typedef IEnumOLEVERB IEnumOleVerb;

extern "C" const IID IID_IParseDisplayName;


struct IParseDisplayName : public IUnknown
{
 virtual HRESULT __attribute__((__stdcall__)) QueryInterface( const IID&,PVOID*) =0;
 virtual ULONG __attribute__((__stdcall__)) AddRef(void) =0;
 virtual ULONG __attribute__((__stdcall__)) Release(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) ParseDisplayName( IBindCtx*,LPOLESTR,ULONG*,IMoniker**) =0;
};
# 114 "H:/CPP/wxdevcpp6.10/include/oleidl.h" 3
extern "C" const IID IID_IOleContainer;


struct IOleContainer : public IParseDisplayName
{
 virtual HRESULT __attribute__((__stdcall__)) QueryInterface( const IID&,PVOID*) =0;
 virtual ULONG __attribute__((__stdcall__)) AddRef(void) =0;
 virtual ULONG __attribute__((__stdcall__)) Release(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) ParseDisplayName( IBindCtx*,LPOLESTR,ULONG*,IMoniker**) =0;
 virtual HRESULT __attribute__((__stdcall__)) EnumObjects( DWORD,IEnumUnknown**) =0;
 virtual HRESULT __attribute__((__stdcall__)) LockContainer( BOOL) =0;
};

extern "C" const IID IID_IOleItemContainer;


struct IOleItemContainer : public IOleContainer
{
 virtual HRESULT __attribute__((__stdcall__)) QueryInterface( const IID&,PVOID*) =0;
 virtual ULONG __attribute__((__stdcall__)) AddRef(void) =0;
 virtual ULONG __attribute__((__stdcall__)) Release(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) ParseDisplayName( IBindCtx*,LPOLESTR,ULONG*,IMoniker**) =0;
 virtual HRESULT __attribute__((__stdcall__)) EnumObjects( DWORD,IEnumUnknown**) =0;
 virtual HRESULT __attribute__((__stdcall__)) LockContainer( BOOL) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetObjectA( LPOLESTR,DWORD,IBindCtx*,const IID&,void**) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetObjectStorage( LPOLESTR,IBindCtx*,const IID&,void**) =0;
 virtual HRESULT __attribute__((__stdcall__)) IsRunning( LPOLESTR) =0;
};
# 155 "H:/CPP/wxdevcpp6.10/include/oleidl.h" 3
extern "C" const IID IID_IOleClientSite;


struct IOleClientSite : public IUnknown
{
 virtual HRESULT __attribute__((__stdcall__)) QueryInterface( const IID&,PVOID*) =0;
 virtual ULONG __attribute__((__stdcall__)) AddRef(void) =0;
 virtual ULONG __attribute__((__stdcall__)) Release(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) SaveObject(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetMoniker( DWORD,DWORD,LPMONIKER*) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetContainer( LPOLECONTAINER*) =0;
 virtual HRESULT __attribute__((__stdcall__)) ShowObject(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) OnShowWindow( BOOL) =0;
 virtual HRESULT __attribute__((__stdcall__)) RequestNewObjectLayout(void) =0;
};
# 183 "H:/CPP/wxdevcpp6.10/include/oleidl.h" 3
extern "C" const IID IID_IOleObject;


struct IOleObject : public IUnknown
{
 virtual HRESULT __attribute__((__stdcall__)) QueryInterface( const IID&,PVOID*) =0;
 virtual ULONG __attribute__((__stdcall__)) AddRef(void) =0;
 virtual ULONG __attribute__((__stdcall__)) Release(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) SetClientSite( LPOLECLIENTSITE) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetClientSite( LPOLECLIENTSITE*) =0;
 virtual HRESULT __attribute__((__stdcall__)) SetHostNames( LPCOLESTR,LPCOLESTR) =0;
 virtual HRESULT __attribute__((__stdcall__)) Close( DWORD) =0;
 virtual HRESULT __attribute__((__stdcall__)) SetMoniker( DWORD,LPMONIKER) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetMoniker( DWORD,DWORD,LPMONIKER*) =0;
 virtual HRESULT __attribute__((__stdcall__)) InitFromData( LPDATAOBJECT,BOOL,DWORD) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetClipboardData( DWORD,LPDATAOBJECT*) =0;
 virtual HRESULT __attribute__((__stdcall__)) DoVerb( LONG,LPMSG,LPOLECLIENTSITE,LONG,HWND,LPCRECT) =0;
 virtual HRESULT __attribute__((__stdcall__)) EnumVerbs( LPENUMOLEVERB*) =0;
 virtual HRESULT __attribute__((__stdcall__)) Update(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) IsUpToDate(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetUserClassID( LPCLSID) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetUserType( DWORD,LPOLESTR*) =0;
 virtual HRESULT __attribute__((__stdcall__)) SetExtent( DWORD,SIZEL*) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetExtent( DWORD,SIZEL*) =0;
 virtual HRESULT __attribute__((__stdcall__)) Advise( LPADVISESINK,PDWORD) =0;
 virtual HRESULT __attribute__((__stdcall__)) Unadvise( DWORD) =0;
 virtual HRESULT __attribute__((__stdcall__)) EnumAdvise( LPENUMSTATDATA*) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetMiscStatus( DWORD,PDWORD) =0;
 virtual HRESULT __attribute__((__stdcall__)) SetColorScheme( LPLOGPALETTE) =0;
};
# 241 "H:/CPP/wxdevcpp6.10/include/oleidl.h" 3
extern "C" const IID IID_IOleWindow;


struct IOleWindow : public IUnknown
{
 virtual HRESULT __attribute__((__stdcall__)) QueryInterface( const IID&,PVOID*) =0;
 virtual ULONG __attribute__((__stdcall__)) AddRef(void) =0;
 virtual ULONG __attribute__((__stdcall__)) Release(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetWindow( HWND*) =0;
 virtual HRESULT __attribute__((__stdcall__)) ContextSensitiveHelp( BOOL) =0;
};
# 261 "H:/CPP/wxdevcpp6.10/include/oleidl.h" 3
extern "C" const IID IID_IOleInPlaceUIWindow;


struct IOleInPlaceUIWindow : public IOleWindow
{
 virtual HRESULT __attribute__((__stdcall__)) QueryInterface( const IID&,PVOID*) =0;
 virtual ULONG __attribute__((__stdcall__)) AddRef(void) =0;
 virtual ULONG __attribute__((__stdcall__)) Release(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetWindow( HWND*) =0;
 virtual HRESULT __attribute__((__stdcall__)) ContextSensitiveHelp( BOOL) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetBorder( LPRECT) =0;
 virtual HRESULT __attribute__((__stdcall__)) RequestBorderSpace( LPCBORDERWIDTHS) =0;
 virtual HRESULT __attribute__((__stdcall__)) SetBorderSpace( LPCBORDERWIDTHS) =0;
 virtual HRESULT __attribute__((__stdcall__)) SetActiveObject( LPOLEINPLACEACTIVEOBJECT,LPCOLESTR) =0;
};

extern "C" const IID IID_IOleInPlaceObject;


struct IOleInPlaceObject : public IOleWindow
{
 virtual HRESULT __attribute__((__stdcall__)) QueryInterface( const IID&,PVOID*) =0;
 virtual ULONG __attribute__((__stdcall__)) AddRef(void) =0;
 virtual ULONG __attribute__((__stdcall__)) Release(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetWindow( HWND*) =0;
 virtual HRESULT __attribute__((__stdcall__)) ContextSensitiveHelp( BOOL) =0;
 virtual HRESULT __attribute__((__stdcall__)) InPlaceDeactivate(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) UIDeactivate(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) SetObjectRects( LPCRECT,LPCRECT) =0;
 virtual HRESULT __attribute__((__stdcall__)) ReactivateAndUndo(void) =0;
};

extern "C" const IID IID_IOleInPlaceActiveObject;


struct IOleInPlaceActiveObject : public IOleWindow
{
 virtual HRESULT __attribute__((__stdcall__)) QueryInterface( const IID&,PVOID*) =0;
 virtual ULONG __attribute__((__stdcall__)) AddRef(void) =0;
 virtual ULONG __attribute__((__stdcall__)) Release(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetWindow( HWND*) =0;
 virtual HRESULT __attribute__((__stdcall__)) ContextSensitiveHelp( BOOL) =0;
 virtual HRESULT __attribute__((__stdcall__)) TranslateAcceleratorA( LPMSG) =0;
 virtual HRESULT __attribute__((__stdcall__)) OnFrameWindowActivate( BOOL) =0;
 virtual HRESULT __attribute__((__stdcall__)) OnDocWindowActivate( BOOL) =0;
 virtual HRESULT __attribute__((__stdcall__)) ResizeBorder( LPCRECT,LPOLEINPLACEUIWINDOW,BOOL) =0;
 virtual HRESULT __attribute__((__stdcall__)) EnableModeless( BOOL) =0;
};

extern "C" const IID IID_IOleInPlaceFrame;


struct IOleInPlaceFrame : public IOleInPlaceUIWindow
{
 virtual HRESULT __attribute__((__stdcall__)) QueryInterface( const IID&,PVOID*) =0;
 virtual ULONG __attribute__((__stdcall__)) AddRef(void) =0;
 virtual ULONG __attribute__((__stdcall__)) Release(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetWindow( HWND*) =0;
 virtual HRESULT __attribute__((__stdcall__)) ContextSensitiveHelp( BOOL) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetBorder( LPRECT) =0;
 virtual HRESULT __attribute__((__stdcall__)) RequestBorderSpace( LPCBORDERWIDTHS) =0;
 virtual HRESULT __attribute__((__stdcall__)) SetBorderSpace( LPCBORDERWIDTHS) =0;
 virtual HRESULT __attribute__((__stdcall__)) SetActiveObject( LPOLEINPLACEACTIVEOBJECT,LPCOLESTR) =0;
 virtual HRESULT __attribute__((__stdcall__)) InsertMenus( HMENU,LPOLEMENUGROUPWIDTHS) =0;
 virtual HRESULT __attribute__((__stdcall__)) SetMenu( HMENU,HOLEMENU,HWND) =0;
 virtual HRESULT __attribute__((__stdcall__)) RemoveMenus( HMENU) =0;
 virtual HRESULT __attribute__((__stdcall__)) SetStatusText( LPCOLESTR) =0;
 virtual HRESULT __attribute__((__stdcall__)) EnableModeless( BOOL) =0;
 virtual HRESULT __attribute__((__stdcall__)) TranslateAcceleratorA( LPMSG,WORD) =0;
};
# 350 "H:/CPP/wxdevcpp6.10/include/oleidl.h" 3
extern "C" const IID IID_IOleInPlaceSite;


struct IOleInPlaceSite : public IOleWindow
{
 virtual HRESULT __attribute__((__stdcall__)) QueryInterface( const IID&,PVOID*) =0;
 virtual ULONG __attribute__((__stdcall__)) AddRef(void) =0;
 virtual ULONG __attribute__((__stdcall__)) Release(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetWindow( HWND*) =0;
 virtual HRESULT __attribute__((__stdcall__)) ContextSensitiveHelp( BOOL) =0;
 virtual HRESULT __attribute__((__stdcall__)) CanInPlaceActivate(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) OnInPlaceActivate(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) OnUIActivate(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetWindowContext( IOleInPlaceFrame**,IOleInPlaceUIWindow**,LPRECT,LPRECT,LPOLEINPLACEFRAMEINFO) =0;
 virtual HRESULT __attribute__((__stdcall__)) Scroll( SIZE) =0;
 virtual HRESULT __attribute__((__stdcall__)) OnUIDeactivate( BOOL) =0;
 virtual HRESULT __attribute__((__stdcall__)) OnInPlaceDeactivate(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) DiscardUndoState(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) DeactivateAndUndo(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) OnPosRectChange( LPCRECT) =0;
};

extern "C" const IID IID_IOleAdviseHolder;


struct IOleAdviseHolder : public IUnknown
{
 virtual HRESULT __attribute__((__stdcall__)) QueryInterface( const IID&,PVOID*) =0;
 virtual ULONG __attribute__((__stdcall__)) AddRef(void) =0;
 virtual ULONG __attribute__((__stdcall__)) Release(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) Advise( LPADVISESINK,PDWORD) =0;
 virtual HRESULT __attribute__((__stdcall__)) Unadvise( DWORD) =0;
 virtual HRESULT __attribute__((__stdcall__)) EnumAdvise( LPENUMSTATDATA*) =0;
 virtual HRESULT __attribute__((__stdcall__)) SendOnRename( LPMONIKER) =0;
 virtual HRESULT __attribute__((__stdcall__)) SendOnSave(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) SendOnClose(void) =0;
};
# 400 "H:/CPP/wxdevcpp6.10/include/oleidl.h" 3
extern "C" const IID IID_IDropSource;


struct IDropSource : public IUnknown
{
 virtual HRESULT __attribute__((__stdcall__)) QueryInterface( const IID&,PVOID*) =0;
 virtual ULONG __attribute__((__stdcall__)) AddRef(void) =0;
 virtual ULONG __attribute__((__stdcall__)) Release(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) QueryContinueDrag( BOOL,DWORD) =0;
 virtual HRESULT __attribute__((__stdcall__)) GiveFeedback( DWORD) =0;
};
# 420 "H:/CPP/wxdevcpp6.10/include/oleidl.h" 3
extern "C" const IID IID_IDropTarget;


struct IDropTarget : public IUnknown
{
 virtual HRESULT __attribute__((__stdcall__)) QueryInterface( const IID&,PVOID*) =0;
 virtual ULONG __attribute__((__stdcall__)) AddRef(void) =0;
 virtual ULONG __attribute__((__stdcall__)) Release(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) DragEnter( LPDATAOBJECT,DWORD,POINTL,PDWORD) =0;
 virtual HRESULT __attribute__((__stdcall__)) DragOver( DWORD,POINTL,PDWORD) =0;
 virtual HRESULT __attribute__((__stdcall__)) DragLeave(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) Drop( LPDATAOBJECT,DWORD,POINTL,PDWORD) =0;
};
# 444 "H:/CPP/wxdevcpp6.10/include/oleidl.h" 3
typedef BOOL(__attribute__((__stdcall__)) *__IView_pfncont)(DWORD);
extern "C" const IID IID_IViewObject;


struct IViewObject : public IUnknown
{
 virtual HRESULT __attribute__((__stdcall__)) QueryInterface( const IID&,PVOID*) =0;
 virtual ULONG __attribute__((__stdcall__)) AddRef(void) =0;
 virtual ULONG __attribute__((__stdcall__)) Release(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) Draw( DWORD,LONG,PVOID,DVTARGETDEVICE*,HDC,HDC,LPCRECTL,LPCRECTL,__IView_pfncont pfnContinue,DWORD) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetColorSet( DWORD,LONG,PVOID,DVTARGETDEVICE*,HDC,LPLOGPALETTE*) =0;
 virtual HRESULT __attribute__((__stdcall__)) Freeze( DWORD,LONG,PVOID,PDWORD) =0;
 virtual HRESULT __attribute__((__stdcall__)) Unfreeze( DWORD) =0;
 virtual HRESULT __attribute__((__stdcall__)) SetAdvise( DWORD,DWORD,IAdviseSink*) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetAdvise( PDWORD,PDWORD,IAdviseSink**) =0;
};
# 473 "H:/CPP/wxdevcpp6.10/include/oleidl.h" 3
extern "C" const IID IID_IViewObject2;


struct IViewObject2 : public IViewObject
{
 virtual HRESULT __attribute__((__stdcall__)) QueryInterface( const IID&,PVOID*) =0;
 virtual ULONG __attribute__((__stdcall__)) AddRef(void) =0;
 virtual ULONG __attribute__((__stdcall__)) Release(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) Draw( DWORD,LONG,PVOID,DVTARGETDEVICE*,HDC,HDC,LPCRECTL,LPCRECTL,__IView_pfncont pfnContinue,DWORD) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetColorSet( DWORD,LONG,PVOID,DVTARGETDEVICE*,HDC,LPLOGPALETTE*) =0;
 virtual HRESULT __attribute__((__stdcall__)) Freeze( DWORD,LONG,PVOID,PDWORD) =0;
 virtual HRESULT __attribute__((__stdcall__)) Unfreeze( DWORD) =0;
 virtual HRESULT __attribute__((__stdcall__)) SetAdvise( DWORD,DWORD,IAdviseSink*) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetAdvise( PDWORD,PDWORD,IAdviseSink**) =0;
 virtual HRESULT __attribute__((__stdcall__)) GetExtent( DWORD,LONG,DVTARGETDEVICE*,LPSIZEL) =0;
};
# 503 "H:/CPP/wxdevcpp6.10/include/oleidl.h" 3
extern "C" const IID IID_IOleCache;


struct IOleCache : public IUnknown
{
 virtual HRESULT __attribute__((__stdcall__)) QueryInterface( const IID&,PVOID*) =0;
 virtual ULONG __attribute__((__stdcall__)) AddRef(void) =0;
 virtual ULONG __attribute__((__stdcall__)) Release(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) Cache( FORMATETC*,DWORD,DWORD*) =0;
 virtual HRESULT __attribute__((__stdcall__)) Uncache( DWORD) =0;
 virtual HRESULT __attribute__((__stdcall__)) EnumCache( IEnumSTATDATA**);
 virtual HRESULT __attribute__((__stdcall__)) InitCache( LPDATAOBJECT);
 virtual HRESULT __attribute__((__stdcall__)) SetData( FORMATETC*,STGMEDIUM*,BOOL);
};
# 529 "H:/CPP/wxdevcpp6.10/include/oleidl.h" 3
extern "C" const IID IID_IOleCache2;


struct IOleCache2 : public IOleCache
{
 virtual HRESULT __attribute__((__stdcall__)) QueryInterface( const IID&,PVOID*) =0;
 virtual ULONG __attribute__((__stdcall__)) AddRef(void) =0;
 virtual ULONG __attribute__((__stdcall__)) Release(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) Cache( FORMATETC*,DWORD,DWORD*) =0;
 virtual HRESULT __attribute__((__stdcall__)) Uncache( DWORD) =0;
 virtual HRESULT __attribute__((__stdcall__)) EnumCache( IEnumSTATDATA**) =0;
 virtual HRESULT __attribute__((__stdcall__)) InitCache( LPDATAOBJECT) =0;
 virtual HRESULT __attribute__((__stdcall__)) SetData( FORMATETC*,STGMEDIUM*,BOOL) =0;
 virtual HRESULT __attribute__((__stdcall__)) UpdateCache( LPDATAOBJECT,DWORD,LPVOID) =0;
 virtual HRESULT __attribute__((__stdcall__)) DiscardCache( DWORD) =0;
};
# 559 "H:/CPP/wxdevcpp6.10/include/oleidl.h" 3
extern "C" const IID IID_IOleCacheControl;


struct IOleCacheControl : public IUnknown
{
 virtual HRESULT __attribute__((__stdcall__)) QueryInterface( const IID&,PVOID*) =0;
 virtual ULONG __attribute__((__stdcall__)) AddRef(void) =0;
 virtual ULONG __attribute__((__stdcall__)) Release(void) =0;
 virtual HRESULT __attribute__((__stdcall__)) OnRun( LPDATAOBJECT) =0;
 virtual HRESULT __attribute__((__stdcall__)) OnStop(void) =0;
};


}
# 30 "H:/CPP/wxdevcpp6.10/include/ole2.h" 2 3

typedef struct _OLESTREAMVTBL *LPOLESTREAMVTBL;
typedef struct _OLESTREAM {
 LPOLESTREAMVTBL lpstbl;
} OLESTREAM,*LPOLESTREAM;
typedef struct _OLESTREAMVTBL {
 DWORD (__attribute__((__stdcall__))* Get)(LPOLESTREAM,void*,DWORD);
 DWORD (__attribute__((__stdcall__))* Put)(LPOLESTREAM,const void*,DWORD);
} OLESTREAMVTBL;

extern "C" HRESULT __attribute__((__stdcall__)) CreateDataAdviseHolder(LPDATAADVISEHOLDER*);
extern "C" DWORD __attribute__((__stdcall__)) OleBuildVersion(void);
extern "C" HRESULT __attribute__((__stdcall__)) ReadClassStg(LPSTORAGE,CLSID*);
extern "C" HRESULT __attribute__((__stdcall__)) WriteClassStg(LPSTORAGE,const CLSID&);
extern "C" HRESULT __attribute__((__stdcall__)) ReadClassStm(LPSTREAM,CLSID*);
extern "C" HRESULT __attribute__((__stdcall__)) WriteClassStm(LPSTREAM,const CLSID&);
extern "C" HRESULT __attribute__((__stdcall__)) WriteFmtUserTypeStg(LPSTORAGE,CLIPFORMAT,LPOLESTR);
extern "C" HRESULT __attribute__((__stdcall__)) ReadFmtUserTypeStg(LPSTORAGE,CLIPFORMAT*,LPOLESTR*);
extern "C" HRESULT __attribute__((__stdcall__)) OleInitialize(PVOID);
extern "C" void __attribute__((__stdcall__)) OleUninitialize(void);
extern "C" HRESULT __attribute__((__stdcall__)) OleQueryLinkFromData(LPDATAOBJECT);
extern "C" HRESULT __attribute__((__stdcall__)) OleQueryCreateFromData(LPDATAOBJECT);
extern "C" HRESULT __attribute__((__stdcall__)) OleCreate(const CLSID&,const IID&,DWORD,LPFORMATETC,LPOLECLIENTSITE,LPSTORAGE,PVOID*);
extern "C" HRESULT __attribute__((__stdcall__)) OleCreateFromData(LPDATAOBJECT,const IID&,DWORD,LPFORMATETC,LPOLECLIENTSITE,LPSTORAGE,PVOID*);
extern "C" HRESULT __attribute__((__stdcall__)) OleCreateLinkFromData(LPDATAOBJECT,const IID&,DWORD,LPFORMATETC,LPOLECLIENTSITE,LPSTORAGE,PVOID*);
extern "C" HRESULT __attribute__((__stdcall__)) OleCreateStaticFromData(LPDATAOBJECT,const IID&,DWORD,LPFORMATETC,LPOLECLIENTSITE,LPSTORAGE,PVOID*);
extern "C" HRESULT __attribute__((__stdcall__)) OleCreateLink(LPMONIKER,const IID&,DWORD,LPFORMATETC,LPOLECLIENTSITE,LPSTORAGE,PVOID*);
extern "C" HRESULT __attribute__((__stdcall__)) OleCreateLinkToFile(LPCOLESTR,const IID&,DWORD,LPFORMATETC,LPOLECLIENTSITE,LPSTORAGE,PVOID*);
extern "C" HRESULT __attribute__((__stdcall__)) OleCreateFromFile(const CLSID&,LPCOLESTR,const IID&,DWORD,LPFORMATETC,LPOLECLIENTSITE,LPSTORAGE,PVOID*);
extern "C" HRESULT __attribute__((__stdcall__)) OleLoad(LPSTORAGE,const IID&,LPOLECLIENTSITE,PVOID*);
extern "C" HRESULT __attribute__((__stdcall__)) OleSave(LPPERSISTSTORAGE,LPSTORAGE,BOOL);
extern "C" HRESULT __attribute__((__stdcall__)) OleLoadFromStream(LPSTREAM,const IID&,PVOID*);
extern "C" HRESULT __attribute__((__stdcall__)) OleSaveToStream(LPPERSISTSTREAM,LPSTREAM);
extern "C" HRESULT __attribute__((__stdcall__)) OleSetContainedObject(LPUNKNOWN,BOOL);
extern "C" HRESULT __attribute__((__stdcall__)) OleNoteObjectVisible(LPUNKNOWN,BOOL);
extern "C" HRESULT __attribute__((__stdcall__)) RegisterDragDrop(HWND,LPDROPTARGET);
extern "C" HRESULT __attribute__((__stdcall__)) RevokeDragDrop(HWND);
extern "C" HRESULT __attribute__((__stdcall__)) DoDragDrop(LPDATAOBJECT,LPDROPSOURCE,DWORD,PDWORD);
extern "C" HRESULT __attribute__((__stdcall__)) OleSetClipboard(LPDATAOBJECT);
extern "C" HRESULT __attribute__((__stdcall__)) OleGetClipboard(LPDATAOBJECT*);
extern "C" HRESULT __attribute__((__stdcall__)) OleFlushClipboard(void);
extern "C" HRESULT __attribute__((__stdcall__)) OleIsCurrentClipboard(LPDATAOBJECT);
extern "C" HOLEMENU __attribute__((__stdcall__)) OleCreateMenuDescriptor(HMENU,LPOLEMENUGROUPWIDTHS);
extern "C" HRESULT __attribute__((__stdcall__)) OleSetMenuDescriptor(HOLEMENU,HWND,HWND,LPOLEINPLACEFRAME,LPOLEINPLACEACTIVEOBJECT);
extern "C" HRESULT __attribute__((__stdcall__)) OleDestroyMenuDescriptor(HOLEMENU);
extern "C" HRESULT __attribute__((__stdcall__)) OleTranslateAccelerator(LPOLEINPLACEFRAME,LPOLEINPLACEFRAMEINFO,LPMSG);
extern "C" HANDLE __attribute__((__stdcall__)) OleDuplicateData(HANDLE,CLIPFORMAT,UINT);
extern "C" HRESULT __attribute__((__stdcall__)) OleDraw(LPUNKNOWN,DWORD,HDC,LPCRECT);
extern "C" HRESULT __attribute__((__stdcall__)) OleRun(LPUNKNOWN);
extern "C" BOOL __attribute__((__stdcall__)) OleIsRunning(LPOLEOBJECT);
extern "C" HRESULT __attribute__((__stdcall__)) OleLockRunning(LPUNKNOWN,BOOL,BOOL);
extern "C" void __attribute__((__stdcall__)) ReleaseStgMedium(LPSTGMEDIUM);
extern "C" HRESULT __attribute__((__stdcall__)) CreateOleAdviseHolder(LPOLEADVISEHOLDER*);
extern "C" HRESULT __attribute__((__stdcall__)) OleCreateDefaultHandler(const CLSID&,LPUNKNOWN,const IID&,PVOID*);
extern "C" HRESULT __attribute__((__stdcall__)) OleCreateEmbeddingHelper(const CLSID&,LPUNKNOWN,DWORD,LPCLASSFACTORY,const IID&,PVOID*);
extern "C" BOOL __attribute__((__stdcall__)) IsAccelerator(HACCEL,int,LPMSG,WORD*);
extern "C" HGLOBAL __attribute__((__stdcall__)) OleGetIconOfFile(LPOLESTR,BOOL);
extern "C" HGLOBAL __attribute__((__stdcall__)) OleGetIconOfClass(const CLSID&,LPOLESTR,BOOL);
extern "C" HGLOBAL __attribute__((__stdcall__)) OleMetafilePictFromIconAndLabel(HICON,LPOLESTR,LPOLESTR,UINT);
extern "C" HRESULT __attribute__((__stdcall__)) OleRegGetUserType(const CLSID&,DWORD,LPOLESTR*);
extern "C" HRESULT __attribute__((__stdcall__)) OleRegGetMiscStatus(const CLSID&,DWORD,DWORD*);
extern "C" HRESULT __attribute__((__stdcall__)) OleRegEnumFormatEtc (const CLSID&,DWORD,LPENUMFORMATETC*);
extern "C" HRESULT __attribute__((__stdcall__)) OleRegEnumVerbs (const CLSID&,LPENUMOLEVERB*);
extern "C" HRESULT __attribute__((__stdcall__)) OleConvertOLESTREAMToIStorage(LPOLESTREAM,LPSTORAGE,const DVTARGETDEVICE*);
extern "C" HRESULT __attribute__((__stdcall__)) OleConvertIStorageToOLESTREAM(LPSTORAGE,LPOLESTREAM);
extern "C" HRESULT __attribute__((__stdcall__)) GetHGlobalFromILockBytes(LPLOCKBYTES,HGLOBAL*);
extern "C" HRESULT __attribute__((__stdcall__)) CreateILockBytesOnHGlobal(HGLOBAL,BOOL,LPLOCKBYTES*);
extern "C" HRESULT __attribute__((__stdcall__)) GetHGlobalFromStream(LPSTREAM,HGLOBAL*);
extern "C" HRESULT __attribute__((__stdcall__)) CreateStreamOnHGlobal(HGLOBAL,BOOL,LPSTREAM*);
extern "C" HRESULT __attribute__((__stdcall__)) OleDoAutoConvert(LPSTORAGE,LPCLSID);
extern "C" HRESULT __attribute__((__stdcall__)) OleGetAutoConvert(const CLSID&,LPCLSID);
extern "C" HRESULT __attribute__((__stdcall__)) OleSetAutoConvert(const CLSID&,const CLSID&);
extern "C" HRESULT __attribute__((__stdcall__)) GetConvertStg(LPSTORAGE);
extern "C" HRESULT __attribute__((__stdcall__)) SetConvertStg(LPSTORAGE,BOOL);
extern "C" HRESULT __attribute__((__stdcall__)) OleConvertIStorageToOLESTREAMEx(LPSTORAGE,CLIPFORMAT,LONG,LONG,DWORD,LPSTGMEDIUM,LPOLESTREAM);
extern "C" HRESULT __attribute__((__stdcall__)) OleConvertOLESTREAMToIStorageEx(LPOLESTREAM,LPSTORAGE,CLIPFORMAT*,LONG*,LONG*,DWORD*,LPSTGMEDIUM);

}

#pragma pack(pop)
# 112 "H:/CPP/wxdevcpp6.10/include/windows.h" 2 3
# 12 "shooter.cpp" 2

# 1 "irrevent.h" 1




using namespace irr;

class CIrrLichtEvent : public IEventReceiver
{
public:
bool m_key_buf[256];
bool m_key_buf_old[256];
bool m_mouse_button_buf[3];
bool m_mouse_button_buf_old[3];
public:
CIrrLichtEvent();
virtual ~CIrrLichtEvent();

void Init()
{
memset(m_key_buf, 0, 256);
memset(m_key_buf_old, 0, 256);
memset(m_mouse_button_buf, 0, 3);
memset(m_mouse_button_buf_old, 0, 3);
}


virtual bool OnEvent(SEvent event)
{
switch(event.EventType)
{
case EET_KEY_INPUT_EVENT:
m_key_buf_old[event.KeyInput.Key] = m_key_buf[event.KeyInput.Key];
m_key_buf[event.KeyInput.Key] = event.KeyInput.PressedDown;
break;
case EET_MOUSE_INPUT_EVENT:
if (event.MouseInput.Event < EMIE_MOUSE_MOVED)
{
m_mouse_button_buf_old[event.MouseInput.Event%3] = m_mouse_button_buf[event.MouseInput.Event%3];
m_mouse_button_buf[event.MouseInput.Event%3] = ((event.MouseInput.Event/3)?false:true);
}
break;
}

return true;
}

bool IsKeyDown(int index)
{
return m_key_buf[index];
}

bool IsKeyUpDown(int index)
{
return (m_key_buf[index] && !m_key_buf_old[index]);
}

bool IsKeyDownUp(int index)
{
return (!m_key_buf[index] && m_key_buf_old[index]);
}

bool IsMouseButtonDown(int index)
{
return m_mouse_button_buf[index];
}

bool IsMouseButtonUpDown(int index)
{
return (m_mouse_button_buf[index] && !m_mouse_button_buf_old[index]);
}

bool IsMouseButtonDownUp(int index)
{
return (!m_mouse_button_buf[index] && m_mouse_button_buf_old[index]);
}
};

CIrrLichtEvent::CIrrLichtEvent(void)
{
    return;
}

CIrrLichtEvent::~CIrrLichtEvent(void)
{
    return;
}
# 14 "shooter.cpp" 2
# 1 "timesensor.h" 1






class TimeSensor
{
protected:
   TimeSensor(void);

   double sensor;
   double k;
   double max_sensor;
   double critical_value;
   bool hasMadeObservation;
   LARGE_INTEGER t_last_observation;

private:
   void init_emkt_lookup(void);
   double LN_2;
   double emkt_lookup[128];

public:
   virtual void setFrequency(double hertz);
   virtual void setLambda(double lambda);
   virtual void reset(void);
   virtual bool poll(void);
   virtual void wait(void);
   virtual double getSeconds(void);
   virtual double getTickFrequency(void) = 0;
   virtual void getTicks(LARGE_INTEGER *ticks) = 0;
   virtual void killTime(void);
   virtual ~TimeSensor(void);

   static TimeSensor *getNewClockSensor();
};
# 15 "shooter.cpp" 2
# 1 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/sstream" 1
# 43 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/sstream"
       
# 44 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/sstream" 3




namespace std
{
# 62 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/sstream" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    class basic_stringbuf : public basic_streambuf<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;


      typedef _Alloc allocator_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;







      typedef basic_streambuf<char_type, traits_type> __streambuf_type;
      typedef basic_string<char_type, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;


    protected:





      ios_base::openmode _M_mode;







      __string_type _M_string;

    public:
# 112 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/sstream" 3
      explicit
      basic_stringbuf(ios_base::openmode __mode = ios_base::in | ios_base::out)
      : __streambuf_type(), _M_mode(), _M_string()
      { _M_stringbuf_init(__mode); }
# 125 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/sstream" 3
      explicit
      basic_stringbuf(const __string_type& __str,
        ios_base::openmode __mode = ios_base::in | ios_base::out)
      : __streambuf_type(), _M_mode(), _M_string(__str.data(), __str.size())
      { _M_stringbuf_init(__mode); }
# 140 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/sstream" 3
      __string_type
      str() const
      {
 const bool __testout = this->_M_mode & ios_base::out;
 if (__testout)
   {

     if (this->pptr() > this->egptr())
       return __string_type(this->pbase(), this->pptr());
     else
        return __string_type(this->pbase(), this->egptr());
   }
 else
   return _M_string;
      }
# 163 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/sstream" 3
      void
      str(const __string_type& __s)
      {

 _M_string.assign(__s.data(), __s.size());
 _M_stringbuf_init(this->_M_mode);
      }

    protected:






      void
      _M_stringbuf_init(ios_base::openmode __mode)
      {
 this->_M_mode = __mode;

 __size_type __len = 0;
 if (this->_M_mode & (ios_base::ate | ios_base::app))
   __len = _M_string.size();
 _M_sync(const_cast<char_type*>(_M_string.data()), 0, __len);
      }


      virtual int_type
      underflow();


      virtual int_type
      pbackfail(int_type __c = traits_type::eof());


      virtual int_type
      overflow(int_type __c = traits_type::eof());
# 212 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/sstream" 3
      virtual __streambuf_type*
      setbuf(char_type* __s, streamsize __n)
      {
 if (__s && __n >= 0)
   {






     _M_string = __string_type(__s, __n);


     _M_sync(__s, 0, 0);
   }
 return this;
      }


      virtual pos_type
      seekoff(off_type __off, ios_base::seekdir __way,
       ios_base::openmode __mode = ios_base::in | ios_base::out);


      virtual pos_type
      seekpos(pos_type __sp,
       ios_base::openmode __mode = ios_base::in | ios_base::out);
# 252 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/sstream" 3
      void
      _M_sync(char_type* __base, __size_type __i, __size_type __o)
      {
 const bool __testin = this->_M_mode & ios_base::in;
 const bool __testout = this->_M_mode & ios_base::out;
 const __size_type __len = _M_string.size();

 if (__testin)
   this->setg(__base, __base + __i, __base + __len);
 if (__testout)
   {
     this->setp(__base, __base + _M_string.capacity());
     this->pbump(__o);




     if (!__testin)
       this->setg(__base + __len, __base + __len, __base + __len);
   }
      }



      void
      _M_update_egptr()
      {
 const bool __testin = this->_M_mode & ios_base::in;
 const bool __testout = this->_M_mode & ios_base::out;

 if (__testout && this->pptr() > this->egptr())
   if (__testin)
     this->setg(this->eback(), this->gptr(), this->pptr());
   else
     this->setg(this->pptr(), this->pptr(), this->pptr());
      }
    };
# 300 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/sstream" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    class basic_istringstream : public basic_istream<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;


      typedef _Alloc allocator_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;


      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef basic_stringbuf<_CharT, _Traits, _Alloc> __stringbuf_type;
      typedef basic_istream<char_type, traits_type> __istream_type;

    private:





      __stringbuf_type _M_stringbuf;

    public:
# 343 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/sstream" 3
      explicit
      basic_istringstream(ios_base::openmode __mode = ios_base::in)
      : __istream_type(), _M_stringbuf(__mode | ios_base::in)
      { this->init(&_M_stringbuf); }
# 363 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/sstream" 3
      explicit
      basic_istringstream(const __string_type& __str,
     ios_base::openmode __mode = ios_base::in)
      : __istream_type(), _M_stringbuf(__str, __mode | ios_base::in)
      { this->init(&_M_stringbuf); }







      ~basic_istringstream()
      { }
# 385 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/sstream" 3
      __stringbuf_type*
      rdbuf() const
      { return const_cast<__stringbuf_type*>(&_M_stringbuf); }





      __string_type
      str() const
      { return _M_stringbuf.str(); }







      void
      str(const __string_type& __s)
      { _M_stringbuf.str(__s); }
    };
# 418 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/sstream" 3
  template <typename _CharT, typename _Traits, typename _Alloc>
    class basic_ostringstream : public basic_ostream<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;


      typedef _Alloc allocator_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;


      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef basic_stringbuf<_CharT, _Traits, _Alloc> __stringbuf_type;
      typedef basic_ostream<char_type, traits_type> __ostream_type;

    private:





      __stringbuf_type _M_stringbuf;

    public:
# 461 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/sstream" 3
      explicit
      basic_ostringstream(ios_base::openmode __mode = ios_base::out)
      : __ostream_type(), _M_stringbuf(__mode | ios_base::out)
      { this->init(&_M_stringbuf); }
# 481 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/sstream" 3
      explicit
      basic_ostringstream(const __string_type& __str,
     ios_base::openmode __mode = ios_base::out)
      : __ostream_type(), _M_stringbuf(__str, __mode | ios_base::out)
      { this->init(&_M_stringbuf); }







      ~basic_ostringstream()
      { }
# 503 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/sstream" 3
      __stringbuf_type*
      rdbuf() const
      { return const_cast<__stringbuf_type*>(&_M_stringbuf); }





      __string_type
      str() const
      { return _M_stringbuf.str(); }







      void
      str(const __string_type& __s)
      { _M_stringbuf.str(__s); }
    };
# 536 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/sstream" 3
  template <typename _CharT, typename _Traits, typename _Alloc>
    class basic_stringstream : public basic_iostream<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;


      typedef _Alloc allocator_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;


      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef basic_stringbuf<_CharT, _Traits, _Alloc> __stringbuf_type;
      typedef basic_iostream<char_type, traits_type> __iostream_type;

    private:





      __stringbuf_type _M_stringbuf;

    public:
# 577 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/sstream" 3
      explicit
      basic_stringstream(ios_base::openmode __m = ios_base::out | ios_base::in)
      : __iostream_type(), _M_stringbuf(__m)
      { this->init(&_M_stringbuf); }
# 595 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/sstream" 3
      explicit
      basic_stringstream(const __string_type& __str,
    ios_base::openmode __m = ios_base::out | ios_base::in)
      : __iostream_type(), _M_stringbuf(__str, __m)
      { this->init(&_M_stringbuf); }







      ~basic_stringstream()
      { }
# 617 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/sstream" 3
      __stringbuf_type*
      rdbuf() const
      { return const_cast<__stringbuf_type*>(&_M_stringbuf); }





      __string_type
      str() const
      { return _M_stringbuf.str(); }







      void
      str(const __string_type& __s)
      { _M_stringbuf.str(__s); }
    };
}


# 1 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/sstream.tcc" 1 3
# 38 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/sstream.tcc" 3
       
# 39 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/sstream.tcc" 3

# 1 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/sstream" 1 3
# 41 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/sstream.tcc" 2 3

namespace std
{
  template <class _CharT, class _Traits, class _Alloc>
    typename basic_stringbuf<_CharT, _Traits, _Alloc>::int_type
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    pbackfail(int_type __c)
    {
      int_type __ret = traits_type::eof();
      const bool __testeof = traits_type::eq_int_type(__c, __ret);

      if (this->eback() < this->gptr())
 {
   const bool __testeq = traits_type::eq(traits_type::to_char_type(__c),
      this->gptr()[-1]);
   this->gbump(-1);



   if (!__testeof && __testeq)
     __ret = __c;
   else if (__testeof)
     __ret = traits_type::not_eof(__c);
   else
     {
       *this->gptr() = traits_type::to_char_type(__c);
       __ret = __c;
     }
 }
      return __ret;
    }

  template <class _CharT, class _Traits, class _Alloc>
    typename basic_stringbuf<_CharT, _Traits, _Alloc>::int_type
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    overflow(int_type __c)
    {
      const bool __testout = this->_M_mode & ios_base::out;
      if (__builtin_expect(!__testout, false))
 return traits_type::eof();

      const bool __testeof = traits_type::eq_int_type(__c, traits_type::eof());
      if (__builtin_expect(__testeof, false))
 return traits_type::not_eof(__c);

      const __size_type __capacity = _M_string.capacity();
      const __size_type __max_size = _M_string.max_size();
      const bool __testput = this->pptr() < this->epptr();
      if (__builtin_expect(!__testput && __capacity == __max_size, false))
 return traits_type::eof();



      if (!__testput)
 {






   const __size_type __opt_len = std::max(__size_type(2 * __capacity),
       __size_type(512));
   const __size_type __len = std::min(__opt_len, __max_size);
   __string_type __tmp;
   __tmp.reserve(__len);
   __tmp.assign(_M_string.data(), this->epptr() - this->pbase());
   _M_string.swap(__tmp);
   _M_sync(const_cast<char_type*>(_M_string.data()),
    this->gptr() - this->eback(), this->pptr() - this->pbase());
 }
      return this->sputc(traits_type::to_char_type(__c));
    }

  template <class _CharT, class _Traits, class _Alloc>
    typename basic_stringbuf<_CharT, _Traits, _Alloc>::int_type
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    underflow()
    {
      int_type __ret = traits_type::eof();
      const bool __testin = this->_M_mode & ios_base::in;
      if (__testin)
 {

   _M_update_egptr();
   if (this->gptr() < this->egptr())
     __ret = traits_type::to_int_type(*this->gptr());
 }
      return __ret;
    }

  template <class _CharT, class _Traits, class _Alloc>
    typename basic_stringbuf<_CharT, _Traits, _Alloc>::pos_type
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    seekoff(off_type __off, ios_base::seekdir __way, ios_base::openmode __mode)
    {
      pos_type __ret = pos_type(off_type(-1));
      bool __testin = (ios_base::in & this->_M_mode & __mode) != 0;
      bool __testout = (ios_base::out & this->_M_mode & __mode) != 0;
      const bool __testboth = __testin && __testout && __way != ios_base::cur;
      __testin &= !(__mode & ios_base::out);
      __testout &= !(__mode & ios_base::in);

      if (_M_string.capacity() && (__testin || __testout || __testboth))
 {
   char_type* __beg = __testin ? this->eback() : this->pbase();

   _M_update_egptr();

   off_type __newoffi = 0;
   off_type __newoffo = 0;
   if (__way == ios_base::cur)
     {
       __newoffi = this->gptr() - __beg;
       __newoffo = this->pptr() - __beg;
     }
   else if (__way == ios_base::end)
     __newoffo = __newoffi = this->egptr() - __beg;

   if ((__testin || __testboth)
       && __newoffi + __off >= 0
       && this->egptr() - __beg >= __newoffi + __off)
     {
       this->gbump((__beg + __newoffi + __off) - this->gptr());
       __ret = pos_type(__newoffi);
     }
   if ((__testout || __testboth)
       && __newoffo + __off >= 0
       && this->egptr() - __beg >= __newoffo + __off)
     {
       this->pbump((__beg + __newoffo + __off) - this->pptr());
       __ret = pos_type(__newoffo);
     }
 }
      return __ret;
    }

  template <class _CharT, class _Traits, class _Alloc>
    typename basic_stringbuf<_CharT, _Traits, _Alloc>::pos_type
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    seekpos(pos_type __sp, ios_base::openmode __mode)
    {
      pos_type __ret = pos_type(off_type(-1));
      if (_M_string.capacity())
 {
   off_type __pos (__sp);
   const bool __testin = (ios_base::in & this->_M_mode & __mode) != 0;
   const bool __testout = (ios_base::out & this->_M_mode & __mode) != 0;
   char_type* __beg = __testin ? this->eback() : this->pbase();

   _M_update_egptr();

   const bool __testpos = 0 <= __pos
                          && __pos <= this->egptr() - __beg;
   if ((__testin || __testout) && __testpos)
     {
       if (__testin)
  this->gbump((__beg + __pos) - this->gptr());
       if (__testout)
                this->pbump((__beg + __pos) - this->pptr());
       __ret = pos_type(off_type(__pos));
     }
 }
      return __ret;
    }





  extern template class basic_stringbuf<char>;
  extern template class basic_istringstream<char>;
  extern template class basic_ostringstream<char>;
  extern template class basic_stringstream<char>;
# 223 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/sstream.tcc" 3
}
# 643 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/sstream" 2 3
# 16 "shooter.cpp" 2
# 1 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/backward/fstream.h" 1
# 32 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/backward/fstream.h"
# 1 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/fstream" 1
# 43 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/fstream"
       
# 44 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/fstream" 3





# 1 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/mingw32/bits/basic_file.h" 1 3
# 42 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/mingw32/bits/basic_file.h" 3
       
# 43 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/mingw32/bits/basic_file.h" 3




namespace std
{

  template<typename _CharT>
    class __basic_file;


  template<>
    class __basic_file<char>
    {

      __c_file* _M_cfile;


      bool _M_cfile_created;

    public:
      __basic_file(__c_lock* __lock = 0);

      __basic_file*
      open(const char* __name, ios_base::openmode __mode, int __prot = 0664);

      __basic_file*
      sys_open(__c_file* __file, ios_base::openmode);

      __basic_file*
      sys_open(int __fd, ios_base::openmode __mode);

      __basic_file*
      close();

      bool
      is_open() const;

      int
      fd();

      __c_file*
      file();

      ~__basic_file();

      streamsize
      xsputn(const char* __s, streamsize __n);

      streamsize
      xsputn_2(const char* __s1, streamsize __n1,
        const char* __s2, streamsize __n2);

      streamsize
      xsgetn(char* __s, streamsize __n);

      streamoff
      seekoff(streamoff __off, ios_base::seekdir __way);

      int
      sync();

      streamsize
      showmanyc();
    };
}
# 50 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/fstream" 2 3


namespace std
{
# 68 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/fstream" 3
  template<typename _CharT, typename _Traits>
    class basic_filebuf : public basic_streambuf<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;







      typedef basic_streambuf<char_type, traits_type> __streambuf_type;
      typedef basic_filebuf<char_type, traits_type> __filebuf_type;
      typedef __basic_file<char> __file_type;
      typedef typename traits_type::state_type __state_type;
      typedef codecvt<char_type, char, __state_type> __codecvt_type;


      friend class ios_base;

    protected:







      __c_lock _M_lock;







      __file_type _M_file;






      ios_base::openmode _M_mode;







      __state_type _M_state_beg;
# 135 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/fstream" 3
      __state_type _M_state_cur;
# 144 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/fstream" 3
      __state_type _M_state_last;






      char_type* _M_buf;
# 160 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/fstream" 3
      size_t _M_buf_size;







      bool _M_buf_allocated;
# 179 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/fstream" 3
      bool _M_reading;
      bool _M_writing;
# 190 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/fstream" 3
      char_type _M_pback;
      char_type* _M_pback_cur_save;
      char_type* _M_pback_end_save;
      bool _M_pback_init;



      const __codecvt_type* _M_codecvt;
# 206 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/fstream" 3
      char* _M_ext_buf;






      streamsize _M_ext_buf_size;
# 222 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/fstream" 3
      const char* _M_ext_next;
      char* _M_ext_end;
# 232 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/fstream" 3
      void
      _M_create_pback()
      {
 if (!_M_pback_init)
   {
     _M_pback_cur_save = this->gptr();
     _M_pback_end_save = this->egptr();
     this->setg(&_M_pback, &_M_pback, &_M_pback + 1);
     _M_pback_init = true;
   }
      }
# 251 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/fstream" 3
      void
      _M_destroy_pback() throw()
      {
 if (_M_pback_init)
   {

     _M_pback_cur_save += this->gptr() != this->eback();
     this->setg(this->_M_buf, _M_pback_cur_save, _M_pback_end_save);
     _M_pback_init = false;
   }
      }

    public:







      basic_filebuf();




      virtual
      ~basic_filebuf()
      { this->close(); }





      bool
      is_open() const throw() { return _M_file.is_open(); }
# 300 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/fstream" 3
      __filebuf_type*
      open(const char* __s, ios_base::openmode __mode);
# 314 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/fstream" 3
      __filebuf_type*
      close() throw();

    protected:





      void
      _M_allocate_internal_buffer();






      void
      _M_destroy_internal_buffer() throw();



      virtual streamsize
      showmanyc();







      virtual int_type
      underflow();


      virtual int_type
      pbackfail(int_type __c = _Traits::eof());
# 364 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/fstream" 3
      virtual int_type
      overflow(int_type __c = _Traits::eof());
# 374 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/fstream" 3
      bool
      _M_convert_to_external(char_type*, streamsize);
# 389 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/fstream" 3
      virtual __streambuf_type*
      setbuf(char_type* __s, streamsize __n);


      virtual pos_type
      seekoff(off_type __off, ios_base::seekdir __way,
       ios_base::openmode __mode = ios_base::in | ios_base::out);


      virtual pos_type
      seekpos(pos_type __pos,
       ios_base::openmode __mode = ios_base::in | ios_base::out);







      pos_type
      _M_seek(off_type __off, ios_base::seekdir __way, __state_type __state);


      virtual int
      sync();


      virtual void
      imbue(const locale& __loc);


      virtual streamsize
      xsgetn(char_type* __s, streamsize __n);


      virtual streamsize
      xsputn(const char_type* __s, streamsize __n);







      bool
      _M_terminate_output();
# 450 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/fstream" 3
      void
      _M_set_buffer(streamsize __off)
      {
  const bool __testin = this->_M_mode & ios_base::in;
  const bool __testout = this->_M_mode & ios_base::out;

 if (__testin && __off > 0)
   this->setg(this->_M_buf, this->_M_buf, this->_M_buf + __off);
 else
   this->setg(this->_M_buf, this->_M_buf, this->_M_buf);

 if (__testout && __off == 0 && this->_M_buf_size > 1 )
   this->setp(this->_M_buf, this->_M_buf + this->_M_buf_size - 1);
 else
   this->setp(__null, __null);
      }
    };
# 477 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/fstream" 3
  template<typename _CharT, typename _Traits>
    class basic_ifstream : public basic_istream<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;


      typedef basic_filebuf<char_type, traits_type> __filebuf_type;
      typedef basic_istream<char_type, traits_type> __istream_type;

    private:





      __filebuf_type _M_filebuf;

    public:
# 509 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/fstream" 3
      basic_ifstream() : __istream_type(), _M_filebuf()
      { this->init(&_M_filebuf); }
# 522 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/fstream" 3
      explicit
      basic_ifstream(const char* __s, ios_base::openmode __mode = ios_base::in)
      : __istream_type(), _M_filebuf()
      {
 this->init(&_M_filebuf);
 this->open(__s, __mode);
      }







      ~basic_ifstream()
      { }
# 546 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/fstream" 3
      __filebuf_type*
      rdbuf() const
      { return const_cast<__filebuf_type*>(&_M_filebuf); }





      bool
      is_open() { return _M_filebuf.is_open(); }
# 568 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/fstream" 3
      void
      open(const char* __s, ios_base::openmode __mode = ios_base::in)
      {
 if (!_M_filebuf.open(__s, __mode | ios_base::in))
   this->setstate(ios_base::failbit);
      }







      void
      close()
      {
 if (!_M_filebuf.close())
   this->setstate(ios_base::failbit);
      }
    };
# 599 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/fstream" 3
  template<typename _CharT, typename _Traits>
    class basic_ofstream : public basic_ostream<_CharT,_Traits>
    {
    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;


      typedef basic_filebuf<char_type, traits_type> __filebuf_type;
      typedef basic_ostream<char_type, traits_type> __ostream_type;

    private:





      __filebuf_type _M_filebuf;

    public:
# 631 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/fstream" 3
      basic_ofstream(): __ostream_type(), _M_filebuf()
      { this->init(&_M_filebuf); }
# 645 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/fstream" 3
      explicit
      basic_ofstream(const char* __s,
       ios_base::openmode __mode = ios_base::out|ios_base::trunc)
      : __ostream_type(), _M_filebuf()
      {
 this->init(&_M_filebuf);
 this->open(__s, __mode);
      }







      ~basic_ofstream()
      { }
# 670 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/fstream" 3
      __filebuf_type*
      rdbuf() const
      { return const_cast<__filebuf_type*>(&_M_filebuf); }





      bool
      is_open() { return _M_filebuf.is_open(); }
# 692 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/fstream" 3
      void
      open(const char* __s,
    ios_base::openmode __mode = ios_base::out | ios_base::trunc)
      {
 if (!_M_filebuf.open(__s, __mode | ios_base::out))
   this->setstate(ios_base::failbit);
      }







      void
      close()
      {
 if (!_M_filebuf.close())
   this->setstate(ios_base::failbit);
      }
    };
# 724 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/fstream" 3
  template<typename _CharT, typename _Traits>
    class basic_fstream : public basic_iostream<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;


      typedef basic_filebuf<char_type, traits_type> __filebuf_type;
      typedef basic_ios<char_type, traits_type> __ios_type;
      typedef basic_iostream<char_type, traits_type> __iostream_type;

    private:





      __filebuf_type _M_filebuf;

    public:
# 757 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/fstream" 3
      basic_fstream()
      : __iostream_type(), _M_filebuf()
      { this->init(&_M_filebuf); }
# 769 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/fstream" 3
      explicit
      basic_fstream(const char* __s,
      ios_base::openmode __mode = ios_base::in | ios_base::out)
      : __iostream_type(__null), _M_filebuf()
      {
 this->init(&_M_filebuf);
 this->open(__s, __mode);
      }







      ~basic_fstream()
      { }
# 794 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/fstream" 3
      __filebuf_type*
      rdbuf() const
      { return const_cast<__filebuf_type*>(&_M_filebuf); }





      bool
      is_open() { return _M_filebuf.is_open(); }
# 816 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/fstream" 3
      void
      open(const char* __s,
    ios_base::openmode __mode = ios_base::in | ios_base::out)
      {
 if (!_M_filebuf.open(__s, __mode))
   this->setstate(ios_base::failbit);
      }







      void
      close()
      {
 if (!_M_filebuf.close())
   this->setstate(ios_base::failbit);
      }
    };
}


# 1 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/fstream.tcc" 1 3
# 38 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/fstream.tcc" 3
       
# 39 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/fstream.tcc" 3

namespace std
{
  template<typename _CharT, typename _Traits>
    void
    basic_filebuf<_CharT, _Traits>::
    _M_allocate_internal_buffer()
    {


      if (!_M_buf_allocated && !this->_M_buf)
 {
   this->_M_buf = new char_type[this->_M_buf_size];
   _M_buf_allocated = true;
 }
    }

  template<typename _CharT, typename _Traits>
    void
    basic_filebuf<_CharT, _Traits>::
    _M_destroy_internal_buffer() throw()
    {
      if (_M_buf_allocated)
 {
   delete [] this->_M_buf;
   this->_M_buf = __null;
   _M_buf_allocated = false;
 }
      delete [] _M_ext_buf;
      _M_ext_buf = __null;
      _M_ext_buf_size = 0;
      _M_ext_next = __null;
      _M_ext_end = __null;
    }

  template<typename _CharT, typename _Traits>
    basic_filebuf<_CharT, _Traits>::
    basic_filebuf() : __streambuf_type(), _M_lock(), _M_file(&_M_lock),
    _M_mode(ios_base::openmode(0)), _M_state_beg(), _M_state_cur(),
    _M_state_last(), _M_buf(__null), _M_buf_size(512),
    _M_buf_allocated(false), _M_reading(false), _M_writing(false), _M_pback(),
    _M_pback_cur_save(0), _M_pback_end_save(0), _M_pback_init(false),
    _M_codecvt(0), _M_ext_buf(0), _M_ext_buf_size(0), _M_ext_next(0),
    _M_ext_end(0)
    {
      if (has_facet<__codecvt_type>(this->_M_buf_locale))
 _M_codecvt = &use_facet<__codecvt_type>(this->_M_buf_locale);
    }

  template<typename _CharT, typename _Traits>
    typename basic_filebuf<_CharT, _Traits>::__filebuf_type*
    basic_filebuf<_CharT, _Traits>::
    open(const char* __s, ios_base::openmode __mode)
    {
      __filebuf_type *__ret = __null;
      if (!this->is_open())
 {
   _M_file.open(__s, __mode);
   if (this->is_open())
     {
       _M_allocate_internal_buffer();
       this->_M_mode = __mode;


       _M_reading = false;
       _M_writing = false;
       _M_set_buffer(-1);


       _M_state_last = _M_state_cur = _M_state_beg;


       if ((__mode & ios_base::ate)
    && this->seekoff(0, ios_base::end, __mode)
    == pos_type(off_type(-1)))
  this->close();
       else
  __ret = this;
     }
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    typename basic_filebuf<_CharT, _Traits>::__filebuf_type*
    basic_filebuf<_CharT, _Traits>::
    close() throw()
    {
      __filebuf_type* __ret = __null;
      if (this->is_open())
 {
   bool __testfail = false;
   try
     {
       if (!_M_terminate_output())
  __testfail = true;
     }
   catch(...)
     { __testfail = true; }


   this->_M_mode = ios_base::openmode(0);
   this->_M_pback_init = false;
   _M_destroy_internal_buffer();
   _M_reading = false;
   _M_writing = false;
   _M_set_buffer(-1);
   _M_state_last = _M_state_cur = _M_state_beg;

   if (!_M_file.close())
     __testfail = true;

   if (!__testfail)
     __ret = this;
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    streamsize
    basic_filebuf<_CharT, _Traits>::
    showmanyc()
    {
      streamsize __ret = -1;
      const bool __testin = this->_M_mode & ios_base::in;
      if (__testin && this->is_open())
 {


   __ret = this->egptr() - this->gptr();
   if (__check_facet(_M_codecvt).encoding() >= 0)
     __ret += _M_file.showmanyc() / _M_codecvt->max_length();
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    typename basic_filebuf<_CharT, _Traits>::int_type
    basic_filebuf<_CharT, _Traits>::
    underflow()
    {
      int_type __ret = traits_type::eof();
      const bool __testin = this->_M_mode & ios_base::in;
      if (__testin && !_M_writing)
 {



   _M_destroy_pback();

   if (this->gptr() < this->egptr())
     return traits_type::to_int_type(*this->gptr());


   const size_t __buflen = this->_M_buf_size > 1
                           ? this->_M_buf_size - 1 : 1;


   bool __got_eof = false;

   streamsize __ilen = 0;
   codecvt_base::result __r = codecvt_base::ok;
   if (__check_facet(_M_codecvt).always_noconv())
     {
       __ilen = _M_file.xsgetn(reinterpret_cast<char*>(this->eback()),
          __buflen);
       if (__ilen == 0)
  __got_eof = true;
     }
   else
     {


       const int __enc = _M_codecvt->encoding();
       streamsize __blen;
       streamsize __rlen;
       if (__enc > 0)
  __blen = __rlen = __buflen * __enc;
       else
  {
    __blen = __buflen + _M_codecvt->max_length() - 1;
    __rlen = __buflen;
  }
       const streamsize __remainder = _M_ext_end - _M_ext_next;
       __rlen = __rlen > __remainder ? __rlen - __remainder : 0;



       if (_M_reading && this->egptr() == this->eback() && __remainder)
  __rlen = 0;



       if (_M_ext_buf_size < __blen)
  {
    char* __buf = new char[__blen];
    if (__remainder)
      std::memcpy(__buf, _M_ext_next, __remainder);

    delete [] _M_ext_buf;
    _M_ext_buf = __buf;
    _M_ext_buf_size = __blen;
  }
       else if (__remainder)
  std::memmove(_M_ext_buf, _M_ext_next, __remainder);

       _M_ext_next = _M_ext_buf;
       _M_ext_end = _M_ext_buf + __remainder;
       _M_state_last = _M_state_cur;

       do
  {
    if (__rlen > 0)
      {



        if (_M_ext_end - _M_ext_buf + __rlen > _M_ext_buf_size)
   {
     __throw_ios_failure(("basic_filebuf::underflow " "codecvt::max_length() " "is not valid"));


   }
        streamsize __elen = _M_file.xsgetn(_M_ext_end, __rlen);
        if (__elen == 0)
   __got_eof = true;
        else if (__elen == -1)
   break;
        _M_ext_end += __elen;
      }

    char_type* __iend;
    __r = _M_codecvt->in(_M_state_cur, _M_ext_next,
           _M_ext_end, _M_ext_next, this->eback(),
           this->eback() + __buflen, __iend);
    if (__r == codecvt_base::noconv)
      {
        size_t __avail = _M_ext_end - _M_ext_buf;
        __ilen = std::min(__avail, __buflen);
        traits_type::copy(this->eback(),
     reinterpret_cast<char_type*>(_M_ext_buf), __ilen);
        _M_ext_next = _M_ext_buf + __ilen;
      }
    else
      __ilen = __iend - this->eback();




    if (__r == codecvt_base::error)
      break;

    __rlen = 1;
  }
       while (__ilen == 0 && !__got_eof);
     }

   if (__ilen > 0)
     {
       _M_set_buffer(__ilen);
       _M_reading = true;
       __ret = traits_type::to_int_type(*this->gptr());
     }
   else if (__got_eof)
     {



       _M_set_buffer(-1);
       _M_reading = false;


       if (__r == codecvt_base::partial)
  __throw_ios_failure(("basic_filebuf::underflow " "incomplete character in file"));

     }
   else if (__r == codecvt_base::error)
     __throw_ios_failure(("basic_filebuf::underflow " "invalid byte sequence in file"));

   else
     __throw_ios_failure(("basic_filebuf::underflow " "error reading the file"));

 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    typename basic_filebuf<_CharT, _Traits>::int_type
    basic_filebuf<_CharT, _Traits>::
    pbackfail(int_type __i)
    {
      int_type __ret = traits_type::eof();
      const bool __testin = this->_M_mode & ios_base::in;
      if (__testin && !_M_writing)
 {


   const bool __testpb = this->_M_pback_init;
   const bool __testeof = traits_type::eq_int_type(__i, __ret);
   int_type __tmp;
   if (this->eback() < this->gptr())
     {
       this->gbump(-1);
       __tmp = traits_type::to_int_type(*this->gptr());
     }
   else if (this->seekoff(-1, ios_base::cur) != pos_type(off_type(-1)))
     {
       __tmp = this->underflow();
       if (traits_type::eq_int_type(__tmp, __ret))
  return __ret;
     }
   else
     {





       return __ret;
     }



   if (!__testeof && traits_type::eq_int_type(__i, __tmp))
     __ret = __i;
   else if (__testeof)
     __ret = traits_type::not_eof(__i);
   else if (!__testpb)
     {
       _M_create_pback();
       _M_reading = true;
       *this->gptr() = traits_type::to_char_type(__i);
       __ret = __i;
     }
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    typename basic_filebuf<_CharT, _Traits>::int_type
    basic_filebuf<_CharT, _Traits>::
    overflow(int_type __c)
    {
      int_type __ret = traits_type::eof();
      const bool __testeof = traits_type::eq_int_type(__c, __ret);
      const bool __testout = this->_M_mode & ios_base::out;
      if (__testout && !_M_reading)
 {
   if (this->pbase() < this->pptr())
     {

       if (!__testeof)
  {
    *this->pptr() = traits_type::to_char_type(__c);
    this->pbump(1);
  }



       if (_M_convert_to_external(this->pbase(),
      this->pptr() - this->pbase())
    && (!__testeof || !_M_file.sync()))
  {
    _M_set_buffer(0);
    __ret = traits_type::not_eof(__c);
  }
     }
   else if (this->_M_buf_size > 1)
     {



       _M_set_buffer(0);
       _M_writing = true;
       if (!__testeof)
  {
    *this->pptr() = traits_type::to_char_type(__c);
    this->pbump(1);
  }
       __ret = traits_type::not_eof(__c);
     }
   else
     {

       char_type __conv = traits_type::to_char_type(__c);
       if (__testeof || _M_convert_to_external(&__conv, 1))
  {
    _M_writing = true;
    __ret = traits_type::not_eof(__c);
  }
     }
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    bool
    basic_filebuf<_CharT, _Traits>::
    _M_convert_to_external(_CharT* __ibuf, streamsize __ilen)
    {

      streamsize __elen;
      streamsize __plen;
      if (__check_facet(_M_codecvt).always_noconv())
 {
   __elen = _M_file.xsputn(reinterpret_cast<char*>(__ibuf), __ilen);
   __plen = __ilen;
 }
      else
 {


   streamsize __blen = __ilen * _M_codecvt->max_length();
   char* __buf = static_cast<char*>(__builtin_alloca(__blen));

   char* __bend;
   const char_type* __iend;
   codecvt_base::result __r;
   __r = _M_codecvt->out(_M_state_cur, __ibuf, __ibuf + __ilen,
    __iend, __buf, __buf + __blen, __bend);

   if (__r == codecvt_base::ok || __r == codecvt_base::partial)
     __blen = __bend - __buf;
   else if (__r == codecvt_base::noconv)
     {

       __buf = reinterpret_cast<char*>(__ibuf);
       __blen = __ilen;
     }
   else
     __throw_ios_failure(("basic_filebuf::_M_convert_to_external " "conversion error"));


   __elen = _M_file.xsputn(__buf, __blen);
   __plen = __blen;


   if (__r == codecvt_base::partial && __elen == __plen)
     {
       const char_type* __iresume = __iend;
       streamsize __rlen = this->pptr() - __iend;
       __r = _M_codecvt->out(_M_state_cur, __iresume,
        __iresume + __rlen, __iend, __buf,
        __buf + __blen, __bend);
       if (__r != codecvt_base::error)
  {
    __rlen = __bend - __buf;
    __elen = _M_file.xsputn(__buf, __rlen);
    __plen = __rlen;
  }
       else
  __throw_ios_failure(("basic_filebuf::_M_convert_to_external " "conversion error"));

     }
 }
      return __elen == __plen;
    }

   template<typename _CharT, typename _Traits>
     streamsize
     basic_filebuf<_CharT, _Traits>::
     xsgetn(_CharT* __s, streamsize __n)
     {

       streamsize __ret = 0;
       if (this->_M_pback_init)
  {
    if (__n > 0 && this->gptr() == this->eback())
      {
        *__s++ = *this->gptr();
        this->gbump(1);
        __ret = 1;
        --__n;
      }
    _M_destroy_pback();
  }




       const bool __testin = this->_M_mode & ios_base::in;
       const streamsize __buflen = this->_M_buf_size > 1 ? this->_M_buf_size - 1
                                                  : 1;
       if (__n > __buflen && __check_facet(_M_codecvt).always_noconv()
    && __testin && !_M_writing)
  {

    const streamsize __avail = this->egptr() - this->gptr();
    if (__avail != 0)
      {
        if (__avail == 1)
   *__s = *this->gptr();
        else if (__avail > 1)
   traits_type::copy(__s, this->gptr(), __avail);
        __s += __avail;
        this->gbump(__avail);
        __ret += __avail;
        __n -= __avail;
      }

    const streamsize __len = _M_file.xsgetn(reinterpret_cast<char*>(__s),
         __n);
    if (__len == -1)
      __throw_ios_failure(("basic_filebuf::xsgetn " "error reading the file"));

    __ret += __len;
    if (__len == __n)
      {
        _M_set_buffer(0);
        _M_reading = true;
      }
    else if (__len == 0)
      {



        _M_set_buffer(-1);
        _M_reading = false;
      }
  }
       else
  __ret += __streambuf_type::xsgetn(__s, __n);

       return __ret;
     }

   template<typename _CharT, typename _Traits>
     streamsize
     basic_filebuf<_CharT, _Traits>::
     xsputn(const _CharT* __s, streamsize __n)
     {



       streamsize __ret = 0;
       const bool __testout = this->_M_mode & ios_base::out;
       if (__check_facet(_M_codecvt).always_noconv()
    && __testout && !_M_reading)
 {

   const streamsize __chunk = 1ul << 10;
   streamsize __bufavail = this->epptr() - this->pptr();


   if (!_M_writing && this->_M_buf_size > 1)
     __bufavail = this->_M_buf_size - 1;

   const streamsize __limit = std::min(__chunk, __bufavail);
   if (__n >= __limit)
     {
       const streamsize __buffill = this->pptr() - this->pbase();
       const char* __buf = reinterpret_cast<const char*>(this->pbase());
       __ret = _M_file.xsputn_2(__buf, __buffill,
           reinterpret_cast<const char*>(__s),
           __n);
       if (__ret == __buffill + __n)
  {
    _M_set_buffer(0);
    _M_writing = true;
  }
       if (__ret > __buffill)
  __ret -= __buffill;
       else
  __ret = 0;
     }
   else
     __ret = __streambuf_type::xsputn(__s, __n);
 }
       else
  __ret = __streambuf_type::xsputn(__s, __n);
       return __ret;
    }

  template<typename _CharT, typename _Traits>
    typename basic_filebuf<_CharT, _Traits>::__streambuf_type*
    basic_filebuf<_CharT, _Traits>::
    setbuf(char_type* __s, streamsize __n)
    {
      if (!this->is_open())
 if (__s == 0 && __n == 0)
   this->_M_buf_size = 1;
 else if (__s && __n > 0)
   {
# 630 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/fstream.tcc" 3
     this->_M_buf = __s;
     this->_M_buf_size = __n;
   }
      return this;
    }




  template<typename _CharT, typename _Traits>
    typename basic_filebuf<_CharT, _Traits>::pos_type
    basic_filebuf<_CharT, _Traits>::
    seekoff(off_type __off, ios_base::seekdir __way, ios_base::openmode)
    {
      int __width = 0;
      if (_M_codecvt)
 __width = _M_codecvt->encoding();
      if (__width < 0)
 __width = 0;

      pos_type __ret = pos_type(off_type(-1));
      const bool __testfail = __off != 0 && __width <= 0;
      if (this->is_open() && !__testfail)
 {

   _M_destroy_pback();






   __state_type __state = _M_state_beg;
   off_type __computed_off = __off * __width;
   if (_M_reading && __way == ios_base::cur)
     {
       if (_M_codecvt->always_noconv())
  __computed_off += this->gptr() - this->egptr();
       else
  {



    const int __gptr_off =
      _M_codecvt->length(_M_state_last, _M_ext_buf, _M_ext_next,
           this->gptr() - this->eback());
    __computed_off += _M_ext_buf + __gptr_off - _M_ext_end;



    __state = _M_state_last;
  }
     }
   __ret = _M_seek(__computed_off, __way, __state);
 }
      return __ret;
    }





  template<typename _CharT, typename _Traits>
    typename basic_filebuf<_CharT, _Traits>::pos_type
    basic_filebuf<_CharT, _Traits>::
    seekpos(pos_type __pos, ios_base::openmode)
    {
      pos_type __ret = pos_type(off_type(-1));
      if (this->is_open())
 {

   _M_destroy_pback();
   __ret = _M_seek(off_type(__pos), ios_base::beg, __pos.state());
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    typename basic_filebuf<_CharT, _Traits>::pos_type
    basic_filebuf<_CharT, _Traits>::
    _M_seek(off_type __off, ios_base::seekdir __way, __state_type __state)
    {
      pos_type __ret = pos_type(off_type(-1));
      if (_M_terminate_output())
 {

   __ret = pos_type(_M_file.seekoff(__off, __way));
   _M_reading = false;
   _M_writing = false;
   _M_ext_next = _M_ext_end = _M_ext_buf;
   _M_set_buffer(-1);
   _M_state_cur = __state;
   __ret.state(_M_state_cur);
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    bool
    basic_filebuf<_CharT, _Traits>::
    _M_terminate_output()
    {

      bool __testvalid = true;
      if (this->pbase() < this->pptr())
 {
   const int_type __tmp = this->overflow();
   if (traits_type::eq_int_type(__tmp, traits_type::eof()))
     __testvalid = false;
 }


      if (_M_writing && !__check_facet(_M_codecvt).always_noconv()
   && __testvalid)
 {



   const size_t __blen = 128;
   char __buf[__blen];
   codecvt_base::result __r;
   streamsize __ilen = 0;

   do
     {
       char* __next;
       __r = _M_codecvt->unshift(_M_state_cur, __buf,
     __buf + __blen, __next);
       if (__r == codecvt_base::error)
  __testvalid = false;
       else if (__r == codecvt_base::ok ||
         __r == codecvt_base::partial)
  {
    __ilen = __next - __buf;
    if (__ilen > 0)
      {
        const streamsize __elen = _M_file.xsputn(__buf, __ilen);
        if (__elen != __ilen)
   __testvalid = false;
      }
  }
     }
   while (__r == codecvt_base::partial && __ilen > 0 && __testvalid);

   if (__testvalid)
     {




       const int_type __tmp = this->overflow();
       if (traits_type::eq_int_type(__tmp, traits_type::eof()))
  __testvalid = false;
     }
 }
      return __testvalid;
    }

  template<typename _CharT, typename _Traits>
    int
    basic_filebuf<_CharT, _Traits>::
    sync()
    {



      int __ret = 0;
      if (this->pbase() < this->pptr())
 {
   const int_type __tmp = this->overflow();
   if (traits_type::eq_int_type(__tmp, traits_type::eof()))
     __ret = -1;
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    void
    basic_filebuf<_CharT, _Traits>::
    imbue(const locale& __loc)
    {
      bool __testvalid = true;

      const __codecvt_type* _M_codecvt_tmp = 0;
      if (__builtin_expect(has_facet<__codecvt_type>(__loc), true))
 _M_codecvt_tmp = &use_facet<__codecvt_type>(__loc);

      if (this->is_open())
 {

   if ((_M_reading || _M_writing)
       && __check_facet(_M_codecvt).encoding() == -1)
     __testvalid = false;
   else
     {
       if (_M_reading)
  {
    if (__check_facet(_M_codecvt).always_noconv())
      {
        if (_M_codecvt_tmp
     && !__check_facet(_M_codecvt_tmp).always_noconv())
   __testvalid = this->seekoff(0, ios_base::cur, this->_M_mode)
                 != pos_type(off_type(-1));
      }
    else
      {

        _M_ext_next = _M_ext_buf
   + _M_codecvt->length(_M_state_last, _M_ext_buf, _M_ext_next,
          this->gptr() - this->eback());
        const streamsize __remainder = _M_ext_end - _M_ext_next;
        if (__remainder)
   std::memmove(_M_ext_buf, _M_ext_next, __remainder);

        _M_ext_next = _M_ext_buf;
        _M_ext_end = _M_ext_buf + __remainder;
        _M_set_buffer(-1);
        _M_state_last = _M_state_cur = _M_state_beg;
      }
  }
       else if (_M_writing && (__testvalid = _M_terminate_output()))
  _M_set_buffer(-1);
     }
 }

      if (__testvalid)
 _M_codecvt = _M_codecvt_tmp;
      else
 _M_codecvt = 0;
    }





  extern template class basic_filebuf<char>;
  extern template class basic_ifstream<char>;
  extern template class basic_ofstream<char>;
  extern template class basic_fstream<char>;
# 877 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/bits/fstream.tcc" 3
}
# 841 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/fstream" 2 3
# 33 "H:/CPP/wxdevcpp6.10/include/c++/3.4.2/backward/fstream.h" 2

using std::filebuf;
using std::ifstream;
using std::ofstream;
using std::fstream;
using std::streampos;
# 17 "shooter.cpp" 2
# 1 "aiplayer.h" 1
# 10 "aiplayer.h"
# 1 "dna.h" 1
# 10 "dna.h"
template<class T>
inline T read(ifstream *in)
{
   T result;
   in->read((char *) (&result), sizeof(T));
   return result;
}

template<class T>
inline void write(ofstream *out, T value)
{
   T result;
   out->write((char *) (&value), sizeof(T));
   return;
}

class DNA
{
    public:
       DNA();
       ~DNA();

       Random ra;

       double gameline;
       double bulletpanic;
       int reactioncycles;

       double carefulzone;

       double bulletsee[3];

       double ebulletattract[3];
       double ebulletattractpower[3];
       double ebulletrepel[3];
       double ebulletrepelpower[3];

       double elineattract[3];
       double elineattractpower[3];
       double elinerepel[3];
       double elinerepelpower[3];

       double wlineattract[3];
       double wlineattractpower[3];
       double wlinerepel[3];
       double wlinerepelpower[3];

       double powerupattract[3];
       double powerupattractpower[3];
       double poweruprepel[3];
       double poweruprepelpower[3];





       int getReactionCycles();
       double getBulletSee(int state);
       double getBulletPanic();
       double getCarefulZone();
       double getGameLine();

       double getEBulletAttract(int state);
       double getEBulletAttractPower(int state);
       double getEBulletRepel(int state);
       double getEBulletRepelPower(int state);

       double getELineAttract(int state);
       double getELineAttractPower(int state);
       double getELineRepel(int state);
       double getELineRepelPower(int state);

       double getWLineAttract(int state);
       double getWLineAttractPower(int state);
       double getWLineRepel(int state);
       double getWLineRepelPower(int state);

       double getPowerUpAttract(int state);
       double getPowerUpAttractPower(int state);
       double getPowerUpRepel(int state);
       double getPowerUpRepelPower(int state);

       void load(char* filename);
       void save(char* filename);

       void clear();

       void putInt(ostream *out, int x);
       void putDouble(ostream *out, double x);


       DNA mate(DNA partner, double crossover, int rlock);
       void mutate(double chance, double severity, int rlock, double jostle);

};
# 11 "aiplayer.h" 2

class AIPlayer
{
    private:
    int enemies;
    int enemytarget;
    int items;
    int itemtarget;
    int rps;
    double bulletdangerradius;
    double weightvariance;
    double bulletmissprobability;
    double jitterprobability;

    double gameline;

    double bulletrepel;
    bool bulletrepelsquared;
    double bulletattract;
    bool bulletattractsquared;

    double screenedgerepel;
    bool screenedgerepelsquared;
    double screenedgeattract;
    bool screenedgeattractsquared;

    double gamelinerepel;
    bool gamelinesquared;
    double gamelineattract;
    bool gamelineattractsquared;

    double enemyrepel;
    bool enemysquared;
    double enemyattract;
    bool enemyattractsquared;

    Random airan;

    public:
    AIPlayer();
    ~AIPlayer();

    int getRps();
    void setRps(int newrps);

    double getBulletDangerRadius();
    void setBulletDangerRadius(double newbulletdangerradius);

    double getWeightVariance();
    void setWeightVariance(double newweightvariance);

    double getBulletMissProbability();
    void setBulletMissProbability(double newbulletmissprobability);

    KeyState update(GameSpace* gs, Player* p, DNA dna, KeyState kes);
};
# 18 "shooter.cpp" 2





# 1 "generation.h" 1







using namespace std;

class Generation
{
   public:
      Generation(char* filename, int nseed, int nrlock);
      ~Generation();

      vector<DNA> dnavect;
      vector<int> fitness;

      int seed;
      int reactionlock;

      Generation formNextGeneration(double crossover, double mutationchance, double severity, int tourneysize, int gen, double mjost);
      int bestFitness();
      double meanFitness();
      double standardDeviation();
      int worstFitness();
      void saveBest(char* filename);
      void simulate(int num);
      void simulateAll();

};
# 24 "shooter.cpp" 2
# 1 "genepool.h" 1
# 9 "genepool.h"
using namespace std;

class GenePool
{
   public:
      GenePool(char* filename, int nseed, int nrlock, int simtype, int runs, int smult, int lmult);
      ~GenePool();

      vector<DNA> dnavect;
      vector<int> fitness;

      int seed;
      int reactionlock;


      void doPool(int maxsize, int deltype, int tourneysize, double crossover, double mutationchance, double severity, int numgens, double mutdev, double jostlechance, int simtype, int runs, int smult, int lmult);
      int bestFitness(int top);
      void simulate(int num, int simtype, int runs, int smult, int lmult);
      double meanFitness(int top);
      double standardDeviation(int top);
      int worstFitness(int top);
      void saveBest(char* filename, int top);

};
# 25 "shooter.cpp" 2



using namespace std;
using namespace irr;






#pragma comment(lib, "Irrlicht.lib")



enum {LOC_MAINMENU, LOC_SCORELIST, LOC_GAME, LOC_BAILING};
int pllocation;
vector<core::rect<s32> > spritelist;
vector<SpriteNote>* pspritenotevector;
vector<SpriteNote> p2dspritenotevector;
vector<SpriteNote> spritenotevector;
vector<video::ITexture*> texturevector;
SpriteNote* BG;
list<scene::ISceneNode*> nodelist;

KeyState theKeyState;
KeyState oldKeyState;
CIrrLichtEvent irrevent;
AIPlayer theAI;
Random ran;
bool human;
DNA aidna;
vector<int> replay;
bool replaysave;
bool watchingreplay;
char replayfileout[100];
char replayfilein[100];
char tem[20];
c8 tfile1[100];
c8 tfile2[100];
c8 tfile3[100];
int replayloc;
bool dynamiccam;
bool kcam;


u32 calcDelay(u32 fps)
{
    return 1000/fps;
}


void putInt(ostream *out, int x)
{
   out->put( x & 0xFF);
   out->put((x >> 8) & 0xFF);
   out->put((x >> 16) & 0xFF);
   out->put((x >> 24) & 0xFF);
}

int main()
{
   BG = new SpriteNote(0, 0, 1);
   dynamiccam = false;
   kcam = false;
# 113 "shooter.cpp"
   aidna.load("stock.dna");
# 129 "shooter.cpp"
    cout << "1. Play!\n2. Have Stock AI Play\n3. Have AI From a File Play\n4. Genetic Algorithm: Community\n5. Genetic Algorithm: Gene Pool\n6. Watch Replay\n7. Examine DNA file\n?: ";
    int a = 1;
    cin >> a;
    if (a == 1)
    {
       human = true;
       printf("\n\nSave Replay?\n");

       cin >> tem;
       if ((strcmp(tem, "y") == 0) || (strcmp(tem, "Y") == 0) || (strcmp(tem, "yes") == 0) || (strcmp(tem, "YES") == 0))
       {
          printf("\n\nReplay File Name? (without extension)\n?: ");
          cin >> replayfileout; strcat(replayfileout, ".rep");
          replaysave = true;
          watchingreplay = false;
       }
    }
    if (a == 2)
    {
       human = false;
       printf("\n\nSave Replay?\n");

       cin >> tem;
       if ((strcmp(tem, "y") == 0) || (strcmp(tem, "Y") == 0) || (strcmp(tem, "yes") == 0) || (strcmp(tem, "YES") == 0))
       {
          printf("\n\nReplay File Name? (without extension)\n?: ");
          cin >> replayfileout; strcat(replayfileout, ".rep");
          replaysave = true;
          watchingreplay = false;
       }
    }

    if (a == 3)
    {
       printf("\n\nDNA File Name? (without extension)\n?: ");
       cin >> replayfileout; strcat(replayfileout, ".dna");
       aidna.load(replayfileout);
       human = false;
       printf("\n\nSave Replay?\n");

       cin >> tem;
       if ((strcmp(tem, "y") == 0) || (strcmp(tem, "Y") == 0) || (strcmp(tem, "yes") == 0) || (strcmp(tem, "YES") == 0))
       {
          printf("\n\nReplay File Name? (without extension)\n?: ");
          cin >> replayfileout; strcat(replayfileout, ".rep");
          replaysave = true;
          watchingreplay = false;
       }
    }

    if (a == 4)
    {
# 189 "shooter.cpp"
         SetThreadPriority(GetCurrentThread(), (-1));

         printf("\n\nStarting DNA File Name? (without extension) (stock is a good start point)\n?: ");
          cin >> replayfileout; strcat(replayfileout, ".dna");

         printf("\n\nReaction Time Lock Value (-1 for no lock)?\n?: ");
         int rlock;
         cin >> rlock;

         printf("\n\nSimulation Seed?\n?: ");
         int tseed;
         cin >> tseed;
         Generation ge(replayfileout, tseed, rlock);

         printf("\n\nSave Best DNA As? (without extension)\n?: ");
         cin >> replayfileout; strcat(replayfileout, ".dna");

         printf("\n\nNumber Of Generations?\n?: ");
         int runlength;
         cin >> runlength;

         printf("\n\nCrossover Chance (.1 is reasonable)\n?: ");
         double crosschance;
         cin >> crosschance;

         printf("\n\nMutation Chance (.05 is reasonable)\n?: ");
         double mutchance;
         cin >> mutchance;

         printf("\n\nMutation Severity (5-15 is reasonable)\n?: ");
         double mutsev;
         cin >> mutsev;

         printf("\n\nMutation Jostle Chance (.99 is reasonable)\n?: ");
         double mutjost;
         cin >> mutjost;

         printf("\n\nTournament Size (5 is reasonable)\n?: ");
         int tsize;
         cin >> tsize;

         printf("Simulating\n");
         for (int loop = 0;loop < runlength; loop++)
         {
            ge = ge.formNextGeneration(crosschance, mutchance, mutsev, tsize, loop, mutjost);

         }
         ge.simulateAll();
         SetThreadPriority(GetCurrentThread(), 0);
         ge.saveBest(replayfileout);
         printf("All Done. Best Fitness = %d\n", ge.bestFitness());
         system("pause");
         return 1;
    }

    if (a == 5)
    {
# 254 "shooter.cpp"
         SetThreadPriority(GetCurrentThread(), (-1));

         printf("\n\nStarting DNA File Name? (without extension) (stock is a good start point)\n?: ");
          cin >> tfile1; strcat(tfile1, ".dna");

         printf("\n\nReaction Time Lock Value (-1 for no lock)?\n?: ");
         int rlock;
         cin >> rlock;

         printf("\n\nSimulation Seed?\n?: ");
         int tseed;
         cin >> tseed;


         printf("\n\nSave Best DNA As? (without extension)\n?: ");
         cin >> replayfileout; strcat(replayfileout, ".dna");

         printf("\n\nNumber Of Generations?\n?: ");
         int runlength;
         cin >> runlength;

         printf("\n\nCrossover Chance (.1 is reasonable)\n?: ");
         double crosschance;
         cin >> crosschance;

         printf("\n\nMean Mutation Chance (.07 is reasonable)\n?: ");
         double mutchance;
         cin >> mutchance;

         printf("\n\nMutation Standard Deviation (.02 is reasonable)\n?: ");
         double mutstdev;
         cin >> mutstdev;

         printf("\n\nMutation Severity (5-15 is reasonable)\n?: ");
         double mutsev;
         cin >> mutsev;

         printf("\n\nMutation Jostle Chance (.99 is reasonable)\n?: ");
         double mutjost;
         cin >> mutjost;

         printf("\n\nTournament Size (5 is reasonable)\n?: ");
         int tsize;
         cin >> tsize;

         printf("\n\nGene Pool Size (100 is reasonable)\n?: ");
         int gsize;
         cin >> gsize;

         printf("\n\nDeletion Type (0 = worst, 1 = random, 2 = low tourney)\n?: ");
         int delt;
         cin >> delt;

         printf("\n\nSimulation Type (0 = one run, 1 = multiruns)\n?: ");
         int simtype;
         cin >> simtype;

         printf("\n\nScore Fitness Mult (Must be int. 1 is reasonable)\n?: ");
         int smult;
         cin >> smult;

         printf("\n\nLives Fitness Mult (Must be int. 300 is reasonable)\n?: ");
         int lmult;
         cin >> lmult;

         int runs;
         if (simtype == 1)
         {
            printf("\n\nNumber of Runs (5 is reasonable)\n?: ");
            cin >> runs;
         }
         else
         {
            runs = 1;
         }


         printf("Simulating\n");
         GenePool ge(tfile1, tseed, rlock, simtype, runs, smult, lmult);
         ge.doPool(gsize, delt, tsize, crosschance, mutchance, mutsev, runlength, mutstdev, mutjost, simtype, runs, smult, lmult);

         SetThreadPriority(GetCurrentThread(), 0);
         ge.saveBest(replayfileout, gsize);
         printf("All Done. Best Fitness = %d\n", ge.bestFitness(gsize));
         system("pause");
         return 1;
    }

    if (a == 6)
    {
         watchingreplay = true;
         replaysave = false;
         human = false;
         printf("\n\nReplay File Name? (without extension)\n?: ");
         cin >> replayfilein; strcat(replayfilein, ".rep");
         ifstream myFile(replayfilein, ios::in | ios::binary);
         while(myFile.eof() == false)
         {
            int v;
            myFile.read((char*) (&v), sizeof(int));
            replay.push_back(v);
         }
         myFile.close();

    }
    if (a == 7)
    {
         replayfilein;
         printf("\n\nDNA File Name? (without extension)\n?: ");
         cin >> replayfilein; strcat(replayfilein, ".dna");
         aidna.load(replayfilein);
         printf("\n\n");
         printf("PanicRadius: %g, Reaction: %d, CareZone: %g, GameLine: %g\n", aidna.bulletpanic, aidna.reactioncycles, aidna.carefulzone, aidna.gameline);
         printf("                                    POWERUP ST. BULLETS ST. PANIC ST. \n");
         printf("BULLETSEE                           %g           %g           %g\n",aidna.bulletsee[0],aidna.bulletsee[1],aidna.bulletsee[2]);
         printf("E BULLET ATTRACTION                 %g           %g           %g\n",aidna.ebulletattract[0],aidna.ebulletattract[1],aidna.ebulletattract[2]);
         printf("E BULLET ATT. INV. PROP. EXPONENT   %g           %g           %g\n",aidna.ebulletattractpower[0],aidna.ebulletattractpower[1],aidna.ebulletattractpower[2]);
         printf("E BULLET REPULSION                  %g           %g           %g\n",aidna.ebulletrepel[0],aidna.ebulletrepel[1],aidna.ebulletrepel[2]);
         printf("E BULLET REP. INV. PROP. EXPONENT   %g           %g           %g\n",aidna.ebulletrepelpower[0],aidna.ebulletrepelpower[1],aidna.ebulletrepelpower[2]);
         printf("\n");
         printf("E LINE ATTRACTION                   %g           %g           %g\n",aidna.elineattract[0],aidna.elineattract[1],aidna.elineattract[2]);
         printf("E LINE ATT. INV. PROP. EXPONENT     %g           %g           %g\n",aidna.elineattractpower[0],aidna.elineattractpower[1],aidna.elineattractpower[2]);
         printf("E LINE REPULSION                    %g           %g           %g\n",aidna.elinerepel[0],aidna.elinerepel[1],aidna.elinerepel[2]);
         printf("E LINE REP. INV. PROP. EXPONENT     %g           %g           %g\n",aidna.elinerepelpower[0],aidna.elinerepelpower[1],aidna.elinerepelpower[2]);
         printf("\n");
         printf("W LINE ATTRACTION                   %g           %g           %g\n",aidna.wlineattract[0],aidna.wlineattract[1],aidna.wlineattract[2]);
         printf("W LINE ATT. INV. PROP. EXPONENT     %g           %g           %g\n",aidna.wlineattractpower[0],aidna.wlineattractpower[1],aidna.wlineattractpower[2]);
         printf("W LINE REPULSION                    %g           %g           %g\n",aidna.wlinerepel[0],aidna.wlinerepel[1],aidna.wlinerepel[2]);
         printf("W LINE REP. INV. PROP. EXPONENT     %g           %g           %g\n",aidna.wlinerepelpower[0],aidna.wlinerepelpower[1],aidna.wlinerepelpower[2]);
         printf("\n");
         printf("POWERUP ATTRACTION                  %g           %g           %g\n",aidna.powerupattract[0],aidna.powerupattract[1],aidna.powerupattract[2]);
         printf("POWERUP ATT. INV. PROP. EXPONENT    %g           %g           %g\n",aidna.powerupattractpower[0],aidna.powerupattractpower[1],aidna.powerupattractpower[2]);
         printf("POWERUP REPULSION                   %g           %g           %g\n",aidna.poweruprepel[0],aidna.poweruprepel[1],aidna.poweruprepel[2]);
         printf("POWERUP REP. INV. PROP. EXPONENT    %g           %g           %g\n",aidna.poweruprepelpower[0],aidna.poweruprepelpower[1],aidna.poweruprepelpower[2]);
         printf("\n");
         system("pause");
         return 0;
    }



    TimeSensor* graphicsensor = TimeSensor::getNewClockSensor();
    TimeSensor* inputsensor = TimeSensor::getNewClockSensor();
    TimeSensor* gamesensor = TimeSensor::getNewClockSensor();



    irrevent.Init();
    pllocation = LOC_GAME;
    video::E_DRIVER_TYPE driverType;

    driverType = video::EDT_OPENGL;

    IrrlichtDevice *device = createDevice(driverType,
  core::dimension2d<s32>(800, 600), 32,
   false , false , true , 0);
    device->setWindowCaption(L"Alice Game");
    scene::ISceneManager* smgr = device->getSceneManager();

    scene::ICameraSceneNode* cam = smgr->addCameraSceneNode(0, core::vector3df(380,280,410), core::vector3df(380,280,0));
  if (dynamiccam == true) {cam->setPosition(core::vector3df(380,600,310));}
    cam->setUpVector(core::vector3df(0,-1,0));

    video::IVideoDriver* driver = device->getVideoDriver();
  device->getFileSystem()->addZipFileArchive("./data.zip");
  video::ITexture* images = driver->getTexture("./sprites.png");


    gui::IGUIFont* font = device->getGUIEnvironment()->getBuiltInFont();
    gui::IGUIEnvironment* guienv = device->getGUIEnvironment();


    gui::IGUIStaticText* scoretext = guienv->addStaticText(L"",
         core::rect<s32>(10,10,200,22), true, true, __null, -1, true);


    gui::IGUIStaticText* livestext = guienv->addStaticText(L"",
         core::rect<s32>(10,30,200,42), true);
    device->getCursorControl()->setVisible(false);
# 449 "shooter.cpp"
    for(int i = 0;true;i++)
    {
       strcpy(tfile1,"./");
       itoa(i, tfile2, 10);strcat(tfile1, tfile2);strcat(tfile1,".png");
       if (!device->getFileSystem()->existFile(tfile1)) {break;}
       texturevector.push_back(driver->getTexture(tfile1));
       driver->makeColorKeyTexture(texturevector[i], video::SColor(255, 255, 0, 255));

    }


    scene::IAnimatedMesh* mesh = smgr->getMesh("./mesh.3ds");
# 477 "shooter.cpp"
 pspritenotevector = &spritenotevector;


 int sa = ran.nextInt(1000000);
 if (replaysave) {replay.push_back(sa);}
 if (watchingreplay) {sa = replay[0];}
 GameSpace gs(1, 10, 500, 10, 590, sa, false, "levels/test.lua", "characters/shinku.lua");
 replayloc = 1;
 device->setEventReceiver(&irrevent);




    inputsensor->setLambda(.07);inputsensor->setFrequency(55);
 inputsensor->reset();
    gamesensor->setLambda(.07);gamesensor->setFrequency(80);
 gamesensor->reset();


    while(device->run() && driver && pllocation != LOC_BAILING)
    {
        if (device->isWindowActive())
  {




           if (pllocation == LOC_MAINMENU)
           {
                driver->beginScene(true, true, video::SColor(0,120,102,136));
    driver->endScene();
           }

           else if (pllocation == LOC_GAME)
           {





                if (gamesensor->poll())
                {





                   if (human == true)
                   {
                      theKeyState.clearKeys();
                      if (irrevent.IsKeyDown(KEY_UP)) {theKeyState.setUp(true);}
                      if (irrevent.IsKeyDown(KEY_DOWN)) {theKeyState.setDown(true);}
                      if (irrevent.IsKeyDown(KEY_LEFT)) {theKeyState.setLeft(true);}
                      if (irrevent.IsKeyDown(KEY_RIGHT)) {theKeyState.setRight(true);}
                      if (irrevent.IsKeyDown(KEY_KEY_Z)) {theKeyState.setZ(true);}
                      if (irrevent.IsKeyDown(KEY_KEY_X)) {theKeyState.setX(true);}
                      if (irrevent.IsKeyDown(KEY_ESCAPE)) {theKeyState.setEsc(true);}
                      if (irrevent.IsKeyDown(KEY_SHIFT)) {theKeyState.setShift(true);}
                    }
                    else
                    {

                        if (watchingreplay == true)
                        {
                           while(gs.cycle == replay[replayloc])
                           {
                              if (replay[replayloc + 1] == 0)
                              {
                                 theKeyState.setUp((bool)replay[replayloc + 2]);
                              }
                              if (replay[replayloc + 1] == 1)
                              {
                                 theKeyState.setDown((bool)replay[replayloc + 2]);
                              }
                              if (replay[replayloc + 1] == 2)
                              {
                                 theKeyState.setLeft((bool)replay[replayloc + 2]);
                              }
                              if (replay[replayloc + 1] == 3)
                              {
                                 theKeyState.setRight((bool)replay[replayloc + 2]);
                              }
                              if (replay[replayloc + 1] == 4)
                              {
                                 theKeyState.setZ((bool)replay[replayloc + 2]);
                              }
                              if (replay[replayloc + 1] == 5)
                              {
                                 theKeyState.setX((bool)replay[replayloc + 2]);
                              }
                              if (replay[replayloc + 1] == 6)
                              {
                                 theKeyState.setEsc((bool)replay[replayloc + 2]);
                              }
                              if (replay[replayloc + 1] == 7)
                              {
                                 theKeyState.setShift((bool)replay[replayloc + 2]);
                              }
                              replayloc += 3;
                           }
                        }
                        else
                        {


                           theKeyState = theAI.update(&gs, gs.thePlayer, aidna, theKeyState);
                        }
                    }

                    if (irrevent.IsKeyDown(KEY_ESCAPE)) {theKeyState.setEsc(true);}

                    if (irrevent.IsKeyDown(KEY_KEY_R))
                    {
                        if (kcam == false)
                        {
                           kcam = true;
                           if (dynamiccam == true)
                           {
                              dynamiccam = false;
                              cam->setPosition(core::vector3df(380,280,410));
                              cam->setTarget(core::vector3df(380,280,0));
                           }
                           else
                           {
                              dynamiccam = true;
                              cam->setPosition(core::vector3df(380,500,310));
                           }
                        }
                        else
                        {
                        }
                    }
                    else
                    {
                        kcam = false;
                    }
# 625 "shooter.cpp"
                   if (replaysave)
                   {
                        if (theKeyState.isUp() != oldKeyState.isUp())
                        {
                           replay.push_back(gs.cycle);
                           replay.push_back(0);
                           replay.push_back((int)theKeyState.isUp());
                        }
                        if (theKeyState.isDown() != oldKeyState.isDown())
                        {
                           replay.push_back(gs.cycle);
                           replay.push_back(1);
                           replay.push_back((int)theKeyState.isDown());
                        }
                        if (theKeyState.isLeft() != oldKeyState.isLeft())
                        {
                           replay.push_back(gs.cycle);
                           replay.push_back(2);
                           replay.push_back((int)theKeyState.isLeft());
                        }
                        if (theKeyState.isRight() != oldKeyState.isRight())
                        {
                           replay.push_back(gs.cycle);
                           replay.push_back(3);
                           replay.push_back((int)theKeyState.isRight());
                        }
                        if (theKeyState.isZ() != oldKeyState.isZ())
                        {
                           replay.push_back(gs.cycle);
                           replay.push_back(4);
                           replay.push_back((int)theKeyState.isZ());
                        }
                        if (theKeyState.isX() != oldKeyState.isX())
                        {
                           replay.push_back(gs.cycle);
                           replay.push_back(5);
                           replay.push_back((int)theKeyState.isX());
                        }
                        if (theKeyState.isEsc() != oldKeyState.isEsc())
                        {
                           replay.push_back(gs.cycle);
                           replay.push_back(6);
                           replay.push_back((int)theKeyState.isEsc());
                        }
                        if (theKeyState.isShift() != oldKeyState.isShift())
                        {
                           replay.push_back(gs.cycle);
                           replay.push_back(7);
                           replay.push_back((int)theKeyState.isShift());
                        }
                        oldKeyState = theKeyState;
                   }


                   if (gs.updateGameState(theKeyState) !=1 ) {theKeyState.setEsc(true);}

                }





                   driver->beginScene(true, true, video::SColor(0,0,0,0));



                   list<Star>::iterator s;
                   for(s=gs.lStars.begin(); s != gs.lStars.end();)
                   {
                      if (s->getY() > gs.screenbottom)
                      {
                         s = gs.lStars.erase(s);

                         gs.lStars.push_front(Star(ran.nextDouble(800),0,ran.nextDouble(100)));
                      }
                      else
                      {

                         s->update(1.8);
                         int co = (int)(((1 - (s->getZ()/100))*170) + 74);
                         driver->draw2DRectangle(video::SColor(co,co,co,co),
                                                 core::rect<int>((int)(s->getX()),(int)(s->getY()),(int)(s->getX()+1),(int)(s->getY()+1)),
                                                 __null);
                         s++;
                      }

                   }


                   gs.getSprites(pspritenotevector, BG, theKeyState);
                   int j;
                   for (j = 0; j < pspritenotevector->size();j++)
                   {


                      scene::IAnimatedMeshSceneNode* node = smgr->addAnimatedMeshSceneNode(mesh, __null, j, core::vector3df(spritenotevector[j].getX()-20,spritenotevector[j].getY()-20,(j)*.002), core::vector3df(90, 0, spritenotevector[j].getRotation()), core::vector3df(26,26,26));

                      node->setMaterialTexture(0, texturevector[spritenotevector[j].getSprite()]);

                      node->setMaterialFlag(video::EMF_LIGHTING, false);
                      node->setMaterialFlag(video::EMF_ANISOTROPIC_FILTER, false);
                      node->setMaterialFlag(video::EMF_BILINEAR_FILTER, false);
                      node->setMaterialFlag(video::EMF_TRILINEAR_FILTER, false);
                      node->setMaterialType(video::EMT_TRANSPARENT_ALPHA_CHANNEL);

                      nodelist.push_back(node);




                   }

                      if (BG == __null) {printf("uh oh\n");}
                      scene::IAnimatedMeshSceneNode* node = smgr->addAnimatedMeshSceneNode(mesh, __null, -1, core::vector3df(BG->getX(),BG->getY(),10), core::vector3df(90, 0, BG->getRotation()), core::vector3df(98*4,1,98*3), false);

                      node->setMaterialTexture(0, texturevector[BG->getSprite()]);
                      node->setMaterialFlag(video::EMF_LIGHTING, false);
                      node->setMaterialFlag(video::EMF_ANISOTROPIC_FILTER, false);
                      node->setMaterialFlag(video::EMF_BILINEAR_FILTER, false);
                      node->setMaterialFlag(video::EMF_TRILINEAR_FILTER, false);
                      node->setMaterialType(video::EMT_TRANSPARENT_ALPHA_CHANNEL);
                      nodelist.push_back(node);
# 755 "shooter.cpp"
                   driver->draw2DRectangle(video::SColor(255,255,255,255),
                                                 core::rect<int>(10,10,200,22),
                                                 __null);

                  driver->draw2DRectangle(video::SColor(255,255,255,255),
                                                 core::rect<int>(10,30,200,42),
                                                 __null);



                   wchar_t buf[80];
                   _snwprintf(buf,80,L"Score: %d",gs.thePlayer->getScore());
                   scoretext->setText(buf);

                   _snwprintf(buf,80,L"Lives: %d",gs.thePlayer->getLives());
                   livestext->setText(buf);
# 784 "shooter.cpp"
                   if (dynamiccam) {cam->setTarget(core::vector3df(((gs.thePlayer->getX()-380)/2.0)+380, gs.thePlayer->getY(), 0));}


                   smgr->drawAll();
                   guienv->drawAll();
                   driver->endScene();


                   list <scene::ISceneNode*>::iterator f;
                   for (f=nodelist.begin(); f != nodelist.end();)
                   {
                       (*f)->remove();
                       f = nodelist.erase(f);
                   }


           }





           if (theKeyState.isEsc()) {break;}
        }
       if (theKeyState.isEsc()) {break;}
       Sleep(10);

   }
if (replaysave)
{


   fstream myFile(replayfileout, ios::out | ios::binary);





for (int ii = 0;ii < replay.size();ii++)
   putInt(&myFile, replay[ii]);


   myFile.close();
}

}
